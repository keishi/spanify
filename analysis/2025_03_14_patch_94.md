# Build Failure: 2025_03_14_patch_94

## Chromium Revision

`92fa51da0b065871ab54d1337a4d4f09e21ed717`

## Code Changes (Diff)

```diff
diff --git a/base/bits.h b/base/bits.h
index 5f93183d034b7..98e0f4e6397ff 100644
--- a/base/bits.h
+++ b/base/bits.h
@@ -14,6 +14,7 @@
 #include <concepts>
 #include <type_traits>
 
+#include "base/containers/span.h"
 #include "base/check.h"
 
 namespace base::bits {
@@ -91,7 +92,7 @@ inline constexpr T AlignUpDeprecatedDoNotUse(T size, T alignment) {
 // two. Defined for types where sizeof(T) is one byte.
 template <typename T>
   requires(sizeof(T) == 1)
-inline T* AlignUp(T* ptr, uintptr_t alignment) {
+inline base::span<T> AlignUp(T* ptr, uintptr_t alignment) {
   return reinterpret_cast<T*>(
       AlignUp(reinterpret_cast<uintptr_t>(ptr), alignment));
 }
diff --git a/base/bits_unittest.cc b/base/bits_unittest.cc
index 6464844af0598..9364342817b5d 100644
--- a/base/bits_unittest.cc
+++ b/base/bits_unittest.cc
@@ -64,21 +64,21 @@ TEST(BitsTest, AlignUpPointer) {
   static constexpr uintptr_t kUintPtrTMax =
       std::numeric_limits<uintptr_t>::max();
   EXPECT_EQ(reinterpret_cast<uint8_t*>(0),
-            AlignUp(reinterpret_cast<uint8_t*>(0), 4));
+            AlignUp(reinterpret_cast<uint8_t*>(0), 4).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4),
-            AlignUp(reinterpret_cast<uint8_t*>(1), 4));
+            AlignUp(reinterpret_cast<uint8_t*>(1), 4).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(1), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(1), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(4096), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4096), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(4095), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4095), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(8192),
-            AlignUp(reinterpret_cast<uint8_t*>(4097), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4097), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(kUintPtrTMax - 31),
-            AlignUp(reinterpret_cast<uint8_t*>(kUintPtrTMax - 62), 32));
+            AlignUp(reinterpret_cast<uint8_t*>(kUintPtrTMax - 62), 32).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(kUintPtrTMax / 2 + 1),
-            AlignUp(reinterpret_cast<uint8_t*>(1), kUintPtrTMax / 2 + 1));
+            AlignUp(reinterpret_cast<uint8_t*>(1), kUintPtrTMax / 2 + 1).data());
 }
 
 TEST(BitsTest, AlignDown) {
diff --git a/base/debug/test_elf_image_builder.cc b/base/debug/test_elf_image_builder.cc
index f9b8a93bdccbe..3530ab3d8d72e 100644
--- a/base/debug/test_elf_image_builder.cc
+++ b/base/debug/test_elf_image_builder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -74,19 +76,19 @@ TestElfImageBuilder& TestElfImageBuilder::AddNoteSegment(
       sizeof(Nhdr) + bits::AlignUp(name_with_null_size, size_t{4}) +
           bits::AlignUp(desc.size(), size_t{4}),
       '\0');
-  uint8_t* loc = &buffer.front();
+  base::span<uint8_t>loc = &buffer.front();
   Nhdr nhdr;
   nhdr.n_namesz = name_with_null_size;
   nhdr.n_descsz = desc.size();
   nhdr.n_type = type;
   loc = AppendHdr(nhdr, loc);
 
-  memcpy(loc, name.data(), name.size());
-  *(loc + name.size()) = '\0';
-  loc += bits::AlignUp(name_with_null_size, size_t{4});
+  memcpy(loc.data(), name.data(), name.size());
+   (loc .subspan( name.size())[0]) = '\0';
+  loc=loc.subspan(bits::AlignUp(name_with_null_size, size_t{4}));
 
-  memcpy(loc, &desc.front(), desc.size());
-  loc += bits::AlignUp(desc.size(), size_t{4});
+  memcpy(loc.data(), &desc.front(), desc.size());
+  loc=loc.subspan(bits::AlignUp(desc.size(), size_t{4}));
 
   DCHECK_EQ(&buffer.front() + buffer.size(), loc);
 
@@ -195,18 +197,18 @@ TestElfImage TestElfImageBuilder::Build() {
       mapping_type_ == RELOCATABLE_WITH_BIAS ? kLoadBias : 0;
   std::vector<uint8_t> buffer(load_bias + (kPageSize - 1) + measures.total_size,
                               '\0');
-  uint8_t* const elf_start =
+  const base::span<uint8_t>elf_start =
       bits::AlignUp(&buffer.front() + load_bias, kPageSize);
-  uint8_t* loc = elf_start;
+  base::span<uint8_t>loc = elf_start;
 
   // Add the ELF header.
   loc = AppendHdr(CreateEhdr(measures.phdrs_required), loc);
 
   // Add the program header table.
-  loc = bits::AlignUp(loc, kPhdrAlign);
+  loc = bits::AlignUp(loc.data(), kPhdrAlign);
   loc = AppendHdr(
       CreatePhdr(PT_PHDR, PF_R, kPhdrAlign, loc - elf_start,
-                 GetVirtualAddressForOffset(loc - elf_start, elf_start),
+                 GetVirtualAddressForOffset(loc - elf_start, elf_start.data()),
                  sizeof(Phdr) * measures.phdrs_required),
       loc);
   for (size_t i = 0; i < load_segments_.size(); ++i) {
@@ -220,14 +222,14 @@ TestElfImage TestElfImageBuilder::Build() {
     loc = AppendHdr(CreatePhdr(PT_LOAD, load_segment.flags, kLoadAlign,
                                measures.load_segment_start[i],
                                GetVirtualAddressForOffset(
-                                   measures.load_segment_start[i], elf_start),
+                                   measures.load_segment_start[i], elf_start.data()),
                                size),
                     loc);
   }
   if (measures.note_size != 0) {
     loc = AppendHdr(
         CreatePhdr(PT_NOTE, PF_R, kNoteAlign, measures.note_start,
-                   GetVirtualAddressForOffset(measures.note_start, elf_start),
+                   GetVirtualAddressForOffset(measures.note_start, elf_start.data()),
                    measures.note_size),
         loc);
   }
@@ -235,28 +237,28 @@ TestElfImage TestElfImageBuilder::Build() {
     loc = AppendHdr(
         CreatePhdr(
             PT_DYNAMIC, PF_R | PF_W, kDynamicAlign, measures.dynamic_start,
-            GetVirtualAddressForOffset(measures.dynamic_start, elf_start),
+            GetVirtualAddressForOffset(measures.dynamic_start, elf_start.data()),
             sizeof(Dyn) * 2),
         loc);
   }
 
   // Add the notes.
-  loc = bits::AlignUp(loc, kNoteAlign);
+  loc = bits::AlignUp(loc.data(), kNoteAlign);
   for (const std::vector<uint8_t>& contents : note_contents_) {
-    memcpy(loc, &contents.front(), contents.size());
-    loc += contents.size();
+    memcpy(loc.data(), &contents.front(), contents.size());
+    loc=loc.subspan(contents.size());
   }
 
   // Add the load segments.
   for (auto it = load_segments_.begin(); it != load_segments_.end(); ++it) {
     if (it != load_segments_.begin()) {
-      loc = bits::AlignUp(loc, kLoadAlign);
+      loc = bits::AlignUp(loc.data(), kLoadAlign);
     }
-    memset(loc, 0, it->size);
-    loc += it->size;
+    memset(loc.data(), 0, it->size);
+    loc=loc.subspan(size);
   }
 
-  loc = bits::AlignUp(loc, kDynamicAlign);
+  loc = bits::AlignUp(loc.data(), kDynamicAlign);
 
   // Add the soname state.
   if (soname_) {
@@ -278,16 +280,16 @@ TestElfImage TestElfImageBuilder::Build() {
   // Linux relocates this value on ELF load, so produce the pointer value after
   // relocation. That value will always be equal to the actual memory address.
   strtab_dyn.d_un.d_ptr =
-      reinterpret_cast<uintptr_t>(elf_start + measures.strtab_start);
+      reinterpret_cast<uintptr_t>(elf_start .subspan( measures.strtab_start));
 #endif
   loc = AppendHdr(strtab_dyn, loc);
 
   // Add a string table with one entry for the soname, if necessary.
-  *loc++ = '\0';  // The first byte holds a null character.
+  (loc++)[0] = '\0';  // The first byte holds a null character.
   if (soname_) {
-    memcpy(loc, soname_->data(), soname_->size());
-    *(loc + soname_->size()) = '\0';
-    loc += soname_->size() + 1;
+    memcpy(loc.data(), soname_->data(), soname_->size());
+     (loc .subspan( soname_->size())[0]) = '\0';
+    loc=loc.subspan(soname_->size() + 1);
   }
 
   // The offset past the end of the contents should be consistent with the size
@@ -299,10 +301,10 @@ TestElfImage TestElfImageBuilder::Build() {
 
 // static
 template <typename T>
-uint8_t* TestElfImageBuilder::AppendHdr(const T& hdr, uint8_t* loc) {
+base::span<uint8_t> TestElfImageBuilder::AppendHdr(const T& hdr, base::span<uint8_t>loc) {
   static_assert(std::is_trivially_copyable_v<T>, "T should be a plain struct");
   memcpy(loc, &hdr, sizeof(T));
-  return loc + sizeof(T);
+  return loc .subspan( sizeof)(T);
 }
 
 Ehdr TestElfImageBuilder::CreateEhdr(Half phnum) {
diff --git a/base/debug/test_elf_image_builder.h b/base/debug/test_elf_image_builder.h
index 7dfee81fab428..bf13c693af648 100644
--- a/base/debug/test_elf_image_builder.h
+++ b/base/debug/test_elf_image_builder.h
@@ -108,7 +108,7 @@ class TestElfImageBuilder {
   // Appends a header of type |T| at |loc|, a memory address within the ELF
   // image being constructed, and returns the address past the header.
   template <typename T>
-  static uint8_t* AppendHdr(const T& hdr, uint8_t* loc);
+  static base::span<uint8_t> AppendHdr(const T& hdr, base::span<uint8_t>loc);
 
   Ehdr CreateEhdr(Half phnum);
   Phdr CreatePhdr(Word type,
diff --git a/base/files/memory_mapped_file.h b/base/files/memory_mapped_file.h
index 420779bbb9a44..024c6b6fb55f4 100644
--- a/base/files/memory_mapped_file.h
+++ b/base/files/memory_mapped_file.h
@@ -111,7 +111,7 @@ class BASE_EXPORT MemoryMappedFile {
   }
 
   const uint8_t* data() const { return bytes_.data(); }
-  uint8_t* data() { return bytes_.data(); }
+  base::span<uint8_t> data() { return bytes_; }
   size_t length() const { return bytes_.size(); }
 
   span<const uint8_t> bytes() const { return bytes_; }
diff --git a/base/i18n/icu_util.cc b/base/i18n/icu_util.cc
index 7c2960a56ff69..e623b41798c1b 100644
--- a/base/i18n/icu_util.cc
+++ b/base/i18n/icu_util.cc
@@ -231,7 +231,7 @@ int LoadIcuData(PlatformFile data_fd,
   }
 
   (*out_error_code) = U_ZERO_ERROR;
-  udata_setCommonData(const_cast<uint8_t*>((*out_mapped_data_file)->data()),
+  udata_setCommonData(const_cast<uint8_t*>((*out_mapped_data_file)->data().data()),
                       out_error_code);
   if (U_FAILURE(*out_error_code)) {
     LOG(ERROR) << "Failed to initialize ICU with data file: "
diff --git a/base/memory/platform_shared_memory_region_unittest.cc b/base/memory/platform_shared_memory_region_unittest.cc
index 34dc53fa27018..f9ad30955773c 100644
--- a/base/memory/platform_shared_memory_region_unittest.cc
+++ b/base/memory/platform_shared_memory_region_unittest.cc
@@ -315,7 +315,7 @@ TEST_F(PlatformSharedMemoryRegionTest, MappingProtectionSetCorrectly) {
   // The `mapped_size()` is larger then `size()` but is the actual size of the
   // shared memory backing.
   auto full_map_mem =
-      UNSAFE_BUFFERS(span(ro_mapping.data(), ro_mapping.mapped_size()));
+      UNSAFE_BUFFERS(span(ro_mapping.data().data(), ro_mapping.mapped_size()));
   EXPECT_FALSE(TryToRestoreWritablePermissions(full_map_mem.data(),
                                                full_map_mem.size()));
 
diff --git a/base/memory/shared_memory_mapping.h b/base/memory/shared_memory_mapping.h
index b45619dda274e..5e2091678c2a3 100644
--- a/base/memory/shared_memory_mapping.h
+++ b/base/memory/shared_memory_mapping.h
@@ -118,34 +118,34 @@ class BASE_EXPORT ReadOnlySharedMemoryMapping : public SharedMemoryMapping {
   // Use `span(mapping)` to make a span of `uint8_t`, `GetMemoryAs<T>()` to
   // access the memory as a single `T` or `GetMemoryAsSpan<T>()` to access it as
   // an array of `T`.
-  const uint8_t* data() const { return mapped_memory().data(); }
+  const base::span<uint8_t> data() const { return mapped_memory(); }
 
   // Iterate memory as bytes up to the end of its logical size.
   iterator begin() const {
     // SAFETY: There is an internal invariant (enforced in the constructors)
     // that `size() <= mapped_memory().size()`, so `data()` points to at least
     // that many valid bytes.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size()));
   }
   iterator end() const {
     // SAFETY: As in `begin()` above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size(), data() + size()));
   }
 
   // TODO(crbug.com/355451178): Deprecated. Use `span(mapping)` to make a span
   // of `uint8_t`, `GetMemoryAs<T>()` to access the memory as a single `T` or
   // `GetMemoryAsSpan<T>()` to access it as an array of `T`, or `data()` for an
   // unbounded pointer.
-  const void* memory() const { return data(); }
+  const base::span<void> memory() const { return data(); }
 
   // Returns a pointer to a page-aligned const T if the mapping is valid and
   // large enough to contain a T, or nullptr otherwise.
   template <typename T>
     requires subtle::AllowedOverSharedMemory<T>
-  const T* GetMemoryAs() const {
+  const base::span<T> GetMemoryAs() const {
     return (IsValid() && sizeof(T) <= size())
-               ? reinterpret_cast<const T*>(mapped_memory().data())
-               : nullptr;
+               ? reinterpret_cast<const T*>(mapped_memory())
+               : {};
   }
 
   // Returns a span of const T. The number of elements is autodeduced from the
@@ -211,34 +211,34 @@ class BASE_EXPORT WritableSharedMemoryMapping : public SharedMemoryMapping {
   // Use `span(mapping)` to make a span of `uint8_t`, `GetMemoryAs<T>()` to
   // access the memory as a single `T` or `GetMemoryAsSpan<T>()` to access it as
   // an array of `T`.
-  uint8_t* data() { return mapped_memory().data(); }
-  const uint8_t* data() const { return mapped_memory().data(); }
+  base::span<uint8_t> data() { return mapped_memory(); }
+  const base::span<uint8_t> data() const { return mapped_memory(); }
 
   // Iterate memory as bytes up to the end of its logical size.
   iterator begin() {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size()));
   }
   const_iterator begin() const {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(const_iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(const_iterator(data().data(), data() + size()));
   }
   iterator end() {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size(), data() + size()));
   }
   const_iterator end() const {
     // SAFETY: As in the ReadOnly code above.
     return UNSAFE_BUFFERS(
-        const_iterator(data(), data() + size(), data() + size()));
+        const_iterator(data().data(), data() + size(), data() + size()));
   }
 
   // TODO(crbug.com/355451178): Deprecated. Use `span(mapping)` to make a span
   // of `uint8_t`, `GetMemoryAs<T>()` to access the memory as a single `T`, or
   // `GetMemoryAsSpan<T>()` to access it as an array of `T` or `data()` for an
   // unbounded pointer.
-  void* memory() { return data(); }
-  const void* memory() const { return data(); }
+  base::span<void> memory() { return data(); }
+  const void* memory() const { return data().data(); }
 
   // Returns a pointer to a page-aligned T if the mapping is valid and large
   // enough to contain a T, or nullptr otherwise.
diff --git a/base/memory/shared_memory_mapping_unittest.cc b/base/memory/shared_memory_mapping_unittest.cc
index d8ead663827f6..4aa2b4b480089 100644
--- a/base/memory/shared_memory_mapping_unittest.cc
+++ b/base/memory/shared_memory_mapping_unittest.cc
@@ -42,7 +42,7 @@ class SharedMemoryMappingTest : public ::testing::Test {
 
 TEST_F(SharedMemoryMappingTest, Invalid) {
   EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint8_t>());
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint8_t>());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint8_t>().data());
   EXPECT_TRUE(write_mapping_.GetMemoryAsSpan<uint8_t>().empty());
   EXPECT_TRUE(read_mapping_.GetMemoryAsSpan<uint8_t>().empty());
   EXPECT_TRUE(write_mapping_.GetMemoryAsSpan<uint8_t>(1).empty());
@@ -55,7 +55,7 @@ TEST_F(SharedMemoryMappingTest, Scalar) {
   uint32_t* write_ptr = write_mapping_.GetMemoryAs<uint32_t>();
   ASSERT_NE(nullptr, write_ptr);
 
-  const uint32_t* read_ptr = read_mapping_.GetMemoryAs<uint32_t>();
+  const uint32_t* read_ptr = read_mapping_.GetMemoryAs<uint32_t>().data();
   ASSERT_NE(nullptr, read_ptr);
 
   *write_ptr = 0u;
@@ -211,7 +211,7 @@ TEST_F(SharedMemoryMappingTest, TooBigScalar) {
 
   EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint32_t>());
 
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint32_t>());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint32_t>().data());
 }
 
 TEST_F(SharedMemoryMappingTest, TooBigSpanWithAutoDeducedElementCount) {
@@ -245,7 +245,7 @@ TEST_F(SharedMemoryMappingTest, Atomic) {
   // Placement new to initialize the std::atomic in place.
   new (write_ptr) std::atomic<uint32_t>;
 
-  const auto* read_ptr = read_mapping_.GetMemoryAs<std::atomic<uint32_t>>();
+  const auto* read_ptr = read_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data();
   ASSERT_NE(nullptr, read_ptr);
 
   write_ptr->store(0u, std::memory_order_relaxed);
@@ -260,7 +260,7 @@ TEST_F(SharedMemoryMappingTest, TooBigAtomic) {
 
   EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<std::atomic<uint32_t>>());
 
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<std::atomic<uint32_t>>());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data());
 }
 
 // TODO(dcheng): This test is temporarily disabled on iOS. iOS devices allow
diff --git a/base/metrics/persistent_histogram_allocator.cc b/base/metrics/persistent_histogram_allocator.cc
index 60e62a99308a3..d16db99392905 100644
--- a/base/metrics/persistent_histogram_allocator.cc
+++ b/base/metrics/persistent_histogram_allocator.cc
@@ -9,6 +9,7 @@
 #include <string_view>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/debug/crash_logging.h"
 #include "base/files/file_path.h"
@@ -65,7 +66,7 @@ subtle::AtomicWord g_histogram_allocator = 0;
 // which is returned to the caller. A return of nullptr indicates that the
 // passed boundaries are invalid.
 std::unique_ptr<BucketRanges> CreateRangesFromData(
-    HistogramBase::Sample32* ranges_data,
+    base::span<HistogramBase::Sample32>ranges_data,
     uint32_t ranges_checksum,
     size_t count) {
   // To avoid racy destruction at shutdown, the following may be leaked.
@@ -418,10 +419,10 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::AllocateHistogram(
       ranges_ref =
           memory_allocator_->Allocate(ranges_bytes, kTypeIdRangesArray);
       if (ranges_ref) {
-        HistogramBase::Sample32* ranges_data =
+        base::span<HistogramBase::Sample32>ranges_data =
             memory_allocator_->GetAsArray<HistogramBase::Sample32>(
                 ranges_ref, kTypeIdRangesArray, ranges_count);
-        if (ranges_data) {
+        if (!ranges_data.empty()) {
           for (size_t i = 0; i < bucket_ranges->size(); ++i) {
             UNSAFE_TODO(ranges_data[i]) = bucket_ranges->range(i);
           }
@@ -607,7 +608,7 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(
   uint32_t histogram_ranges_checksum = histogram_data_ptr->ranges_checksum;
 
   size_t allocated_bytes = 0;
-  HistogramBase::Sample32* ranges_data =
+  base::span<HistogramBase::Sample32>ranges_data =
       memory_allocator_->GetAsArray<HistogramBase::Sample32>(
           histogram_ranges_ref, kTypeIdRangesArray,
           PersistentMemoryAllocator::kSizeAny, &allocated_bytes);
@@ -616,7 +617,7 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(
       std::numeric_limits<uint32_t>::max() / sizeof(HistogramBase::Sample32);
   size_t required_bytes =
       (histogram_bucket_count + 1) * sizeof(HistogramBase::Sample32);
-  if (!ranges_data || histogram_bucket_count < 2 ||
+  if (ranges_data.empty() || histogram_bucket_count < 2 ||
       histogram_bucket_count >= max_buckets ||
       allocated_bytes < required_bytes) {
     return nullptr;
@@ -649,8 +650,7 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(
 
   PersistentMemoryAllocator::Reference counts_ref =
       histogram_data_ptr->counts_ref.load(std::memory_order_acquire);
-  if (counts_ref != 0 && !memory_allocator_->GetAsArray<uint8_t>(
-                             counts_ref, kTypeIdCountsArray, counts_bytes)) {
+  if (counts_ref != 0 && ).empty()) {
     return nullptr;
   }
 
diff --git a/base/metrics/persistent_histogram_allocator_unittest.cc b/base/metrics/persistent_histogram_allocator_unittest.cc
index a04b7e610a819..c74463d8def2a 100644
--- a/base/metrics/persistent_histogram_allocator_unittest.cc
+++ b/base/metrics/persistent_histogram_allocator_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -627,9 +629,9 @@ TEST_F(PersistentHistogramAllocatorTest, RangesDeDuplication) {
   EXPECT_NE(0U, ref2);
   EXPECT_NE(ref1, ref2);
 
-  uint32_t* data1 =
+  base::span<uint32_t>data1 =
       allocator_->GetAsArray<uint32_t>(ref1, 0, kRangesRefIndex + 1);
-  uint32_t* data2 =
+  base::span<uint32_t>data2 =
       allocator_->GetAsArray<uint32_t>(ref2, 0, kRangesRefIndex + 1);
   EXPECT_EQ(ranges_ref, data1[kRangesRefIndex]);
   EXPECT_EQ(ranges_ref, data2[kRangesRefIndex]);
diff --git a/base/metrics/persistent_memory_allocator.cc b/base/metrics/persistent_memory_allocator.cc
index 5cddd459ec3b6..d859eb42f983a 100644
--- a/base/metrics/persistent_memory_allocator.cc
+++ b/base/metrics/persistent_memory_allocator.cc
@@ -11,6 +11,7 @@
 #include <optional>
 #include <string_view>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
@@ -435,7 +436,7 @@ PersistentMemoryAllocator::PersistentMemoryAllocator(Memory memory,
     if (!name.empty()) {
       const size_t name_length = name.length() + 1;
       shared_meta()->name = Allocate(name_length, 0);
-      char* name_cstr = GetAsArray<char>(shared_meta()->name, 0, name_length);
+      char* name_cstr = GetAsArray<char>(shared_meta()->name, 0, name_length).data();
       if (name_cstr) {
         memcpy(name_cstr, name.data(), name.length());
       }
@@ -538,7 +539,7 @@ PersistentMemoryAllocator::Reference PersistentMemoryAllocator::GetAsReference(
   }
 
   Reference ref = static_cast<Reference>(offset) - sizeof(BlockHeader);
-  if (!GetBlockData(ref, type_id, kSizeAny)) {
+  if ().empty()) {
     return kReferenceNull;
   }
 
@@ -997,7 +998,7 @@ uint32_t PersistentMemoryAllocator::version() const {
   return shared_meta()->version;
 }
 
-const volatile void* PersistentMemoryAllocator::GetBlockData(
+const volatile base::span<void> PersistentMemoryAllocator::GetBlockData(
     Reference ref,
     uint32_t type_id,
     size_t size,
@@ -1006,7 +1007,7 @@ const volatile void* PersistentMemoryAllocator::GetBlockData(
   const volatile BlockHeader* block = GetBlock(
       ref, type_id, size, /*queue_ok=*/false, /*free_ok=*/false, alloc_size);
   if (!block) {
-    return nullptr;
+    return {};
   }
   return UNSAFE_TODO(reinterpret_cast<const volatile char*>(block) +
                      sizeof(BlockHeader));
@@ -1333,8 +1334,8 @@ span<uint8_t> DelayedPersistentAllocation::GetUntyped() const {
   }
 
   // Find the referenced memory and return it as a span if successful.
-  uint8_t* mem = allocator_->GetAsArray<uint8_t>(ref, type_, size_);
-  if (mem) {
+  base::span<uint8_t>mem = allocator_->GetAsArray<uint8_t>(ref, type_, size_);
+  if (!mem.empty()) {
     // This is the success path.
     return UNSAFE_TODO(span(mem + offset_, size_ - offset_));
   }
diff --git a/base/metrics/persistent_memory_allocator.h b/base/metrics/persistent_memory_allocator.h
index 25b4501fc8b41..0913e2e78cfcf 100644
--- a/base/metrics/persistent_memory_allocator.h
+++ b/base/metrics/persistent_memory_allocator.h
@@ -473,7 +473,7 @@ class BASE_EXPORT PersistentMemoryAllocator {
   // compatibilty when using these accessors. Only use fixed-size types such
   // as char, float, double, or (u)intXX_t.
   template <typename T>
-  T* GetAsArray(Reference ref,
+  base::span<T> GetAsArray(Reference ref,
                 uint32_t type_id,
                 size_t count,
                 size_t* alloc_size = nullptr) {
@@ -488,7 +488,7 @@ class BASE_EXPORT PersistentMemoryAllocator {
                       size_t* alloc_size = nullptr) const {
     static_assert(std::is_fundamental_v<T>, "use GetAsObject<>()");
     return const_cast<const char*>(reinterpret_cast<const volatile T*>(
-        GetBlockData(ref, type_id, count * sizeof(T), alloc_size)));
+        GetBlockData(ref, type_id, count * sizeof(T), alloc_size).data()));
   }
 
   // Gets the corresponding reference for an object held in persistent memory.
@@ -778,11 +778,11 @@ class BASE_EXPORT PersistentMemoryAllocator {
   }
 
   // Gets the actual data within a block associated with a specific reference.
-  const volatile void* GetBlockData(Reference ref,
+  const volatile base::span<void> GetBlockData(Reference ref,
                                     uint32_t type_id,
                                     size_t size,
                                     size_t* alloc_size = nullptr) const;
-  volatile void* GetBlockData(Reference ref,
+  volatile base::span<void> GetBlockData(Reference ref,
                               uint32_t type_id,
                               size_t size,
                               size_t* alloc_size = nullptr) {
diff --git a/base/metrics/persistent_memory_allocator_unittest.cc b/base/metrics/persistent_memory_allocator_unittest.cc
index 63d045b063c39..6eca24ce77ae7 100644
--- a/base/metrics/persistent_memory_allocator_unittest.cc
+++ b/base/metrics/persistent_memory_allocator_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -152,8 +154,8 @@ TEST_F(PersistentMemoryAllocatorTest, AllocateAndIterate) {
 
   // Verify that pointers can be turned back into references and that invalid
   // addresses return null.
-  char* memory1 = allocator_->GetAsArray<char>(block1, 1, 1);
-  ASSERT_TRUE(memory1);
+  base::span<char>memory1 = allocator_->GetAsArray<char>(block1, 1, 1);
+  ASSERT_TRUE(memory1.data());
   EXPECT_EQ(block1, allocator_->GetAsReference(memory1, 0));
   EXPECT_EQ(block1, allocator_->GetAsReference(memory1, 1));
   EXPECT_EQ(0U, allocator_->GetAsReference(memory1, 2));
@@ -780,8 +782,8 @@ TEST(SharedPersistentMemoryAllocatorTest, CreationTest) {
 
   // Clear-on-change test.
   Reference data_ref = shalloc3.Allocate(sizeof(int) * 4, 911);
-  int* data = shalloc3.GetAsArray<int>(data_ref, 911, 4);
-  ASSERT_TRUE(data);
+  base::span<int>data = shalloc3.GetAsArray<int>(data_ref, 911, 4);
+  ASSERT_TRUE(data.data());
   data[0] = 0;
   data[1] = 1;
   data[2] = 2;
diff --git a/base/process/process_metrics_unittest.cc b/base/process/process_metrics_unittest.cc
index d61a242093588..ed906159ed914 100644
--- a/base/process/process_metrics_unittest.cc
+++ b/base/process/process_metrics_unittest.cc
@@ -1047,7 +1047,7 @@ TEST(ProcessMetricsTestLinux, GetPageFaultCounts) {
     WritableSharedMemoryMapping mapping = region.Map();
     ASSERT_TRUE(mapping.IsValid());
 
-    memset(mapping.memory(), 42, kMappedSize);
+    memset(mapping.memory().data(), 42, kMappedSize);
   }
 
   PageFaultCounts counts_after;
diff --git a/base/profiler/stack_copier.cc b/base/profiler/stack_copier.cc
index 85f2ae0d8a3a9..45b0f5578430f 100644
--- a/base/profiler/stack_copier.cc
+++ b/base/profiler/stack_copier.cc
@@ -94,7 +94,7 @@ const uint8_t* StackCopier::CopyStackContentsAndRewritePointers(
   // RewritePointerIfInOriginalStack(). Bytes before this cannot be a pointer
   // because they occupy less space than a pointer would.
   const uint8_t* first_aligned_address =
-      bits::AlignUp(byte_src, sizeof(uintptr_t));
+      bits::AlignUp(byte_src, sizeof(uintptr_t)).data();
 
   // The stack copy bottom, which is offset from |stack_buffer_bottom| by the
   // same alignment as in the original stack. This guarantees identical
diff --git a/base/trace_event/process_memory_dump_unittest.cc b/base/trace_event/process_memory_dump_unittest.cc
index e596dc486694e..8954b97b6ff88 100644
--- a/base/trace_event/process_memory_dump_unittest.cc
+++ b/base/trace_event/process_memory_dump_unittest.cc
@@ -72,7 +72,7 @@ std::optional<size_t> CountResidentBytesInSharedMemory(
   // mapped_size() is larger than `mem.size()` but represents the actual memory
   // segment size in the SharedMemoryMapping.
   auto mapped =
-      UNSAFE_BUFFERS(base::span(mapping.data(), mapping.mapped_size()));
+      UNSAFE_BUFFERS(base::span(mapping.data().data(), mapping.mapped_size()));
   return ProcessMemoryDump::CountResidentBytesInSharedMemory(mapped.data(),
                                                              mapped.size());
 }
diff --git a/cc/trees/layer_tree_host_unittest.cc b/cc/trees/layer_tree_host_unittest.cc
index 07ab503e53fb6..d2f4c5d614373 100644
--- a/cc/trees/layer_tree_host_unittest.cc
+++ b/cc/trees/layer_tree_host_unittest.cc
@@ -9707,7 +9707,7 @@ class LayerTreeHostUkmSmoothnessMetric : public LayerTreeTest {
   void AfterTest() override {
     ASSERT_TRUE(shmem_region_.IsValid());
     auto mapping = shmem_region_.Map();
-    auto* smoothness = mapping.GetMemoryAs<UkmSmoothnessDataShared>();
+    auto* smoothness = mapping.GetMemoryAs<UkmSmoothnessDataShared>().data();
     ASSERT_TRUE(smoothness);
     // It is not always possible to guarantee an exact number of dropped frames.
     // So validate that there are non-zero dropped frames.
diff --git a/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc b/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
index b7448cedc7e96..72632a5e64bf9 100644
--- a/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
+++ b/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
@@ -24,7 +24,7 @@ namespace enterprise_connectors {
 static base::ReadOnlySharedMemoryRegion CreateFakePage(size_t page_size) {
   base::MappedReadOnlyRegion page =
       base::ReadOnlySharedMemoryRegion::Create(page_size);
-  memset(page.mapping.memory(), 'a', page_size);
+  memset(page.mapping.memory().data(), 'a', page_size);
   return std::move(page.region);
 }
 
diff --git a/chrome/browser/enterprise/data_protection/print_utils.cc b/chrome/browser/enterprise/data_protection/print_utils.cc
index b5b0f0a629d8d..a86f88e1c6acd 100644
--- a/chrome/browser/enterprise/data_protection/print_utils.cc
+++ b/chrome/browser/enterprise/data_protection/print_utils.cc
@@ -122,7 +122,7 @@ void PrintIfAllowedByPolicy(
     std::move(on_verdict).Run(/*allowed=*/true);
     return;
   }
-  std::memcpy(region.mapping.memory(), print_data->data(), print_data->size());
+  std::memcpy(region.mapping.memory().data(), print_data->data(), print_data->size());
   scanning_data.page = std::move(region.region);
 
   auto on_scan_result = base::BindOnce(
diff --git a/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc b/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
index 368fe5ba89ae6..ac0ee27853188 100644
--- a/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
+++ b/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
@@ -151,7 +151,7 @@ class FileOperationProxyImplTest : public testing::Test {
     base::MemoryMappedFile mapped_file;
     CHECK(mapped_file.Initialize(std::move(open_result)));
     EXPECT_THAT(
-        std::string_view(reinterpret_cast<const char*>(mapped_file.data()),
+        std::string_view(reinterpret_cast<const char*>(mapped_file.data().data()),
                          mapped_file.length()),
         *expected_file_content);
   }
diff --git a/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc b/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
index 4262fbbc3dab7..fb2d714ccab48 100644
--- a/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
+++ b/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
@@ -1528,7 +1528,7 @@ void UkmPageLoadMetricsObserver::RecordPageLoadTimestampMetrics(
 
 void UkmPageLoadMetricsObserver::RecordDroppedFramesMetrics() {
   auto* dropped_frames =
-      ukm_dropped_frames_data_.GetMemoryAs<cc::UkmDroppedFramesDataShared>();
+      ukm_dropped_frames_data_.GetMemoryAs<cc::UkmDroppedFramesDataShared>().data();
   if (!dropped_frames) {
     return;
   }
@@ -1547,7 +1547,7 @@ void UkmPageLoadMetricsObserver::RecordDroppedFramesMetrics() {
 
 void UkmPageLoadMetricsObserver::RecordSmoothnessMetrics() {
   auto* smoothness =
-      ukm_smoothness_data_.GetMemoryAs<cc::UkmSmoothnessDataShared>();
+      ukm_smoothness_data_.GetMemoryAs<cc::UkmSmoothnessDataShared>().data();
   if (!smoothness) {
     return;
   }
diff --git a/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc b/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
index 021e7a99fcabf..6547671d7cd29 100644
--- a/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
+++ b/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
@@ -60,7 +60,7 @@ base::MappedReadOnlyRegion GetPdfRegion(const char* file_name) {
   if (!pdf_region.IsValid())
     return pdf_region;
 
-  memcpy(pdf_region.mapping.memory(), pdf_str.data(), pdf_str.size());
+  memcpy(pdf_region.mapping.memory().data(), pdf_str.data(), pdf_str.size());
   return pdf_region;
 }
 
@@ -71,7 +71,7 @@ base::MappedReadOnlyRegion GetBadDataRegion() {
   if (!pdf_region.IsValid())
     return pdf_region;
 
-  memcpy(pdf_region.mapping.memory(), kBadData, std::size(kBadData));
+  memcpy(pdf_region.mapping.memory().data(), kBadData, std::size(kBadData));
   return pdf_region;
 }
 
diff --git a/chrome/browser/printing/pwg_raster_converter.cc b/chrome/browser/printing/pwg_raster_converter.cc
index 99e65447132e9..a6f8c68622da9 100644
--- a/chrome/browser/printing/pwg_raster_converter.cc
+++ b/chrome/browser/printing/pwg_raster_converter.cc
@@ -110,7 +110,7 @@ void PwgRasterConverterHelper::Convert(
 
   // TODO(thestig): Write `data` into shared memory in the first place, to avoid
   // this memcpy().
-  memcpy(memory.mapping.memory(), data->data(), data->size());
+  memcpy(memory.mapping.memory().data(), data->data(), data->size());
   pdf_to_pwg_raster_converter_remote_->Convert(
       std::move(memory.region), settings_, bitmap_settings_,
       base::BindOnce(&PwgRasterConverterHelper::RunCallback, this));
diff --git a/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc b/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
index 4fc77f73f6a9e..32a3d3c7b1e22 100644
--- a/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
+++ b/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
@@ -113,7 +113,7 @@ class FakeClientSideDetectionService : public ClientSideDetectionService {
   base::ReadOnlySharedMemoryRegion GetModelSharedMemoryRegion() override {
     base::MappedReadOnlyRegion mapped_region =
         base::ReadOnlySharedMemoryRegion::Create(client_side_model_.length());
-    memcpy(mapped_region.mapping.memory(), client_side_model_.data(),
+    memcpy(mapped_region.mapping.memory().data(), client_side_model_.data(),
            client_side_model_.length());
     return mapped_region.region.Duplicate();
   }
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
index 667838cfbd978..93eb357195e68 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
@@ -71,7 +71,7 @@ class ConnectorDataPipeGetterTest : public testing::Test {
     if (!region.IsValid())
       return base::ReadOnlySharedMemoryRegion();
 
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
index f775531bfc617..ef9dc722d1a75 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
@@ -69,7 +69,7 @@ class MultipartUploadRequestTest : public testing::Test {
     base::MappedReadOnlyRegion region =
         base::ReadOnlySharedMemoryRegion::Create(content.size());
     EXPECT_TRUE(region.IsValid());
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
index 2b232d3f3a121..98fb680e03ccb 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
@@ -102,7 +102,7 @@ class ResumableUploadRequestTest : public testing::Test {
     base::MappedReadOnlyRegion region =
         base::ReadOnlySharedMemoryRegion::Create(content.size());
     EXPECT_TRUE(region.IsValid());
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc b/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
index 2c6e6e87aa29c..5176c39ce1d60 100644
--- a/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
+++ b/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
@@ -203,7 +203,7 @@ class PhishingClassifierTest
     mapped_region_ =
         base::ReadOnlySharedMemoryRegion::Create(model_str.length());
     ASSERT_TRUE(mapped_region_.IsValid());
-    memcpy(mapped_region_.mapping.memory(), model_str.data(),
+    memcpy(mapped_region_.mapping.memory().data(), model_str.data(),
            model_str.length());
     base::File tflite_model;
     base::FilePath tflite_path;
diff --git a/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc b/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
index 31f983e13c0da..b1bfe8d18185c 100644
--- a/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
+++ b/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
@@ -193,7 +193,7 @@ class PhishingClassifierDelegateTest : public ChromeRenderViewTest {
     std::string model_str = GetFlatBufferString(model_version);
     base::MappedReadOnlyRegion mapped_region =
         base::ReadOnlySharedMemoryRegion::Create(model_str.length());
-    memcpy(mapped_region.mapping.memory(), model_str.data(),
+    memcpy(mapped_region.mapping.memory().data(), model_str.data(),
            model_str.length());
 
     ScorerStorage::GetInstance()->SetScorer(
@@ -357,7 +357,7 @@ TEST_F(PhishingClassifierDelegateTest, HasVisualTfLiteModel) {
   std::string model_str = GetFlatBufferString(0);
   base::MappedReadOnlyRegion mapped_region =
       base::ReadOnlySharedMemoryRegion::Create(model_str.length());
-  memcpy(mapped_region.mapping.memory(), model_str.data(), model_str.length());
+  memcpy(mapped_region.mapping.memory().data(), model_str.data(), model_str.length());
   ScorerStorage::GetInstance()->SetScorer(
       Scorer::Create(mapped_region.region.Duplicate(), std::move(file)));
   ASSERT_TRUE(classifier_->is_ready());
diff --git a/chrome/services/printing/pdf_nup_converter.cc b/chrome/services/printing/pdf_nup_converter.cc
index 0276c9a34a4bc..3eec151c93abb 100644
--- a/chrome/services/printing/pdf_nup_converter.cc
+++ b/chrome/services/printing/pdf_nup_converter.cc
@@ -47,7 +47,7 @@ void RunCallbackWithConversionResult(Callback callback,
     return;
   }
 
-  memcpy(region_mapping.mapping.memory(), buffer.data(), buffer.size());
+  memcpy(region_mapping.mapping.memory().data(), buffer.data(), buffer.size());
   std::move(callback).Run(mojom::PdfNupConverter::Status::SUCCESS,
                           std::move(region_mapping.region));
 }
diff --git a/chrome/services/printing/pdf_to_pwg_raster_converter.cc b/chrome/services/printing/pdf_to_pwg_raster_converter.cc
index 4b133378c3baa..2f5eda9c56831 100644
--- a/chrome/services/printing/pdf_to_pwg_raster_converter.cc
+++ b/chrome/services/printing/pdf_to_pwg_raster_converter.cc
@@ -130,7 +130,7 @@ base::ReadOnlySharedMemoryRegion RenderPdfPagesToPwgRaster(
     return invalid_pwg_region;
 
   *page_count = total_page_count;
-  memcpy(region_mapping.mapping.memory(), pwg_data.data(), pwg_data.size());
+  memcpy(region_mapping.mapping.memory().data(), pwg_data.data(), pwg_data.size());
   return std::move(region_mapping.region);
 }
 
diff --git a/components/enterprise/watermarking/content/watermark_text_container.cc b/components/enterprise/watermarking/content/watermark_text_container.cc
index a06fbbf576b6e..f57f9e5dcf23a 100644
--- a/components/enterprise/watermarking/content/watermark_text_container.cc
+++ b/components/enterprise/watermarking/content/watermark_text_container.cc
@@ -38,7 +38,7 @@ watermark::mojom::WatermarkBlockPtr WatermarkTextContainer::Serialize() const {
   if (!region_mapping.IsValid()) {
     return nullptr;
   }
-  stream.copyTo(region_mapping.mapping.memory());
+  stream.copyTo(region_mapping.mapping.memory().data());
   return watermark::mojom::WatermarkBlockPtr(std::in_place,
                                              std::move(region_mapping.region),
                                              block_width_, block_height_);
diff --git a/components/enterprise/watermarking/watermark_test_utils.cc b/components/enterprise/watermarking/watermark_test_utils.cc
index 9959aaea6cdfd..4e682a8443dd9 100644
--- a/components/enterprise/watermarking/watermark_test_utils.cc
+++ b/components/enterprise/watermarking/watermark_test_utils.cc
@@ -47,7 +47,7 @@ watermark::mojom::WatermarkBlockPtr MakeTestWatermarkBlock(
   if (!region_mapping.IsValid()) {
     return nullptr;
   }
-  stream.copyTo(region_mapping.mapping.memory());
+  stream.copyTo(region_mapping.mapping.memory().data());
 
   // Measure string dimensions
   SkScalar text_width = font.measureText(
diff --git a/components/metrics/persistent_system_profile.cc b/components/metrics/persistent_system_profile.cc
index 5ffc5ec97f90a..7b1221b84cbcf 100644
--- a/components/metrics/persistent_system_profile.cc
+++ b/components/metrics/persistent_system_profile.cc
@@ -86,7 +86,7 @@ void PersistentSystemProfile::RecordAllocator::Reset() {
     // arrays of fundamental types are allowed.
     RecordHeader* header =
         reinterpret_cast<RecordHeader*>(allocator_->GetAsArray<char>(
-            alloc_reference_, kTypeIdSystemProfile, sizeof(RecordHeader)));
+            alloc_reference_, kTypeIdSystemProfile, sizeof(RecordHeader)).data());
     DCHECK(header);
     base::subtle::NoBarrier_Store(&header->as_atomic, 0);
   }
@@ -122,15 +122,15 @@ bool PersistentSystemProfile::RecordAllocator::HasMoreData() const {
   if (alloc_reference_ == 0 && !NextSegment())
     return false;
 
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block)
+  if (block.empty())
     return false;
 
   RecordHeader header;
   header.as_atomic = base::subtle::Acquire_Load(
-      reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_));
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()));
   return header.as_parts.type != kUnusedSpace;
 }
 
@@ -163,7 +163,7 @@ bool PersistentSystemProfile::RecordAllocator::AddSegment(size_t min_size) {
     // or by the "reset" procedure.
     DCHECK_EQ(0, base::subtle::NoBarrier_Load(
                      allocator_->GetAsArray<base::subtle::Atomic32>(
-                         alloc_reference_, kTypeIdSystemProfile, 1)));
+                         alloc_reference_, kTypeIdSystemProfile, 1).data()));
     return true;
   }
 
@@ -188,10 +188,10 @@ bool PersistentSystemProfile::RecordAllocator::AddSegment(size_t min_size) {
 bool PersistentSystemProfile::RecordAllocator::WriteData(RecordType type,
                                                          const char** data,
                                                          size_t* data_size) {
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block)
+  if (block.empty())
     return false;  // It's bad if there is no accessible block.
 
   const size_t max_write_size = std::min(
@@ -212,11 +212,11 @@ bool PersistentSystemProfile::RecordAllocator::WriteData(RecordType type,
   if (end_offset_ < alloc_size_) {
     // An empty record header has to be next before this one gets written.
     base::subtle::NoBarrier_Store(
-        reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_), 0);
+        reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()), 0);
   }
-  memcpy(block + offset + sizeof(header), *data, write_size);
+  memcpy(block .subspan( offset + sizeof).data()(header), *data, write_size);
   base::subtle::Release_Store(
-      reinterpret_cast<base::subtle::Atomic32*>(block + offset),
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( offset).data()),
       header.as_atomic);
 
   // Account for what was stored and prepare for follow-on records with any
@@ -232,10 +232,10 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
     std::string* record) const {
   DCHECK_GT(alloc_size_, end_offset_);
 
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block) {
+  if (block.empty()) {
     *type = kUnusedSpace;
     return true;  // No more data.
   }
@@ -243,7 +243,7 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
   // Get and validate the record header.
   RecordHeader header;
   header.as_atomic = base::subtle::Acquire_Load(
-      reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_));
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()));
   bool continued = !!header.as_parts.continued;
   if (header.as_parts.type == kUnusedSpace) {
     *type = kUnusedSpace;
@@ -275,7 +275,7 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
   }
 
   // Append the record data to the output string.
-  record->append(block + end_offset_ + sizeof(header), read_size);
+  record->append(block .subspan( end_offset_ + sizeof).data()(header), read_size);
   end_offset_ += CalculateRecordSize(read_size);
   DCHECK_GE(alloc_size_, end_offset_);
 
diff --git a/components/mirroring/service/fake_video_capture_host.cc b/components/mirroring/service/fake_video_capture_host.cc
index e998ac5d3548b..0ea240404a3dd 100644
--- a/components/mirroring/service/fake_video_capture_host.cc
+++ b/components/mirroring/service/fake_video_capture_host.cc
@@ -74,7 +74,7 @@ void FakeVideoCaptureHost::SendOneFrame(const gfx::Size& size,
   if (!shmem.IsValid()) {
     return;
   }
-  memset(shmem.mapping.memory(), 125, 5000);
+  memset(shmem.mapping.memory().data(), 125, 5000);
   observer_->OnNewBuffer(
       0, media::mojom::VideoBufferHandle::NewReadOnlyShmemRegion(
              std::move(shmem.region)));
diff --git a/components/mirroring/service/video_capture_client.cc b/components/mirroring/service/video_capture_client.cc
index a5a5d3a9047a6..b219550e29844 100644
--- a/components/mirroring/service/video_capture_client.cc
+++ b/components/mirroring/service/video_capture_client.cc
@@ -253,7 +253,7 @@ void VideoCaptureClient::OnBufferReady(media::mojom::ReadyBufferPtr buffer) {
       frame = media::VideoFrame::WrapExternalData(
           buffer->info->pixel_format, buffer->info->coded_size,
           buffer->info->visible_rect, buffer->info->visible_rect.size(),
-          mapping.GetMemoryAs<uint8_t>(), frame_allocation_size,
+          mapping.GetMemoryAs<uint8_t>().data(), frame_allocation_size,
           buffer->info->timestamp);
       if (frame) {
         frame->BackWithOwnedSharedMemory(std::move(shm_region),
diff --git a/components/omnibox/browser/on_device_tail_model_executor.cc b/components/omnibox/browser/on_device_tail_model_executor.cc
index 417e608c292a4..e4b15b3927ea8 100644
--- a/components/omnibox/browser/on_device_tail_model_executor.cc
+++ b/components/omnibox/browser/on_device_tail_model_executor.cc
@@ -276,7 +276,7 @@ bool OnDeviceTailModelExecutor::InitModelInterpreter(
 
   std::unique_ptr<tflite::FlatBufferModel> model =
       tflite::FlatBufferModel::VerifyAndBuildFromBuffer(
-          reinterpret_cast<const char*>(model_fb_->data()),
+          reinterpret_cast<const char*>(model_fb_->data().data()),
           model_fb_->length());
 
   if (model == nullptr) {
diff --git a/components/optimization_guide/core/base_model_executor.h b/components/optimization_guide/core/base_model_executor.h
index 14271ca47e228..e3a7ad15d5269 100644
--- a/components/optimization_guide/core/base_model_executor.h
+++ b/components/optimization_guide/core/base_model_executor.h
@@ -62,7 +62,7 @@ class BaseModelExecutor : public TFLiteModelExecutor<OutputType, InputType>,
         std::make_unique<tflite::task::core::TfLiteEngine>(
             std::make_unique<TFLiteOpResolver>());
     absl::Status model_load_status = tflite_engine->BuildModelFromFlatBuffer(
-        reinterpret_cast<const char*>(model_file->data()),
+        reinterpret_cast<const char*>(model_file->data().data()),
         model_file->length());
     if (!model_load_status.ok()) {
       DLOG(ERROR) << "Failed to load model: " << model_load_status.ToString();
diff --git a/components/optimization_guide/core/bert_model_executor.cc b/components/optimization_guide/core/bert_model_executor.cc
index b0b24a57962bd..3862b3430f67d 100644
--- a/components/optimization_guide/core/bert_model_executor.cc
+++ b/components/optimization_guide/core/bert_model_executor.cc
@@ -54,7 +54,7 @@ BertModelExecutor::BuildModelExecutionTask(base::MemoryMappedFile* model_file) {
   *options.mutable_base_options()
        ->mutable_model_file()
        ->mutable_file_content() = std::string(
-      reinterpret_cast<const char*>(model_file->data()), model_file->length());
+      reinterpret_cast<const char*>(model_file->data().data()), model_file->length());
   options.mutable_base_options()
       ->mutable_compute_settings()
       ->mutable_tflite_settings()
diff --git a/components/page_content_annotations/core/page_visibility_model_executor.cc b/components/page_content_annotations/core/page_visibility_model_executor.cc
index 3abee43a2308b..509c1cedfdb6c 100644
--- a/components/page_content_annotations/core/page_visibility_model_executor.cc
+++ b/components/page_content_annotations/core/page_visibility_model_executor.cc
@@ -62,7 +62,7 @@ PageVisibilityModelExecutor::BuildModelExecutionTask(
   *options.mutable_base_options()
        ->mutable_model_file()
        ->mutable_file_content() = std::string(
-      reinterpret_cast<const char*>(model_file->data()), model_file->length());
+      reinterpret_cast<const char*>(model_file->data().data()), model_file->length());
   options.mutable_base_options()
       ->mutable_compute_settings()
       ->mutable_tflite_settings()
diff --git a/components/printing/browser/print_to_pdf/pdf_print_job.cc b/components/printing/browser/print_to_pdf/pdf_print_job.cc
index e736489665708..64433ac068f4b 100644
--- a/components/printing/browser/print_to_pdf/pdf_print_job.cc
+++ b/components/printing/browser/print_to_pdf/pdf_print_job.cc
@@ -130,7 +130,7 @@ void PdfPrintJob::ReportMemoryRegion(
   }
 
   std::string data =
-      std::string(static_cast<const char*>(mapping.memory()), mapping.size());
+      std::string(static_cast<const char*>(mapping.memory().data()), mapping.size());
   std::move(print_to_pdf_callback_)
       .Run(PdfPrintResult::kPrintSuccess,
            base::MakeRefCounted<base::RefCountedString>(std::move(data)));
diff --git a/components/safe_browsing/content/browser/client_side_phishing_model.cc b/components/safe_browsing/content/browser/client_side_phishing_model.cc
index 9ccdc04cc17ad..9a8fd47dbfcf2 100644
--- a/components/safe_browsing/content/browser/client_side_phishing_model.cc
+++ b/components/safe_browsing/content/browser/client_side_phishing_model.cc
@@ -313,7 +313,7 @@ void ClientSidePhishingModel::OnModelAndVisualTfLiteFileLoaded(
           base::ReadOnlySharedMemoryRegion::Create(model_str.length());
       if (mapped_region_.IsValid()) {
         model_type_ = CSDModelType::kFlatbuffer;
-        memcpy(mapped_region_.mapping.memory(), model_str.data(),
+        memcpy(mapped_region_.mapping.memory().data(), model_str.data(),
                model_str.length());
 
         const flat::ClientSideModel* flatbuffer_model =
@@ -604,7 +604,7 @@ void ClientSidePhishingModel::SetModelStringForTesting(
           base::ReadOnlySharedMemoryRegion::Create(model_str.length());
       if (mapped_region_.IsValid()) {
         model_type_ = CSDModelType::kFlatbuffer;
-        memcpy(mapped_region_.mapping.memory(), model_str.data(),
+        memcpy(mapped_region_.mapping.memory().data(), model_str.data(),
                model_str.length());
       } else {
         model_valid = false;
@@ -652,7 +652,7 @@ void ClientSidePhishingModel::ClearMappedRegionForTesting() {
 
 void* ClientSidePhishingModel::GetFlatBufferMemoryAddressForTesting() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return mapped_region_.mapping.memory();
+  return mapped_region_.mapping.memory().data();
 }
 
 // This function is used for testing in client_side_phishing_model_unittest
@@ -699,7 +699,7 @@ void ClientSidePhishingModel::OnGetOverridenModelData(
         VLOG(2) << "Could not create shared memory region for flatbuffer";
         return;
       }
-      memcpy(mapped_region_.mapping.memory(), model_data.data(),
+      memcpy(mapped_region_.mapping.memory().data(), model_data.data(),
              model_data.length());
       model_type_ = model_type;
       break;
diff --git a/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc b/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
index 6c7fb8dc400e2..e16621a7e0ff3 100644
--- a/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
+++ b/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
@@ -192,7 +192,7 @@ void GetFlatBufferStringFromMappedMemory(
   ASSERT_TRUE(region.IsValid());
   base::ReadOnlySharedMemoryMapping mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  *output = std::string(reinterpret_cast<const char*>(mapping.memory()),
+  *output = std::string(reinterpret_cast<const char*>(mapping.memory().data()),
                         mapping.size());
 }
 
diff --git a/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc b/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
index c822c39d8e283..a4b69e4f93328 100644
--- a/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
+++ b/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
@@ -406,7 +406,7 @@ std::unique_ptr<Scorer> Scorer::Create(base::ReadOnlySharedMemoryRegion region,
   }
 
   flatbuffers::Verifier verifier(
-      reinterpret_cast<const uint8_t*>(mapping.memory()), mapping.size());
+      reinterpret_cast<const uint8_t*>(mapping.memory().data()), mapping.size());
   if (!flat::VerifyClientSideModelBuffer(verifier)) {
     RecordScorerCreationStatus(SCORER_FAIL_FLATBUFFER_FAILED_VERIFY);
     return nullptr;
diff --git a/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc b/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
index fe7db86e1a356..e59ee7456fade 100644
--- a/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
+++ b/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
@@ -98,7 +98,7 @@ base::MappedReadOnlyRegion GetMappedReadOnlyRegionWithData(std::string data) {
   base::MappedReadOnlyRegion mapped_region =
       base::ReadOnlySharedMemoryRegion::Create(data.length());
   EXPECT_TRUE(mapped_region.IsValid());
-  memcpy(mapped_region.mapping.memory(), data.data(), data.length());
+  memcpy(mapped_region.mapping.memory().data(), data.data(), data.length());
   return mapped_region;
 }
 
diff --git a/components/services/font/public/cpp/mapped_font_file.cc b/components/services/font/public/cpp/mapped_font_file.cc
index 23e48d2841166..562a2e45cc939 100644
--- a/components/services/font/public/cpp/mapped_font_file.cc
+++ b/components/services/font/public/cpp/mapped_font_file.cc
@@ -27,7 +27,7 @@ bool MappedFontFile::Initialize(base::File file) {
 SkMemoryStream* MappedFontFile::CreateMemoryStream() {
   DCHECK(mapped_font_file_.IsValid());
   sk_sp<SkData> data =
-      SkData::MakeWithProc(mapped_font_file_.data(), mapped_font_file_.length(),
+      SkData::MakeWithProc(mapped_font_file_.data().data(), mapped_font_file_.length(),
                            &MappedFontFile::ReleaseProc, this);
   if (!data)
     return nullptr;
diff --git a/components/services/on_device_translation/translate_kit_client.cc b/components/services/on_device_translation/translate_kit_client.cc
index cd4aaa316289a..31178ba81a97f 100644
--- a/components/services/on_device_translation/translate_kit_client.cc
+++ b/components/services/on_device_translation/translate_kit_client.cc
@@ -62,7 +62,7 @@ void DeleteReadOnlyMemoryRegion(std::uintptr_t memory_map_ptr,
 const void* ReadOnlyMemoryRegionData(std::uintptr_t memory_map_ptr,
                                      std::uintptr_t user_data) {
   CHECK(memory_map_ptr);
-  return reinterpret_cast<base::MemoryMappedFile*>(memory_map_ptr)->data();
+  return reinterpret_cast<base::MemoryMappedFile*>(memory_map_ptr)->data().data();
 }
 
 uint64_t ReadOnlyMemoryRegionLength(std::uintptr_t memory_map_ptr,
diff --git a/components/services/print_compositor/print_compositor_impl.cc b/components/services/print_compositor/print_compositor_impl.cc
index 4ec2e6ccf47a1..d9713fb833fed 100644
--- a/components/services/print_compositor/print_compositor_impl.cc
+++ b/components/services/print_compositor/print_compositor_impl.cc
@@ -485,7 +485,7 @@ mojom::PrintCompositor::Status PrintCompositorImpl::CompositePages(
     return mojom::PrintCompositor::Status::kHandleMapError;
   }
 
-  wstream.copyToAndReset(region_mapping.mapping.memory());
+  wstream.copyToAndReset(region_mapping.mapping.memory().data());
   *region = std::move(region_mapping.region);
   return mojom::PrintCompositor::Status::kSuccess;
 }
@@ -557,7 +557,7 @@ void PrintCompositorImpl::FinishDocumentRequest(
           doc_info_->compositor_stream.bytesWritten());
   if (region_mapping.IsValid()) {
     doc_info_->compositor_stream.copyToAndReset(
-        region_mapping.mapping.memory());
+        region_mapping.mapping.memory().data());
     region = std::move(region_mapping.region);
     status = mojom::PrintCompositor::Status::kSuccess;
   } else {
diff --git a/components/visitedlink/browser/partitioned_visitedlink_writer.cc b/components/visitedlink/browser/partitioned_visitedlink_writer.cc
index 4f583e1671f12..56901e152c8bf 100644
--- a/components/visitedlink/browser/partitioned_visitedlink_writer.cc
+++ b/components/visitedlink/browser/partitioned_visitedlink_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -278,11 +280,11 @@ bool PartitionedVisitedLinkWriter::CreateVisitedLinkTableHelper(
     return false;
   }
 
-  memset(memory->mapping.memory(), 0, alloc_size);
+  memset(memory->mapping.memory().data(), 0, alloc_size);
 
   // Save the header for other processes to read.
   PartitionedSharedHeader* header =
-      static_cast<PartitionedSharedHeader*>(memory->mapping.memory());
+      static_cast<PartitionedSharedHeader*>(memory->mapping.memory().data());
   header->length = num_entries;
   return true;
 }
@@ -329,7 +331,7 @@ void PartitionedVisitedLinkWriter::ResizeTable(int32_t new_size) {
   }
 
   {
-    Fingerprint* old_hash_table =
+    base::span<Fingerprint>old_hash_table =
         GetHashTableFromMapping(old_hash_table_mapping);
     // Now we have two tables, our local copy which is the old one, and the new
     // one loaded into this object where we need to copy the data.
@@ -363,7 +365,7 @@ bool PartitionedVisitedLinkWriter::BuildTableFromDelegate() {
 VisitedLinkWriter::Hash PartitionedVisitedLinkWriter::AddFingerprint(
     Fingerprint fingerprint,
     bool send_notifications) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     base::UmaHistogramEnumeration("History.VisitedLinks.TryToAddFingerprint",
                                   AddFingerprint::kTableError);
     NOTREACHED();  // Not initialized.
@@ -418,7 +420,7 @@ void PartitionedVisitedLinkWriter::DeleteFingerprintsFromCurrentTable(
 }
 
 bool PartitionedVisitedLinkWriter::DeleteFingerprint(Fingerprint fingerprint) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     NOTREACHED();  // Not initialized.
   }
   if (!IsVisited(fingerprint)) {
@@ -658,7 +660,7 @@ void PartitionedVisitedLinkWriter::DeleteAllVisitedLinks() {
 
   // Clear the hash table.
   used_items_ = 0;
-  memset(hash_table_, 0, this->table_length_ * sizeof(Fingerprint));
+  memset(hash_table_.data(), 0, this->table_length_ * sizeof(Fingerprint));
 
   // Resize it if it is now too empty. Resize may write the new table out for
   // us, otherwise, schedule writing the new table to disk ourselves.
@@ -769,14 +771,14 @@ std::optional<uint64_t> PartitionedVisitedLinkWriter::GetOrAddOriginSalt(
 }
 
 // static
-VisitedLinkCommon::Fingerprint*
+base::span<VisitedLinkCommon::Fingerprint>
 PartitionedVisitedLinkWriter::GetHashTableFromMapping(
     base::WritableSharedMemoryMapping& hash_table_mapping) {
   DCHECK(hash_table_mapping.IsValid());
   // Our table pointer is just the data immediately following the header.
   return reinterpret_cast<Fingerprint*>(
-      static_cast<char*>(hash_table_mapping.memory()) +
-      sizeof(PartitionedSharedHeader));
+      static_cast<char*>(hash_table_mapping.memory()) .subspan(
+      sizeof)(PartitionedSharedHeader));
 }
 
 }  // namespace visitedlink
diff --git a/components/visitedlink/browser/partitioned_visitedlink_writer.h b/components/visitedlink/browser/partitioned_visitedlink_writer.h
index 9a7eeb5926e4a..0109394d456b9 100644
--- a/components/visitedlink/browser/partitioned_visitedlink_writer.h
+++ b/components/visitedlink/browser/partitioned_visitedlink_writer.h
@@ -8,6 +8,7 @@
 #include <map>
 #include <set>
 
+#include "base/containers/span.h"
 #include "base/memory/read_only_shared_memory_region.h"
 #include "components/visitedlink/common/visitedlink_common.h"
 #include "components/visitedlink/core/visited_link.h"
@@ -240,7 +241,7 @@ class PartitionedVisitedLinkWriter : public VisitedLinkCommon {
 
   // Returns a pointer to the start of the hash table, given the mapping
   // containing the hash table.
-  static Fingerprint* GetHashTableFromMapping(
+  static base::span<Fingerprint> GetHashTableFromMapping(
       base::WritableSharedMemoryMapping& hash_table_mapping);
 
   // Returns the default table size. It can be overridden in unit tests.
diff --git a/components/visitedlink/browser/visitedlink_writer.cc b/components/visitedlink/browser/visitedlink_writer.cc
index 2582ca68a4b0f..fe23687b32d7f 100644
--- a/components/visitedlink/browser/visitedlink_writer.cc
+++ b/components/visitedlink/browser/visitedlink_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -406,7 +408,7 @@ void VisitedLinkWriter::DeleteAllURLs() {
 
   // Clear the hash table.
   used_items_ = 0;
-  memset(hash_table_, 0, this->table_length_ * sizeof(Fingerprint));
+  memset(hash_table_.data(), 0, this->table_length_ * sizeof(Fingerprint));
 
   // Resize it if it is now too empty. Resize may write the new table out for
   // us, otherwise, schedule writing the new table to disk ourselves.
@@ -486,7 +488,7 @@ void VisitedLinkWriter::DeleteURLs(URLIterator* urls) {
 VisitedLinkWriter::Hash VisitedLinkWriter::AddFingerprint(
     Fingerprint fingerprint,
     bool send_notifications) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     UMA_HISTOGRAM_ENUMERATION("History.VisitedLinks.TryToAddFingerprint",
                               AddFingerprint::kTableError);
     NOTREACHED();  // Not initialized.
@@ -546,7 +548,7 @@ void VisitedLinkWriter::DeleteFingerprintsFromCurrentTable(
 
 bool VisitedLinkWriter::DeleteFingerprint(Fingerprint fingerprint,
                                           bool update_file) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     NOTREACHED();  // Not initialized.
   }
   if (!IsVisited(fingerprint))
@@ -921,10 +923,10 @@ bool VisitedLinkWriter::CreateApartURLTable(
   if (!memory->IsValid())
     return false;
 
-  memset(memory->mapping.memory(), 0, alloc_size);
+  memset(memory->mapping.memory().data(), 0, alloc_size);
 
   // Save the header for other processes to read.
-  SharedHeader* header = static_cast<SharedHeader*>(memory->mapping.memory());
+  SharedHeader* header = static_cast<SharedHeader*>(memory->mapping.memory().data());
   header->length = num_entries;
   memcpy(header->salt, salt, LINK_SALT_LENGTH);
 
@@ -985,7 +987,7 @@ void VisitedLinkWriter::ResizeTable(int32_t new_size) {
   shared_memory_serial_++;
 
   {
-    Fingerprint* old_hash_table =
+    base::span<Fingerprint>old_hash_table =
         GetHashTableFromMapping(old_hash_table_mapping);
     // Now we have two tables, our local copy which is the old one, and the new
     // one loaded into this object where we need to copy the data.
@@ -1202,12 +1204,12 @@ void VisitedLinkWriter::TableBuilder::OnCompleteMainThread() {
 }
 
 // static
-VisitedLinkCommon::Fingerprint* VisitedLinkWriter::GetHashTableFromMapping(
+base::span<VisitedLinkCommon::Fingerprint> VisitedLinkWriter::GetHashTableFromMapping(
     base::WritableSharedMemoryMapping& hash_table_mapping) {
   DCHECK(hash_table_mapping.IsValid());
   // Our table pointer is just the data immediately following the header.
   return reinterpret_cast<Fingerprint*>(
-      static_cast<char*>(hash_table_mapping.memory()) + sizeof(SharedHeader));
+      static_cast<char*>(hash_table_mapping.memory()) .subspan( sizeof)(SharedHeader));
 }
 
 }  // namespace visitedlink
diff --git a/components/visitedlink/browser/visitedlink_writer.h b/components/visitedlink/browser/visitedlink_writer.h
index 79de29510d397..0344b065b34f9 100644
--- a/components/visitedlink/browser/visitedlink_writer.h
+++ b/components/visitedlink/browser/visitedlink_writer.h
@@ -13,6 +13,7 @@
 #include <set>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/files/file_path.h"
 #include "base/files/scoped_file.h"
 #include "base/functional/callback.h"
@@ -402,7 +403,7 @@ class VisitedLinkWriter : public VisitedLinkCommon {
 
   // Returns a pointer to the start of the hash table, given the mapping
   // containing the hash table.
-  static Fingerprint* GetHashTableFromMapping(
+  static base::span<Fingerprint> GetHashTableFromMapping(
       base::WritableSharedMemoryMapping& hash_table_mapping);
 
   // Reference to the browser context that this object belongs to
diff --git a/components/visitedlink/common/visitedlink_common.cc b/components/visitedlink/common/visitedlink_common.cc
index f5bd0ffc685d4..6abc4f684a666 100644
--- a/components/visitedlink/common/visitedlink_common.cc
+++ b/components/visitedlink/common/visitedlink_common.cc
@@ -54,7 +54,7 @@ bool VisitedLinkCommon::IsVisited(std::string_view canonical_url) const {
   if (canonical_url.size() == 0) {
     return false;
   }
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     return false;
   }
   return IsVisited(ComputeURLFingerprint(canonical_url));
@@ -65,7 +65,7 @@ bool VisitedLinkCommon::IsVisited(const GURL& url) const {
 }
 
 bool VisitedLinkCommon::IsVisited(const VisitedLink& link, uint64_t salt) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     return false;
   }
   if (!link.IsValid()) {
diff --git a/components/visitedlink/common/visitedlink_common.h b/components/visitedlink/common/visitedlink_common.h
index 5b97414065022..78256f87ff908 100644
--- a/components/visitedlink/common/visitedlink_common.h
+++ b/components/visitedlink/common/visitedlink_common.h
@@ -11,6 +11,7 @@
 #include <string_view>
 #include <vector>
 
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "components/visitedlink/core/visited_link.h"
 
@@ -142,7 +143,7 @@ class VisitedLinkCommon {
   // function should be called instead of accessing the table directly to
   // contain endian issues.
   Fingerprint FingerprintAt(int32_t table_offset) const {
-    if (!hash_table_)
+    if (!!hash_table_.empty())
       return null_fingerprint_;
     return hash_table_[table_offset];
   }
@@ -182,7 +183,7 @@ class VisitedLinkCommon {
 
   // pointer to the first item
   // May temporarily point to an old unmapped region during update.
-  raw_ptr<VisitedLinkCommon::Fingerprint,
+  base::raw_span<VisitedLinkCommon::Fingerprint,
           DisableDanglingPtrDetection | AllowPtrArithmetic>
       hash_table_ = nullptr;
 
diff --git a/components/visitedlink/renderer/visitedlink_reader.cc b/components/visitedlink/renderer/visitedlink_reader.cc
index 34e6e6d50d1f6..43093c96d755b 100644
--- a/components/visitedlink/renderer/visitedlink_reader.cc
+++ b/components/visitedlink/renderer/visitedlink_reader.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -85,7 +87,7 @@ void VisitedLinkReader::UpdateUnpartitionedVisitedLinks(
       return;
 
     const SharedHeader* header =
-        static_cast<const SharedHeader*>(header_mapping.memory());
+        static_cast<const SharedHeader*>(header_mapping.memory().data());
     table_len = header->length;
     memcpy(salt_, header->salt, sizeof(salt_));
   }
@@ -97,7 +99,7 @@ void VisitedLinkReader::UpdateUnpartitionedVisitedLinks(
 
   // Commit the data.
   hash_table_ = const_cast<Fingerprint*>(reinterpret_cast<const Fingerprint*>(
-      static_cast<const SharedHeader*>(table_mapping_.memory()) + 1));
+      static_cast<const SharedHeader*>(table_mapping_.memory()) .subspan( 1)));
   table_length_ = table_len;
   base::UmaHistogramCounts10M(
       "History.VisitedLinks.HashTableLengthOnReaderInit", table_length_);
@@ -116,7 +118,7 @@ void VisitedLinkReader::UpdatePartitionedVisitedLinks(
     }
 
     const PartitionedSharedHeader* header =
-        static_cast<const PartitionedSharedHeader*>(header_mapping.memory());
+        static_cast<const PartitionedSharedHeader*>(header_mapping.memory().data());
     table_len = header->length;
   }
 
@@ -128,8 +130,8 @@ void VisitedLinkReader::UpdatePartitionedVisitedLinks(
 
   // Commit the data.
   hash_table_ = const_cast<Fingerprint*>(reinterpret_cast<const Fingerprint*>(
-      static_cast<const PartitionedSharedHeader*>(table_mapping_.memory()) +
-      1));
+      static_cast<const PartitionedSharedHeader*>(table_mapping_.memory()) .subspan(
+      1)));
   table_length_ = table_len;
   base::UmaHistogramCounts10M(
       "History.VisitedLinks.HashTableLengthOnReaderInit", table_length_);
@@ -155,11 +157,11 @@ void VisitedLinkReader::UpdateOriginSalts(
 }
 
 void VisitedLinkReader::FreeTable() {
-  if (!hash_table_)
+  if (!!hash_table_.empty())
     return;
 
   table_mapping_ = base::ReadOnlySharedMemoryMapping();
-  hash_table_ = nullptr;
+  hash_table_ = {};
   table_length_ = 0;
 }
 
diff --git a/components/viz/common/yuv_readback_unittest.cc b/components/viz/common/yuv_readback_unittest.cc
index 31a262e025ee2..6da54197bd563 100644
--- a/components/viz/common/yuv_readback_unittest.cc
+++ b/components/viz/common/yuv_readback_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -240,7 +242,7 @@ class YUVReadbackTest : public testing::Test {
     return ret;
   }
 
-  void PrintPlane(const unsigned char* plane,
+  void PrintPlane(base::span<const unsigned char>plane,
                   int xsize,
                   int stride,
                   int ysize) {
@@ -255,9 +257,9 @@ class YUVReadbackTest : public testing::Test {
 
   // Compare two planes make sure that each component of each pixel
   // is no more than |maxdiff| apart.
-  void ComparePlane(const unsigned char* truth,
+  void ComparePlane(base::span<const unsigned char>truth,
                     int truth_stride,
-                    const unsigned char* other,
+                    base::span<const unsigned char>other,
                     int other_stride,
                     int maxdiff,
                     int xsize,
@@ -386,18 +388,18 @@ class YUVReadbackTest : public testing::Test {
       FlipSKBitmap(&input_pixels);
     }
 
-    unsigned char* Y =
+    base::span<unsigned char>Y =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY);
-    unsigned char* U =
+    base::span<unsigned char>U =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU);
-    unsigned char* V =
+    base::span<unsigned char>V =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV);
     int32_t y_stride = truth_frame->stride(media::VideoFrame::Plane::kY);
     int32_t u_stride = truth_frame->stride(media::VideoFrame::Plane::kU);
     int32_t v_stride = truth_frame->stride(media::VideoFrame::Plane::kV);
-    memset(Y, 0x00, y_stride * output_ysize);
-    memset(U, 0x80, u_stride * output_ysize / 2);
-    memset(V, 0x80, v_stride * output_ysize / 2);
+    memset(Y.data(), 0x00, y_stride * output_ysize);
+    memset(U.data(), 0x80, u_stride * output_ysize / 2);
+    memset(V.data(), 0x80, v_stride * output_ysize / 2);
 
     const auto kRGBtoYColorWeights =
         std::to_array<float>({0.257f, 0.504f, 0.098f, 0.0625f});
diff --git a/components/viz/service/display/renderer_pixeltest.cc b/components/viz/service/display/renderer_pixeltest.cc
index 46e42db96a399..6c3291bb45000 100644
--- a/components/viz/service/display/renderer_pixeltest.cc
+++ b/components/viz/service/display/renderer_pixeltest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -485,30 +487,30 @@ void CreateTestY16TextureDrawQuad_TwoColor(
   DCHECK_EQ(video_frame->stride(0) % 2, 0ul);
 
   for (int j = 0; j < video_frame->rows(0); ++j) {
-    uint8_t* row = video_frame->writable_data(0) + j * video_frame->stride(0);
+    base::span<uint8_t>row = video_frame->writable_data(0) .subspan( j * video_frame->stride(0));
     if (j < foreground_rect.y() || j >= foreground_rect.bottom()) {
       for (size_t i = 0; i < video_frame->stride(0) / 2; ++i) {
-        *row++ = i & 0xFF;  // Fill R with anything. It is not rendered.
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;  // Fill R with anything. It is not rendered.
+        (row++)[0] = g_background;
       }
     } else {
       for (size_t i = 0; i < std::min<size_t>(video_frame->stride(0) / 2,
                                               foreground_rect.x());
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_background;
       }
       for (size_t i = foreground_rect.x();
            i < std::min<size_t>(video_frame->stride(0) / 2,
                                 foreground_rect.right());
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_foreground;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_foreground;
       }
       for (size_t i = foreground_rect.right(); i < video_frame->stride(0) / 2;
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_background;
       }
     }
   }
@@ -547,16 +549,16 @@ scoped_refptr<media::VideoFrame> CreateHighbitVideoFrame(
   for (int plane = media::VideoFrame::Plane::kY;
        plane <= media::VideoFrame::Plane::kV; ++plane) {
     int width = video_frame->row_bytes(plane);
-    const uint8_t* src = video_frame->data(plane);
-    uint16_t* dst = reinterpret_cast<uint16_t*>(ret->writable_data(plane));
+    base::span<const uint8_t>src = video_frame->data(plane);
+    base::span<uint16_t>dst = reinterpret_cast<uint16_t*>(ret->writable_data(plane));
     for (int row = 0; row < video_frame->rows(plane); row++) {
       for (int x = 0; x < width; x++) {
         // Replicate the top bits into the lower bits, this way
         // 0xFF becomes 0x3FF.
         dst[x] = (src[x] << 2) | (src[x] >> 6);
       }
-      src += video_frame->stride(plane);
-      dst += ret->stride(plane) / 2;
+      src=src.subspan(video_frame->stride(plane));
+      dst=dst.subspan(ret->stride(plane) / 2);
     }
   }
   return ret;
@@ -580,7 +582,7 @@ void CreateTestMultiplanarVideoDrawQuad_FromVideoFrame(
   float draw_opacity = 1.0f;
   const bool with_alpha = (video_frame->format() == media::PIXEL_FORMAT_I420A);
   if (with_alpha) {
-    memset(video_frame->writable_data(media::VideoFrame::Plane::kA),
+    memset(video_frame->writable_data(media::VideoFrame::Plane::kA).data(),
            alpha_value,
            video_frame->stride(media::VideoFrame::Plane::kA) *
                video_frame->rows(media::VideoFrame::Plane::kA));
@@ -639,18 +641,18 @@ void CreateTestMultiplanarVideoDrawQuad_Striped(
   uint8_t u_value = 0;
   uint8_t v_value = 0;
   for (int i = 0; i < video_frame->rows(media::VideoFrame::Plane::kY); ++i) {
-    uint8_t* y_row = video_frame->writable_data(media::VideoFrame::Plane::kY) +
-                     video_frame->stride(media::VideoFrame::Plane::kY) * i;
+    base::span<uint8_t>y_row = video_frame->writable_data(media::VideoFrame::Plane::kY) .subspan(
+                     video_frame->stride(media::VideoFrame::Plane::kY) * i);
     for (int j = 0; j < video_frame->row_bytes(media::VideoFrame::Plane::kY);
          ++j) {
       y_row[j] = (y_value += 1);
     }
   }
   for (int i = 0; i < video_frame->rows(media::VideoFrame::Plane::kU); ++i) {
-    uint8_t* u_row = video_frame->writable_data(media::VideoFrame::Plane::kU) +
-                     video_frame->stride(media::VideoFrame::Plane::kU) * i;
-    uint8_t* v_row = video_frame->writable_data(media::VideoFrame::Plane::kV) +
-                     video_frame->stride(media::VideoFrame::Plane::kV) * i;
+    base::span<uint8_t>u_row = video_frame->writable_data(media::VideoFrame::Plane::kU) .subspan(
+                     video_frame->stride(media::VideoFrame::Plane::kU) * i);
+    base::span<uint8_t>v_row = video_frame->writable_data(media::VideoFrame::Plane::kV) .subspan(
+                     video_frame->stride(media::VideoFrame::Plane::kV) * i);
     for (int j = 0; j < video_frame->row_bytes(media::VideoFrame::Plane::kU);
          ++j) {
       u_row[j] = (u_value += 3);
@@ -717,7 +719,7 @@ void CreateTestMultiplanarVideoDrawQuad_TwoColor(
   int sample_size[] = {1, 2, 2};
 
   for (int i = 0; i < 3; ++i) {
-    memset(video_frame->writable_data(planes[i]), yuv_background[i],
+    memset(video_frame->writable_data(planes[i]).data(), yuv_background[i],
            video_frame->stride(planes[i]) * video_frame->rows(planes[i]));
   }
 
@@ -780,18 +782,18 @@ void CreateTestMultiplanarVideoDrawQuad_Solid(
 
   // YUV values of a solid, constant, color. Useful for testing that color
   // space/color range are being handled properly.
-  memset(video_frame->writable_data(media::VideoFrame::Plane::kY), y,
+  memset(video_frame->writable_data(media::VideoFrame::Plane::kY).data(), y,
          video_frame->stride(media::VideoFrame::Plane::kY) *
              video_frame->rows(media::VideoFrame::Plane::kY));
   if (format == media::PIXEL_FORMAT_NV12) {
     const int stride_uv = video_frame->stride(media::VideoFrame::Plane::kUV);
     const int half_height = (coded_size.height() + 1) / 2;
-    uint8_t* uv_plane =
+    base::span<uint8_t>uv_plane =
         video_frame->writable_data(media::VideoFrame::Plane::kUV);
     // Set U and V.
     for (int row = 0; row < half_height; ++row) {
       for (int col = 0; col < stride_uv; col++) {
-        *uv_plane = col % 2 == 0 ? u : v;
+         uv_plane[0] = col % 2 == 0 ? u : v;
         uv_plane++;
       }
     }
@@ -799,10 +801,10 @@ void CreateTestMultiplanarVideoDrawQuad_Solid(
     // Only NV12, YV12 and I420 formats are used for testing here.
     CHECK(format == media::PIXEL_FORMAT_I420 ||
           format == media::PIXEL_FORMAT_YV12);
-    memset(video_frame->writable_data(media::VideoFrame::Plane::kU), u,
+    memset(video_frame->writable_data(media::VideoFrame::Plane::kU).data(), u,
            video_frame->stride(media::VideoFrame::Plane::kU) *
                video_frame->rows(media::VideoFrame::Plane::kU));
-    memset(video_frame->writable_data(media::VideoFrame::Plane::kV), v,
+    memset(video_frame->writable_data(media::VideoFrame::Plane::kV).data(), v,
            video_frame->stride(media::VideoFrame::Plane::kV) *
                video_frame->rows(media::VideoFrame::Plane::kV));
   }
diff --git a/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc b/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
index 2ca58bd295b02..19468f98e4c8d 100644
--- a/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -273,7 +275,7 @@ class MockConsumer : public mojom::FrameSinkVideoConsumer {
       ASSERT_LE(required_bytes_to_hold_planes, mapping.size());
       frame = media::VideoFrame::WrapExternalData(
           info->pixel_format, info->coded_size, info->visible_rect,
-          info->visible_rect.size(), mapping.GetMemoryAs<const uint8_t>(),
+          info->visible_rect.size(), mapping.GetMemoryAs<const uint8_t>().data(),
           mapping.size(), info->timestamp);
       ASSERT_TRUE(frame);
       frame->AddDestructionObserver(
@@ -644,7 +646,7 @@ bool IsLetterboxedI420Plane(int plane,
         content_rect_copy.width() / 2, content_rect_copy.height() / 2);
   }
   for (int row = 0; row < frame.rows(plane); ++row) {
-    const uint8_t* p = frame.visible_data(plane) + row * frame.stride(plane);
+    base::span<const uint8_t>p = frame.visible_data(plane) .subspan( row * frame.stride(plane));
     for (int col = 0; col < frame.row_bytes(plane); ++col) {
       if (content_rect_copy.Contains(gfx::Point(col, row))) {
         if (p[col] != component) {
@@ -679,7 +681,7 @@ bool IsLetterboxedRGBA(SkColor color,
                                                 frame.coded_size().height());
   bitmap.installPixels(
       bitmap_info,
-      const_cast<uint8_t*>(frame.visible_data(VideoFrame::Plane::kARGB)),
+      const_cast<uint8_t*>(frame.visible_data(VideoFrame::Plane::kARGB).data()),
       frame.stride(VideoFrame::Plane::kARGB));
 
   for (int row = 0; row < bitmap.height(); ++row) {
diff --git a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
index 5217379fd0c50..ee9344f2e7211 100644
--- a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
+++ b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
@@ -115,7 +115,7 @@ scoped_refptr<VideoFrame> SharedMemoryVideoFramePool::WrapBuffer(
   // destroyed).
   scoped_refptr<VideoFrame> frame = VideoFrame::WrapExternalData(
       format, size, gfx::Rect(size), size,
-      static_cast<uint8_t*>(pooled_buffer.mapping.memory()),
+      static_cast<uint8_t*>(pooled_buffer.mapping.memory().data()),
       pooled_buffer.mapping.size(), base::TimeDelta());
   CHECK(frame);
   // Sanity-check the assumption being made for SetMarkedBuffer():
diff --git a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
index 364672359b769..2e0b2f6c3de63 100644
--- a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -171,7 +173,7 @@ bool PlanesAreFilledWithValues(const VideoFrame& frame, const uint8_t* values) {
        ++plane) {
     const uint8_t expected_value = values[plane - VideoFrame::Plane::kY];
     for (int y = 0; y < frame.rows(plane); ++y) {
-      const uint8_t* row = frame.visible_data(plane) + y * frame.stride(plane);
+      base::span<const uint8_t>row = frame.visible_data(plane) .subspan( y * frame.stride(plane));
       for (int x = 0; x < frame.row_bytes(plane); ++x) {
         EXPECT_EQ(expected_value, row[x])
             << "at row " << y << " in plane " << plane;
diff --git a/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc b/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
index 82a8a1938abb0..779229daf199a 100644
--- a/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -454,11 +456,11 @@ class VideoCaptureOverlayRenderTest
     // as those of the YUV tests, and so only one set of golden files needs to
     // be used.
     if (is_argb_test()) {
-      uint8_t* dst = frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
+      base::span<uint8_t>dst = frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
       const int stride = frame->stride(VideoFrame::Plane::kARGB);
-      for (int row = 0; row < size.height(); ++row, dst += stride) {
-        uint32_t* const begin = reinterpret_cast<uint32_t*>(dst);
-        std::fill(begin, begin + size.width(), UINT32_C(0xff000000));
+      for (int row = 0; row < size.height(); ++row, dst=dst.subspan(stride)) {
+        const base::span<uint32_t>begin = reinterpret_cast<uint32_t*>(dst);
+        std::fill(begin.data(), begin .subspan( size.width()).data(), UINT32_C(0xff000000));
       }
     } else /* if (!is_argb_test()) */ {
       media::FillYUV(frame.get(), 0x00, 0x80, 0x80);
@@ -491,7 +493,7 @@ class VideoCaptureOverlayRenderTest
             kBGRA_8888_SkColorType, kUnpremul_SkAlphaType,
             frame.ColorSpace().ToSkColorSpace());
         canonical_bitmap.writePixels(
-            SkPixmap(frame_format, frame.visible_data(VideoFrame::Plane::kARGB),
+            SkPixmap(frame_format, frame.visible_data(VideoFrame::Plane::kARGB).data(),
                      frame.stride(VideoFrame::Plane::kARGB)),
             0, 0);
         break;
@@ -505,12 +507,12 @@ class VideoCaptureOverlayRenderTest
             new gfx::ColorTransform::TriStim[size.GetArea()]);
         int pos = 0;
         for (int row = 0; row < size.height(); ++row) {
-          const uint8_t* y = frame.visible_data(VideoFrame::Plane::kY) +
-                             (row * frame.stride(VideoFrame::Plane::kY));
-          const uint8_t* u = frame.visible_data(VideoFrame::Plane::kU) +
-                             ((row / 2) * frame.stride(VideoFrame::Plane::kU));
-          const uint8_t* v = frame.visible_data(VideoFrame::Plane::kV) +
-                             ((row / 2) * frame.stride(VideoFrame::Plane::kV));
+          base::span<const uint8_t>y = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                             (row * frame.stride(VideoFrame::Plane::kY)));
+          base::span<const uint8_t>u = frame.visible_data(VideoFrame::Plane::kU) .subspan(
+                             ((row / 2) * frame.stride(VideoFrame::Plane::kU)));
+          base::span<const uint8_t>v = frame.visible_data(VideoFrame::Plane::kV) .subspan(
+                             ((row / 2) * frame.stride(VideoFrame::Plane::kV)));
           for (int col = 0; col < size.width(); ++col) {
             colors[pos].SetPoint(y[col] / 255.0f, u[col / 2] / 255.0f,
                                  v[col / 2] / 255.0f);
diff --git a/components/viz/test/test_raster_interface.h b/components/viz/test/test_raster_interface.h
index 136976e2936f6..196acfc62e6dc 100644
--- a/components/viz/test/test_raster_interface.h
+++ b/components/viz/test/test_raster_interface.h
@@ -7,6 +7,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "components/viz/test/test_context_support.h"
 #include "gpu/command_buffer/client/raster_interface.h"
@@ -117,7 +118,7 @@ class TestRasterInterface : public gpu::raster::RasterInterface {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override {}
   void ReadbackYUVPixelsAsync(
       const gpu::Mailbox& source_mailbox,
@@ -126,11 +127,11 @@ class TestRasterInterface : public gpu::raster::RasterInterface {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override {}
diff --git a/components/zucchini/mapped_file.h b/components/zucchini/mapped_file.h
index 4834d78d25c21..09ec0bc73447b 100644
--- a/components/zucchini/mapped_file.h
+++ b/components/zucchini/mapped_file.h
@@ -52,7 +52,7 @@ class MappedFileWriter {
   const MappedFileWriter& operator=(const MappedFileWriter&) = delete;
   ~MappedFileWriter();
 
-  uint8_t* data() { return buffer_.data(); }
+  uint8_t* data() { return buffer_.data().data(); }
   size_t length() const { return buffer_.length(); }
   zucchini::MutableBufferView region() { return {data(), length()}; }
 
diff --git a/content/browser/font_access/font_access_manager_unittest.cc b/content/browser/font_access/font_access_manager_unittest.cc
index 185e5d76fe8e6..35ac1d2ee93ea 100644
--- a/content/browser/font_access/font_access_manager_unittest.cc
+++ b/content/browser/font_access/font_access_manager_unittest.cc
@@ -184,7 +184,7 @@ void ValidateFontEnumerationBasic(FontEnumerationStatus status,
   base::ReadOnlySharedMemoryMapping mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
   blink::FontEnumerationTable table;
-  EXPECT_TRUE(table.ParseFromArray(mapping.memory(), mapping.size()));
+  EXPECT_TRUE(table.ParseFromArray(mapping.memory().data(), mapping.size()));
 
   blink::FontEnumerationTable_FontData previous_font;
   for (const auto& font : table.fonts()) {
diff --git a/content/browser/media/capture/fake_video_capture_stack.cc b/content/browser/media/capture/fake_video_capture_stack.cc
index c62276750ef19..8591b13dcb4d7 100644
--- a/content/browser/media/capture/fake_video_capture_stack.cc
+++ b/content/browser/media/capture/fake_video_capture_stack.cc
@@ -154,7 +154,7 @@ class FakeVideoCaptureStackReceiver final : public media::VideoFrameReceiver {
     auto video_frame = media::VideoFrame::WrapExternalData(
         frame.frame_info->pixel_format, frame.frame_info->coded_size,
         frame.frame_info->visible_rect, frame.frame_info->visible_rect.size(),
-        mapping.GetMemoryAs<const uint8_t>(), mapping.size(),
+        mapping.GetMemoryAs<const uint8_t>().data(), mapping.size(),
         frame.frame_info->timestamp);
     CHECK(video_frame);
 
diff --git a/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc b/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
index b236a38f7f108..5265311878e89 100644
--- a/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
+++ b/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
@@ -390,7 +390,7 @@ class FrameSinkVideoCaptureDeviceTest : public testing::Test {
         base::ReadOnlySharedMemoryRegion::Create(
             media::VideoFrame::AllocationSize(kFormat, kResolution));
     CHECK(region.IsValid());
-    memset(region.mapping.memory(), GetFrameFillValue(frame_number),
+    memset(region.mapping.memory().data(), GetFrameFillValue(frame_number),
            region.mapping.size());
 
     mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>
diff --git a/content/browser/media/capture/frame_test_util.cc b/content/browser/media/capture/frame_test_util.cc
index ce30a4e0b42f7..471a26d69f6ac 100644
--- a/content/browser/media/capture/frame_test_util.cc
+++ b/content/browser/media/capture/frame_test_util.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/342213636): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -36,9 +38,9 @@ using TriStim = gfx::ColorTransform::TriStim;
 
 // Copies YUV row data into an array of TriStims, mapping [0,255][0.0,1.0]. The
 // chroma planes are assumed to be half-width.
-void LoadStimsFromYUV(const uint8_t y_src[],
-                      const uint8_t u_src[],
-                      const uint8_t v_src[],
+void LoadStimsFromYUV(base::span<const uint8_t> y_src,
+                      base::span<const uint8_t> u_src,
+                      base::span<const uint8_t> v_src,
                       int width,
                       TriStim stims[]) {
   for (int i = 0; i < width; ++i) {
@@ -47,8 +49,8 @@ void LoadStimsFromYUV(const uint8_t y_src[],
   }
 }
 
-void LoadStimsFromYUV(const uint8_t y_src[],
-                      const uint16_t uv_src[],
+void LoadStimsFromYUV(base::span<const uint8_t> y_src,
+                      base::span<const uint16_t> uv_src,
                       int width,
                       TriStim stims[]) {
 // https://docs.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering#nv12
@@ -121,21 +123,21 @@ SkBitmap FrameTestUtil::ConvertToBitmap(const media::VideoFrame& frame) {
   for (int row = 0; row < bitmap.height(); ++row) {
     if (frame.format() == media::VideoPixelFormat::PIXEL_FORMAT_I420) {
       LoadStimsFromYUV(
-          frame.visible_data(media::VideoFrame::Plane::kY) +
-              row * frame.stride(media::VideoFrame::Plane::kY),
-          frame.visible_data(media::VideoFrame::Plane::kU) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kU),
-          frame.visible_data(media::VideoFrame::Plane::kV) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kV),
+          frame.visible_data(media::VideoFrame::Plane::kY) .subspan(
+              row * frame.stride(media::VideoFrame::Plane::kY)),
+          frame.visible_data(media::VideoFrame::Plane::kU) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kU)),
+          frame.visible_data(media::VideoFrame::Plane::kV) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kV)),
           bitmap.width(), stims.data());
     } else {
       CHECK_EQ(frame.format(), media::VideoPixelFormat::PIXEL_FORMAT_NV12);
       LoadStimsFromYUV(
-          frame.visible_data(media::VideoFrame::Plane::kY) +
-              row * frame.stride(media::VideoFrame::Plane::kY),
+          frame.visible_data(media::VideoFrame::Plane::kY) .subspan(
+              row * frame.stride(media::VideoFrame::Plane::kY)),
           reinterpret_cast<const uint16_t*>(
-              frame.visible_data(media::VideoFrame::Plane::kUV) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kUV)),
+              frame.visible_data(media::VideoFrame::Plane::kUV) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kUV))),
           bitmap.width(), stims.data());
     }
     transform->Transform(stims.data(), stims.size());
diff --git a/content/browser/renderer_host/media/video_capture_controller_unittest.cc b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
index f565efdfde01e..769c17e20ab49 100644
--- a/content/browser/renderer_host/media/video_capture_controller_unittest.cc
+++ b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
@@ -216,7 +216,7 @@ class VideoCaptureControllerTest
     const int rotation = 0;
     const int frame_feedback_id = 0;
     device_client_->OnIncomingCapturedData(
-        stub_frame->data(0),
+        stub_frame->data(0).data(),
         media::VideoFrame::AllocationSize(stub_frame->format(),
                                           stub_frame->coded_size()),
         format, color_space, rotation, false /* flip_y */, base::TimeTicks(),
diff --git a/content/browser/service_host/service_process_host_browsertest.cc b/content/browser/service_host/service_process_host_browsertest.cc
index d995a1119fd56..51408718e8104 100644
--- a/content/browser/service_host/service_process_host_browsertest.cc
+++ b/content/browser/service_host/service_process_host_browsertest.cc
@@ -164,7 +164,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, AllMessagesReceived) {
   });
   auto region = base::UnsafeSharedMemoryRegion::Create(kBufferSize);
   base::WritableSharedMemoryMapping mapping = region.Map();
-  memset(mapping.memory(), 0, kBufferSize);
+  memset(mapping.memory().data(), 0, kBufferSize);
 
   // Send several messages, since it helps to verify a lack of raciness between
   // service-side message dispatch and service termination.
@@ -177,7 +177,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, AllMessagesReceived) {
 
   const std::string& kLastMessage = kMessages[std::size(kMessages) - 1];
   EXPECT_EQ(0,
-            memcmp(mapping.memory(), kLastMessage.data(), kLastMessage.size()));
+            memcmp(mapping.memory().data(), kLastMessage.data(), kLastMessage.size()));
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, ObserveCrash) {
diff --git a/content/browser/service_host/utility_process_host_browsertest.cc b/content/browser/service_host/utility_process_host_browsertest.cc
index 26de0c829ebb1..ab4165d4efa1d 100644
--- a/content/browser/service_host/utility_process_host_browsertest.cc
+++ b/content/browser/service_host/utility_process_host_browsertest.cc
@@ -148,7 +148,7 @@ class UtilityProcessHostBrowserTest : public BrowserChildProcessObserver,
     DCHECK(mojo::core::IsMojoIpczEnabled());
     auto region = base::WritableSharedMemoryRegion::Create(kTestMessage.size());
     auto mapping = region.Map();
-    memcpy(mapping.memory(), kTestMessage.data(), kTestMessage.size());
+    memcpy(mapping.memory().data(), kTestMessage.data(), kTestMessage.size());
     service_->CloneSharedMemoryContents(
         base::WritableSharedMemoryRegion::ConvertToReadOnly(std::move(region)),
         base::BindOnce(&UtilityProcessHostBrowserTest::OnMemoryCloneReceived,
@@ -201,7 +201,7 @@ class UtilityProcessHostBrowserTest : public BrowserChildProcessObserver,
     auto mapping = region.Map();
     ASSERT_EQ(kTestMessage.size(), mapping.size());
     EXPECT_EQ(kTestMessage,
-              std::string_view(static_cast<const char*>(mapping.memory()),
+              std::string_view(static_cast<const char*>(mapping.memory().data()),
                                kTestMessage.size()));
     ResetService();
     GetUIThreadTaskRunner({})->PostTask(FROM_HERE, std::move(done_closure_));
diff --git a/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc b/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
index 39a8a8439397f..eca6437cdf641 100644
--- a/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
+++ b/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
@@ -331,7 +331,7 @@ class SharedMemoryDeviceExerciser : public VirtualDeviceExerciser,
     const uint8_t dummy_value = frame_count % 256;
 
     // Reset the whole buffer to 0
-    memset(outgoing_buffer.memory(), 0, outgoing_buffer.size());
+    memset(outgoing_buffer.memory().data(), 0, outgoing_buffer.size());
 
     // Set all bytes affecting |info->visible_rect| to |dummy_value|.
     const int kYStride = info->strides ? info->strides->stride_by_plane[0]
diff --git a/content/shell/utility/shell_content_utility_client.cc b/content/shell/utility/shell_content_utility_client.cc
index 4b7a885fa28fe..650a0c5e5e955 100644
--- a/content/shell/utility/shell_content_utility_client.cc
+++ b/content/shell/utility/shell_content_utility_client.cc
@@ -128,7 +128,7 @@ class TestUtilityServiceImpl : public mojom::TestService {
     auto mapping = region.Map();
     auto new_region = base::UnsafeSharedMemoryRegion::Create(region.GetSize());
     auto new_mapping = new_region.Map();
-    memcpy(new_mapping.memory(), mapping.memory(), region.GetSize());
+    memcpy(new_mapping.memory().data(), mapping.memory().data(), region.GetSize());
     std::move(callback).Run(std::move(new_region));
   }
 
diff --git a/device/gamepad/gamepad_provider_unittest.cc b/device/gamepad/gamepad_provider_unittest.cc
index a7e8c1ea67a84..7a003108b5773 100644
--- a/device/gamepad/gamepad_provider_unittest.cc
+++ b/device/gamepad/gamepad_provider_unittest.cc
@@ -128,7 +128,7 @@ TEST_F(GamepadProviderTest, PollingAccess) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -178,7 +178,7 @@ TEST_F(GamepadProviderTest, ConnectDisconnectMultiple) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -237,7 +237,7 @@ TEST_F(GamepadProviderTest, UserGesture) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -291,7 +291,7 @@ TEST_F(GamepadProviderTest, Sanitization) {
   ASSERT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
diff --git a/extensions/browser/user_script_loader.cc b/extensions/browser/user_script_loader.cc
index 8c2938efef967..69787901809f7 100644
--- a/extensions/browser/user_script_loader.cc
+++ b/extensions/browser/user_script_loader.cc
@@ -402,7 +402,7 @@ base::ReadOnlySharedMemoryRegion UserScriptLoader::Serialize(
   }
 
   // Copy the pickle to shared memory.
-  memcpy(shared_memory.mapping.memory(), pickle.data(), pickle.size());
+  memcpy(shared_memory.mapping.memory().data(), pickle.data(), pickle.size());
   return std::move(shared_memory.region);
 }
 
diff --git a/extensions/renderer/user_script_set.cc b/extensions/renderer/user_script_set.cc
index 9e2bab8055a8b..2b5edd5bc7032 100644
--- a/extensions/renderer/user_script_set.cc
+++ b/extensions/renderer/user_script_set.cc
@@ -103,7 +103,7 @@ bool UserScriptSet::UpdateUserScripts(
 
   // First get the size of the memory block.
   const base::Pickle::Header* pickle_header =
-      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>();
+      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>().data();
   if (!pickle_header)
     return false;
 
diff --git a/gpu/command_buffer/client/client_shared_image.cc b/gpu/command_buffer/client/client_shared_image.cc
index 623b9541c714d..ddd9caf31f4ec 100644
--- a/gpu/command_buffer/client/client_shared_image.cc
+++ b/gpu/command_buffer/client/client_shared_image.cc
@@ -105,7 +105,7 @@ class ScopedMappingGpuMemoryBuffer : public ClientSharedImage::ScopedMapping {
     // the start of the plane, as that region is by definition the memory
     // storing the data of the plane.
     return UNSAFE_BUFFERS(base::span<uint8_t>(
-        reinterpret_cast<uint8_t*>(buffer_->memory(plane_index)), span_length));
+        reinterpret_cast<uint8_t*>(buffer_->memory(plane_index).data()), span_length));
   }
   size_t Stride(const uint32_t plane_index) override {
     CHECK(buffer_);
diff --git a/gpu/command_buffer/client/client_transfer_cache.cc b/gpu/command_buffer/client/client_transfer_cache.cc
index e45e08d072f36..4bc2e0ac5e853 100644
--- a/gpu/command_buffer/client/client_transfer_cache.cc
+++ b/gpu/command_buffer/client/client_transfer_cache.cc
@@ -19,7 +19,7 @@ void* ClientTransferCache::MapEntry(MappedMemoryManager* mapped_memory,
     mapped_ptr_ = std::nullopt;
     return nullptr;
   }
-  return mapped_ptr_->address();
+  return mapped_ptr_->address().data();
 }
 
 void* ClientTransferCache::MapTransferBufferEntry(
diff --git a/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc b/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
index d17b92f7fdd0f..043bb50ac8b9b 100644
--- a/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
+++ b/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
@@ -144,7 +144,7 @@ void* DawnClientMemoryTransferService::AllocateHandle(
   DCHECK(mapped_memory_);
   return mapped_memory_->Alloc(
       alloc_size, &handle->shm_id, &handle->shm_offset,
-      TransferBufferAllocationOption::kReturnNullOnOOM);
+      TransferBufferAllocationOption::kReturnNullOnOOM).data();
 }
 
 void DawnClientMemoryTransferService::MarkHandleFree(void* ptr) {
diff --git a/gpu/command_buffer/client/gl_helper.cc b/gpu/command_buffer/client/gl_helper.cc
index 4bdc07751b19f..9e77fcc902aae 100644
--- a/gpu/command_buffer/client/gl_helper.cc
+++ b/gpu/command_buffer/client/gl_helper.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -158,7 +161,7 @@ class GLHelper::CopyTextureToImpl final {
                             GLenum texture_target,
                             const gfx::Point& src_starting_point,
                             const gfx::Size& dst_size,
-                            unsigned char* out,
+                            base::span<unsigned char>out,
                             size_t row_stride_bytes,
                             bool flip_y,
                             GLenum format,
@@ -170,7 +173,7 @@ class GLHelper::CopyTextureToImpl final {
                      const gfx::Size& dst_size,
                      size_t bytes_per_row,     // generally dst_size.width() * 4
                      size_t row_stride_bytes,  // generally dst_size.width() * 4
-                     unsigned char* out,
+                     base::span<unsigned char>out,
                      GLenum format,
                      GLenum type,
                      size_t bytes_per_pixel,
@@ -179,7 +182,7 @@ class GLHelper::CopyTextureToImpl final {
 
   void ReadbackPlane(const gfx::Size& texture_size,
                      int row_stride_bytes,
-                     unsigned char* data,
+                     base::span<unsigned char>data,
                      int size_shift,
                      const gfx::Rect& paste_rect,
                      ReadbackSwizzle swizzle,
@@ -202,7 +205,7 @@ class GLHelper::CopyTextureToImpl final {
             size_t bytes_per_pixel_,
             size_t bytes_per_row_,
             size_t row_stride_bytes_,
-            unsigned char* pixels_,
+            base::span<unsigned char>pixels_,
             bool flip_y_,
             base::OnceCallback<void(bool)> callback_)
         : size(size_),
@@ -221,7 +224,7 @@ class GLHelper::CopyTextureToImpl final {
     size_t row_stride_bytes;
     bool flip_y;
     base::OnceCallback<void(bool)> callback;
-    raw_ptr<unsigned char> pixels;
+    base::raw_span<unsigned char> pixels;
     GLuint buffer = 0;
     GLuint query = 0;
   };
@@ -278,11 +281,11 @@ class GLHelper::CopyTextureToImpl final {
                      const gfx::Size& src_texture_size,
                      const gfx::Rect& output_rect,
                      int y_plane_row_stride_bytes,
-                     unsigned char* y_plane_data,
+                     base::span<unsigned char>y_plane_data,
                      int u_plane_row_stride_bytes,
-                     unsigned char* u_plane_data,
+                     base::span<unsigned char>u_plane_data,
                      int v_plane_row_stride_bytes,
-                     unsigned char* v_plane_data,
+                     base::span<unsigned char>v_plane_data,
                      const gfx::Point& paste_location,
                      base::OnceCallback<void(bool)> callback) override;
 
@@ -360,7 +363,7 @@ void GLHelper::CopyTextureToImpl::ReadbackAsync(
     const gfx::Size& dst_size,
     size_t bytes_per_row,
     size_t row_stride_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     GLenum format,
     GLenum type,
     size_t bytes_per_pixel,
@@ -396,7 +399,7 @@ void GLHelper::CopyTextureToImpl::ReadbackTextureAsync(
     GLenum texture_target,
     const gfx::Point& src_starting_point,
     const gfx::Size& dst_size,
-    unsigned char* out,
+    base::span<unsigned char>out,
     size_t row_stride_bytes,
     bool flip_y,
     GLenum format,
@@ -453,17 +456,17 @@ void GLHelper::CopyTextureToImpl::ReadbackDone(Request* finished_request) {
                                                    request->size.width());
         size_t bytes_to_copy =
             std::min(request->row_stride_bytes, request->bytes_per_row);
-        unsigned char* dst = request->pixels;
+        base::span<unsigned char>dst = request->pixels;
         if (request->flip_y && request->size.height() > 1) {
-          dst += dst_stride * (request->size.height() - 1);
+          dst=dst.subspan(dst_stride * ()request->size.height() - 1);
           dst_stride = -dst_stride;
         }
         // We need to use `RelaxedAtomicWriteMemcpy` because we might be writing
         // into memory observed by JS at the same time.
         for (int y = 0; y < request->size.height(); y++) {
           base::subtle::RelaxedAtomicWriteMemcpy(
-              base::span(dst, bytes_to_copy), base::span(src, bytes_to_copy));
-          dst += dst_stride;
+              base::span(dst.data(), bytes_to_copy), base::span(src, bytes_to_copy));
+          dst=dst.subspan(dst_stride);
           src += src_stride;
         }
         gl_->UnmapBufferCHROMIUM(GL_PIXEL_PACK_TRANSFER_BUFFER_CHROMIUM);
@@ -526,7 +529,7 @@ void GLHelper::ReadbackTextureAsync(GLuint texture,
                                     GLenum texture_target,
                                     const gfx::Point& src_starting_point,
                                     const gfx::Size& dst_size,
-                                    unsigned char* out,
+                                    base::span<unsigned char>out,
                                     size_t row_stride_bytes,
                                     bool flip_y,
                                     GLenum format,
@@ -570,7 +573,7 @@ GLint GLHelper::MaxDrawBuffers() {
 void GLHelper::CopyTextureToImpl::ReadbackPlane(
     const gfx::Size& texture_size,
     int row_stride_bytes,
-    unsigned char* data,
+    base::span<unsigned char>data,
     int size_shift,
     const gfx::Rect& paste_rect,
     ReadbackSwizzle swizzle,
@@ -583,7 +586,7 @@ void GLHelper::CopyTextureToImpl::ReadbackPlane(
   const bool kFlipY = false;
   size_t bytes_per_row = paste_rect.width() >> size_shift;
   ReadbackAsync(gfx::Point(), texture_size, bytes_per_row, row_stride_bytes,
-                data + offset,
+                data .subspan( offset),
                 (swizzle == kSwizzleBGRA) ? GL_BGRA_EXT : GL_RGBA,
                 GL_UNSIGNED_BYTE, 4, kFlipY, std::move(callback));
 }
@@ -773,11 +776,11 @@ void GLHelper::CopyTextureToImpl::ReadbackYUVImpl::ReadbackYUV(
     const gfx::Size& src_texture_size,
     const gfx::Rect& output_rect,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void(bool)> callback) {
   DCHECK(!(paste_location.x() & 1));
diff --git a/gpu/command_buffer/client/gl_helper.h b/gpu/command_buffer/client/gl_helper.h
index f7ed136f8f5c0..0954bf7b186a4 100644
--- a/gpu/command_buffer/client/gl_helper.h
+++ b/gpu/command_buffer/client/gl_helper.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -166,7 +167,7 @@ class GPU_EXPORT GLHelper {
                             GLenum texture_target,
                             const gfx::Point& src_starting_point,
                             const gfx::Size& dst_size,
-                            unsigned char* out,
+                            base::span<unsigned char>out,
                             size_t row_stride_bytes,
                             bool flip_y,
                             GLenum format,
@@ -458,11 +459,11 @@ class GPU_EXPORT ReadbackYUVInterface {
                            const gfx::Size& src_texture_size,
                            const gfx::Rect& output_rect,
                            int y_plane_row_stride_bytes,
-                           unsigned char* y_plane_data,
+                           base::span<unsigned char>y_plane_data,
                            int u_plane_row_stride_bytes,
-                           unsigned char* u_plane_data,
+                           base::span<unsigned char>u_plane_data,
                            int v_plane_row_stride_bytes,
-                           unsigned char* v_plane_data,
+                           base::span<unsigned char>v_plane_data,
                            const gfx::Point& paste_location,
                            base::OnceCallback<void(bool)> callback) = 0;
 };
diff --git a/gpu/command_buffer/client/gles2_implementation_unittest.cc b/gpu/command_buffer/client/gles2_implementation_unittest.cc
index 069a1bf71d396..cbe6ac0d638c9 100644
--- a/gpu/command_buffer/client/gles2_implementation_unittest.cc
+++ b/gpu/command_buffer/client/gles2_implementation_unittest.cc
@@ -430,7 +430,7 @@ class GLES2ImplementationTest : public testing::Test {
 
     // Temporarily allocate memory and expect that memory block to be reused.
     mem.ptr = static_cast<uint8_t*>(
-        gl_->mapped_memory_->Alloc(size, &mem.id, &mem.offset));
+        gl_->mapped_memory_->Alloc(size, &mem.id, &mem.offset).data());
     gl_->mapped_memory_->Free(mem.ptr);
 
     return mem;
diff --git a/gpu/command_buffer/client/mapped_memory.cc b/gpu/command_buffer/client/mapped_memory.cc
index ab2be5f7b166a..6cdada259c363 100644
--- a/gpu/command_buffer/client/mapped_memory.cc
+++ b/gpu/command_buffer/client/mapped_memory.cc
@@ -10,6 +10,7 @@
 #include <algorithm>
 #include <functional>
 
+#include "base/containers/span.h"
 #include "base/atomic_sequence_num.h"
 #include "base/check.h"
 #include "base/memory/ptr_util.h"
@@ -59,7 +60,7 @@ MappedMemoryManager::~MappedMemoryManager() {
   }
 }
 
-void* MappedMemoryManager::Alloc(unsigned int size,
+base::span<void> MappedMemoryManager::Alloc(unsigned int size,
                                  int32_t* shm_id,
                                  unsigned int* shm_offset,
                                  TransferBufferAllocationOption option) {
@@ -100,7 +101,7 @@ void* MappedMemoryManager::Alloc(unsigned int size,
 
   if (max_allocated_bytes_ != SharedMemoryLimits::kNoLimit &&
       (allocated_memory_ + size) > max_allocated_bytes_) {
-    return nullptr;
+    return {};
   }
 
   // Make a new chunk to satisfy the request.
@@ -109,13 +110,13 @@ void* MappedMemoryManager::Alloc(unsigned int size,
   chunk_size = (size + chunk_size_multiple_ - 1) & ~(chunk_size_multiple_ - 1);
   uint32_t safe_chunk_size = 0;
   if (!chunk_size.AssignIfValid(&safe_chunk_size))
-    return nullptr;
+    return {};
 
   int32_t id = -1;
   scoped_refptr<gpu::Buffer> shm = cmd_buf->CreateTransferBuffer(
       safe_chunk_size, &id, /* alignment */ 0, option);
   if (id  < 0)
-    return nullptr;
+    return {};
   DCHECK(shm.get());
   MemoryChunk* mc = new MemoryChunk(id, shm, helper_);
   allocated_memory_ += mc->GetSize();
@@ -223,9 +224,9 @@ FencedAllocator::State MappedMemoryManager::GetPointerStatusForTest(
 }
 
 void ScopedMappedMemoryPtr::Release() {
-  if (buffer_) {
+  if (!buffer_.empty()) {
     mapped_memory_manager_->FreePendingToken(buffer_, helper_->InsertToken());
-    buffer_ = nullptr;
+    buffer_ = {};
     size_ = 0;
     shm_id_ = 0;
     shm_offset_ = 0;
@@ -240,7 +241,7 @@ void ScopedMappedMemoryPtr::Reset(uint32_t new_size) {
 
   if (new_size) {
     buffer_ = mapped_memory_manager_->Alloc(new_size, &shm_id_, &shm_offset_);
-    size_ = buffer_ ? new_size : 0;
+    size_ = !buffer_.empty() ? new_size : 0;
   }
 }
 
diff --git a/gpu/command_buffer/client/mapped_memory.h b/gpu/command_buffer/client/mapped_memory.h
index bf183fddcb012..06e0d040a8fde 100644
--- a/gpu/command_buffer/client/mapped_memory.h
+++ b/gpu/command_buffer/client/mapped_memory.h
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -167,7 +170,7 @@ class GPU_EXPORT MappedMemoryManager {
   //           to check error conditions.
   // Returns:
   //   pointer to allocated block of memory. nullptr if failure.
-  void* Alloc(uint32_t size,
+  base::span<void> Alloc(uint32_t size,
               int32_t* shm_id,
               uint32_t* shm_offset,
               TransferBufferAllocationOption option =
@@ -238,7 +241,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
   ScopedMappedMemoryPtr(uint32_t size,
                         CommandBufferHelper* helper,
                         MappedMemoryManager* mapped_memory_manager)
-      : buffer_(nullptr),
+      : buffer_({}),
         size_(0),
         shm_id_(0),
         shm_offset_(0),
@@ -273,7 +276,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
     return shm_offset_;
   }
 
-  void* address() const {
+  base::span<void> address() const {
     return buffer_;
   }
 
@@ -282,7 +285,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
   void Reset(uint32_t new_size);
 
  private:
-  raw_ptr<void> buffer_;
+  base::raw_span<void> buffer_;
   uint32_t size_;
   int32_t shm_id_;
   uint32_t shm_offset_;
diff --git a/gpu/command_buffer/client/raster_implementation.cc b/gpu/command_buffer/client/raster_implementation.cc
index b3f4c43c1e3b6..0d2e7fd9c56b7 100644
--- a/gpu/command_buffer/client/raster_implementation.cc
+++ b/gpu/command_buffer/client/raster_implementation.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -146,7 +148,7 @@ class ScopedSharedMemoryPtr {
 
   void* address() {
     return scoped_transfer_ptr_ ? scoped_transfer_ptr_->address()
-                                : scoped_mapped_ptr_->address();
+                                : scoped_mapped_ptr_->address().data();
   }
 
  private:
@@ -1162,7 +1164,7 @@ void* RasterImplementation::MapFontBuffer(uint32_t size) {
     font_mapped_buffer_ = std::nullopt;
     return nullptr;
   }
-  return font_mapped_buffer_->address();
+  return font_mapped_buffer_->address().data();
 }
 
 void RasterImplementation::UnmapRasterCHROMIUM(uint32_t raster_written_size,
@@ -1588,7 +1590,7 @@ void RasterImplementation::OnAsyncARGBReadbackDone(
     // region.
     auto* result =
         static_cast<cmds::ReadbackARGBImagePixelsINTERNALImmediate::Result*>(
-            request->shared_memory->address());
+            request->shared_memory->address().data());
     if (*result) {
       // We need to use `RelaxedAtomicWriteMemcpy` because we might be writing
       // into memory observed by JS at the same time.
@@ -1596,8 +1598,8 @@ void RasterImplementation::OnAsyncARGBReadbackDone(
       auto dst = base::span<uint8_t>(
           static_cast<uint8_t*>(request->dst_pixels.get()), plane_size);
       auto src = base::span<uint8_t>(
-          static_cast<uint8_t*>(request->shared_memory->address()) +
-              request->pixels_offset,
+          static_cast<uint8_t*>(request->shared_memory->address()) .subspan(
+              request->pixels_offset).data(),
           plane_size);
       base::subtle::RelaxedAtomicWriteMemcpy(dst, src);
       request->readback_successful = true;
@@ -1638,7 +1640,7 @@ void RasterImplementation::ReadbackARGBPixelsAsync(
     const gfx::Point& source_starting_point,
     const SkImageInfo& dst_info,
     GLuint dst_row_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     base::OnceCallback<void(bool)> readback_done) {
   TRACE_EVENT0("gpu", "RasterImplementation::ReadbackARGBPixelsAsync");
   DCHECK(!!readback_done);
@@ -1680,11 +1682,11 @@ void RasterImplementation::ReadbackYUVPixelsAsync(
     const gfx::Rect& output_rect,
     bool vertically_flip_texture,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void()> release_mailbox,
     base::OnceCallback<void(bool)> readback_done) {
@@ -1764,9 +1766,9 @@ void RasterImplementation::ReadbackYUVPixelsAsync(
   EndQueryEXT(GL_COMMANDS_ISSUED_CHROMIUM);
 
   auto request = std::make_unique<AsyncYUVReadbackRequest>(
-      output_rect, query, y_plane_row_stride_bytes, y_offset, y_plane_data,
-      u_plane_row_stride_bytes, u_offset, u_plane_data,
-      v_plane_row_stride_bytes, v_offset, v_plane_data,
+      output_rect, query, y_plane_row_stride_bytes, y_offset, y_plane_data.data(),
+      u_plane_row_stride_bytes, u_offset, u_plane_data.data(),
+      v_plane_row_stride_bytes, v_offset, v_plane_data.data(),
       std::move(scoped_shared_memory), std::move(release_mailbox),
       std::move(readback_done));
   auto* request_ptr = request.get();
diff --git a/gpu/command_buffer/client/raster_implementation.h b/gpu/command_buffer/client/raster_implementation.h
index 9039dd6c87aa2..16dbbb8c3392a 100644
--- a/gpu/command_buffer/client/raster_implementation.h
+++ b/gpu/command_buffer/client/raster_implementation.h
@@ -14,6 +14,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/trace_event/memory_dump_provider.h"
 #include "cc/paint/paint_cache.h"
@@ -164,7 +165,7 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override;
 
   void ReadbackYUVPixelsAsync(
@@ -174,11 +175,11 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override;
diff --git a/gpu/command_buffer/client/raster_implementation_gles.cc b/gpu/command_buffer/client/raster_implementation_gles.cc
index 2cadedb61d3ea..bb51f7ab3b04e 100644
--- a/gpu/command_buffer/client/raster_implementation_gles.cc
+++ b/gpu/command_buffer/client/raster_implementation_gles.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -286,7 +288,7 @@ void RasterImplementationGLES::ReadbackARGBPixelsAsync(
     const gfx::Point& source_starting_point,
     const SkImageInfo& dst_info,
     GLuint dst_row_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     base::OnceCallback<void(bool)> readback_done) {
   DCHECK(!readback_done.is_null());
   DCHECK(dst_info.colorType() == kRGBA_8888_SkColorType ||
@@ -348,11 +350,11 @@ void RasterImplementationGLES::ReadbackYUVPixelsAsync(
     const gfx::Rect& output_rect,
     bool vertically_flip_texture,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void()> release_mailbox,
     base::OnceCallback<void(bool)> readback_done) {
diff --git a/gpu/command_buffer/client/raster_implementation_gles.h b/gpu/command_buffer/client/raster_implementation_gles.h
index f19daa9461756..d10cd097cd947 100644
--- a/gpu/command_buffer/client/raster_implementation_gles.h
+++ b/gpu/command_buffer/client/raster_implementation_gles.h
@@ -5,6 +5,7 @@
 #ifndef GPU_COMMAND_BUFFER_CLIENT_RASTER_IMPLEMENTATION_GLES_H_
 #define GPU_COMMAND_BUFFER_CLIENT_RASTER_IMPLEMENTATION_GLES_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/client/client_font_manager.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -112,7 +113,7 @@ class RASTER_EXPORT RasterImplementationGLES : public RasterInterface {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override;
 
   void ReadbackYUVPixelsAsync(
@@ -122,11 +123,11 @@ class RASTER_EXPORT RasterImplementationGLES : public RasterInterface {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override;
diff --git a/gpu/command_buffer/client/raster_implementation_unittest.cc b/gpu/command_buffer/client/raster_implementation_unittest.cc
index 2eef962fdb268..836a0d30f5efb 100644
--- a/gpu/command_buffer/client/raster_implementation_unittest.cc
+++ b/gpu/command_buffer/client/raster_implementation_unittest.cc
@@ -264,7 +264,7 @@ class RasterImplementationTest : public testing::Test {
 
     // Temporarily allocate memory and expect that memory block to be reused.
     mem.ptr = static_cast<uint8_t*>(
-        gl_->mapped_memory_->Alloc(size, &mem.id, &mem.offset));
+        gl_->mapped_memory_->Alloc(size, &mem.id, &mem.offset).data());
     gl_->mapped_memory_->Free(mem.ptr);
 
     return mem;
diff --git a/gpu/command_buffer/client/raster_interface.h b/gpu/command_buffer/client/raster_interface.h
index 50c3071c974fa..8fdbb39c092e1 100644
--- a/gpu/command_buffer/client/raster_interface.h
+++ b/gpu/command_buffer/client/raster_interface.h
@@ -143,7 +143,7 @@ class RasterInterface : public InterfaceBase {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) = 0;
 
   // Starts an asynchronus readback and translation of RGBA |source_mailbox|
@@ -161,11 +161,11 @@ class RasterInterface : public InterfaceBase {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) = 0;
diff --git a/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc b/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
index fc1740c53ebfb..76ba536ad8d4e 100644
--- a/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
+++ b/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -32,7 +34,7 @@ uint32_t ReadbackBufferShadowTracker::Buffer::Alloc(int32_t* shm_id,
                                                     uint32_t* shm_offset,
                                                     bool* already_allocated) {
   *already_allocated = readback_shm_address_ != nullptr;
-  if (!readback_shm_address_) {
+  if (!!readback_shm_address_.empty()) {
     readback_shm_address_ =
         mapped_memory_->Alloc(size_, &shm_id_, &shm_offset_);
   }
@@ -42,11 +44,11 @@ uint32_t ReadbackBufferShadowTracker::Buffer::Alloc(int32_t* shm_id,
 }
 
 void ReadbackBufferShadowTracker::Buffer::Free() {
-  if (readback_shm_address_) {
+  if (!readback_shm_address_.empty()) {
     mapped_memory_->FreePendingToken(readback_shm_address_,
                                      helper_->InsertToken());
   }
-  readback_shm_address_ = nullptr;
+  readback_shm_address_ = {};
 }
 
 void* ReadbackBufferShadowTracker::Buffer::MapReadbackShm(uint32_t offset,
@@ -55,7 +57,7 @@ void* ReadbackBufferShadowTracker::Buffer::MapReadbackShm(uint32_t offset,
   if (serial_of_readback_data_ != serial_of_last_write_) {
     return nullptr;
   }
-  if (!readback_shm_address_) {
+  if (!!readback_shm_address_.empty()) {
     return nullptr;
   }
   if (map_size > size_) {
diff --git a/gpu/command_buffer/client/readback_buffer_shadow_tracker.h b/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
index e8ed2dfa6e853..a55887698ca35 100644
--- a/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
+++ b/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
@@ -6,6 +6,7 @@
 #define GPU_COMMAND_BUFFER_CLIENT_READBACK_BUFFER_SHADOW_TRACKER_H_
 
 #include <GLES2/gl2.h>
+#include "base/memory/raw_span.h"
 #include "base/containers/flat_map.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/weak_ptr.h"
@@ -54,7 +55,7 @@ class ReadbackBufferShadowTracker {
     raw_ptr<GLES2CmdHelper> helper_;
     int32_t shm_id_ = 0;
     uint32_t shm_offset_ = 0;
-    raw_ptr<void> readback_shm_address_ = nullptr;
+    base::raw_span<void> readback_shm_address_ = nullptr;
     uint64_t serial_of_last_write_ = 1;  // will be updated right after creation
     uint64_t serial_of_readback_data_ = 0;
     uint32_t size_ = 0;
diff --git a/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc b/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
index e53de27bd0096..79523b9238359 100644
--- a/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
+++ b/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -51,11 +53,11 @@ class GpuMemoryBufferImpl : public gfx::GpuMemoryBuffer {
     mapped_ = true;
     return true;
   }
-  void* memory(size_t plane) override {
+  base::span<void> memory(size_t plane) override {
     DCHECK(mapped_);
     DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
-    return reinterpret_cast<uint8_t*>(mapping_.memory()) + offset_ +
-           gfx::BufferOffsetForBufferFormat(size_, format_, plane);
+    return reinterpret_cast<uint8_t*>(mapping_.memory()) .subspan( offset_ +
+           gfx::BufferOffsetForBufferFormat(size_, format_, plane));
   }
   void Unmap() override {
     DCHECK(mapped_);
@@ -106,7 +108,7 @@ class GpuMemoryBufferFromClient : public gfx::GpuMemoryBuffer {
   ~GpuMemoryBufferFromClient() override = default;
 
   bool Map() override { return client_buffer_->Map(); }
-  void* memory(size_t plane) override { return client_buffer_->memory(plane); }
+  base::span<void> memory(size_t plane) override { return client_buffer_->memory(plane); }
   void Unmap() override { client_buffer_->Unmap(); }
   gfx::Size GetSize() const override { return client_buffer_->GetSize(); }
   gfx::BufferFormat GetFormat() const override {
diff --git a/gpu/command_buffer/common/buffer.cc b/gpu/command_buffer/common/buffer.cc
index 45b72b3832c75..f39a99ab50f21 100644
--- a/gpu/command_buffer/common/buffer.cc
+++ b/gpu/command_buffer/common/buffer.cc
@@ -46,7 +46,7 @@ MemoryBufferBacking::MemoryBufferBacking(uint32_t size, uint32_t alignment)
 MemoryBufferBacking::~MemoryBufferBacking() = default;
 
 const void* MemoryBufferBacking::GetMemory() const {
-  return alignment_ > 0 ? base::bits::AlignUp(memory_.get(), alignment_)
+  return alignment_ > 0 ? base::bits::AlignUp(memory_.get(), alignment_).data()
                         : memory_.get();
 }
 
diff --git a/gpu/command_buffer/common/shm_count.cc b/gpu/command_buffer/common/shm_count.cc
index e596ad61162af..63221310ba763 100644
--- a/gpu/command_buffer/common/shm_count.cc
+++ b/gpu/command_buffer/common/shm_count.cc
@@ -23,7 +23,7 @@ bool ShmCountBase::IsInitialized() const {
 }
 
 volatile ShmCountBase::AtomicType* ShmCountBase::AsAtomic() {
-  return reinterpret_cast<volatile AtomicType*>(mapping_.memory());
+  return reinterpret_cast<volatile AtomicType*>(mapping_.memory().data());
 }
 
 GpuProcessShmCount::GpuProcessShmCount() = default;
diff --git a/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc b/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
index edfec700b8dae..2f2500442c89d 100644
--- a/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
+++ b/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
@@ -163,7 +163,7 @@ TEST_P(GpuMemoryBufferTest, MapUnmap) {
   ASSERT_TRUE(buffer->Map());
   ASSERT_NE(nullptr, buffer->memory(0));
   ASSERT_NE(0, buffer->stride(0));
-  const uint8_t* data = static_cast<uint8_t*>(buffer->memory(0));
+  const uint8_t* data = static_cast<uint8_t*>(buffer->memory(0).data());
   const int stride = buffer->stride(0);
   // libyuv defines the formats as word-order.
   uint8_t argb[kImageWidth * kImageHeight * 4] = {};
diff --git a/gpu/command_buffer/tests/gl_helper_unittest.cc b/gpu/command_buffer/tests/gl_helper_unittest.cc
index af833ef9360b7..7d38b7cb54134 100644
--- a/gpu/command_buffer/tests/gl_helper_unittest.cc
+++ b/gpu/command_buffer/tests/gl_helper_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -1001,7 +1003,7 @@ class GLHelperTest : public testing::Test {
 
   bool ReadBackTexture(GLuint src_texture,
                        const gfx::Rect& src_rect,
-                       unsigned char* pixels,
+                       base::span<unsigned char>pixels,
                        size_t pixels_stride,
                        bool flip_y,
                        SkColorType color_type) {
@@ -1047,7 +1049,7 @@ class GLHelperTest : public testing::Test {
     // Initialize the output bitmap with Green color.
     // When the readback is over output bitmap should have the red color.
     output_pixels.eraseColor(SK_ColorGREEN);
-    uint8_t* pixels = static_cast<uint8_t*>(output_pixels.getPixels());
+    base::span<uint8_t>pixels = static_cast<uint8_t*>(output_pixels.getPixels());
     if (!ReadBackTexture(src_texture, gfx::Rect(src_size), pixels,
                          output_pixels.rowBytes(), /*flip_y=*/false,
                          color_type) ||
diff --git a/gpu/command_buffer/tests/gl_manager.cc b/gpu/command_buffer/tests/gl_manager.cc
index b72bf92c3b56e..09ecf29b890f0 100644
--- a/gpu/command_buffer/tests/gl_manager.cc
+++ b/gpu/command_buffer/tests/gl_manager.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -81,7 +83,7 @@ class GpuMemoryBufferImplTest : public gfx::GpuMemoryBuffer {
     mapped_ = true;
     return true;
   }
-  void* memory(size_t plane) override {
+  base::span<void> memory(size_t plane) override {
     DCHECK(mapped_);
     DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
     return bytes_->as_vector().data() +
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
index 1f35a94838d3d..438b6f72c899a 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/memory/ptr_util.h"
 #include "gpu/ipc/common/gpu_memory_buffer_support.h"
@@ -108,7 +109,7 @@ bool GpuMemoryBufferImplNativePixmap::Map() {
   return true;
 }
 
-void* GpuMemoryBufferImplNativePixmap::memory(size_t plane) {
+base::span<void> GpuMemoryBufferImplNativePixmap::memory(size_t plane) {
   AssertMapped();
   return pixmap_->GetMemoryAddress(plane);
 }
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
index 3ffb148887675..7211c2d3c1051 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
@@ -10,6 +10,7 @@
 #include <memory>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "gpu/gpu_export.h"
 #include "gpu/ipc/common/gpu_memory_buffer_impl.h"
 
@@ -48,7 +49,7 @@ class GPU_EXPORT GpuMemoryBufferImplNativePixmap : public GpuMemoryBufferImpl {
 
   // Overridden from gfx::GpuMemoryBuffer:
   bool Map() override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   int stride(size_t plane) const override;
   gfx::GpuMemoryBufferType GetType() const override;
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
index b9f194444dab9..6c42c1d56d704 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -252,11 +254,11 @@ bool GpuMemoryBufferImplSharedMemory::Map() {
   return true;
 }
 
-void* GpuMemoryBufferImplSharedMemory::memory(size_t plane) {
+base::span<void> GpuMemoryBufferImplSharedMemory::memory(size_t plane) {
   AssertMapped();
   DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
-  return static_cast<uint8_t*>(shared_memory_mapping_.memory()) + offset_ +
-         gfx::BufferOffsetForBufferFormat(size_, format_, plane);
+  return static_cast<uint8_t*>(shared_memory_mapping_.memory()) .subspan( offset_ +
+         gfx::BufferOffsetForBufferFormat(size_, format_, plane));
 }
 
 void GpuMemoryBufferImplSharedMemory::Unmap() {
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
index 506376f984df0..9acc11d18737b 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
@@ -9,6 +9,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "gpu/gpu_export.h"
 #include "gpu/ipc/common/gpu_memory_buffer_impl.h"
 
@@ -61,7 +62,7 @@ class GPU_EXPORT GpuMemoryBufferImplSharedMemory : public GpuMemoryBufferImpl {
 
   // Overridden from gfx::GpuMemoryBuffer:
   bool Map() override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   int stride(size_t plane) const override;
   gfx::GpuMemoryBufferType GetType() const override;
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h b/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
index 97c6ac742b137..1a9d20ae84866 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
@@ -309,8 +309,8 @@ TYPED_TEST_P(GpuMemoryBufferImplTest, Map) {
       size_t height = kBufferSize.height() /
                       gfx::SubsamplingFactorForBufferFormat(format, plane);
       for (size_t y = 0; y < height; ++y) {
-        memcpy(static_cast<char*>(buffer->memory(plane)) +
-                   y * buffer->stride(plane),
+        memcpy(static_cast<char*>(buffer->memory(plane)) .subspan(
+                   y * buffer).data()->stride(plane),
                data.data(), row_size_in_bytes);
         EXPECT_EQ(0, memcmp(static_cast<char*>(buffer->memory(plane)) +
                                 y * buffer->stride(plane),
@@ -368,8 +368,8 @@ TYPED_TEST_P(GpuMemoryBufferImplTest, PersistentMap) {
       size_t height = kBufferSize.height() /
                       gfx::SubsamplingFactorForBufferFormat(format, plane);
       for (size_t y = 0; y < height; ++y) {
-        memcpy(static_cast<char*>(buffer->memory(plane)) +
-                   y * buffer->stride(plane),
+        memcpy(static_cast<char*>(buffer->memory(plane)) .subspan(
+                   y * buffer).data()->stride(plane),
                data.data(), row_size_in_bytes);
         EXPECT_EQ(0, memcmp(static_cast<char*>(buffer->memory(plane)) +
                                 y * buffer->stride(plane),
diff --git a/ipc/ipc_channel_mojo_unittest.cc b/ipc/ipc_channel_mojo_unittest.cc
index 0ad0d599a1895..322fa877da9f1 100644
--- a/ipc/ipc_channel_mojo_unittest.cc
+++ b/ipc/ipc_channel_mojo_unittest.cc
@@ -1637,7 +1637,7 @@ TYPED_TEST(IPCChannelMojoSharedMemoryRegionTypedTest, Send) {
       base::CreateMappedRegion<typename TypeParam::RegionType>(size);
 
   std::string content = HandleSendingHelper::GetSendingFileContent();
-  memcpy(mapping.memory(), content.data(), content.size());
+  memcpy(mapping.memory().data(), content.data(), content.size());
 
   // Create a success listener, and launch the child process.
   base::RunLoop run_loop;
diff --git a/media/audio/audio_input_device.cc b/media/audio/audio_input_device.cc
index 8d6e46c3fe186..6a0aa4c9900cb 100644
--- a/media/audio/audio_input_device.cc
+++ b/media/audio/audio_input_device.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -420,14 +422,14 @@ void AudioInputDevice::AudioThreadCallback::MapSharedMemory() {
   shared_memory_mapping_ = shared_memory_region_.MapAt(0, memory_length_);
 
   // Create vector of audio buses by wrapping existing blocks of memory.
-  const uint8_t* ptr =
+  base::span<const uint8_t>ptr =
       static_cast<const uint8_t*>(shared_memory_mapping_.memory());
   for (uint32_t i = 0; i < total_segments_; ++i) {
     const media::AudioInputBuffer* buffer =
-        reinterpret_cast<const media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<const media::AudioInputBuffer*>(ptr.data());
     audio_buses_.push_back(
         media::AudioBus::WrapReadOnlyMemory(audio_parameters_, buffer->audio));
-    ptr += segment_length_;
+    ptr=ptr.subspan(segment_length_);
   }
 
   // Indicate that browser side capture initialization has succeeded and IPC
@@ -442,9 +444,9 @@ void AudioInputDevice::AudioThreadCallback::Process(uint32_t pending_data) {
   // The shared memory represents parameters, size of the data buffer and the
   // actual data buffer containing audio data. Map the memory into this
   // structure and parse out parameters and the data area.
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
-  ptr += current_segment_id_ * segment_length_;
-  AudioInputBuffer* buffer = reinterpret_cast<AudioInputBuffer*>(ptr);
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  ptr=ptr.subspan(current_segment_id_ * segment_length_);
+  AudioInputBuffer* buffer = reinterpret_cast<AudioInputBuffer*>(ptr.data());
 
   // Usually this will be equal but in the case of low sample rate (e.g. 8kHz,
   // the buffer may be bigger (on mac at least)).
diff --git a/media/audio/audio_input_device_unittest.cc b/media/audio/audio_input_device_unittest.cc
index dcc82cfe32981..37d5cc077aa80 100644
--- a/media/audio/audio_input_device_unittest.cc
+++ b/media/audio/audio_input_device_unittest.cc
@@ -120,7 +120,7 @@ class AudioInputDeviceTest
     shared_memory_ = base::UnsafeSharedMemoryRegion::Create(memory_size);
     shared_memory_mapping_ = shared_memory_.Map();
     ASSERT_TRUE(shared_memory_.IsValid());
-    memset(shared_memory_mapping_.memory(), 0xff, memory_size);
+    memset(shared_memory_mapping_.memory().data(), 0xff, memory_size);
 
     ASSERT_TRUE(
         CancelableSyncSocket::CreatePair(&browser_socket_, &renderer_socket_));
@@ -146,7 +146,7 @@ class AudioInputDeviceTest
     EXPECT_CALL(*capture_callback_, OnCaptureStarted());
     EXPECT_CALL(*input_ipc, CloseStream());
 
-    uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+    uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory().data());
     buffer_ = reinterpret_cast<AudioInputBuffer*>(ptr);
     buffer_->params.id = 0;
     buffer_->params.capture_time_us =
diff --git a/media/audio/audio_output_device_thread_callback.cc b/media/audio/audio_output_device_thread_callback.cc
index 986a80038efd0..2f8d96b86a091 100644
--- a/media/audio/audio_output_device_thread_callback.cc
+++ b/media/audio/audio_output_device_thread_callback.cc
@@ -45,7 +45,7 @@ void AudioOutputDeviceThreadCallback::MapSharedMemory() {
 
   media::AudioOutputBuffer* buffer =
       reinterpret_cast<media::AudioOutputBuffer*>(
-          shared_memory_mapping_.memory());
+          shared_memory_mapping_.memory().data());
   output_bus_ = media::AudioBus::WrapMemory(audio_parameters_, buffer->audio);
   output_bus_->set_is_bitstream_format(audio_parameters_.IsBitstreamFormat());
 }
@@ -57,7 +57,7 @@ void AudioOutputDeviceThreadCallback::Process(uint32_t control_signal) {
   // Read and reset the glitch info.
   media::AudioOutputBuffer* buffer =
       reinterpret_cast<media::AudioOutputBuffer*>(
-          shared_memory_mapping_.memory());
+          shared_memory_mapping_.memory().data());
   media::AudioGlitchInfo glitch_info{
       .duration = base::Microseconds(buffer->params.glitch_duration_us),
       .count = buffer->params.glitch_count};
diff --git a/media/audio/audio_output_device_unittest.cc b/media/audio/audio_output_device_unittest.cc
index 1242380dd2bc8..4bb43e9dce807 100644
--- a/media/audio/audio_output_device_unittest.cc
+++ b/media/audio/audio_output_device_unittest.cc
@@ -203,7 +203,7 @@ void AudioOutputDeviceTest::CallOnStreamCreated() {
   ASSERT_TRUE(shared_memory_region_.IsValid());
   shared_memory_mapping_ = shared_memory_region_.Map();
   ASSERT_TRUE(shared_memory_mapping_.IsValid());
-  memset(shared_memory_mapping_.memory(), 0xff, kMemorySize);
+  memset(shared_memory_mapping_.memory().data(), 0xff, kMemorySize);
 
   ASSERT_TRUE(CancelableSyncSocket::CreatePair(&browser_socket_,
                                                &renderer_socket_));
diff --git a/media/base/decoder_buffer_unittest.cc b/media/base/decoder_buffer_unittest.cc
index 0eed6599ec20d..cbc5a56d32bf2 100644
--- a/media/base/decoder_buffer_unittest.cc
+++ b/media/base/decoder_buffer_unittest.cc
@@ -137,7 +137,7 @@ TEST(DecoderBufferTest, FromPlatformSharedMemoryRegion_ZeroSize) {
   auto region = base::UnsafeSharedMemoryRegion::Create(kDataSize);
   auto mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  memcpy(mapping.memory(), kData, kDataSize);
+  memcpy(mapping.memory().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(
       DecoderBuffer::FromSharedMemoryRegion(std::move(region), 0, 0));
diff --git a/media/base/test_helpers.cc b/media/base/test_helpers.cc
index 5d3a2f2d7e8c7..c383207bcbde7 100644
--- a/media/base/test_helpers.cc
+++ b/media/base/test_helpers.cc
@@ -73,13 +73,13 @@ void I4xxxRect(VideoFrame* dest_frame,
       << VideoPixelFormatToString(dest_frame->format());
 
   // Write known full size planes first.
-  libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kY) +
-                       y * dest_frame->stride(VideoFrame::Plane::kY) + x,
+  libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kY) .subspan(
+                       y * dest_frame->stride(VideoFrame::Plane::kY) + x).data(),
                    dest_frame->stride(VideoFrame::Plane::kY), width, height,
                    value_y);
   if (num_planes == 4) {
-    libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kA) +
-                         y * dest_frame->stride(VideoFrame::Plane::kA) + x,
+    libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kA) .subspan(
+                         y * dest_frame->stride(VideoFrame::Plane::kA) + x).data(),
                      dest_frame->stride(VideoFrame::Plane::kA), width, height,
                      value_a);
   }
@@ -92,15 +92,15 @@ void I4xxxRect(VideoFrame* dest_frame,
 
   // Write variable sized planes.
   libyuv::SetPlane(
-      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kU) +
+      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kU) .subspan(
           start_xy.height() * dest_frame->stride(VideoFrame::Plane::kU) +
-          start_xy.width(),
+          start_xy.width()).data(),
       dest_frame->stride(VideoFrame::Plane::kU), uv_size.width(),
       uv_size.height(), value_u);
   libyuv::SetPlane(
-      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kV) +
+      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kV) .subspan(
           start_xy.height() * dest_frame->stride(VideoFrame::Plane::kV) +
-          start_xy.width(),
+          start_xy.width()).data(),
       dest_frame->stride(VideoFrame::Plane::kV), uv_size.width(),
       uv_size.height(), value_v);
 }
@@ -160,24 +160,24 @@ void FillFourColorsFrameYUV(VideoFrame& dest_frame,
 
   if (temp_frame) {
     ASSERT_EQ(libyuv::I420ToNV12(
-                  temp_frame->visible_data(VideoFrame::Plane::kY),
+                  temp_frame->visible_data(VideoFrame::Plane::kY).data(),
                   temp_frame->stride(VideoFrame::Plane::kY),
-                  temp_frame->visible_data(VideoFrame::Plane::kU),
+                  temp_frame->visible_data(VideoFrame::Plane::kU).data(),
                   temp_frame->stride(VideoFrame::Plane::kU),
-                  temp_frame->visible_data(VideoFrame::Plane::kV),
+                  temp_frame->visible_data(VideoFrame::Plane::kV).data(),
                   temp_frame->stride(VideoFrame::Plane::kV),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
                   dest_frame.stride(VideoFrame::Plane::kY),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
                   dest_frame.stride(VideoFrame::Plane::kUV),
                   dest_frame.visible_rect().width(),
                   dest_frame.visible_rect().height()),
               0);
     if (dest_frame.format() == PIXEL_FORMAT_NV12A) {
       libyuv::CopyPlane(
-          temp_frame->visible_data(VideoFrame::Plane::kA),
+          temp_frame->visible_data(VideoFrame::Plane::kA).data(),
           temp_frame->stride(VideoFrame::Plane::kA),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
           dest_frame.stride(VideoFrame::Plane::kATriPlanar),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height());
@@ -202,7 +202,7 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
 
   // Yellow top left.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB), 0, 0,
                 visible_size.width() / 2, visible_size.height() / 2, yellow),
             0);
@@ -210,14 +210,14 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
   // Red top right.
   ASSERT_EQ(
       libyuv::ARGBRect(
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
           dest_frame.stride(VideoFrame::Plane::kARGB), visible_size.width() / 2,
           0, visible_size.width() / 2, visible_size.height() / 2, red),
       0);
 
   // Blue bottom left.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB), 0,
                 visible_size.height() / 2, visible_size.width() / 2,
                 visible_size.height() / 2, blue),
@@ -225,7 +225,7 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
 
   // Green bottom right.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB),
                 visible_size.width() / 2, visible_size.height() / 2,
                 visible_size.width() / 2, visible_size.height() / 2, green),
@@ -234,9 +234,9 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
   if (dest_frame.format() == PIXEL_FORMAT_XBGR ||
       dest_frame.format() == PIXEL_FORMAT_ABGR) {
     ASSERT_EQ(libyuv::ARGBToABGR(
-                  dest_frame.visible_data(VideoFrame::Plane::kARGB),
+                  dest_frame.visible_data(VideoFrame::Plane::kARGB).data(),
                   dest_frame.stride(VideoFrame::Plane::kARGB),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                   dest_frame.stride(VideoFrame::Plane::kARGB),
                   visible_size.width(), visible_size.height()),
               0);
diff --git a/media/base/video_frame.cc b/media/base/video_frame.cc
index c424431760303..f8b6aa828a406 100644
--- a/media/base/video_frame.cc
+++ b/media/base/video_frame.cc
@@ -17,6 +17,7 @@
 #include <string_view>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -1581,12 +1582,12 @@ base::span<uint8_t> VideoFrame::GetWritableVisiblePlaneData(size_t plane) {
   return GetVisibleDataInternal(non_const_span, plane);
 }
 
-const uint8_t* VideoFrame::visible_data(size_t plane) const {
-  return GetVisiblePlaneData(plane).data();
+const base::span<uint8_t> VideoFrame::visible_data(size_t plane) const {
+  return GetVisiblePlaneData(plane);
 }
 
-uint8_t* VideoFrame::GetWritableVisibleData(size_t plane) {
-  return GetWritableVisiblePlaneData(plane).data();
+base::span<uint8_t> VideoFrame::GetWritableVisibleData(size_t plane) {
+  return GetWritableVisiblePlaneData(plane);
 }
 
 gpu::SyncToken VideoFrame::acquire_sync_token() const {
@@ -2014,7 +2015,7 @@ VideoFrame::ScopedMapping::~ScopedMapping() {
   }
 }
 
-uint8_t* VideoFrame::ScopedMapping::Memory(uint32_t plane_index) {
+base::span<uint8_t> VideoFrame::ScopedMapping::Memory(uint32_t plane_index) {
   return static_cast<uint8_t*>(
       gpu_memory_buffer_
           ? gpu_memory_buffer_->memory(plane_index)
diff --git a/media/base/video_frame.h b/media/base/video_frame.h
index c44af122bdf71..d614697dd4785 100644
--- a/media/base/video_frame.h
+++ b/media/base/video_frame.h
@@ -127,7 +127,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     ~ScopedMapping();
 
     // Returns a pointer to the beginning of the plane.
-    uint8_t* Memory(uint32_t plane_index);
+    base::span<uint8_t> Memory(uint32_t plane_index);
 
     // Returns plane stride.
     size_t Stride(uint32_t plane_index);
@@ -688,12 +688,12 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // Returns pointer to the buffer for a given plane, if this is an
   // IsMappable() frame type. The memory is owned by VideoFrame object and must
   // not be freed by the caller.
-  const uint8_t* data(size_t plane) const {
+  const base::span<uint8_t> data(size_t plane) const {
     auto span = data_span(plane);
     if (span.empty()) [[unlikely]] {
-      return nullptr;
+      return {};
     }
-    return span.data();
+    return span;
   }
 
   base::span<const uint8_t> data_span(size_t plane) const {
@@ -702,7 +702,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     return data_[plane];
   }
 
-  uint8_t* writable_data(size_t plane) {
+  base::span<uint8_t> writable_data(size_t plane) {
     // TODO(crbug.com/40265179): Also CHECK that the storage type isn't
     // STORAGE_UNOWNED_MEMORY once non-compliant usages are fixed.
     CHECK_NE(storage_type_, STORAGE_SHMEM);
@@ -719,8 +719,8 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // IsMappable() storage types. The returned pointer is offset into the
   // plane buffer specified by visible_rect().origin(). Memory is owned by
   // VideoFrame object and must not be freed by the caller.
-  const uint8_t* visible_data(size_t plane) const;
-  uint8_t* GetWritableVisibleData(size_t plane);
+  const base::span<uint8_t> visible_data(size_t plane) const;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane);
 
   // Returns spans of data in the visible region of the frame, for
   // IsMappable() storage types. The returned span is offset into the
diff --git a/media/base/video_frame_converter.cc b/media/base/video_frame_converter.cc
index 8764f54a60f03..c471b7d9044e9 100644
--- a/media/base/video_frame_converter.cc
+++ b/media/base/video_frame_converter.cc
@@ -39,7 +39,7 @@ scoped_refptr<VideoFrame> WrapTempFrameForABGRToARGB(
   return VideoFrame::WrapExternalData(
       override_format, tmp_frame->coded_size(), tmp_frame->visible_rect(),
       tmp_frame->natural_size(),
-      tmp_frame->writable_data(VideoFrame::Plane::kARGB),
+      tmp_frame->writable_data(VideoFrame::Plane::kARGB).data(),
       VideoFrame::AllocationSize(override_format, tmp_frame->coded_size()),
       tmp_frame->timestamp());
 }
diff --git a/media/base/video_frame_converter_internals.cc b/media/base/video_frame_converter_internals.cc
index ab17fde3fab0e..a9718c4bde2ec 100644
--- a/media/base/video_frame_converter_internals.cc
+++ b/media/base/video_frame_converter_internals.cc
@@ -24,11 +24,11 @@ bool ARGBScale(const VideoFrame& src_frame,
                libyuv::FilterMode filter) {
   DCHECK(IsSupportedRGBFormat(src_frame.format()));
   return libyuv::ARGBScale(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
              src_frame.visible_rect().width(),
              src_frame.visible_rect().height(),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
              dest_frame.stride(VideoFrame::Plane::kARGB),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height(), filter) == 0;
@@ -58,9 +58,9 @@ bool ARGBToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
              dest_frame.stride(VideoFrame::Plane::kA),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -73,13 +73,13 @@ bool ARGBToI444x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   DCHECK(dest_frame.format() == PIXEL_FORMAT_I444 ||
          dest_frame.format() == PIXEL_FORMAT_I444A);
   if (libyuv::ARGBToI444(
-          src_frame.visible_data(VideoFrame::Plane::kARGB),
+          src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
           src_frame.stride(VideoFrame::Plane::kARGB),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
           dest_frame.stride(VideoFrame::Plane::kU),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
           dest_frame.stride(VideoFrame::Plane::kV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -89,9 +89,9 @@ bool ARGBToI444x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
              dest_frame.stride(VideoFrame::Plane::kA),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -120,9 +120,9 @@ bool ARGBToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
              dest_frame.stride(VideoFrame::Plane::kATriPlanar),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -135,9 +135,9 @@ bool ABGRToARGB(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_XRGB);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   return libyuv::ABGRToARGB(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
              dest_frame.stride(VideoFrame::Plane::kARGB),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -168,12 +168,12 @@ void I4xxxScale(const VideoFrame& src_frame, VideoFrame& dest_frame) {
 
   for (size_t i = 0; i < VideoFrame::NumPlanes(dest_frame.format()); ++i) {
     libyuv::ScalePlane(
-        src_frame.visible_data(i), src_frame.stride(i),
+        src_frame.visible_data(i).data(), src_frame.stride(i),
         VideoFrame::Columns(i, src_frame.format(),
                             src_frame.visible_rect().size().width()),
         VideoFrame::Rows(i, src_frame.format(),
                          src_frame.visible_rect().size().height()),
-        dest_frame.GetWritableVisibleData(i), dest_frame.stride(i),
+        dest_frame.GetWritableVisibleData(i).data(), dest_frame.stride(i),
         VideoFrame::Columns(i, dest_frame.format(),
                             dest_frame.visible_rect().size().width()),
         VideoFrame::Rows(i, dest_frame.format(),
@@ -189,15 +189,15 @@ bool I420xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::I420ToNV12(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kU),
+          src_frame.visible_data(VideoFrame::Plane::kU).data(),
           src_frame.stride(VideoFrame::Plane::kU),
-          src_frame.visible_data(VideoFrame::Plane::kV),
+          src_frame.visible_data(VideoFrame::Plane::kV).data(),
           src_frame.stride(VideoFrame::Plane::kV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -207,9 +207,9 @@ bool I420xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   libyuv::CopyPlane(
-      src_frame.visible_data(VideoFrame::Plane::kA),
+      src_frame.visible_data(VideoFrame::Plane::kA).data(),
       src_frame.stride(VideoFrame::Plane::kA),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height());
   return true;
@@ -222,15 +222,15 @@ bool I444xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::I444ToNV12(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kU),
+          src_frame.visible_data(VideoFrame::Plane::kU).data(),
           src_frame.stride(VideoFrame::Plane::kU),
-          src_frame.visible_data(VideoFrame::Plane::kV),
+          src_frame.visible_data(VideoFrame::Plane::kV).data(),
           src_frame.stride(VideoFrame::Plane::kV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -240,9 +240,9 @@ bool I444xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   libyuv::CopyPlane(
-      src_frame.visible_data(VideoFrame::Plane::kA),
+      src_frame.visible_data(VideoFrame::Plane::kA).data(),
       src_frame.stride(VideoFrame::Plane::kA),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height());
   return true;
@@ -255,11 +255,11 @@ void MergeUV(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   libyuv::MergeUVPlane(
-      src_frame.visible_data(VideoFrame::Plane::kU),
+      src_frame.visible_data(VideoFrame::Plane::kU).data(),
       src_frame.stride(VideoFrame::Plane::kU),
-      src_frame.visible_data(VideoFrame::Plane::kV),
+      src_frame.visible_data(VideoFrame::Plane::kV).data(),
       src_frame.stride(VideoFrame::Plane::kV),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
       dest_frame.stride(VideoFrame::Plane::kUV),
       dest_frame.visible_rect().width() / 2,
       dest_frame.visible_rect().height() / 2);
@@ -271,11 +271,11 @@ void SplitUV(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   DCHECK(dest_frame.format() == PIXEL_FORMAT_I420 ||
          dest_frame.format() == PIXEL_FORMAT_I420A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
-  libyuv::SplitUVPlane(src_frame.visible_data(VideoFrame::Plane::kUV),
+  libyuv::SplitUVPlane(src_frame.visible_data(VideoFrame::Plane::kUV).data(),
                        src_frame.stride(VideoFrame::Plane::kUV),
-                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
                        dest_frame.stride(VideoFrame::Plane::kU),
-                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
                        dest_frame.stride(VideoFrame::Plane::kV),
                        dest_frame.visible_rect().width() / 2,
                        dest_frame.visible_rect().height() / 2);
@@ -289,14 +289,14 @@ bool NV12xScale(const VideoFrame& src_frame,
   DCHECK(dest_frame.format() == PIXEL_FORMAT_NV12 ||
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   if (libyuv::NV12Scale(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kUV),
+          src_frame.visible_data(VideoFrame::Plane::kUV).data(),
           src_frame.stride(VideoFrame::Plane::kUV),
           src_frame.visible_rect().width(), src_frame.visible_rect().height(),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(), dest_frame.visible_rect().height(),
           filter) != 0) {
@@ -306,10 +306,10 @@ bool NV12xScale(const VideoFrame& src_frame,
     return true;
   }
   libyuv::ScalePlane(
-      src_frame.visible_data(VideoFrame::Plane::kATriPlanar),
+      src_frame.visible_data(VideoFrame::Plane::kATriPlanar).data(),
       src_frame.stride(VideoFrame::Plane::kATriPlanar),
       src_frame.visible_rect().width(), src_frame.visible_rect().height(),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height(),
       filter);
@@ -323,15 +323,15 @@ bool NV12xToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_I420A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::NV12ToI420(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kUV),
+          src_frame.visible_data(VideoFrame::Plane::kUV).data(),
           src_frame.stride(VideoFrame::Plane::kUV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
           dest_frame.stride(VideoFrame::Plane::kU),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
           dest_frame.stride(VideoFrame::Plane::kV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -340,9 +340,9 @@ bool NV12xToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   if (dest_frame.format() == PIXEL_FORMAT_I420) {
     return true;
   }
-  libyuv::CopyPlane(src_frame.visible_data(VideoFrame::Plane::kATriPlanar),
+  libyuv::CopyPlane(src_frame.visible_data(VideoFrame::Plane::kATriPlanar).data(),
                     src_frame.stride(VideoFrame::Plane::kATriPlanar),
-                    dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+                    dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
                     dest_frame.stride(VideoFrame::Plane::kA),
                     dest_frame.visible_rect().width(),
                     dest_frame.visible_rect().height());
diff --git a/media/base/video_frame_converter_unittest.cc b/media/base/video_frame_converter_unittest.cc
index ce97e02ac8679..878570b4af78d 100644
--- a/media/base/video_frame_converter_unittest.cc
+++ b/media/base/video_frame_converter_unittest.cc
@@ -94,7 +94,7 @@ bool IsConversionSupported(VideoPixelFormat src, VideoPixelFormat dest) {
     auto plane_size =
         VideoFrame::PlaneSize(frame.format(), i, frame.visible_rect().size());
     for (int y = 0; y < plane_size.height(); ++y) {
-      fwrite(frame.visible_data(i) + y * frame.stride(i), 1, plane_size.width(),
+      fwrite(frame.visible_data(i) .subspan( y * frame.stride(i)).data(), 1, plane_size.width(),
              f);
     }
   }
@@ -160,12 +160,12 @@ TEST_P(VideoFrameConverterTest, ConvertAndScale) {
     auto plane_size = VideoFrame::PlaneSize(expected_dest_frame->format(), i,
                                             dest_visible_size);
     auto ssim = libyuv::CalcFrameSsim(
-        dest_frame->visible_data(i), dest_frame->stride(i),
-        expected_dest_frame->visible_data(i), expected_dest_frame->stride(i),
+        dest_frame->visible_data(i).data(), dest_frame->stride(i),
+        expected_dest_frame->visible_data(i).data(), expected_dest_frame->stride(i),
         plane_size.width(), plane_size.height());
     auto psnr = libyuv::CalcFramePsnr(
-        dest_frame->visible_data(i), dest_frame->stride(i),
-        expected_dest_frame->visible_data(i), expected_dest_frame->stride(i),
+        dest_frame->visible_data(i).data(), dest_frame->stride(i),
+        expected_dest_frame->visible_data(i).data(), expected_dest_frame->stride(i),
         plane_size.width(), plane_size.height());
     EXPECT_DOUBLE_EQ(ssim, 1.0);
     EXPECT_EQ(psnr, libyuv::kMaxPsnr);
diff --git a/media/base/video_frame_pool_unittest.cc b/media/base/video_frame_pool_unittest.cc
index bf580169d0960..7298cc6dd425d 100644
--- a/media/base/video_frame_pool_unittest.cc
+++ b/media/base/video_frame_pool_unittest.cc
@@ -75,7 +75,7 @@ TEST_P(VideoFramePoolTest, FrameInitializedAndZeroed) {
 TEST_P(VideoFramePoolTest, FrameReuse) {
   scoped_refptr<VideoFrame> frame =
       CreateFrame(std::get<0>(GetParam()), std::get<1>(GetParam()), 10);
-  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY);
+  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY).data();
 
   // Clear frame reference to return the frame to the pool.
   frame.reset();
@@ -83,7 +83,7 @@ TEST_P(VideoFramePoolTest, FrameReuse) {
   // Verify that the next frame from the pool uses the same memory.
   scoped_refptr<VideoFrame> new_frame =
       CreateFrame(std::get<0>(GetParam()), std::get<1>(GetParam()), 20);
-  EXPECT_EQ(old_y_data, new_frame->data(VideoFrame::Plane::kY));
+  EXPECT_EQ(old_y_data, new_frame->data(VideoFrame::Plane::kY).data());
 }
 
 INSTANTIATE_TEST_SUITE_P(All,
@@ -126,7 +126,7 @@ TEST_F(VideoFramePoolTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(frame->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(frame->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          frame->rows(VideoFrame::Plane::kY) *
              frame->stride(VideoFrame::Plane::kY));
 }
diff --git a/media/base/video_frame_unittest.cc b/media/base/video_frame_unittest.cc
index 8af9ae75baa43..868c1a392a677 100644
--- a/media/base/video_frame_unittest.cc
+++ b/media/base/video_frame_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -160,19 +162,19 @@ void InitializeYV12Frame(VideoFrame* frame, double white_to_black) {
   EXPECT_EQ(PIXEL_FORMAT_YV12, frame->format());
   const int first_black_row =
       static_cast<int>(frame->coded_size().height() * white_to_black);
-  uint8_t* y_plane = frame->writable_data(VideoFrame::Plane::kY);
+  base::span<uint8_t>y_plane = frame->writable_data(VideoFrame::Plane::kY);
   for (int row = 0; row < frame->coded_size().height(); ++row) {
     int color = (row < first_black_row) ? 0xFF : 0x00;
-    memset(y_plane, color, frame->stride(VideoFrame::Plane::kY));
-    y_plane += frame->stride(VideoFrame::Plane::kY);
+    memset(y_plane.data(), color, frame->stride(VideoFrame::Plane::kY));
+    y_plane=y_plane.subspan(frame->stride(VideoFrame::Plane::kY));
   }
-  uint8_t* u_plane = frame->writable_data(VideoFrame::Plane::kU);
-  uint8_t* v_plane = frame->writable_data(VideoFrame::Plane::kV);
+  base::span<uint8_t>u_plane = frame->writable_data(VideoFrame::Plane::kU);
+  base::span<uint8_t>v_plane = frame->writable_data(VideoFrame::Plane::kV);
   for (int row = 0; row < frame->coded_size().height(); row += 2) {
-    memset(u_plane, 0x80, frame->stride(VideoFrame::Plane::kU));
-    memset(v_plane, 0x80, frame->stride(VideoFrame::Plane::kV));
-    u_plane += frame->stride(VideoFrame::Plane::kU);
-    v_plane += frame->stride(VideoFrame::Plane::kV);
+    memset(u_plane.data(), 0x80, frame->stride(VideoFrame::Plane::kU));
+    memset(v_plane.data(), 0x80, frame->stride(VideoFrame::Plane::kV));
+    u_plane=u_plane.subspan(frame->stride(VideoFrame::Plane::kU));
+    v_plane=v_plane.subspan(frame->stride(VideoFrame::Plane::kV));
   }
 }
 
@@ -195,11 +197,11 @@ void ExpectFrameColor(VideoFrame* yv12_frame, uint32_t expect_rgb_color) {
                              VideoFrame::kFrameSizePadding,
                          VideoFrame::kFrameAddressAlignment));
 
-  libyuv::I420ToARGB(yv12_frame->data(VideoFrame::Plane::kY),
+  libyuv::I420ToARGB(yv12_frame->data(VideoFrame::Plane::kY).data(),
                      yv12_frame->stride(VideoFrame::Plane::kY),
-                     yv12_frame->data(VideoFrame::Plane::kU),
+                     yv12_frame->data(VideoFrame::Plane::kU).data(),
                      yv12_frame->stride(VideoFrame::Plane::kU),
-                     yv12_frame->data(VideoFrame::Plane::kV),
+                     yv12_frame->data(VideoFrame::Plane::kV).data(),
                      yv12_frame->stride(VideoFrame::Plane::kV), rgb_data,
                      bytes_per_row, yv12_frame->coded_size().width(),
                      yv12_frame->coded_size().height());
@@ -233,13 +235,13 @@ void ExpectFrameExtents(VideoPixelFormat format, const char* expected_hash) {
   int planes = VideoFrame::NumPlanes(format);
   for (int plane = 0; plane < planes; plane++) {
     SCOPED_TRACE(base::StringPrintf("Checking plane %d", plane));
-    EXPECT_TRUE(frame->data(plane));
+    EXPECT_TRUE(frame->data(plane).data());
     EXPECT_TRUE(frame->stride(plane));
     EXPECT_TRUE(frame->rows(plane));
     EXPECT_TRUE(frame->row_bytes(plane));
     EXPECT_TRUE(frame->columns(plane));
 
-    memset(frame->writable_data(plane), kFillByte,
+    memset(frame->writable_data(plane).data(), kFillByte,
            frame->stride(plane) * frame->rows(plane));
   }
 
@@ -347,19 +349,19 @@ TEST(VideoFrame, CreateBlackFrame) {
   EXPECT_EQ(kHeight, frame->coded_size().height());
 
   // Test frames themselves.
-  uint8_t* y_plane = frame->writable_data(VideoFrame::Plane::kY);
+  base::span<uint8_t>y_plane = frame->writable_data(VideoFrame::Plane::kY);
   for (int y = 0; y < frame->coded_size().height(); ++y) {
-    EXPECT_EQ(0, memcmp(kExpectedYRow, y_plane, std::size(kExpectedYRow)));
-    y_plane += frame->stride(VideoFrame::Plane::kY);
+    EXPECT_EQ(0, memcmp(kExpectedYRow, y_plane.data(), std::size(kExpectedYRow)));
+    y_plane=y_plane.subspan(frame->stride(VideoFrame::Plane::kY));
   }
 
-  uint8_t* u_plane = frame->writable_data(VideoFrame::Plane::kU);
-  uint8_t* v_plane = frame->writable_data(VideoFrame::Plane::kV);
+  base::span<uint8_t>u_plane = frame->writable_data(VideoFrame::Plane::kU);
+  base::span<uint8_t>v_plane = frame->writable_data(VideoFrame::Plane::kV);
   for (int y = 0; y < frame->coded_size().height() / 2; ++y) {
-    EXPECT_EQ(0, memcmp(kExpectedUVRow, u_plane, std::size(kExpectedUVRow)));
-    EXPECT_EQ(0, memcmp(kExpectedUVRow, v_plane, std::size(kExpectedUVRow)));
-    u_plane += frame->stride(VideoFrame::Plane::kU);
-    v_plane += frame->stride(VideoFrame::Plane::kV);
+    EXPECT_EQ(0, memcmp(kExpectedUVRow, u_plane.data(), std::size(kExpectedUVRow)));
+    EXPECT_EQ(0, memcmp(kExpectedUVRow, v_plane.data(), std::size(kExpectedUVRow)));
+    u_plane=u_plane.subspan(frame->stride(VideoFrame::Plane::kU));
+    v_plane=v_plane.subspan(frame->stride(VideoFrame::Plane::kV));
   }
 }
 
@@ -420,8 +422,8 @@ TEST(VideoFrame, WrapVideoFrame) {
         &FrameNoLongerNeededCallback, &base_frame_done_callback_was_run));
     ASSERT_TRUE(frame);
     EXPECT_EQ(base_frame->coded_size(), frame->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame->visible_rect());
     EXPECT_EQ(visible_rect, frame->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame->natural_size());
@@ -444,8 +446,8 @@ TEST(VideoFrame, WrapVideoFrame) {
                                         natural_size);
     ASSERT_TRUE(frame2);
     EXPECT_EQ(base_frame->coded_size(), frame2->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame2->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame2->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame2->visible_rect());
     EXPECT_EQ(visible_rect, frame2->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame2->natural_size());
@@ -464,8 +466,8 @@ TEST(VideoFrame, WrapVideoFrame) {
                                              larger_visible_rect.size());
     ASSERT_TRUE(frame3);
     EXPECT_EQ(base_frame->coded_size(), frame3->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame3->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame3->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame3->visible_rect());
     EXPECT_EQ(larger_visible_rect, frame3->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame3->natural_size());
@@ -1028,12 +1030,12 @@ TEST(VideoFrame, WrappedPlaneDataAccess) {
       /* U plane */ base::span(u_pixels.data(), 0u),
       /* V plane */ v_pixels, timestamp);
 
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kY), y_pixels.data());
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kY).data(), y_pixels.data());
   EXPECT_EQ(frame->data_span(VideoFrame::Plane::kY).data(), y_pixels.data());
   EXPECT_EQ(frame->data_span(VideoFrame::Plane::kY).size(), y_pixels.size());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU), nullptr);
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(), nullptr);
   EXPECT_TRUE(frame->data_span(VideoFrame::Plane::kU).empty());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kV), nullptr);
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kV).data(), nullptr);
   EXPECT_TRUE(frame->data_span(VideoFrame::Plane::kV).empty());
 }
 }  // namespace media
diff --git a/media/base/video_util.cc b/media/base/video_util.cc
index 20b7864971ee9..662d4e100fa95 100644
--- a/media/base/video_util.cc
+++ b/media/base/video_util.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -46,30 +48,30 @@ namespace {
 
 // Helper to apply padding to the region outside visible rect up to the coded
 // size with the repeated last column / row of the visible rect.
-void FillRegionOutsideVisibleRect(uint8_t* data,
+void FillRegionOutsideVisibleRect(base::span<uint8_t>data,
                                   size_t stride,
                                   const gfx::Size& coded_size,
                                   const gfx::Size& visible_size) {
   if (visible_size.IsEmpty()) {
     if (!coded_size.IsEmpty())
-      memset(data, 0, coded_size.height() * stride);
+      memset(data.data(), 0, coded_size.height() * stride);
     return;
   }
 
   const int coded_width = coded_size.width();
   if (visible_size.width() < coded_width) {
     const int pad_length = coded_width - visible_size.width();
-    uint8_t* dst = data + visible_size.width();
-    for (int i = 0; i < visible_size.height(); ++i, dst += stride)
-      memset(dst, *(dst - 1), pad_length);
+    base::span<uint8_t>dst = data .subspan( visible_size.width());
+    for (int i = 0; i < visible_size.height(); ++i, dst=dst.subspan(stride))
+      memset(dst.data(), *(dst - 1), pad_length);
   }
 
   if (visible_size.height() < coded_size.height()) {
-    uint8_t* dst = data + visible_size.height() * stride;
+    base::span<uint8_t>dst = data .subspan( visible_size.height() * stride);
     uint8_t* src = dst - stride;
     for (int i = visible_size.height(); i < coded_size.height();
-         ++i, dst += stride)
-      memcpy(dst, src, coded_width);
+         ++i, dst=dst.subspan(stride))
+      memcpy(dst.data(), src, coded_width);
   }
 }
 
@@ -104,45 +106,45 @@ VideoPixelFormat ReadbackFormat(const VideoFrame& frame) {
 }
 
 void LetterboxPlane(const gfx::Rect& view_area_in_bytes,
-                    uint8_t* ptr,
+                    base::span<uint8_t>ptr,
                     int rows,
                     int row_bytes,
                     int stride,
                     int bytes_per_element,
                     uint8_t fill_byte) {
   if (view_area_in_bytes.IsEmpty()) {
-    libyuv::SetPlane(ptr, stride, row_bytes, rows, fill_byte);
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, rows, fill_byte);
     return;
   }
 
   if (view_area_in_bytes.y() > 0) {
-    libyuv::SetPlane(ptr, stride, row_bytes, view_area_in_bytes.y(), fill_byte);
-    ptr += stride * view_area_in_bytes.y();
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, view_area_in_bytes.y(), fill_byte);
+    ptr=ptr.subspan(stride * view_area_in_bytes.y());
   }
 
   if (view_area_in_bytes.width() < row_bytes) {
     if (view_area_in_bytes.x() > 0) {
-      libyuv::SetPlane(ptr, stride, view_area_in_bytes.x(),
+      libyuv::SetPlane(ptr.data(), stride, view_area_in_bytes.x(),
                        view_area_in_bytes.height(), fill_byte);
     }
     if (view_area_in_bytes.right() < row_bytes) {
-      libyuv::SetPlane(ptr + view_area_in_bytes.right(), stride,
+      libyuv::SetPlane(ptr .subspan( view_area_in_bytes.right()).data(), stride,
                        row_bytes - view_area_in_bytes.right(),
                        view_area_in_bytes.height(), fill_byte);
     }
   }
 
-  ptr += stride * view_area_in_bytes.height();
+  ptr=ptr.subspan(stride * view_area_in_bytes.height());
 
   if (view_area_in_bytes.bottom() < rows) {
-    libyuv::SetPlane(ptr, stride, row_bytes, rows - view_area_in_bytes.bottom(),
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, rows - view_area_in_bytes.bottom(),
                      fill_byte);
   }
 }
 
 void LetterboxPlane(VideoFrame* frame,
                     int plane,
-                    uint8_t* ptr,
+                    base::span<uint8_t>ptr,
                     const gfx::Rect& view_area_in_pixels,
                     uint8_t fill_byte) {
   const int rows = frame->rows(plane);
@@ -173,13 +175,13 @@ void LetterboxPlane(VideoFrame* frame,
                     int plane,
                     const gfx::Rect& view_area_in_pixels,
                     uint8_t fill_byte) {
-  uint8_t* ptr = nullptr;
+  base::span<uint8_t>ptr = {};
   if (frame->IsMappable()) {
     ptr = frame->writable_data(plane);
   } else if (scoped_mapping) {
     ptr = scoped_mapping->Memory(plane);
   }
-  CHECK(ptr);
+  CHECK(!ptr.empty());
 
   LetterboxPlane(frame, plane, ptr, view_area_in_pixels, fill_byte);
 }
@@ -230,11 +232,11 @@ void ProcessAsyncMappingResult(
 }  // namespace
 
 void FillYUV(VideoFrame* frame, uint8_t y, uint8_t u, uint8_t v) {
-  libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+  libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                    frame->stride(VideoFrame::Plane::kY),
-                   frame->writable_data(VideoFrame::Plane::kU),
+                   frame->writable_data(VideoFrame::Plane::kU).data(),
                    frame->stride(VideoFrame::Plane::kU),
-                   frame->writable_data(VideoFrame::Plane::kV),
+                   frame->writable_data(VideoFrame::Plane::kV).data(),
                    frame->stride(VideoFrame::Plane::kV), 0, 0,
                    frame->coded_size().width(), frame->coded_size().height(), y,
                    u, v);
@@ -245,7 +247,7 @@ void FillYUVA(VideoFrame* frame, uint8_t y, uint8_t u, uint8_t v, uint8_t a) {
   FillYUV(frame, y, u, v);
 
   // Fill the A plane.
-  libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA),
+  libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA).data(),
                    frame->stride(VideoFrame::Plane::kA),
                    frame->row_bytes(VideoFrame::Plane::kA),
                    frame->rows(VideoFrame::Plane::kA), a);
@@ -628,17 +630,17 @@ bool I420CopyWithPadding(const VideoFrame& src_frame, VideoFrame* dst_frame) {
             src_frame.visible_rect().height());
   DCHECK(dst_frame->visible_rect().origin().IsOrigin());
 
-  if (libyuv::I420Copy(src_frame.visible_data(VideoFrame::Plane::kY),
+  if (libyuv::I420Copy(src_frame.visible_data(VideoFrame::Plane::kY).data(),
                        src_frame.stride(VideoFrame::Plane::kY),
-                       src_frame.visible_data(VideoFrame::Plane::kU),
+                       src_frame.visible_data(VideoFrame::Plane::kU).data(),
                        src_frame.stride(VideoFrame::Plane::kU),
-                       src_frame.visible_data(VideoFrame::Plane::kV),
+                       src_frame.visible_data(VideoFrame::Plane::kV).data(),
                        src_frame.stride(VideoFrame::Plane::kV),
-                       dst_frame->writable_data(VideoFrame::Plane::kY),
+                       dst_frame->writable_data(VideoFrame::Plane::kY).data(),
                        dst_frame->stride(VideoFrame::Plane::kY),
-                       dst_frame->writable_data(VideoFrame::Plane::kU),
+                       dst_frame->writable_data(VideoFrame::Plane::kU).data(),
                        dst_frame->stride(VideoFrame::Plane::kU),
-                       dst_frame->writable_data(VideoFrame::Plane::kV),
+                       dst_frame->writable_data(VideoFrame::Plane::kV).data(),
                        dst_frame->stride(VideoFrame::Plane::kV),
                        src_frame.visible_rect().width(),
                        src_frame.visible_rect().height())) {
@@ -703,7 +705,7 @@ scoped_refptr<VideoFrame> ReadbackTextureBackedFrameToMemorySync(
   for (size_t plane = 0; plane < planes; plane++) {
     gfx::Rect src_rect(0, 0, txt_frame.columns(plane), txt_frame.rows(plane));
     if (!ReadbackTexturePlaneToMemorySync(txt_frame, plane, src_rect,
-                                          result->writable_data(plane),
+                                          result->writable_data(plane).data(),
                                           result->stride(plane), ri)) {
       return nullptr;
     }
diff --git a/media/base/video_util_unittest.cc b/media/base/video_util_unittest.cc
index 57824d9a06740..3854a220c851e 100644
--- a/media/base/video_util_unittest.cc
+++ b/media/base/video_util_unittest.cc
@@ -25,14 +25,14 @@
 namespace {
 
 // Initialize a plane's visible rect with value circularly from 0 to 255.
-void FillPlaneWithPattern(uint8_t* data,
+void FillPlaneWithPattern(base::span<uint8_t>data,
                           int stride,
                           const gfx::Size& visible_size) {
-  DCHECK(data && visible_size.width() <= stride);
+  DCHECK(!data.empty() && visible_size.width() <= stride);
 
   uint32_t val = 0;
-  uint8_t* src = data;
-  for (int i = 0; i < visible_size.height(); ++i, src += stride) {
+  base::span<uint8_t>src = data;
+  for (int i = 0; i < visible_size.height(); ++i, src=src.subspan(stride)) {
     for (int j = 0; j < visible_size.width(); ++j, ++val)
       src[j] = val & 0xff;
   }
@@ -70,15 +70,15 @@ scoped_refptr<media::VideoFrame> CreateFrameWithPatternFilled(
 
 // Helper function used to verify the data in the coded region after copying the
 // visible region and padding the remaining area.
-bool VerifyPlanCopyWithPadding(const uint8_t* src,
+bool VerifyPlanCopyWithPadding(base::span<const uint8_t>src,
                                size_t src_stride,
                                // Size of visible region.
                                const gfx::Size& src_size,
-                               const uint8_t* dst,
+                               base::span<const uint8_t>dst,
                                size_t dst_stride,
                                // Coded size of |dst|.
                                const gfx::Size& dst_size) {
-  if (!src || !dst)
+  if (src.empty() || dst.empty())
     return false;
 
   const size_t src_width = src_size.width();
@@ -89,10 +89,10 @@ bool VerifyPlanCopyWithPadding(const uint8_t* src,
       src_height > dst_height || src_size.IsEmpty() || dst_size.IsEmpty())
     return false;
 
-  const uint8_t *src_ptr = src, *dst_ptr = dst;
+  base::span<const uint8_t>dst_ptr = dst;
   for (size_t i = 0; i < src_height;
-       ++i, src_ptr += src_stride, dst_ptr += dst_stride) {
-    if (memcmp(src_ptr, dst_ptr, src_width))
+       ++i, src_ptr=src_ptr.subspan(src_stride), dst_ptr=dst_ptr.subspan(dst_stride)) {
+    if (memcmp(src_ptr.data(), dst_ptr.data(), src_width))
       return false;
     for (size_t j = src_width; j < dst_width; ++j) {
       if (src_ptr[src_width - 1] != dst_ptr[j])
@@ -100,8 +100,8 @@ bool VerifyPlanCopyWithPadding(const uint8_t* src,
     }
   }
   if (src_height < dst_height) {
-    src_ptr = dst + (src_height - 1) * dst_stride;
-    if (memcmp(src_ptr, dst_ptr, dst_width))
+    src_ptr = dst .subspan( (src_height - 1) * dst_stride);
+    if (memcmp(src_ptr.data(), dst_ptr.data(), dst_width))
       return false;
   }
   return true;
@@ -616,14 +616,14 @@ TEST_F(VideoUtilTest, WrapAsI420VideoFrame) {
   std::vector<size_t> planes = {VideoFrame::Plane::kY, VideoFrame::Plane::kU,
                                 VideoFrame::Plane::kV};
   for (auto plane : planes)
-    EXPECT_EQ(dst_frame->data(plane), src_frame->data(plane));
+    EXPECT_EQ(dst_frame->data(plane).data(), src_frame->data(plane).data());
 
   // Check that memory for planes is not released upon destruction of the
   // original frame pointer (new frame holds a reference). This check relies on
   // ASAN.
   src_frame.reset();
   for (auto plane : planes)
-    memset(dst_frame->writable_data(plane), 1, dst_frame->stride(plane));
+    memset(dst_frame->writable_data(plane).data(), 1, dst_frame->stride(plane));
 }
 
 }  // namespace media
diff --git a/media/capture/video/mock_device.cc b/media/capture/video/mock_device.cc
index 4f2d5032e5089..896f1bbd38b74 100644
--- a/media/capture/video/mock_device.cc
+++ b/media/capture/video/mock_device.cc
@@ -18,7 +18,7 @@ void MockDevice::SendStubFrame(const media::VideoCaptureFormat& format,
       gfx::Rect(format.frame_size.width(), format.frame_size.height()),
       format.frame_size, base::TimeDelta());
   client_->OnIncomingCapturedData(
-      stub_frame->data(0),
+      stub_frame->data(0).data(),
       static_cast<int>(media::VideoFrame::AllocationSize(
           stub_frame->format(), stub_frame->coded_size())),
       format, gfx::ColorSpace(), rotation, false /* flip_y */,
diff --git a/media/cast/encoding/av1_encoder.cc b/media/cast/encoding/av1_encoder.cc
index ebdfabce7ef0f..4738442d851df 100644
--- a/media/cast/encoding/av1_encoder.cc
+++ b/media/cast/encoding/av1_encoder.cc
@@ -220,7 +220,7 @@ void Av1Encoder::Encode(scoped_refptr<media::VideoFrame> video_frame,
   aom_image_t aom_image;
   aom_image_t* const result = aom_img_wrap(
       &aom_image, aom_format, frame_size.width(), frame_size.height(), 1,
-      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(result, &aom_image);
 
   aom_image.planes[AOM_PLANE_Y] =
diff --git a/media/cast/encoding/external_video_encoder.cc b/media/cast/encoding/external_video_encoder.cc
index dfe5939096851..a4610b7109d30 100644
--- a/media/cast/encoding/external_video_encoder.cc
+++ b/media/cast/encoding/external_video_encoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -278,7 +280,7 @@ class ExternalVideoEncoder::VEAClientImpl final
           video_frame->format(), frame_coded_size_,
           gfx::Rect(video_frame->visible_rect().size()),
           video_frame->visible_rect().size(),
-          static_cast<uint8_t*>(mapped_region.mapping.memory()),
+          static_cast<uint8_t*>(mapped_region.mapping.memory().data()),
           mapped_region.mapping.size(), video_frame->timestamp());
       if (!frame || !media::I420CopyWithPadding(*video_frame, frame.get())) {
         LOG(DFATAL) << "Error: ExternalVideoEncoder: copy failed.";
@@ -905,12 +907,12 @@ std::optional<double> QuantizerEstimator::EstimateForKeyFrame(
   const int row_skip = size.height() / rows_in_subset;
   int y = 0;
   for (int i = 0; i < rows_in_subset; ++i, y += row_skip) {
-    const uint8_t* const row_begin = frame.visible_data(VideoFrame::Plane::kY) +
-                                     y * frame.stride(VideoFrame::Plane::kY);
-    const uint8_t* const row_end = row_begin + size.width();
-    int left_hand_pixel_value = static_cast<int>(*row_begin);
-    for (const uint8_t* p = row_begin + 1; p < row_end; ++p) {
-      const int right_hand_pixel_value = static_cast<int>(*p);
+    const base::span<const uint8_t>row_begin = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                                     y * frame.stride(VideoFrame::Plane::kY));
+    const uint8_t* const row_end = row_begin .subspan( size.width()).data();
+    int left_hand_pixel_value = static_cast<int>( row_begin[0]);
+    for (base::span<const uint8_t>p = row_begin .subspan( 1); p < row_end; ++p) {
+      const int right_hand_pixel_value = static_cast<int>( p[0]);
       const int difference = right_hand_pixel_value - left_hand_pixel_value;
       const int histogram_index = difference + 255;
       ++histogram[histogram_index];
@@ -919,7 +921,7 @@ std::optional<double> QuantizerEstimator::EstimateForKeyFrame(
 
     // Copy the row of pixels into the buffer.  This will be used when
     // generating histograms for future delta frames.
-    memcpy(last_frame_pixel_buffer_.get() + i * size.width(), row_begin,
+    memcpy(last_frame_pixel_buffer_.get() + i * size.width(), row_begin.data(),
            size.width());
   }
 
@@ -952,21 +954,21 @@ std::optional<double> QuantizerEstimator::EstimateForDeltaFrame(
   const int row_skip = size.height() / rows_in_subset;
   int y = 0;
   for (int i = 0; i < rows_in_subset; ++i, y += row_skip) {
-    const uint8_t* const row_begin = frame.visible_data(VideoFrame::Plane::kY) +
-                                     y * frame.stride(VideoFrame::Plane::kY);
-    const uint8_t* const row_end = row_begin + size.width();
+    const base::span<const uint8_t>row_begin = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                                     y * frame.stride(VideoFrame::Plane::kY));
+    const uint8_t* const row_end = row_begin .subspan( size.width()).data();
     uint8_t* const last_frame_row_begin =
         last_frame_pixel_buffer_.get() + i * size.width();
-    for (const uint8_t *p = row_begin, *q = last_frame_row_begin; p < row_end;
+    for (base::span<const uint8_t>p = row_begin, *q = last_frame_row_begin; p < row_end;
          ++p, ++q) {
-      const int difference = static_cast<int>(*p) - static_cast<int>(*q);
+      const int difference = static_cast<int>( p[0]) - static_cast<int>(*q);
       const int histogram_index = difference + 255;
       ++histogram[histogram_index];
     }
 
     // Copy the row of pixels into the buffer.  This will be used when
     // generating histograms for future delta frames.
-    memcpy(last_frame_row_begin, row_begin, size.width());
+    memcpy(last_frame_row_begin, row_begin.data(), size.width());
   }
 
   // Estimate a quantizer value depending on the difference data in the
diff --git a/media/cast/encoding/external_video_encoder_unittest.cc b/media/cast/encoding/external_video_encoder_unittest.cc
index 7f077fcaca89a..271a9730ef510 100644
--- a/media/cast/encoding/external_video_encoder_unittest.cc
+++ b/media/cast/encoding/external_video_encoder_unittest.cc
@@ -24,8 +24,8 @@ scoped_refptr<VideoFrame> CreateFrame(const uint8_t* y_plane_data,
   scoped_refptr<VideoFrame> result = VideoFrame::CreateFrame(
       PIXEL_FORMAT_I420, size, gfx::Rect(size), size, base::TimeDelta());
   for (int y = 0, y_end = size.height(); y < y_end; ++y) {
-    memcpy(result->GetWritableVisibleData(VideoFrame::Plane::kY) +
-               y * result->stride(VideoFrame::Plane::kY),
+    memcpy(result->GetWritableVisibleData(VideoFrame::Plane::kY) .subspan(
+               y * result->stride(VideoFrame::Plane::kY)).data(),
            y_plane_data + y * size.width(), size.width());
   }
   return result;
diff --git a/media/cast/encoding/vpx_encoder.cc b/media/cast/encoding/vpx_encoder.cc
index 53b7e1601b789..8c40b1ecfdb2b 100644
--- a/media/cast/encoding/vpx_encoder.cc
+++ b/media/cast/encoding/vpx_encoder.cc
@@ -254,7 +254,7 @@ void VpxEncoder::Encode(scoped_refptr<media::VideoFrame> video_frame,
   vpx_image_t vpx_image;
   vpx_image_t* const result = vpx_img_wrap(
       &vpx_image, vpx_format, frame_size.width(), frame_size.height(), 1,
-      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(result, &vpx_image);
   switch (vpx_format) {
     case VPX_IMG_FMT_I420:
diff --git a/media/cast/sender/performance_metrics_overlay.cc b/media/cast/sender/performance_metrics_overlay.cc
index f4b2b858c3dfb..2901be14ac5cb 100644
--- a/media/cast/sender/performance_metrics_overlay.cc
+++ b/media/cast/sender/performance_metrics_overlay.cc
@@ -113,17 +113,17 @@ scoped_refptr<VideoFrame> CopyVideoFrame(scoped_refptr<VideoFrame> source) {
   }
 
   // Copy the contents of the VideoFrame over.
-  libyuv::I420Copy(source->data(media::VideoFrame::Plane::kY),
+  libyuv::I420Copy(source->data(media::VideoFrame::Plane::kY).data(),
                    source->stride(media::VideoFrame::Plane::kY),
-                   source->data(media::VideoFrame::Plane::kU),
+                   source->data(media::VideoFrame::Plane::kU).data(),
                    source->stride(media::VideoFrame::Plane::kU),
-                   source->data(media::VideoFrame::Plane::kV),
+                   source->data(media::VideoFrame::Plane::kV).data(),
                    source->stride(media::VideoFrame::Plane::kV),
-                   frame->writable_data(media::VideoFrame::Plane::kY),
+                   frame->writable_data(media::VideoFrame::Plane::kY).data(),
                    frame->stride(media::VideoFrame::Plane::kY),
-                   frame->writable_data(media::VideoFrame::Plane::kU),
+                   frame->writable_data(media::VideoFrame::Plane::kU).data(),
                    frame->stride(media::VideoFrame::Plane::kU),
-                   frame->writable_data(media::VideoFrame::Plane::kV),
+                   frame->writable_data(media::VideoFrame::Plane::kV).data(),
                    frame->stride(media::VideoFrame::Plane::kV),
                    source->coded_size().width(), source->coded_size().height());
 
diff --git a/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc b/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
index 9a016d2e5f00a..4eac75e12d529 100644
--- a/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
+++ b/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
@@ -120,7 +120,7 @@ bool ToCdmVideoFrame(const VideoFrame& video_frame,
   uint8_t* dst = buffer->Data();
   uint32_t offset = 0;
   for (int plane = 0; plane < 3; ++plane) {
-    const uint8_t* src = video_frame.data(plane);
+    const uint8_t* src = video_frame.data(plane).data();
     int src_stride = video_frame.stride(plane);
     int row_bytes = video_frame.row_bytes(plane);
     int rows = video_frame.rows(plane);
diff --git a/media/filters/dav1d_video_decoder_unittest.cc b/media/filters/dav1d_video_decoder_unittest.cc
index 2a1b27f2c5b72..9ba8a587a2b14 100644
--- a/media/filters/dav1d_video_decoder_unittest.cc
+++ b/media/filters/dav1d_video_decoder_unittest.cc
@@ -242,8 +242,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_8bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_I420, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("eeba03dcc9c22c4632bf74b481db36b2", GetVideoFrameHash(*frame));
 }
 
@@ -256,8 +256,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_10bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_YUV420P10, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("026c1fed9e161f09d816ac7278458a80", GetVideoFrameHash(*frame));
 }
 
@@ -270,8 +270,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_12bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_YUV420P12, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("32115092dc00fbe86823b0b714a0f63e", GetVideoFrameHash(*frame));
 }
 
@@ -352,7 +352,7 @@ TEST_F(Dav1dVideoDecoderTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          output_frames_.front()->rows(VideoFrame::Plane::kY) *
              output_frames_.front()->stride(VideoFrame::Plane::kY));
 }
diff --git a/media/filters/ffmpeg_video_decoder.cc b/media/filters/ffmpeg_video_decoder.cc
index cc15e1edd8ebe..d82761b9e9d30 100644
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -203,7 +203,7 @@ int FFmpegVideoDecoder::GetVideoBuffer(struct AVCodecContext* codec_context,
     return AVERROR(ENOMEM);
   }
 
-  uint8_t* data = base::bits::AlignUp(span.data(), layout->buffer_addr_align());
+  uint8_t* data = base::bits::AlignUp(span.data(), layout->buffer_addr_align()).data();
 
   for (size_t plane = 0; plane < num_planes; ++plane) {
     frame->data[plane] = data + layout->planes()[plane].offset;
diff --git a/media/filters/file_data_source.cc b/media/filters/file_data_source.cc
index a853dbbf4dc47..ab9b855a99d1b 100644
--- a/media/filters/file_data_source.cc
+++ b/media/filters/file_data_source.cc
@@ -57,7 +57,7 @@ void FileDataSource::Read(int64_t position,
   int64_t clamped_size =
       std::min(static_cast<int64_t>(size), file_size - position);
 
-  memcpy(data, file_.data() + position, clamped_size);
+  memcpy(data, file_.data() .subspan( position).data(), clamped_size);
   bytes_read_ += clamped_size;
   std::move(read_cb).Run(clamped_size);
 }
diff --git a/media/filters/in_memory_url_protocol.cc b/media/filters/in_memory_url_protocol.cc
index ab27c2caf5b77..854bcbe72560c 100644
--- a/media/filters/in_memory_url_protocol.cc
+++ b/media/filters/in_memory_url_protocol.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -13,7 +15,7 @@
 
 namespace media {
 
-InMemoryUrlProtocol::InMemoryUrlProtocol(const uint8_t* data,
+InMemoryUrlProtocol::InMemoryUrlProtocol(base::span<const uint8_t>data,
                                          int64_t size,
                                          bool streaming)
     : data_(data),
@@ -39,7 +41,7 @@ int InMemoryUrlProtocol::Read(int size, uint8_t* data) {
     size = available_bytes;
 
   if (size > 0) {
-    memcpy(data, data_ + base::checked_cast<size_t>(position_), size);
+    memcpy(data, data_ .subspan( base::checked_cast<size_t>(position_)).data(), size);
     position_ += size;
   }
 
diff --git a/media/filters/in_memory_url_protocol.h b/media/filters/in_memory_url_protocol.h
index 38591438434ef..350000fec3a07 100644
--- a/media/filters/in_memory_url_protocol.h
+++ b/media/filters/in_memory_url_protocol.h
@@ -7,6 +7,8 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "media/filters/ffmpeg_glue.h"
@@ -22,7 +24,7 @@ class MEDIA_EXPORT InMemoryUrlProtocol : public FFmpegURLProtocol {
  public:
   InMemoryUrlProtocol() = delete;
 
-  InMemoryUrlProtocol(const uint8_t* buf, int64_t size, bool streaming);
+  InMemoryUrlProtocol(base::span<const uint8_t>buf, int64_t size, bool streaming);
 
   InMemoryUrlProtocol(const InMemoryUrlProtocol&) = delete;
   InMemoryUrlProtocol& operator=(const InMemoryUrlProtocol&) = delete;
@@ -37,7 +39,7 @@ class MEDIA_EXPORT InMemoryUrlProtocol : public FFmpegURLProtocol {
   bool IsStreaming() override;
 
  private:
-  raw_ptr<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> data_;
+  base::raw_span<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> data_;
   int64_t size_;
   int64_t position_;
   bool streaming_;
diff --git a/media/filters/in_memory_url_protocol_unittest.cc b/media/filters/in_memory_url_protocol_unittest.cc
index 95c2fdde039ee..8f2e75460a265 100644
--- a/media/filters/in_memory_url_protocol_unittest.cc
+++ b/media/filters/in_memory_url_protocol_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -15,42 +17,42 @@
 
 namespace media {
 
-static const uint8_t kData[] = {0x01, 0x02, 0x03, 0x04};
+const auto kData = std::to_array<uint8_t>({0x01, 0x02, 0x03, 0x04});
 
 TEST(InMemoryUrlProtocolTest, ReadFromLargeBuffer) {
   InMemoryUrlProtocol protocol(kData, std::numeric_limits<int64_t>::max(),
                                false);
 
-  uint8_t out[sizeof(kData)];
+  uint8_t out[(kData.size() * sizeof(decltype(kData)::value_type))];
   EXPECT_EQ(4, protocol.Read(sizeof(out), out));
-  EXPECT_EQ(0, memcmp(out, kData, sizeof(out)));
+  EXPECT_EQ(0, memcmp(out, kData.data(), sizeof(out)));
 }
 
 TEST(InMemoryUrlProtocolTest, ReadWithNegativeSize) {
-  InMemoryUrlProtocol protocol(kData, sizeof(kData), false);
+  InMemoryUrlProtocol protocol(kData, (kData.size() * sizeof(decltype(kData)::value_type)), false);
 
-  uint8_t out[sizeof(kData)];
+  uint8_t out[(kData.size() * sizeof(decltype(kData)::value_type))];
   EXPECT_EQ(AVERROR(EIO), protocol.Read(-2, out));
 }
 
 TEST(InMemoryUrlProtocolTest, ReadWithZeroSize) {
-  InMemoryUrlProtocol protocol(kData, sizeof(kData), false);
+  InMemoryUrlProtocol protocol(kData, (kData.size() * sizeof(decltype(kData)::value_type)), false);
 
   uint8_t out;
   EXPECT_EQ(0, protocol.Read(0, &out));
 }
 
 TEST(InMemoryUrlProtocolTest, SetPosition) {
-  InMemoryUrlProtocol protocol(kData, sizeof(kData), false);
+  InMemoryUrlProtocol protocol(kData, (kData.size() * sizeof(decltype(kData)::value_type)), false);
 
   EXPECT_FALSE(protocol.SetPosition(-1));
-  EXPECT_FALSE(protocol.SetPosition(sizeof(kData) + 1));
+  EXPECT_FALSE(protocol.SetPosition((kData.size() * sizeof(decltype(kData)::value_type)) + 1));
 
   uint8_t out;
-  EXPECT_TRUE(protocol.SetPosition(sizeof(kData)));
+  EXPECT_TRUE(protocol.SetPosition((kData.size() * sizeof(decltype(kData)::value_type))));
   EXPECT_EQ(AVERROR_EOF, protocol.Read(1, &out));
 
-  int i = sizeof(kData) / 2;
+  int i = (kData.size() * sizeof(decltype(kData)::value_type)) / 2;
   EXPECT_TRUE(protocol.SetPosition(i));
   EXPECT_EQ(1, protocol.Read(1, &out));
   EXPECT_EQ(kData[i], out);
diff --git a/media/filters/vpx_video_decoder.cc b/media/filters/vpx_video_decoder.cc
index 671ffa4ecb2c1..db2a030e76a50 100644
--- a/media/filters/vpx_video_decoder.cc
+++ b/media/filters/vpx_video_decoder.cc
@@ -353,7 +353,7 @@ bool VpxVideoDecoder::VpxDecode(const DecoderBuffer* buffer,
     libyuv::CopyPlane(
         vpx_image_alpha->planes[VPX_PLANE_Y],
         vpx_image_alpha->stride[VPX_PLANE_Y],
-        (*video_frame)->GetWritableVisibleData(VideoFrame::Plane::kA),
+        (*video_frame)->GetWritableVisibleData(VideoFrame::Plane::kA).data(),
         (*video_frame)->stride(VideoFrame::Plane::kA),
         (*video_frame)->visible_rect().width(),
         (*video_frame)->visible_rect().height());
@@ -607,7 +607,7 @@ bool VpxVideoDecoder::CopyVpxImageToVideoFrame(
 
   for (int plane = 0; plane < 3; plane++) {
     libyuv::CopyPlane(vpx_image->planes[plane], vpx_image->stride[plane],
-                      (*video_frame)->GetWritableVisibleData(plane),
+                      (*video_frame)->GetWritableVisibleData(plane).data(),
                       (*video_frame)->stride(plane),
                       (*video_frame)->row_bytes(plane),
                       (*video_frame)->rows(plane));
diff --git a/media/filters/vpx_video_decoder_unittest.cc b/media/filters/vpx_video_decoder_unittest.cc
index c819dba4802dd..5876915be0bd5 100644
--- a/media/filters/vpx_video_decoder_unittest.cc
+++ b/media/filters/vpx_video_decoder_unittest.cc
@@ -271,7 +271,7 @@ TEST_F(VpxVideoDecoderTest, SimpleFrameReuse) {
 
   ASSERT_EQ(1u, output_frames_.size());
   scoped_refptr<VideoFrame> frame = std::move(output_frames_.front());
-  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY);
+  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY).data();
   output_frames_.pop_back();
 
   // Clear frame reference to return the frame to the pool.
@@ -288,7 +288,7 @@ TEST_F(VpxVideoDecoderTest, SimpleFrameReuse) {
   Decode(i_frame_buffer_);
 
   ASSERT_EQ(2u, output_frames_.size());
-  EXPECT_EQ(old_y_data, output_frames_.back()->data(VideoFrame::Plane::kY));
+  EXPECT_EQ(old_y_data, output_frames_.back()->data(VideoFrame::Plane::kY).data());
 }
 
 TEST_F(VpxVideoDecoderTest, SimpleFormatChange) {
@@ -310,7 +310,7 @@ TEST_F(VpxVideoDecoderTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          output_frames_.front()->rows(VideoFrame::Plane::kY) *
              output_frames_.front()->stride(VideoFrame::Plane::kY));
 }
@@ -326,7 +326,7 @@ TEST_F(VpxVideoDecoderTest, MemoryPoolAllowsMultipleDisplay) {
 
   scoped_refptr<DecoderBuffer> data =
       ReadTestDataFile("vp9-duplicate-frame.webm");
-  InMemoryUrlProtocol protocol(data->data(), data->size(), false);
+  InMemoryUrlProtocol protocol(*data, data->size(), false);
   FFmpegGlue glue(&protocol);
   ASSERT_TRUE(glue.OpenContext());
 
@@ -345,12 +345,12 @@ TEST_F(VpxVideoDecoderTest, MemoryPoolAllowsMultipleDisplay) {
   scoped_refptr<VideoFrame> last_frame = output_frames_[25];
   scoped_refptr<VideoFrame> dupe_frame = output_frames_[23];
 
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kY),
-            dupe_frame->data(VideoFrame::Plane::kY));
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kU),
-            dupe_frame->data(VideoFrame::Plane::kU));
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kV),
-            dupe_frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kY).data(),
+            dupe_frame->data(VideoFrame::Plane::kY).data());
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kU).data(),
+            dupe_frame->data(VideoFrame::Plane::kU).data());
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kV).data(),
+            dupe_frame->data(VideoFrame::Plane::kV).data());
 
   // This will release all frames held by the memory pool, but should not
   // release |last_frame| since we still have a ref despite sharing the same
@@ -360,7 +360,7 @@ TEST_F(VpxVideoDecoderTest, MemoryPoolAllowsMultipleDisplay) {
   Destroy();
 
   // ASAN will be very unhappy with this line if the above is incorrect.
-  memset(last_frame->writable_data(VideoFrame::Plane::kY), 0,
+  memset(last_frame->writable_data(VideoFrame::Plane::kY).data(), 0,
          last_frame->row_bytes(VideoFrame::Plane::kY));
 }
 #endif  // !defined(LIBVPX_NO_HIGH_BIT_DEPTH) && !defined(ARCH_CPU_ARM_FAMILY)
diff --git a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
index af8ae8ce4d120..f15d5d034b310 100644
--- a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
+++ b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
@@ -56,7 +56,7 @@ MP4Status H265AnnexBToHevcBitstreamConverter::ConvertChunk(
   //     what configuration (profile and level) is active now.
   // A configure change will only happen on IDR frame. It is expected the
   // encoder output stream repeats VPS/SPS/PPS on IDR frames.
-  parser_.SetStream(input.data(), input.size());
+  parser_.SetStream(input, input.size());
   while ((result = parser_.AdvanceToNextNALU(&nalu)) != H265Parser::kEOStream) {
     if (result == H265Parser::kUnsupportedStream)
       return MP4Status::Codes::kUnsupportedStream;
diff --git a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
index 61d0e94d07251..0d635a45a8ccf 100644
--- a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
+++ b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
@@ -66,7 +66,7 @@ TEST(H265AnnexBToHevcBitstreamConverterTest, Success) {
       // parameter set are write to the output or not.
       EXPECT_TRUE(mp4::AVC::ConvertAVCToAnnexBInPlaceForLengthSize4(&output));
       H265Parser parser;
-      parser.SetStream(output.data(), output.size());
+      parser.SetStream(output, output.size());
       std::vector<H265NALU> parameter_sets;
       while (true) {
         H265NALU nalu;
@@ -226,7 +226,7 @@ TEST(H265AnnexBToHevcBitstreamConverterTest, PPS_SwitchWithoutReconfig) {
     // parameter set are write to the output.
     EXPECT_FALSE(mp4::AVC::ConvertAVCToAnnexBInPlaceForLengthSize4(&output));
     H265Parser parser;
-    parser.SetStream(output.data(), output.size());
+    parser.SetStream(output, output.size());
     std::vector<H265NALU> parameter_sets;
     while (true) {
       H265NALU nalu;
diff --git a/media/formats/mp4/hevc.cc b/media/formats/mp4/hevc.cc
index df64f477a6c00..4acc350488616 100644
--- a/media/formats/mp4/hevc.cc
+++ b/media/formats/mp4/hevc.cc
@@ -239,7 +239,7 @@ bool HEVCDecoderConfigurationRecord::ParseInternal(BufferReader* reader,
   }
   H265Parser parser;
   H265NALU nalu;
-  parser.SetStream(param_sets.data(), param_sets.size());
+  parser.SetStream(param_sets, param_sets.size());
   while (true) {
     H265Parser::Result result = parser.AdvanceToNextNALU(&nalu);
     if (result != H265Parser::kOk) {
@@ -362,11 +362,11 @@ bool HEVC::InsertParamSetsAnnexB(
     const HEVCDecoderConfigurationRecord& hevc_config,
     std::vector<uint8_t>* buffer,
     std::vector<SubsampleEntry>* subsamples) {
-  DCHECK(HEVC::AnalyzeAnnexB(buffer->data(), buffer->size(), *subsamples)
+  DCHECK(HEVC::AnalyzeAnnexB(*buffer, buffer->size(), *subsamples)
              .is_conformant.value_or(true));
 
   std::unique_ptr<H265NaluParser> parser(new H265NaluParser());
-  const uint8_t* start = buffer->data();
+  base::span<const uint8_t>start = *buffer;
   parser->SetEncryptedStream(start, buffer->size(), *subsamples);
 
   H265NALU nalu;
@@ -402,7 +402,7 @@ bool HEVC::InsertParamSetsAnnexB(
   buffer->insert(config_insert_point,
                  param_sets.begin(), param_sets.end());
 
-  DCHECK(HEVC::AnalyzeAnnexB(buffer->data(), buffer->size(), *subsamples)
+  DCHECK(HEVC::AnalyzeAnnexB(*buffer, buffer->size(), *subsamples)
              .is_conformant.value_or(true));
   return true;
 }
@@ -429,7 +429,7 @@ void HEVC::ConvertConfigToAnnexB(
 
 // static
 BitstreamConverter::AnalysisResult HEVC::AnalyzeAnnexB(
-    const uint8_t* buffer,
+    base::span<const uint8_t>buffer,
     size_t size,
     const std::vector<SubsampleEntry>& subsamples) {
   DVLOG(3) << __func__;
@@ -675,7 +675,7 @@ bool HEVCBitstreamConverter::ConvertAndAnalyzeFrame(
 BitstreamConverter::AnalysisResult HEVCBitstreamConverter::Analyze(
     std::vector<uint8_t>* frame_buf,
     std::vector<SubsampleEntry>* subsamples) const {
-  return HEVC::AnalyzeAnnexB(frame_buf->data(), frame_buf->size(), *subsamples);
+  return HEVC::AnalyzeAnnexB(*frame_buf, frame_buf->size(), *subsamples);
 }
 
 }  // namespace mp4
diff --git a/media/formats/mp4/hevc.h b/media/formats/mp4/hevc.h
index b637219ab254a..5aea29550b89c 100644
--- a/media/formats/mp4/hevc.h
+++ b/media/formats/mp4/hevc.h
@@ -11,6 +11,7 @@
 #include <memory>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "media/base/media_export.h"
 #include "media/base/video_codecs.h"
 #include "media/base/video_decoder_config.h"
@@ -106,7 +107,7 @@ class MEDIA_EXPORT HEVC {
   // |subsamples| contains the information about what parts of the buffer are
   // encrypted and which parts are clear.
   static BitstreamConverter::AnalysisResult AnalyzeAnnexB(
-      const uint8_t* buffer,
+      base::span<const uint8_t>buffer,
       size_t size,
       const std::vector<SubsampleEntry>& subsamples);
 };
diff --git a/media/formats/mp4/hevc_unittest.cc b/media/formats/mp4/hevc_unittest.cc
index 11cd86a5a9ee1..3b3ac2b3ef65c 100644
--- a/media/formats/mp4/hevc_unittest.cc
+++ b/media/formats/mp4/hevc_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -46,7 +48,7 @@ TEST(HEVCAnalyzeAnnexBTest, ValidAnnexBConstructs) {
     expected.is_conformant = true;
     expected.is_keyframe = test_cases[i].is_keyframe;
     EXPECT_PRED2(AnalysesMatch,
-                 HEVC::AnalyzeAnnexB(buf.data(), buf.size(), subsamples),
+                 HEVC::AnalyzeAnnexB(buf, buf.size(), subsamples),
                  expected)
         << "'" << test_cases[i].case_string << "' failed";
   }
@@ -54,7 +56,7 @@ TEST(HEVCAnalyzeAnnexBTest, ValidAnnexBConstructs) {
 
 TEST(HEVCAnalyzeAnnexBTest, EmptyBuffer) {
   std::vector<SubsampleEntry> subsamples;
-  auto result = HEVC::AnalyzeAnnexB(nullptr, 0, subsamples);
+  auto result = HEVC::AnalyzeAnnexB({}, 0, subsamples);
   EXPECT_TRUE(result.is_conformant);
   EXPECT_TRUE(subsamples.empty());
   EXPECT_FALSE(result.is_keyframe.has_value());
@@ -96,7 +98,7 @@ TEST(HEVCAnalyzeAnnexBTest, InvalidAnnexBConstructs) {
     HevcStringToAnnexB(test_cases[i].case_string, &buf, nullptr);
     expected.is_keyframe = test_cases[i].is_keyframe;
     EXPECT_PRED2(AnalysesMatch,
-                 HEVC::AnalyzeAnnexB(buf.data(), buf.size(), subsamples),
+                 HEVC::AnalyzeAnnexB(buf, buf.size(), subsamples),
                  expected)
         << "'" << test_cases[i].case_string << "' failed";
   }
diff --git a/media/gpu/av1_decoder_unittest.cc b/media/gpu/av1_decoder_unittest.cc
index a2ebd2a36d22f..c99d033f32e5c 100644
--- a/media/gpu/av1_decoder_unittest.cc
+++ b/media/gpu/av1_decoder_unittest.cc
@@ -247,7 +247,7 @@ std::vector<scoped_refptr<DecoderBuffer>> AV1DecoderTest::ReadIVF(
   IvfParser ivf_parser;
   IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
   EXPECT_EQ(ivf_header.fourcc, /*AV01=*/0x31305641u);
 
@@ -269,7 +269,7 @@ std::vector<scoped_refptr<DecoderBuffer>> AV1DecoderTest::ReadWebm(
   EXPECT_TRUE(base::ReadFileToString(input_file, &webm_data));
 
   InMemoryUrlProtocol protocol(
-      reinterpret_cast<const uint8_t*>(webm_data.data()), webm_data.size(),
+      reinterpret_cast<const uint8_t*>(webm_data), webm_data.size(),
       false);
   FFmpegGlue glue(&protocol);
   LOG_ASSERT(glue.OpenContext());
diff --git a/media/gpu/chromeos/frame_resource.h b/media/gpu/chromeos/frame_resource.h
index 961c9a9b6dfa9..a9180ffb2c7c3 100644
--- a/media/gpu/chromeos/frame_resource.h
+++ b/media/gpu/chromeos/frame_resource.h
@@ -5,6 +5,7 @@
 #ifndef MEDIA_GPU_CHROMEOS_FRAME_RESOURCE_H_
 #define MEDIA_GPU_CHROMEOS_FRAME_RESOURCE_H_
 
+#include "base/containers/span.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/time/time.h"
@@ -70,8 +71,8 @@ class FrameResource : public base::RefCountedThreadSafe<FrameResource> {
 
   // The visible variants return a pointer that is offsetted into the
   // plane buffer specified by visible_rect().origin().
-  virtual const uint8_t* visible_data(size_t plane) const = 0;
-  virtual uint8_t* GetWritableVisibleData(size_t plane) = 0;
+  virtual const base::span<uint8_t> visible_data(size_t plane) const = 0;
+  virtual base::span<uint8_t> GetWritableVisibleData(size_t plane) = 0;
 
   // The number of DmaBufs will be equal or less than the number of planes of
   // the frame. If there are less, this means that the last FD contains the
diff --git a/media/gpu/chromeos/libyuv_image_processor_backend.cc b/media/gpu/chromeos/libyuv_image_processor_backend.cc
index 1e4268aa4b3a0..08daa902da7d7 100644
--- a/media/gpu/chromeos/libyuv_image_processor_backend.cc
+++ b/media/gpu/chromeos/libyuv_image_processor_backend.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -324,22 +326,22 @@ void LibYUVImageProcessorBackend::ProcessFrame(
         for (size_t plane = 0;
              plane < VideoFrame::NumPlanes(crop_intermediate_frame_->format());
              plane++) {
-          const uint8_t* src_row_ptr =
+          base::span<const uint8_t>src_row_ptr =
               crop_intermediate_frame_->visible_data(plane);
-          uint8_t* dst_row_ptr = mapped_frame->GetWritableVisibleData(plane);
+          base::span<uint8_t>dst_row_ptr = mapped_frame->GetWritableVisibleData(plane);
           for (size_t row = 0;
                row < VideoFrame::Rows(
                          plane, crop_intermediate_frame_->format(),
                          crop_intermediate_frame_->visible_rect().height());
                row++) {
-            memcpy(dst_row_ptr, src_row_ptr,
+            memcpy(dst_row_ptr.data(), src_row_ptr.data(),
                    VideoFrame::Columns(
                        plane, crop_intermediate_frame_->format(),
                        crop_intermediate_frame_->visible_rect().width()) *
                        VideoFrame::BytesPerElement(
                            crop_intermediate_frame_->format(), plane));
-            src_row_ptr += crop_intermediate_frame_->row_bytes(plane);
-            dst_row_ptr += mapped_frame->row_bytes(plane);
+            src_row_ptr=src_row_ptr.subspan(crop_intermediate_frame_->row_bytes(plane));
+            dst_row_ptr=dst_row_ptr.subspan(mapped_frame->row_bytes(plane));
           }
         }
       }
@@ -362,40 +364,40 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
   DCHECK_CALLED_ON_VALID_SEQUENCE(backend_sequence_checker_);
 
 #define Y_U_V_DATA(fr)                                                        \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kU),                                \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kU).data(),                                \
       fr->stride(VideoFrame::Plane::kU),                                      \
-      fr->visible_data(VideoFrame::Plane::kV),                                \
+      fr->visible_data(VideoFrame::Plane::kV).data(),                                \
       fr->stride(VideoFrame::Plane::kV)
 
 #define Y_U_V_DATA_W(fr)                                 \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kY),     \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kY).data(),     \
       fr->stride(VideoFrame::Plane::kY),                 \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kU), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kU).data(), \
       fr->stride(VideoFrame::Plane::kU),                 \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kV), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kV).data(), \
       fr->stride(VideoFrame::Plane::kV)
 
 #define Y_V_U_DATA(fr)                                                        \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kV),                                \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kV).data(),                                \
       fr->stride(VideoFrame::Plane::kV),                                      \
-      fr->visible_data(VideoFrame::Plane::kU),                                \
+      fr->visible_data(VideoFrame::Plane::kU).data(),                                \
       fr->stride(VideoFrame::Plane::kU)
 
 #define Y_UV_DATA(fr)                                                         \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kUV),                               \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kUV).data(),                               \
       fr->stride(VideoFrame::Plane::kUV)
 
 #define Y_UV_DATA_W(fr)                                   \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kY),      \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kY).data(),      \
       fr->stride(VideoFrame::Plane::kY),                  \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kUV), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kUV).data(), \
       fr->stride(VideoFrame::Plane::kUV)
 
 #define YUY2_DATA(fr) \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY)
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY)
 
 #define Y_UV_DATA_10BIT(fr)                                                   \
   reinterpret_cast<const uint16_t*>(fr->visible_data(VideoFrame::Plane::kY)), \
@@ -414,7 +416,7 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
 
 #if BUILDFLAG(IS_LINUX)
 #define ARGB_DATA(fr)                                   \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kARGB), \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kARGB).data(), \
       fr->stride(VideoFrame::Plane::kARGB)
 #endif
 
@@ -556,13 +558,13 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
           (input->stride(VideoFrame::Plane::kY) * 5) >> 2;
 
       int libyuv_result = libyuv::MT2TToP010(
-          input->visible_data(VideoFrame::Plane::kY), src_stride_mt2t,
-          input->visible_data(VideoFrame::Plane::kUV), src_stride_mt2t,
+          input->visible_data(VideoFrame::Plane::kY).data(), src_stride_mt2t,
+          input->visible_data(VideoFrame::Plane::kUV).data(), src_stride_mt2t,
           reinterpret_cast<uint16_t*>(
-              output->GetWritableVisibleData(VideoFrame::Plane::kY)),
+              output->GetWritableVisibleData(VideoFrame::Plane::kY).data()),
           output->stride(VideoFrame::Plane::kY) >> 1,
           reinterpret_cast<uint16_t*>(
-              output->GetWritableVisibleData(VideoFrame::Plane::kUV)),
+              output->GetWritableVisibleData(VideoFrame::Plane::kUV).data()),
           output->stride(VideoFrame::Plane::kUV) >> 1,
           output->visible_rect().width(), output->visible_rect().height());
 
diff --git a/media/gpu/chromeos/native_pixmap_frame_resource.cc b/media/gpu/chromeos/native_pixmap_frame_resource.cc
index a85e9f38cd59f..e17939ae1eedb 100644
--- a/media/gpu/chromeos/native_pixmap_frame_resource.cc
+++ b/media/gpu/chromeos/native_pixmap_frame_resource.cc
@@ -7,6 +7,7 @@
 #include <atomic>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/feature_list.h"
 #include "base/functional/callback_helpers.h"
 #include "base/logging.h"
@@ -280,12 +281,12 @@ uint8_t* NativePixmapFrameResource::writable_data(size_t plane) {
   return nullptr;
 }
 
-const uint8_t* NativePixmapFrameResource::visible_data(size_t plane) const {
-  return nullptr;
+const base::span<uint8_t> NativePixmapFrameResource::visible_data(size_t plane) const {
+  return {};
 }
 
-uint8_t* NativePixmapFrameResource::GetWritableVisibleData(size_t plane) {
-  return nullptr;
+base::span<uint8_t> NativePixmapFrameResource::GetWritableVisibleData(size_t plane) {
+  return {};
 }
 
 size_t NativePixmapFrameResource::NumDmabufFds() const {
diff --git a/media/gpu/chromeos/native_pixmap_frame_resource.h b/media/gpu/chromeos/native_pixmap_frame_resource.h
index 9a25c5e69eaee..ae8b5c07269d0 100644
--- a/media/gpu/chromeos/native_pixmap_frame_resource.h
+++ b/media/gpu/chromeos/native_pixmap_frame_resource.h
@@ -7,6 +7,7 @@
 
 #include <optional>
 
+#include "base/containers/span.h"
 #include "base/memory/ref_counted.h"
 #include "base/time/time.h"
 #include "base/types/pass_key.h"
@@ -89,8 +90,8 @@ class NativePixmapFrameResource : public FrameResource {
   bool IsMappable() const override;
   const uint8_t* data(size_t plane) const override;
   uint8_t* writable_data(size_t plane) override;
-  const uint8_t* visible_data(size_t plane) const override;
-  uint8_t* GetWritableVisibleData(size_t plane) override;
+  const base::span<uint8_t> visible_data(size_t plane) const override;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane) override;
   size_t NumDmabufFds() const override;
   int GetDmabufFd(size_t i) const override;
   scoped_refptr<const gfx::NativePixmapDmaBuf> GetNativePixmapDmaBuf()
diff --git a/media/gpu/chromeos/video_frame_resource.cc b/media/gpu/chromeos/video_frame_resource.cc
index 0fac2c3ccaa0a..f49683591e4fa 100644
--- a/media/gpu/chromeos/video_frame_resource.cc
+++ b/media/gpu/chromeos/video_frame_resource.cc
@@ -4,6 +4,7 @@
 
 #include "media/gpu/chromeos/video_frame_resource.h"
 
+#include "base/containers/span.h"
 #include "base/functional/callback_helpers.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/types/pass_key.h"
@@ -49,18 +50,18 @@ bool VideoFrameResource::IsMappable() const {
 }
 
 const uint8_t* VideoFrameResource::data(size_t plane) const {
-  return frame_->data(plane);
+  return frame_->data(plane).data();
 }
 
 uint8_t* VideoFrameResource::writable_data(size_t plane) {
-  return GetMutableVideoFrame()->writable_data(plane);
+  return GetMutableVideoFrame()->writable_data(plane).data();
 }
 
-const uint8_t* VideoFrameResource::visible_data(size_t plane) const {
+const base::span<uint8_t> VideoFrameResource::visible_data(size_t plane) const {
   return frame_->visible_data(plane);
 }
 
-uint8_t* VideoFrameResource::GetWritableVisibleData(size_t plane) {
+base::span<uint8_t> VideoFrameResource::GetWritableVisibleData(size_t plane) {
   return GetMutableVideoFrame()->GetWritableVisibleData(plane);
 }
 
diff --git a/media/gpu/chromeos/video_frame_resource.h b/media/gpu/chromeos/video_frame_resource.h
index fe6e585e41fb2..ff5985b45e21f 100644
--- a/media/gpu/chromeos/video_frame_resource.h
+++ b/media/gpu/chromeos/video_frame_resource.h
@@ -5,6 +5,7 @@
 #ifndef MEDIA_GPU_CHROMEOS_VIDEO_FRAME_RESOURCE_H_
 #define MEDIA_GPU_CHROMEOS_VIDEO_FRAME_RESOURCE_H_
 
+#include "base/containers/span.h"
 #include "base/time/time.h"
 #include "base/types/pass_key.h"
 #include "media/base/video_frame_layout.h"
@@ -34,8 +35,8 @@ class VideoFrameResource : public FrameResource {
   bool IsMappable() const override;
   const uint8_t* data(size_t plane) const override;
   uint8_t* writable_data(size_t plane) override;
-  const uint8_t* visible_data(size_t plane) const override;
-  uint8_t* GetWritableVisibleData(size_t plane) override;
+  const base::span<uint8_t> visible_data(size_t plane) const override;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane) override;
   size_t NumDmabufFds() const override;
   int GetDmabufFd(size_t i) const override;
   scoped_refptr<const gfx::NativePixmapDmaBuf> GetNativePixmapDmaBuf()
diff --git a/media/gpu/h265_decoder.cc b/media/gpu/h265_decoder.cc
index e41961e81ef4a..247ce129e5b71 100644
--- a/media/gpu/h265_decoder.cc
+++ b/media/gpu/h265_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -152,16 +154,16 @@ H265Decoder::~H265Decoder() = default;
   } while (0)
 
 void H265Decoder::SetStream(int32_t id, const DecoderBuffer& decoder_buffer) {
-  const uint8_t* ptr = decoder_buffer.data();
+  base::span<const uint8_t>ptr = decoder_buffer;
   const size_t size = decoder_buffer.size();
   const DecryptConfig* decrypt_config = decoder_buffer.decrypt_config();
 
-  DCHECK(ptr);
+  DCHECK(!ptr.empty());
   DCHECK(size);
-  DVLOG(4) << "New input stream id: " << id << " at: " << (void*)ptr
+  DVLOG(4) << "New input stream id: " << id << " at: " << (void*)ptr.data()
            << " size: " << size;
   stream_id_ = id;
-  current_stream_ = ptr;
+  current_stream_ = ptr.data();
   current_stream_size_ = size;
   current_stream_has_been_changed_ = true;
   if (decrypt_config) {
diff --git a/media/gpu/test/image.cc b/media/gpu/test/image.cc
index 3cb74d5f85659..555e8b08a8a5e 100644
--- a/media/gpu/test/image.cc
+++ b/media/gpu/test/image.cc
@@ -228,7 +228,7 @@ bool Image::IsMetadataLoaded() const {
 }
 
 uint8_t* Image::Data() const {
-  return mapped_file_.data();
+  return mapped_file_.data().data();
 }
 
 size_t Image::DataSize() const {
diff --git a/media/gpu/test/image_quality_metrics.cc b/media/gpu/test/image_quality_metrics.cc
index 6142e89035eff..434f0cebe986b 100644
--- a/media/gpu/test/image_quality_metrics.cc
+++ b/media/gpu/test/image_quality_metrics.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -227,7 +229,7 @@ bool ComputeLogJointDistribution(const VideoFrame& frame,
   // Downsample the RGB values of the plane into 4-bits per channel, and use the
   // downsampled color information to increment the corresponding element of the
   // distribution table.
-  const uint8_t* row_ptr = frame.visible_data(0);
+  base::span<const uint8_t>row_ptr = frame.visible_data(0);
   for (int y = 0; y < frame.visible_rect().height(); y++) {
     for (int x = 0; x < frame.visible_rect().width(); x++) {
       log_joint_distribution[row_ptr[4 * x + 1] >> kJointDistributionBitDepth]
@@ -235,7 +237,7 @@ bool ComputeLogJointDistribution(const VideoFrame& frame,
                             [row_ptr[4 * x + 3] >>
                              kJointDistributionBitDepth] += 1.0;
     }
-    row_ptr += frame.stride(0);
+    row_ptr=row_ptr.subspan(frame.stride(0));
   }
 
   // Normalize the joint distribution so that it sums to 1.0 and then take the
@@ -260,7 +262,7 @@ double ComputeLogProbability(const VideoFrame& frame,
 
   double ret = 0.0;
 
-  const uint8_t* row_ptr = frame.visible_data(0);
+  base::span<const uint8_t>row_ptr = frame.visible_data(0);
   for (int y = 0; y < frame.visible_rect().height(); y++) {
     for (int x = 0; x < frame.visible_rect().width(); x++) {
       ret += log_joint_distribution
@@ -268,7 +270,7 @@ double ComputeLogProbability(const VideoFrame& frame,
           [row_ptr[4 * x + 2] >> kJointDistributionBitDepth]
           [row_ptr[4 * x + 3] >> kJointDistributionBitDepth];
     }
-    row_ptr += frame.stride(0);
+    row_ptr=row_ptr.subspan(frame.stride(0));
   }
 
   return ret;
@@ -294,9 +296,9 @@ size_t CompareFramesWithErrorDiff(const VideoFrame& frame1,
   const size_t num_planes = VideoFrame::NumPlanes(format);
   const gfx::Size& visible_size = frame1.visible_rect().size();
   for (size_t i = 0; i < num_planes; ++i) {
-    const uint8_t* data1 = frame1.visible_data(i);
+    base::span<const uint8_t>data1 = frame1.visible_data(i);
     const int stride1 = frame1.stride(i);
-    const uint8_t* data2 = frame2.visible_data(i);
+    base::span<const uint8_t>data2 = frame2.visible_data(i);
     const int stride2 = frame2.stride(i);
     const size_t rows = VideoFrame::Rows(i, format, visible_size.height());
     const int row_bytes = VideoFrame::RowBytes(i, format, visible_size.width());
diff --git a/media/gpu/test/raw_video.cc b/media/gpu/test/raw_video.cc
index caef3c4f7a307..fd39294b78d7a 100644
--- a/media/gpu/test/raw_video.cc
+++ b/media/gpu/test/raw_video.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -246,8 +248,8 @@ class RawVideo::VP9Decoder {
     if (layout_.format() == PIXEL_FORMAT_NV12) {
       uint8_t* nv12_frame = buffer.data();
       int ret = libyuv::I420ToNV12(
-          i420_frame.data(0), i420_frame.stride(0), i420_frame.data(1),
-          i420_frame.stride(1), i420_frame.data(2), i420_frame.stride(2),
+          i420_frame.data(0).data(), i420_frame.stride(0), i420_frame.data(1).data(),
+          i420_frame.stride(1), i420_frame.data(2).data(), i420_frame.stride(2),
           nv12_frame + layout_.planes()[0].offset, layout_.planes()[0].stride,
           nv12_frame + layout_.planes()[1].offset, layout_.planes()[1].stride,
           layout_.coded_size().width(), layout_.coded_size().height());
@@ -265,7 +267,7 @@ class RawVideo::VP9Decoder {
         // VideoFrame::PlaneSize() cannot be used because it computes the
         // plane size with resolutions aligned by two while our test code
         // works with a succinct buffer size.
-        const uint8_t* src = i420_frame.data(plane);
+        const uint8_t* src = i420_frame.data(plane).data();
         libyuv::CopyPlane(src, stride, dst_plane, row_bytes, row_bytes, rows);
         dst_plane += (rows * row_bytes);
       }
@@ -302,13 +304,13 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
     LOG(ERROR) << "Failed to read file: " << vp9_webm_data_file_path;
     return nullptr;
   }
-  base::span<const uint8_t> vp9_webm_data(vp9_webm_data_mmap_file.data(),
+  base::span<const uint8_t> vp9_webm_data(vp9_webm_data_mmap_file.data().data(),
                                           vp9_webm_data_mmap_file.length());
 
   InitializeMediaLibrary();
 
   // Initialize ffmpeg with the compressed video data.
-  InMemoryUrlProtocol protocol(vp9_webm_data.data(), vp9_webm_data.size(),
+  InMemoryUrlProtocol protocol(vp9_webm_data, vp9_webm_data.size(),
                                /*streaming=*/false);
   FFmpegGlue glue(&protocol);
   LOG_ASSERT(glue.OpenContext()) << "Failed to open AVFormatContext";
@@ -332,7 +334,7 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
   }
 
   auto vp9_data_mmap_file = CreateMemoryMappedFile(vp9_webm_data.size());
-  uint8_t* const vp9_data = vp9_data_mmap_file->data();
+  const base::span<uint8_t>vp9_data = vp9_data_mmap_file->data();
   size_t vp9_data_size = 0;
   auto packet = ScopedAVPacket::Allocate();
   size_t num_packets = 0;
@@ -345,9 +347,9 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
         (*vp9_stream_index)) {
       LOG_ASSERT(vp9_data_size + packet->size <= vp9_data_mmap_file->length())
           << "The vp9 data size must be less than webm file size";
-      std::memcpy(vp9_data + vp9_data_size, packet->data, packet->size);
+      std::memcpy(vp9_data .subspan( vp9_data_size).data(), packet->data, packet->size);
       vp9_data_chunks[num_packets] = base::span<const uint8_t>(
-          vp9_data + vp9_data_size, base::checked_cast<size_t>(packet->size));
+          vp9_data .subspan( vp9_data_size).data(), base::checked_cast<size_t>(packet->size));
       vp9_data_size += packet->size;
 
       Vp9FrameHeader header;
@@ -563,7 +565,7 @@ std::unique_ptr<RawVideo> RawVideo::Create(
         CreateMemoryMappedFile(video_frame_size * metadata.num_frames);
     for (size_t i = 0; i < metadata.num_frames; ++i) {
       auto buffer = vp9_decoder->DecodeFrame(i);
-      memcpy(memory_mapped_file->data() + i * video_frame_size, buffer.data(),
+      memcpy(memory_mapped_file->data() .subspan( i * video_frame_size).data(), buffer.data(),
              buffer.size());
     }
   } else {
@@ -598,15 +600,15 @@ std::unique_ptr<RawVideo> RawVideo::CreateNV12Video() const {
   LOG_ASSERT(new_memory_mapped_file) << "Failed creating memory mapped file";
   for (size_t i = 0; i < NumFrames(); ++i) {
     const FrameData i420_frame = GetFrame(i);
-    uint8_t* const nv12_frame =
-        new_memory_mapped_file->data() + i * video_frame_size_;
+    const base::span<uint8_t>nv12_frame =
+        new_memory_mapped_file->data() .subspan( i * video_frame_size_);
     int ret =
         libyuv::I420ToNV12(i420_frame.plane_addrs[0], i420_frame.strides[0],
                            i420_frame.plane_addrs[1], i420_frame.strides[1],
                            i420_frame.plane_addrs[2], i420_frame.strides[2],
-                           nv12_frame + nv12_layout->planes()[0].offset,
+                           nv12_frame .subspan( nv12_layout->planes()[0].offset).data(),
                            nv12_layout->planes()[0].stride,
-                           nv12_frame + nv12_layout->planes()[1].offset,
+                           nv12_frame .subspan( nv12_layout->planes()[1].offset).data(),
                            nv12_layout->planes()[1].stride,
                            Resolution().width(), Resolution().height());
     LOG_ASSERT(ret == 0) << "Failed converting from I420 to NV12";
@@ -655,12 +657,12 @@ std::unique_ptr<RawVideo> RawVideo::CreateExpandedVideo(
       CreateMemoryMappedFile(new_video_frame_size * NumFrames());
   CHECK(new_memory_mapped_file);
   for (size_t i = 0; i < NumFrames(); i++) {
-    uint8_t* const dst_frame =
-        new_memory_mapped_file->data() + (i * new_video_frame_size);
+    const base::span<uint8_t>dst_frame =
+        new_memory_mapped_file->data() .subspan( (i * new_video_frame_size));
     uint8_t* const dst_y_plane_visible_data =
-        dst_frame + dst_planes[0].offset + dst_y_visible_offset;
+        dst_frame .subspan( dst_planes[0].offset + dst_y_visible_offset).data();
     uint8_t* const dst_uv_plane_visible_data =
-        dst_frame + dst_planes[1].offset + dst_uv_visible_offset;
+        dst_frame .subspan( dst_planes[1].offset + dst_uv_visible_offset).data();
     FrameData src_frame = GetFrame(i);
     libyuv::NV12Copy(src_frame.plane_addrs[0], src_frame.strides[0],
                      src_frame.plane_addrs[1], src_frame.strides[1],
@@ -679,12 +681,12 @@ std::unique_ptr<RawVideo> RawVideo::CreateExpandedVideo(
 RawVideo::FrameData RawVideo::GetFrame(size_t frame_index) const {
   CHECK_LT(frame_index, NumFrames());
   std::vector<uint8_t> buffer;
-  const uint8_t* frame_addr;
+  base::span<const uint8_t>frame_addr;
   if (vp9_decoder_) {
     buffer = vp9_decoder_->DecodeFrame(frame_index);
-    frame_addr = buffer.data();
+    frame_addr = buffer;
   } else {
-    frame_addr = memory_mapped_file_->data() + video_frame_size_ * frame_index;
+    frame_addr = memory_mapped_file_->data() .subspan( video_frame_size_ * frame_index);
   }
 
   const auto& plane_layouts = FrameLayout().planes();
@@ -692,7 +694,7 @@ RawVideo::FrameData RawVideo::GetFrame(size_t frame_index) const {
   std::vector<const uint8_t*> plane_addrs(num_planes);
   std::vector<size_t> strides(num_planes);
   for (size_t i = 0; i < num_planes; ++i) {
-    plane_addrs[i] = frame_addr + plane_layouts[i].offset;
+    plane_addrs[i] = frame_addr .subspan( plane_layouts[i].offset);
     strides[i] = plane_layouts[i].stride;
   }
   return RawVideo::FrameData(plane_addrs, strides, std::move(buffer));
diff --git a/media/gpu/test/video_bitstream.cc b/media/gpu/test/video_bitstream.cc
index 35d3c17416002..606c806df6ee4 100644
--- a/media/gpu/test/video_bitstream.cc
+++ b/media/gpu/test/video_bitstream.cc
@@ -204,7 +204,7 @@ std::unique_ptr<VideoBitstream> VideoBitstream::Create(
 
 base::span<const uint8_t> VideoBitstream::Data() const {
   CHECK(memory_mapped_file_ && memory_mapped_file_->IsValid());
-  return base::span<const uint8_t>(memory_mapped_file_->data(),
+  return base::span<const uint8_t>(memory_mapped_file_->data().data(),
                                    memory_mapped_file_->length());
 }
 // static
diff --git a/media/gpu/test/video_frame_file_writer.cc b/media/gpu/test/video_frame_file_writer.cc
index 27455b1224fc3..ead6ce3896221 100644
--- a/media/gpu/test/video_frame_file_writer.cc
+++ b/media/gpu/test/video_frame_file_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -235,7 +237,7 @@ void VideoFrameFileWriter::WriteVideoFramePNG(
 
   // Convert the ARGB frame to PNG.
   std::optional<std::vector<uint8_t>> png_output = gfx::PNGCodec::Encode(
-      argb_out_frame->visible_data(VideoFrame::Plane::kARGB),
+      argb_out_frame->visible_data(VideoFrame::Plane::kARGB).data(),
       gfx::PNGCodec::FORMAT_BGRA, argb_out_frame->visible_rect().size(),
       argb_out_frame->stride(VideoFrame::Plane::kARGB),
       /*discard_transparency=*/true, std::vector<gfx::PNGCodec::Comment>());
@@ -288,7 +290,7 @@ void VideoFrameFileWriter::WriteVideoFrameYUV(
   const VideoPixelFormat pixel_format = out_frame->format();
   const size_t num_planes = VideoFrame::NumPlanes(pixel_format);
   for (size_t i = 0; i < num_planes; i++) {
-    const uint8_t* data = out_frame->visible_data(i);
+    base::span<const uint8_t>data = out_frame->visible_data(i);
     const int stride = out_frame->stride(i);
     const size_t rows =
         VideoFrame::Rows(i, pixel_format, visible_size.height());
@@ -297,7 +299,7 @@ void VideoFrameFileWriter::WriteVideoFrameYUV(
     ASSERT_TRUE(stride > 0);
     for (size_t row = 0; row < rows; ++row) {
       if (yuv_file.WriteAtCurrentPos(
-              reinterpret_cast<const char*>(data + (stride * row)),
+              reinterpret_cast<const char*>(data .subspan( (stride * row).data())),
               row_bytes) != row_bytes) {
         LOG(ERROR) << "Failed to write plane #" << i << " to file: "
                    << base::File::ErrorToString(base::File::GetLastFileError());
diff --git a/media/gpu/test/video_frame_helpers.cc b/media/gpu/test/video_frame_helpers.cc
index 9eb688f8d47ee..6b62e45429b86 100644
--- a/media/gpu/test/video_frame_helpers.cc
+++ b/media/gpu/test/video_frame_helpers.cc
@@ -56,39 +56,39 @@ bool ConvertVideoFrameToI420(const VideoFrame* src_frame,
   const int width = visible_rect.width();
   const int height = visible_rect.height();
   uint8_t* const dst_y =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data();
   uint8_t* const dst_u =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU).data();
   uint8_t* const dst_v =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV).data();
   const int dst_stride_y = dst_frame->stride(VideoFrame::Plane::kY);
   const int dst_stride_u = dst_frame->stride(VideoFrame::Plane::kU);
   const int dst_stride_v = dst_frame->stride(VideoFrame::Plane::kV);
 
   switch (src_frame->format()) {
     case PIXEL_FORMAT_I420:
-      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                               src_frame->stride(VideoFrame::Plane::kY),
-                              src_frame->visible_data(VideoFrame::Plane::kU),
+                              src_frame->visible_data(VideoFrame::Plane::kU).data(),
                               src_frame->stride(VideoFrame::Plane::kU),
-                              src_frame->visible_data(VideoFrame::Plane::kV),
+                              src_frame->visible_data(VideoFrame::Plane::kV).data(),
                               src_frame->stride(VideoFrame::Plane::kV), dst_y,
                               dst_stride_y, dst_u, dst_stride_u, dst_v,
                               dst_stride_v, width, height) == 0;
     case PIXEL_FORMAT_NV12:
-      return libyuv::NV12ToI420(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::NV12ToI420(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kUV),
+                                src_frame->visible_data(VideoFrame::Plane::kUV).data(),
                                 src_frame->stride(VideoFrame::Plane::kUV),
                                 dst_y, dst_stride_y, dst_u, dst_stride_u, dst_v,
                                 dst_stride_v, width, height) == 0;
     case PIXEL_FORMAT_YV12:
       // Swap U and V planes.
-      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                               src_frame->stride(VideoFrame::Plane::kY),
-                              src_frame->visible_data(VideoFrame::Plane::kV),
+                              src_frame->visible_data(VideoFrame::Plane::kV).data(),
                               src_frame->stride(VideoFrame::Plane::kV),
-                              src_frame->visible_data(VideoFrame::Plane::kU),
+                              src_frame->visible_data(VideoFrame::Plane::kU).data(),
                               src_frame->stride(VideoFrame::Plane::kU), dst_y,
                               dst_stride_y, dst_u, dst_stride_u, dst_v,
                               dst_stride_v, width, height) == 0;
@@ -122,19 +122,19 @@ bool ConvertVideoFrameToYUV420P10(const VideoFrame* src_frame,
   // stride needs to be converted from bytes to pixels by dividing by 2.
   const int conversion_result = libyuv::P010ToI010(
       reinterpret_cast<const uint16_t*>(
-          src_frame->visible_data(VideoFrame::Plane::kY)),
+          src_frame->visible_data(VideoFrame::Plane::kY).data()),
       src_frame->stride(VideoFrame::Plane::kY) >> 1,
       reinterpret_cast<const uint16_t*>(
-          src_frame->visible_data(VideoFrame::Plane::kUV)),
+          src_frame->visible_data(VideoFrame::Plane::kUV).data()),
       src_frame->stride(VideoFrame::Plane::kUV) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data()),
       dst_frame->stride(VideoFrame::Plane::kY) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU).data()),
       dst_frame->stride(VideoFrame::Plane::kU) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV).data()),
       dst_frame->stride(VideoFrame::Plane::kV) >> 1,
       src_frame->visible_rect().width(), src_frame->visible_rect().height());
 
@@ -152,33 +152,33 @@ bool ConvertVideoFrameToARGB(const VideoFrame* src_frame,
   const int width = visible_rect.width();
   const int height = visible_rect.height();
   uint8_t* const dst_argb =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kARGB).data();
   const int dst_stride = dst_frame->stride(VideoFrame::Plane::kARGB);
 
   switch (src_frame->format()) {
     case PIXEL_FORMAT_I420:
       // Note that we use J420ToARGB instead of I420ToARGB so that the
       // kYuvJPEGConstants YUV-to-RGB conversion matrix is used.
-      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kU),
+                                src_frame->visible_data(VideoFrame::Plane::kU).data(),
                                 src_frame->stride(VideoFrame::Plane::kU),
-                                src_frame->visible_data(VideoFrame::Plane::kV),
+                                src_frame->visible_data(VideoFrame::Plane::kV).data(),
                                 src_frame->stride(VideoFrame::Plane::kV),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_NV12:
-      return libyuv::NV12ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::NV12ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kUV),
+                                src_frame->visible_data(VideoFrame::Plane::kUV).data(),
                                 src_frame->stride(VideoFrame::Plane::kUV),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_YV12:
       // Same as I420, but U and V planes are swapped.
-      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kV),
+                                src_frame->visible_data(VideoFrame::Plane::kV).data(),
                                 src_frame->stride(VideoFrame::Plane::kV),
-                                src_frame->visible_data(VideoFrame::Plane::kU),
+                                src_frame->visible_data(VideoFrame::Plane::kU).data(),
                                 src_frame->stride(VideoFrame::Plane::kU),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_P010LE: {
@@ -196,13 +196,13 @@ bool ConvertVideoFrameToARGB(const VideoFrame* src_frame,
 
       return libyuv::I010ToARGB(
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kY)),
+                     i010_frame->visible_data(VideoFrame::Plane::kY).data()),
                  i010_frame->stride(VideoFrame::Plane::kY) >> 1,
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kU)),
+                     i010_frame->visible_data(VideoFrame::Plane::kU).data()),
                  i010_frame->stride(VideoFrame::Plane::kU) >> 1,
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kV)),
+                     i010_frame->visible_data(VideoFrame::Plane::kV).data()),
                  i010_frame->stride(VideoFrame::Plane::kV) >> 1, dst_argb,
                  dst_stride, width, height) == 0;
     }
@@ -248,8 +248,8 @@ bool CopyVideoFrame(const VideoFrame* src_frame,
     gfx::Size plane_size =
         VideoFrame::PlaneSize(dst_frame->format(), i, dst_frame->coded_size());
     libyuv::CopyPlane(
-        src_frame->data(i), src_frame->layout().planes()[i].stride,
-        dst_frame->writable_data(i), dst_frame->layout().planes()[i].stride,
+        src_frame->data(i).data(), src_frame->layout().planes()[i].stride,
+        dst_frame->writable_data(i).data(), dst_frame->layout().planes()[i].stride,
         plane_size.width(), plane_size.height());
   }
   return true;
@@ -308,14 +308,14 @@ scoped_refptr<VideoFrame> ScaleVideoFrame(const VideoFrame* src_frame,
       PIXEL_FORMAT_NV12, dst_resolution, gfx::Rect(dst_resolution),
       dst_resolution, src_frame->timestamp());
   const int fail_scaling = libyuv::NV12Scale(
-      src_frame->visible_data(VideoFrame::Plane::kY),
+      src_frame->visible_data(VideoFrame::Plane::kY).data(),
       src_frame->stride(VideoFrame::Plane::kY),
-      src_frame->visible_data(VideoFrame::Plane::kUV),
+      src_frame->visible_data(VideoFrame::Plane::kUV).data(),
       src_frame->stride(VideoFrame::Plane::kUV),
       src_frame->visible_rect().width(), src_frame->visible_rect().height(),
-      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kY),
+      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data(),
       scaled_frame->stride(VideoFrame::Plane::kY),
-      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kUV),
+      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
       scaled_frame->stride(VideoFrame::Plane::kUV), dst_resolution.width(),
       dst_resolution.height(), libyuv::FilterMode::kFilterBilinear);
   if (fail_scaling) {
diff --git a/media/gpu/test/video_frame_validator.cc b/media/gpu/test/video_frame_validator.cc
index 886e541b48ed3..8de3708e4e885 100644
--- a/media/gpu/test/video_frame_validator.cc
+++ b/media/gpu/test/video_frame_validator.cc
@@ -354,7 +354,7 @@ std::string MD5VideoFrameValidator::ComputeMD5FromVideoFrame(
     const size_t stride = video_frame.stride(i);
     for (int row = 0; row < visible_rows; ++row) {
       base::MD5Update(&context, base::span<const uint8_t>(
-                                    video_frame.data(i) + (stride * row),
+                                    video_frame.data(i) .subspan( (stride * row).data()),
                                     visible_row_bytes));
     }
   }
diff --git a/media/gpu/test/video_test_helpers.cc b/media/gpu/test/video_test_helpers.cc
index 61ec076fb95a1..a18467d00709c 100644
--- a/media/gpu/test/video_test_helpers.cc
+++ b/media/gpu/test/video_test_helpers.cc
@@ -284,7 +284,7 @@ EncodedDataHelperH265::EncodedDataHelperH265(base::span<const uint8_t> stream,
                                              VideoCodec codec)
     : EncodedDataHelper(std::move(stream), codec),
       h265_parser_(std::make_unique<H265Parser>()) {
-  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_.data()),
+  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_),
                           data_.size());
 }
 
@@ -437,7 +437,7 @@ bool EncodedDataHelperH265::ReachEndOfStream() const {
 
 void EncodedDataHelperH265::Rewind() {
   h265_parser_->Reset();
-  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_.data()),
+  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_),
                           data_.size());
   previous_nalus_.clear();
   EncodedDataHelper::Rewind();
@@ -734,10 +734,10 @@ scoped_refptr<VideoFrame> AlignedDataHelper::CreateVideoFrameFromVideoFrameData(
       return nullptr;
     }
     base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();
-    uint8_t* buf = const_cast<uint8_t*>(mapping.GetMemoryAs<uint8_t>());
+    base::span<uint8_t>buf = const_cast<uint8_t*>(mapping.GetMemoryAs<uint8_t>());
     std::array<uint8_t*, 3> data = {};
     for (size_t i = 0; i < layout_->planes().size(); i++)
-      data[i] = buf + layout_->planes()[i].offset;
+      data[i] = buf .subspan( layout_->planes()[i].offset);
 
     auto frame = media::VideoFrame::WrapExternalYuvDataWithLayout(
         *layout_, visible_rect_, natural_size_, data[0], data[1], data[2],
@@ -771,7 +771,7 @@ AlignedDataHelper::VideoFrameData AlignedDataHelper::CreateVideoFrameData(
     for (size_t i = 0; i < src_layout.planes().size(); i++) {
       libyuv::CopyPlane(
           src_frame.plane_addrs[i], src_frame.strides[i],
-          memory_frame->writable_data(i), memory_frame->stride(i),
+          memory_frame->writable_data(i).data(), memory_frame->stride(i),
           VideoFrame::RowBytes(i, pixel_format, resolution.width()),
           VideoFrame::Rows(i, pixel_format, resolution.height()));
     }
diff --git a/media/gpu/vaapi/test/decode.cc b/media/gpu/vaapi/test/decode.cc
index 3903447ce3f13..a0aa0595944ec 100644
--- a/media/gpu/vaapi/test/decode.cc
+++ b/media/gpu/vaapi/test/decode.cc
@@ -10,6 +10,7 @@
 #include <sstream>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/command_line.h"
 #include "base/files/memory_mapped_file.h"
 #include "base/logging.h"
@@ -138,14 +139,14 @@ std::unique_ptr<VideoDecoder> CreateDecoder(
     const std::string& codec,
     const VaapiDevice& va_device,
     SharedVASurface::FetchPolicy fetch_policy,
-    const uint8_t* stream_data,
+    base::span<const uint8_t>stream_data,
     size_t stream_len) {
   if (codec == "H264")
-    return std::make_unique<H264Decoder>(stream_data, stream_len, va_device,
+    return std::make_unique<H264Decoder>(stream_data.data(), stream_len, va_device,
                                          fetch_policy);
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
   if (codec == "H265")
-    return std::make_unique<H265Decoder>(stream_data, stream_len, va_device,
+    return std::make_unique<H265Decoder>(stream_data.data(), stream_len, va_device,
                                          fetch_policy);
 #endif
 
diff --git a/media/gpu/vaapi/test/h265_decoder.cc b/media/gpu/vaapi/test/h265_decoder.cc
index cba76a2dc1fcf..7569442e6d6a1 100644
--- a/media/gpu/vaapi/test/h265_decoder.cc
+++ b/media/gpu/vaapi/test/h265_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -85,7 +87,7 @@ bool IsValidBitDepth(uint8_t bit_depth, VideoCodecProfile profile) {
 
 namespace vaapi_test {
 
-H265Decoder::H265Decoder(const uint8_t* stream_data,
+H265Decoder::H265Decoder(base::span<const uint8_t>stream_data,
                          size_t stream_len,
                          const VaapiDevice& va_device,
                          SharedVASurface::FetchPolicy fetch_policy)
diff --git a/media/gpu/vaapi/test/h265_decoder.h b/media/gpu/vaapi/test/h265_decoder.h
index d75b91ebcfc8b..1c5f94dbdaa3d 100644
--- a/media/gpu/vaapi/test/h265_decoder.h
+++ b/media/gpu/vaapi/test/h265_decoder.h
@@ -36,7 +36,7 @@ namespace media::vaapi_test {
 // the test binary.
 class H265Decoder : public VideoDecoder {
  public:
-  H265Decoder(const uint8_t* stream_data,
+  H265Decoder(base::span<const uint8_t>stream_data,
               size_t stream_len,
               const VaapiDevice& va_device,
               SharedVASurface::FetchPolicy fetch_policy);
diff --git a/media/gpu/vaapi/vaapi_wrapper.cc b/media/gpu/vaapi/vaapi_wrapper.cc
index ed93f523c1062..d068b0d9273f2 100644
--- a/media/gpu/vaapi/vaapi_wrapper.cc
+++ b/media/gpu/vaapi/vaapi_wrapper.cc
@@ -2893,11 +2893,11 @@ bool VaapiWrapper::UploadVideoFrameToSurface(const VideoFrame& frame,
     }
 
     if (frame.format() == PIXEL_FORMAT_I420) {
-      ret = libyuv::I420ToNV12(frame.data(VideoFrame::Plane::kY),
+      ret = libyuv::I420ToNV12(frame.data(VideoFrame::Plane::kY).data(),
                                frame.stride(VideoFrame::Plane::kY),
-                               frame.data(VideoFrame::Plane::kU),
+                               frame.data(VideoFrame::Plane::kU).data(),
                                frame.stride(VideoFrame::Plane::kU),
-                               frame.data(VideoFrame::Plane::kV),
+                               frame.data(VideoFrame::Plane::kV).data(),
                                frame.stride(VideoFrame::Plane::kV),
                                image_ptr + image.offsets[0], image.pitches[0],
                                image_ptr + image.offsets[1], image.pitches[1],
diff --git a/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc b/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
index 1a5ddd27fcf05..7bba16d3b2816 100644
--- a/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
+++ b/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
@@ -281,7 +281,7 @@ TEST_F(MojoVideoEncodeAcceleratorTest, EncodeOneFrame) {
     ASSERT_TRUE(shmem.IsValid());
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInputVisibleSize, gfx::Rect(kInputVisibleSize),
-        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory()),
+        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory().data()),
         shmem.mapping.size(), base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
diff --git a/media/mojo/services/mojo_cdm_allocator_unittest.cc b/media/mojo/services/mojo_cdm_allocator_unittest.cc
index a25a84e756ee8..2c7b3c4c7dd5a 100644
--- a/media/mojo/services/mojo_cdm_allocator_unittest.cc
+++ b/media/mojo/services/mojo_cdm_allocator_unittest.cc
@@ -72,7 +72,7 @@ TEST_F(MojoCdmAllocatorTest, ReuseCdmBuffer) {
     // Create a mapping and write some test data.
     auto& mapping = GetRegion(buffer).mapping;
     // Note: deliberately using sizeof() to include the null terminator.
-    memcpy(mapping.memory(), kTestData, sizeof(kTestData));
+    memcpy(mapping.memory().data(), kTestData, sizeof(kTestData));
   }
   buffer->Destroy();
 
diff --git a/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc b/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
index b93e7b1353c50..06a554603a17a 100644
--- a/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
+++ b/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
@@ -277,7 +277,7 @@ TEST_F(MojoVideoEncodeAcceleratorIntegrationTest, EncodeOneFrame) {
     ASSERT_TRUE(shmem.IsValid());
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInputVisibleSize, gfx::Rect(kInputVisibleSize),
-        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory()),
+        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory().data()),
         shmem.mapping.size(), base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
@@ -322,7 +322,7 @@ TEST_F(MojoVideoEncodeAcceleratorIntegrationTest,
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInvalidInputVisibleSize,
         gfx::Rect(kInvalidInputVisibleSize), kInvalidInputVisibleSize,
-        static_cast<uint8_t*>(shmem.mapping.memory()), shmem.mapping.size(),
+        static_cast<uint8_t*>(shmem.mapping.memory().data()), shmem.mapping.size(),
         base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
diff --git a/media/parsers/h264_parser_unittest.cc b/media/parsers/h264_parser_unittest.cc
index 1926f90cccc41..4823199120967 100644
--- a/media/parsers/h264_parser_unittest.cc
+++ b/media/parsers/h264_parser_unittest.cc
@@ -117,7 +117,7 @@ TEST(H264ParserTest, StreamFileParsing) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   H264Parser parser;
-  parser.SetStream(stream.data(), stream.length());
+  parser.SetStream(stream.data().data(), stream.length());
 
   // Parse until the end of stream/unsupported stream/error in stream is found.
   size_t num_parsed_nalus = 0;
@@ -171,7 +171,7 @@ TEST(H264ParserTest, ParseNALUsFromStreamFile) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   std::vector<H264NALU> nalus;
-  ASSERT_TRUE(H264Parser::ParseNALUs(stream.data(), stream.length(), &nalus));
+  ASSERT_TRUE(H264Parser::ParseNALUs(stream.data().data(), stream.length(), &nalus));
   ASSERT_EQ(kTestFileNALUnits, nalus.size());
 }
 
diff --git a/media/parsers/h265_nalu_parser.cc b/media/parsers/h265_nalu_parser.cc
index 6abd7cbd62298..33a4ee55d1ed1 100644
--- a/media/parsers/h265_nalu_parser.cc
+++ b/media/parsers/h265_nalu_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -48,22 +50,22 @@ H265NaluParser::H265NaluParser() {
 H265NaluParser::~H265NaluParser() {}
 
 void H265NaluParser::Reset() {
-  stream_ = nullptr;
+  stream_ = {};
   bytes_left_ = 0;
   encrypted_ranges_.clear();
   previous_nalu_range_.clear();
 }
 
-void H265NaluParser::SetStream(const uint8_t* stream, off_t stream_size) {
+void H265NaluParser::SetStream(base::span<const uint8_t>stream, off_t stream_size) {
   std::vector<SubsampleEntry> subsamples;
   SetEncryptedStream(stream, stream_size, subsamples);
 }
 
 void H265NaluParser::SetEncryptedStream(
-    const uint8_t* stream,
+    base::span<const uint8_t>stream,
     off_t stream_size,
     const std::vector<SubsampleEntry>& subsamples) {
-  CHECK(stream);
+  CHECK(!stream.empty());
   DCHECK_GT(stream_size, 0);
 
   stream_ = stream;
@@ -71,8 +73,8 @@ void H265NaluParser::SetEncryptedStream(
   previous_nalu_range_.clear();
 
   encrypted_ranges_.clear();
-  const uint8_t* start = stream;
-  const uint8_t* stream_end = stream_ + base::checked_cast<size_t>(bytes_left_);
+  const uint8_t* start = stream.data();
+  const uint8_t* stream_end = stream_ .subspan( base::checked_cast<size_t>(bytes_left_)).data();
   for (size_t i = 0; i < subsamples.size() && start < stream_end; ++i) {
     start += subsamples[i].clear_bytes;
 
@@ -89,18 +91,18 @@ bool H265NaluParser::LocateNALU(off_t* nalu_size, off_t* start_code_size) {
   off_t annexb_start_code_size = 0;
 
   if (!H264Parser::FindStartCodeInClearRanges(
-          stream_, bytes_left_, encrypted_ranges_, &nalu_start_off,
+          stream_.data(), bytes_left_, encrypted_ranges_, &nalu_start_off,
           &annexb_start_code_size)) {
     DVLOG(4) << "Could not find start code, end of stream?";
     return false;
   }
 
   // Move the stream to the beginning of the NALU (pointing at the start code).
-  stream_ += base::checked_cast<size_t>(nalu_start_off);
+  stream_=stream_.subspan(base::checked_cast<size_t>(nalu_start_off));
   bytes_left_ -= nalu_start_off;
 
   const uint8_t* nalu_data =
-      stream_ + base::checked_cast<size_t>(annexb_start_code_size);
+      stream_ .subspan( base::checked_cast<size_t>(annexb_start_code_size)).data();
   off_t max_nalu_data_size = bytes_left_ - annexb_start_code_size;
   if (max_nalu_data_size <= 0) {
     DVLOG(3) << "End of stream";
@@ -135,7 +137,7 @@ H265NaluParser::Result H265NaluParser::AdvanceToNextNALU(H265NALU* nalu) {
   }
 
   DCHECK(nalu);
-  nalu->data = (stream_ + base::checked_cast<size_t>(start_code_size)).get();
+  nalu->data = (stream_ .subspan( base::checked_cast<size_t>(start_code_size))).get();
   nalu->size = nalu_size_with_start_code - start_code_size;
   DVLOG(4) << "NALU found: size=" << nalu_size_with_start_code;
 
@@ -147,7 +149,7 @@ H265NaluParser::Result H265NaluParser::AdvanceToNextNALU(H265NALU* nalu) {
   // is called, we will effectively be skipping it;
   // other parsing functions will use the position saved
   // in bit reader for parsing, so we don't have to remember it here.
-  stream_ += base::checked_cast<size_t>(nalu_size_with_start_code);
+  stream_=stream_.subspan(base::checked_cast<size_t>(nalu_size_with_start_code));
   bytes_left_ -= nalu_size_with_start_code;
 
   // Read NALU header, skip the forbidden_zero_bit, but check for it.
diff --git a/media/parsers/h265_nalu_parser.h b/media/parsers/h265_nalu_parser.h
index f3f65367e9443..332e23a3a1a87 100644
--- a/media/parsers/h265_nalu_parser.h
+++ b/media/parsers/h265_nalu_parser.h
@@ -13,6 +13,8 @@
 
 #include <vector>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "media/base/media_export.h"
 #include "media/base/ranges.h"
@@ -130,8 +132,8 @@ class MEDIA_EXPORT H265NaluParser {
   // |stream| owned by caller.
   // |subsamples| contains information about what parts of |stream| are
   // encrypted.
-  void SetStream(const uint8_t* stream, off_t stream_size);
-  void SetEncryptedStream(const uint8_t* stream,
+  void SetStream(base::span<const uint8_t>stream, off_t stream_size);
+  void SetEncryptedStream(base::span<const uint8_t>stream,
                           off_t stream_size,
                           const std::vector<SubsampleEntry>& subsamples);
 
@@ -163,7 +165,7 @@ class MEDIA_EXPORT H265NaluParser {
   bool LocateNALU(off_t* nalu_size, off_t* start_code_size);
 
   // Pointer to the current NALU in the stream.
-  raw_ptr<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> stream_;
+  base::raw_span<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> stream_;
 
   // Bytes left in the stream after the current NALU.
   off_t bytes_left_;
diff --git a/media/parsers/ivf_parser.cc b/media/parsers/ivf_parser.cc
index 22cc1b9f4ee45..5d5fb212af206 100644
--- a/media/parsers/ivf_parser.cc
+++ b/media/parsers/ivf_parser.cc
@@ -19,15 +19,15 @@
 
 namespace media {
 
-IvfParser::IvfParser() : ptr_(nullptr), end_(nullptr) {}
+IvfParser::IvfParser() : ptr_({}), end_(nullptr) {}
 
-bool IvfParser::Initialize(const uint8_t* stream,
+bool IvfParser::Initialize(base::span<const uint8_t>stream,
                            size_t size,
                            IvfFileHeader* file_header) {
-  DCHECK(stream);
+  DCHECK(!stream.empty());
   DCHECK(file_header);
   ptr_ = stream;
-  end_ = stream + size;
+  end_ = stream .subspan( size).data();
   CHECK_GE(end_, ptr_);
 
   if (size < sizeof(IvfFileHeader)) {
@@ -38,7 +38,7 @@ bool IvfParser::Initialize(const uint8_t* stream,
   auto input =
       // TODO(crbug.com/40284755): Initialize() should receive a span, not a
       // pointer. IvfParser should hold a span, not a pointer.
-      UNSAFE_TODO(base::span(ptr_.get(), end_.get()));
+      UNSAFE_TODO(base::span(ptr_.data(), end_.get()));
   auto [in_header, in_rem] = input.split_at<sizeof(IvfFileHeader)>();
 
   // The stream is little-endian encoded, so we can just copy it into place.
@@ -57,14 +57,14 @@ bool IvfParser::Initialize(const uint8_t* stream,
   }
 
   // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-  ptr_ = in_rem.data();
+  ptr_ = in_rem;
 
   return true;
 }
 
 bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
                                const uint8_t** payload) {
-  DCHECK(ptr_);
+  DCHECK(!ptr_.empty());
   DCHECK(payload);
   CHECK_GE(end_, ptr_);
 
@@ -75,14 +75,14 @@ bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
 
   auto input =
       // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-      UNSAFE_TODO(base::span(ptr_.get(), end_.get()));
+      UNSAFE_TODO(base::span(ptr_.data(), end_.get()));
   auto [in_header, in_rem] = input.split_at<sizeof(IvfFrameHeader)>();
 
   // The stream is little-endian encoded, so we can just copy it into place.
   base::byte_span_from_ref(*frame_header).copy_from(in_header);
 
   // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-  ptr_ = in_rem.data();
+  ptr_ = in_rem;
 
   if (base::checked_cast<uint32_t>(end_ - ptr_) < frame_header->frame_size) {
     DLOG(ERROR) << "Not enough frame data";
@@ -90,7 +90,7 @@ bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
   }
 
   *payload = ptr_;
-  ptr_ += frame_header->frame_size;
+  ptr_=ptr_.subspan(frame_size);
 
   return true;
 }
diff --git a/media/parsers/ivf_parser.h b/media/parsers/ivf_parser.h
index bb46e6c718de4..c7b8fc82314c5 100644
--- a/media/parsers/ivf_parser.h
+++ b/media/parsers/ivf_parser.h
@@ -8,6 +8,8 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 
 namespace media {
@@ -55,7 +57,7 @@ class IvfParser {
 
   // Initializes the parser for IVF |stream| with size |size| and parses the
   // file header. Returns true on success.
-  bool Initialize(const uint8_t* stream,
+  bool Initialize(base::span<const uint8_t>stream,
                   size_t size,
                   IvfFileHeader* file_header);
 
@@ -69,7 +71,7 @@ class IvfParser {
   bool ParseFileHeader(IvfFileHeader* file_header);
 
   // Current reading position of input stream.
-  raw_ptr<const uint8_t, AllowPtrArithmetic> ptr_;
+  base::raw_span<const uint8_t, AllowPtrArithmetic> ptr_;
 
   // The end position of input stream.
   raw_ptr<const uint8_t, AllowPtrArithmetic> end_;
diff --git a/media/parsers/temporal_scalability_id_extractor.cc b/media/parsers/temporal_scalability_id_extractor.cc
index e445367630d6b..428caf369d734 100644
--- a/media/parsers/temporal_scalability_id_extractor.cc
+++ b/media/parsers/temporal_scalability_id_extractor.cc
@@ -113,7 +113,7 @@ bool TemporalScalabilityIdExtractor::ParseH264(base::span<const uint8_t> chunk,
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
 bool TemporalScalabilityIdExtractor::ParseHEVC(base::span<const uint8_t> chunk,
                                                BitstreamMetadata& md) {
-  h265_->SetStream(chunk.data(), chunk.size());
+  h265_->SetStream(chunk, chunk.size());
   H265NALU nalu;
   H265NaluParser::Result result;
   while ((result = h265_->AdvanceToNextNALU(&nalu)) !=
diff --git a/media/parsers/temporal_scalability_id_extractor_unittest.cc b/media/parsers/temporal_scalability_id_extractor_unittest.cc
index 8ffe04bd804db..ddf7d22412629 100644
--- a/media/parsers/temporal_scalability_id_extractor_unittest.cc
+++ b/media/parsers/temporal_scalability_id_extractor_unittest.cc
@@ -83,7 +83,7 @@ std::vector<scoped_refptr<media::DecoderBuffer>> ReadIVF(
   media::IvfParser ivf_parser;
   media::IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
 
   std::vector<scoped_refptr<media::DecoderBuffer>> buffers;
diff --git a/media/parsers/webp_parser_unittest.cc b/media/parsers/webp_parser_unittest.cc
index a82d13b19770e..4b75cd43d350c 100644
--- a/media/parsers/webp_parser_unittest.cc
+++ b/media/parsers/webp_parser_unittest.cc
@@ -204,7 +204,7 @@ TEST(WebPParserTest, ParseLossyWebP) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_TRUE(result);
 
   ASSERT_TRUE(result->IsKeyframe());
@@ -231,7 +231,7 @@ TEST(WebPParserTest, ParseLosslessWebP) {
 
   // Should fail because WebP parser does not parse lossless webp images.
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_FALSE(result);
 }
 
@@ -250,7 +250,7 @@ TEST(WebPParserTest, ParseExtendedWebP) {
 
   // Should fail because WebP parser does not parse extended webp images.
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_FALSE(result);
 }
 
diff --git a/media/renderers/paint_canvas_video_renderer.cc b/media/renderers/paint_canvas_video_renderer.cc
index 1a72a21e3d041..72d693a65a380 100644
--- a/media/renderers/paint_canvas_video_renderer.cc
+++ b/media/renderers/paint_canvas_video_renderer.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -304,7 +307,7 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
 
   struct PlaneMetaData {
     size_t stride;
-    raw_ptr<const uint8_t> data;
+    base::raw_span<const uint8_t> data;
   };
   std::array<PlaneMetaData, VideoFrame::kMaxPlanes> plane_meta;
 
@@ -316,11 +319,11 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
           // pixel on row N and column M will wrap to column M on row N + 1.
           .stride = video_frame->stride(plane),
 
-          .data = video_frame->visible_data(plane) +
+          .data = video_frame->visible_data(plane) .subspan(
                   video_frame->stride(plane) * (chunk_start * rows_per_chunk) /
-                      VideoFrame::SampleSize(format, plane).height()};
+                      VideoFrame)::SampleSize(format, plane).height()};
     } else {
-      plane_meta[plane] = {.stride = 0, .data = nullptr};
+      plane_meta[plane] = {.stride = 0, .data = {}};
     }
   }
 
@@ -330,7 +333,7 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   if (format == PIXEL_FORMAT_ARGB || format == PIXEL_FORMAT_XRGB ||
       format == PIXEL_FORMAT_ABGR || format == PIXEL_FORMAT_XBGR) {
     DCHECK_LE(width, static_cast<int>(row_bytes));
-    const uint8_t* data = plane_meta[VideoFrame::Plane::kARGB].data;
+    base::span<const uint8_t>data = plane_meta[VideoFrame::Plane::kARGB].data;
 
     // Handle order swapping depending on the source and destination formats.
     if ((OUTPUT_ARGB &&
@@ -339,12 +342,12 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
          (format == PIXEL_FORMAT_ABGR || format == PIXEL_FORMAT_XBGR))) {
       uint8_t* dest = pixels;
       for (size_t i = 0; i < rows; i++) {
-        memcpy(dest, data, width * 4);
+        memcpy(dest, data.data(), width * 4);
         dest += row_bytes;
-        data += plane_meta[VideoFrame::Plane::kARGB].stride;
+        data=data.subspan(stride);
       }
     } else {
-      LIBYUV_ABGR_TO_ARGB(plane_meta[VideoFrame::Plane::kARGB].data,
+      LIBYUV_ABGR_TO_ARGB(plane_meta[VideoFrame::Plane::kARGB].data.data(),
                           plane_meta[VideoFrame::Plane::kARGB].stride, pixels,
                           row_bytes, width, rows);
     }
@@ -367,11 +370,11 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   const libyuv::YuvConstants* matrix =
       GetYuvContantsForColorSpace(yuv_cs, OUTPUT_ARGB);
 
-  if (!video_frame->data(VideoFrame::Plane::kU) &&
-      !video_frame->data(VideoFrame::Plane::kV)) {
+  if ().empty() &&
+      ).empty()) {
     DCHECK_EQ(format, PIXEL_FORMAT_I420);
     // For monochrome content ARGB and ABGR are interchangeable.
-    libyuv::I400ToARGBMatrix(plane_meta[VideoFrame::Plane::kY].data,
+    libyuv::I400ToARGBMatrix(plane_meta[VideoFrame::Plane::kY].data.data(),
                              plane_meta[VideoFrame::Plane::kY].stride, pixels,
                              row_bytes, matrix, width, rows);
     done->Run();
@@ -426,13 +429,13 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
 
   auto convert_yuv16 = [&](const libyuv::YuvConstants* matrix, auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          pixels, row_bytes, matrix, width, rows);
   };
@@ -440,29 +443,29 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   auto convert_yuv16_with_filter = [&](const libyuv::YuvConstants* matrix,
                                        auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          pixels, row_bytes, matrix, width, rows, filter);
   };
 
   auto convert_yuva16 = [&](const libyuv::YuvConstants* matrix, auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          reinterpret_cast<const uint16_t*>(
-             plane_meta[VideoFrame::Plane::kA].data.get()),
+             plane_meta[VideoFrame::Plane::kA].data),
          plane_meta[VideoFrame::Plane::kA].stride / 2, pixels, row_bytes,
          matrix, width, rows, premultiply_alpha);
   };
@@ -470,16 +473,16 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   auto convert_yuva16_with_filter = [&](const libyuv::YuvConstants* matrix,
                                         auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          reinterpret_cast<const uint16_t*>(
-             plane_meta[VideoFrame::Plane::kA].data.get()),
+             plane_meta[VideoFrame::Plane::kA].data),
          plane_meta[VideoFrame::Plane::kA].stride / 2, pixels, row_bytes,
          matrix, width, rows, premultiply_alpha, filter);
   };
@@ -497,13 +500,13 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
       if (video_frame->ColorSpace().GetMatrixID() ==
           gfx::ColorSpace::MatrixID::GBR) {
         libyuv::MergeARGBPlane(
-            GBR_TO_RGB_ORDER(plane_meta[VideoFrame::Plane::kY].data,
+            GBR_TO_RGB_ORDER(plane_meta[VideoFrame::Plane::kY].data.data(),
                              plane_meta[VideoFrame::Plane::kY].stride,
-                             plane_meta[VideoFrame::Plane::kU].data,
+                             plane_meta[VideoFrame::Plane::kU].data.data(),
                              plane_meta[VideoFrame::Plane::kU].stride,
-                             plane_meta[VideoFrame::Plane::kV].data,
+                             plane_meta[VideoFrame::Plane::kV].data.data(),
                              plane_meta[VideoFrame::Plane::kV].stride),
-            plane_meta[VideoFrame::Plane::kA].data,
+            plane_meta[VideoFrame::Plane::kA].data.data(),
             plane_meta[VideoFrame::Plane::kA].stride, pixels, row_bytes, width,
             rows);
       } else {
@@ -542,19 +545,19 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
       break;
 
     case PIXEL_FORMAT_NV12:
-      LIBYUV_NV12_TO_ARGB_MATRIX(plane_meta[VideoFrame::Plane::kY].data,
+      LIBYUV_NV12_TO_ARGB_MATRIX(plane_meta[VideoFrame::Plane::kY].data.data(),
                                  plane_meta[VideoFrame::Plane::kY].stride,
-                                 plane_meta[VideoFrame::Plane::kUV].data,
+                                 plane_meta[VideoFrame::Plane::kUV].data.data(),
                                  plane_meta[VideoFrame::Plane::kUV].stride,
                                  pixels, row_bytes, matrix, width, rows);
       break;
     case PIXEL_FORMAT_P010LE:
       libyuv::P010ToARGBMatrix(
           reinterpret_cast<const uint16_t*>(
-              plane_meta[VideoFrame::Plane::kY].data.get()),
+              plane_meta[VideoFrame::Plane::kY].data.data()),
           plane_meta[VideoFrame::Plane::kY].stride,
           reinterpret_cast<const uint16_t*>(
-              plane_meta[VideoFrame::Plane::kUV].data.get()),
+              plane_meta[VideoFrame::Plane::kUV].data.data()),
           plane_meta[VideoFrame::Plane::kUV].stride, pixels, row_bytes, matrix,
           width, rows);
       if (!OUTPUT_ARGB)
@@ -790,7 +793,7 @@ class VideoImageGenerator : public cc::PaintImageGenerator {
 
       // Copy the frame to the supplied memory. It'd be nice to avoid this copy,
       // but the memory is externally owned so we can't w/o an API change.
-      libyuv::CopyPlane(frame_->visible_data(plane), frame_->stride(plane),
+      libyuv::CopyPlane(frame_->visible_data(plane).data(), frame_->stride(plane),
                         reinterpret_cast<uint8_t*>(out_plane.writable_addr()),
                         out_plane.rowBytes(), plane_size.width(),
                         plane_size.height());
@@ -1156,8 +1159,8 @@ scoped_refptr<VideoFrame> DownShiftHighbitVideoFrame(
     int height = VideoFrame::Rows(plane, video_frame->format(),
                                   video_frame->visible_rect().height());
     const uint16_t* src =
-        reinterpret_cast<const uint16_t*>(video_frame->visible_data(plane));
-    uint8_t* dst = ret->GetWritableVisibleData(plane);
+        reinterpret_cast<const uint16_t*>(video_frame->visible_data(plane).data());
+    uint8_t* dst = ret->GetWritableVisibleData(plane).data();
     if (!src) {
       // An AV1 monochrome (grayscale) frame has no U and V planes. Set all U
       // and V samples to the neutral value (128).
@@ -1179,19 +1182,19 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
                        unsigned type,
                        bool flip_y,
                        size_t output_row_bytes) {
-  const uint8_t* row_head = video_frame->visible_data(0);
+  base::span<const uint8_t>row_head = video_frame->visible_data(0);
   const size_t stride = video_frame->stride(0);
   const int height = video_frame->visible_rect().height();
-  for (int i = 0; i < height; ++i, row_head += stride) {
+  for (int i = 0; i < height; ++i, row_head=row_head.subspan(stride)) {
     uint8_t* out_row_head = flip_y ? out + output_row_bytes * (height - i - 1)
                                    : out + output_row_bytes * i;
-    const uint16_t* row = reinterpret_cast<const uint16_t*>(row_head);
-    const uint16_t* row_end = row + video_frame->visible_rect().width();
+    base::span<const uint16_t>row = reinterpret_cast<const uint16_t*>(row_head);
+    const uint16_t* row_end = row .subspan( video_frame->visible_rect().width()).data();
     if (type == GL_FLOAT) {
       float* out_row = reinterpret_cast<float*>(out_row_head);
       if (format == GL_RGBA) {
         while (row < row_end) {
-          float gray_value = *row++ / 65535.f;
+          float gray_value = (row++)[0] / 65535.f;
           *out_row++ = gray_value;
           *out_row++ = gray_value;
           *out_row++ = gray_value;
@@ -1200,7 +1203,7 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
         continue;
       } else if (format == GL_RED) {
         while (row < row_end)
-          *out_row++ = *row++ / 65535.f;
+          *out_row++ = (row++)[0] / 65535.f;
         continue;
       }
       // For other formats, hit NOTREACHED below.
@@ -1212,7 +1215,7 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
       DCHECK_EQ(static_cast<unsigned>(GL_RGBA), format);
       uint32_t* rgba = reinterpret_cast<uint32_t*>(out_row_head);
       while (row < row_end) {
-        uint32_t gray_value = *row++ >> 8;
+        uint32_t gray_value = (row++)[0] >> 8;
         *rgba++ = SkColorSetRGB(gray_value, gray_value, gray_value);
       }
       continue;
@@ -1328,8 +1331,8 @@ void PaintCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
       // frame with no U and V planes. Since there are no 10-bit and 12-bit
       // versions of libyuv::I400ToARGBMatrix(), convert the frame to an 8-bit
       // YUV 4:2:0 frame with U and V planes.
-      if (!video_frame->data(VideoFrame::Plane::kU) &&
-          !video_frame->data(VideoFrame::Plane::kV)) {
+      if ().empty() &&
+          ).empty()) {
         temporary_frame = DownShiftHighbitVideoFrame(video_frame);
         video_frame = temporary_frame.get();
       }
diff --git a/media/renderers/paint_canvas_video_renderer_unittest.cc b/media/renderers/paint_canvas_video_renderer_unittest.cc
index 5b752e817bb7d..a8c3c0cdda61d 100644
--- a/media/renderers/paint_canvas_video_renderer_unittest.cc
+++ b/media/renderers/paint_canvas_video_renderer_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -252,11 +254,11 @@ static scoped_refptr<VideoFrame> CreateCroppedFrame() {
   };
 
   libyuv::I420Copy(cropped_y_plane, 16, cropped_u_plane, 8, cropped_v_plane, 8,
-                   cropped_frame->writable_data(VideoFrame::Plane::kY),
+                   cropped_frame->writable_data(VideoFrame::Plane::kY).data(),
                    cropped_frame->stride(VideoFrame::Plane::kY),
-                   cropped_frame->writable_data(VideoFrame::Plane::kU),
+                   cropped_frame->writable_data(VideoFrame::Plane::kU).data(),
                    cropped_frame->stride(VideoFrame::Plane::kU),
-                   cropped_frame->writable_data(VideoFrame::Plane::kV),
+                   cropped_frame->writable_data(VideoFrame::Plane::kV).data(),
                    cropped_frame->stride(VideoFrame::Plane::kV), 16, 16);
 
   return cropped_frame;
@@ -462,14 +464,14 @@ TEST_F(PaintCanvasVideoRendererTest, CroppedFrameToRGBParallel) {
       gfx::Size(1920, 810), base::TimeDelta());
 
   // Fill in the frame with the same data as the cropped frame.
-  libyuv::I420Scale(cropped_frame()->data(0), cropped_frame()->stride(0),
-                    cropped_frame()->data(1), cropped_frame()->stride(1),
-                    cropped_frame()->data(2), cropped_frame()->stride(2),
+  libyuv::I420Scale(cropped_frame()->data(0).data(), cropped_frame()->stride(0),
+                    cropped_frame()->data(1).data(), cropped_frame()->stride(1),
+                    cropped_frame()->data(2).data(), cropped_frame()->stride(2),
                     cropped_frame()->coded_size().width(),
                     cropped_frame()->coded_size().height(),
-                    test_frame->writable_data(0), test_frame->stride(0),
-                    test_frame->writable_data(1), test_frame->stride(1),
-                    test_frame->writable_data(2), test_frame->stride(2),
+                    test_frame->writable_data(0).data(), test_frame->stride(0),
+                    test_frame->writable_data(1).data(), test_frame->stride(1),
+                    test_frame->writable_data(2).data(), test_frame->stride(2),
                     test_frame->coded_size().width(),
                     test_frame->coded_size().height(), libyuv::kFilterNone);
 
@@ -661,14 +663,14 @@ TEST_F(PaintCanvasVideoRendererTest, HighBitDepth) {
     for (int plane = VideoFrame::Plane::kY; plane <= VideoFrame::Plane::kV;
          ++plane) {
       int width = cropped_frame()->row_bytes(plane);
-      uint16_t* dst = reinterpret_cast<uint16_t*>(frame->writable_data(plane));
-      const uint8_t* src = cropped_frame()->data(plane);
+      base::span<uint16_t>dst = reinterpret_cast<uint16_t*>(frame->writable_data(plane));
+      base::span<const uint8_t>src = cropped_frame()->data(plane);
       for (int row = 0; row < cropped_frame()->rows(plane); row++) {
         for (int col = 0; col < width; col++) {
           dst[col] = src[col] << (param.bit_depth - 8);
         }
-        src += cropped_frame()->stride(plane);
-        dst += frame->stride(plane) / 2;
+        src=src.subspan(cropped_frame()->stride(plane));
+        dst=dst.subspan(frame->stride(plane) / 2);
       }
     }
 
diff --git a/media/renderers/video_frame_yuv_converter.cc b/media/renderers/video_frame_yuv_converter.cc
index 88bfe3e16ec0c..09c5b7e58b717 100644
--- a/media/renderers/video_frame_yuv_converter.cc
+++ b/media/renderers/video_frame_yuv_converter.cc
@@ -151,7 +151,7 @@ void ConvertYuvVideoFrameToRgbSharedImage(
     SkImageInfo info = SkImageInfo::Make(gfx::SizeToSkISize(plane_size),
                                          color_type, kPlaneAlphaType);
     pixmaps[plane] =
-        SkPixmap(info, video_frame->data(plane), video_frame->stride(plane));
+        SkPixmap(info, video_frame->data(plane).data(), video_frame->stride(plane));
   }
 
   // Prepare the SkYUVAInfo
diff --git a/media/renderers/video_resource_updater.cc b/media/renderers/video_resource_updater.cc
index d2159995cf8da..20724a1926c64 100644
--- a/media/renderers/video_resource_updater.cc
+++ b/media/renderers/video_resource_updater.cc
@@ -1072,7 +1072,7 @@ bool VideoResourceUpdater::WriteRGBPixelsToTexture(
     // We can passthrough when the texture format matches. Since we
     // always copy the entire coded area we don't have to worry about
     // origin.
-    source_pixels = video_frame->data(VideoFrame::Plane::kARGB);
+    source_pixels = video_frame->data(VideoFrame::Plane::kARGB).data();
   } else {
     size_t needed_size = bytes_per_row * video_frame->coded_size().height();
     if (upload_pixels_size_[0] < needed_size) {
@@ -1169,7 +1169,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
     const uint8_t* pixels;
     int pixels_stride_in_bytes;
     if (!needs_conversion) {
-      pixels = video_frame->data(frame_planes[plane_index]);
+      pixels = video_frame->data(frame_planes[plane_index]).data();
       pixels_stride_in_bytes = video_stride_bytes;
     } else {
       // Avoid malloc for each frame/plane if possible.
@@ -1193,7 +1193,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         float libyuv_multiplier = 1.f / max_value;
         libyuv::HalfFloatPlane(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes,
             reinterpret_cast<uint16_t*>(upload_pixels_[plane_index].get()),
             upload_image_stride, libyuv_multiplier,
@@ -1204,7 +1204,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         const int scale = 0x10000 >> (bits_per_channel - 8);
         libyuv::Convert16To8Plane(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes / 2, upload_pixels_[plane_index].get(),
             upload_image_stride, scale, bytes_per_row,
             resource_size_pixels.height());
@@ -1212,7 +1212,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         CHECK_EQ(resource_bit_depth, 16u);
         libyuv::ConvertToMSBPlane_16(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes / 2,
             reinterpret_cast<uint16_t*>(upload_pixels_[plane_index].get()),
             upload_image_stride / 2, resource_size_pixels.width(),
diff --git a/media/renderers/video_resource_updater_unittest.cc b/media/renderers/video_resource_updater_unittest.cc
index 81f15012b3727..d31de032f6ab2 100644
--- a/media/renderers/video_resource_updater_unittest.cc
+++ b/media/renderers/video_resource_updater_unittest.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -123,7 +126,7 @@ class VideoResourceUpdaterTest : public testing::Test {
     const int kYWidth = kDimension + 5;
     const int kUWidth = (kYWidth + 1) / 2 + 200;
     const int kVWidth = (kYWidth + 1) / 2 + 1;
-    static uint8_t y_data[kYWidth * kDimension] = {};
+    static std::array<uint8_t, kYWidth * kDimension> y_data = {};
     static uint8_t u_data[kUWidth * kDimension] = {};
     static uint8_t v_data[kVWidth * kDimension] = {};
 
@@ -135,7 +138,7 @@ class VideoResourceUpdaterTest : public testing::Test {
         -kYWidth,                                 // y_stride (negative)
         kUWidth,                                  // u_stride
         kVWidth,                                  // v_stride
-        y_data + kYWidth * (kDimension - 1),      // y_data
+        base::span<uint8_t>(y_data ).subspan( kYWidth * ().data()kDimension - 1),      // y_data
         u_data,                                   // u_data
         v_data,                                   // v_data
         base::TimeDelta());                       // timestamp
@@ -398,7 +401,7 @@ TEST_F(VideoResourceUpdaterTest, SoftwareFrameRGBNonOrigin) {
         VideoFrame::BytesPerElement(fmt, VideoFrame::Plane::kARGB);
     auto* dest_pixels = gl_->last_upload() + rect.y() * bytes_per_row +
                         rect.x() * bytes_per_element;
-    auto* src_pixels = video_frame->visible_data(VideoFrame::Plane::kARGB);
+    base::span<const uint8_t>src_pixels = video_frame->visible_data(VideoFrame::Plane::kARGB);
 
     // Pixels are 0xFFFFFFFF, so channel reordering doesn't matter.
     for (int y = 0; y < rect.height(); ++y) {
diff --git a/media/video/alpha_video_encoder_wrapper_unittest.cc b/media/video/alpha_video_encoder_wrapper_unittest.cc
index 7cbced931cdf9..f123e5c5ffe24 100644
--- a/media/video/alpha_video_encoder_wrapper_unittest.cc
+++ b/media/video/alpha_video_encoder_wrapper_unittest.cc
@@ -96,11 +96,11 @@ class AlphaVideoEncoderWrapperTest
     uint32_t y = color & 0xFF;
     uint32_t u = (color >> 8) & 0xFF;
     uint32_t v = (color >> 16) & 0xFF;
-    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                      frame->stride(VideoFrame::Plane::kY),
-                     frame->writable_data(VideoFrame::Plane::kU),
+                     frame->writable_data(VideoFrame::Plane::kU).data(),
                      frame->stride(VideoFrame::Plane::kU),
-                     frame->writable_data(VideoFrame::Plane::kV),
+                     frame->writable_data(VideoFrame::Plane::kV).data(),
                      frame->stride(VideoFrame::Plane::kV),
                      frame->visible_rect().x(),       // x
                      frame->visible_rect().y(),       // y
@@ -109,7 +109,7 @@ class AlphaVideoEncoderWrapperTest
                      y,                               // Y color
                      u,                               // U color
                      v);                              // V color
-    libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA),
+    libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA).data(),
                      frame->stride(VideoFrame::Plane::kA),
                      frame->visible_rect().width(),   // width
                      frame->visible_rect().height(),  // height
diff --git a/media/video/av1_video_encoder.cc b/media/video/av1_video_encoder.cc
index b23e8166c2003..1f7163b9a40ea 100644
--- a/media/video/av1_video_encoder.cc
+++ b/media/video/av1_video_encoder.cc
@@ -494,7 +494,7 @@ void Av1VideoEncoder::Encode(scoped_refptr<VideoFrame> frame,
   aom_image_t* image = aom_img_wrap(
       &image_, GetAomImgFormat(frame->format()), options_.frame_size.width(),
       options_.frame_size.height(), 1,
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(image, &image_);
 
   // Resizing should have been taken care of above.
diff --git a/media/video/fake_gpu_memory_buffer.cc b/media/video/fake_gpu_memory_buffer.cc
index 5a1ebdabda5d0..28d861800c87d 100644
--- a/media/video/fake_gpu_memory_buffer.cc
+++ b/media/video/fake_gpu_memory_buffer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -55,7 +57,7 @@ class FakeGpuMemoryBufferImpl : public gpu::GpuMemoryBufferImpl {
   bool AsyncMappingIsNonBlocking() const override {
     return fake_gmb_->AsyncMappingIsNonBlocking();
   }
-  void* memory(size_t plane) override { return fake_gmb_->memory(plane); }
+  base::span<void> memory(size_t plane) override { return fake_gmb_->memory(plane); }
   void Unmap() override { fake_gmb_->Unmap(); }
   int stride(size_t plane) const override { return fake_gmb_->stride(plane); }
   gfx::GpuMemoryBufferType GetType() const override {
@@ -150,12 +152,11 @@ bool FakeGpuMemoryBuffer::AsyncMappingIsNonBlocking() const {
   return true;
 }
 
-void* FakeGpuMemoryBuffer::memory(size_t plane) {
+base::span<void> FakeGpuMemoryBuffer::memory(size_t plane) {
   DCHECK_LT(plane, VideoFrame::NumPlanes(video_pixel_format_));
-  auto* data_ptr = data_.data();
+  base::span<value_type>data_ptr = data_;
   for (size_t i = 1; i <= plane; i++) {
-    data_ptr +=
-        VideoFrame::PlaneSize(video_pixel_format_, i - 1, size_).GetArea();
+    data_ptr=data_ptr.subspan(VideoFrame::PlaneSize(video_pixel_format_, i - 1, size_).GetArea());
   }
   return data_ptr;
 }
diff --git a/media/video/fake_gpu_memory_buffer.h b/media/video/fake_gpu_memory_buffer.h
index 32baadd553621..5f1d2858b9e70 100644
--- a/media/video/fake_gpu_memory_buffer.h
+++ b/media/video/fake_gpu_memory_buffer.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "gpu/ipc/common/gpu_memory_buffer_support.h"
 #include "media/base/video_types.h"
 #include "ui/gfx/gpu_memory_buffer.h"
@@ -58,7 +59,7 @@ class FakeGpuMemoryBuffer : public gfx::GpuMemoryBuffer {
   bool Map() override;
   void MapAsync(base::OnceCallback<void(bool)> result_cb) override;
   bool AsyncMappingIsNonBlocking() const override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   gfx::Size GetSize() const override;
   gfx::BufferFormat GetFormat() const override;
diff --git a/media/video/gpu_memory_buffer_video_frame_pool.cc b/media/video/gpu_memory_buffer_video_frame_pool.cc
index 4bf99898b53bb..b27cd60b66e5d 100644
--- a/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -343,7 +345,7 @@ void CopyRowsToI420Buffer(int first_row,
                           int rows,
                           int bytes_per_row,
                           size_t bit_depth,
-                          const uint8_t* source,
+                          base::span<const uint8_t>source,
                           int source_stride,
                           uint8_t* output,
                           int dest_stride) {
@@ -359,13 +361,13 @@ void CopyRowsToI420Buffer(int first_row,
   DCHECK_GE(bit_depth, 8u);
 
   if (bit_depth == 8) {
-    libyuv::CopyPlane(source + source_stride * first_row, source_stride,
+    libyuv::CopyPlane(source .subspan( source_stride * first_row).data(), source_stride,
                       output + dest_stride * first_row, dest_stride,
                       bytes_per_row, rows);
   } else {
     const int scale = 0x10000 >> (bit_depth - 8);
     libyuv::Convert16To8Plane(
-        reinterpret_cast<const uint16_t*>(source + source_stride * first_row),
+        reinterpret_cast<const uint16_t*>(source .subspan( source_stride * first_row).data()),
         source_stride / 2, output + dest_stride * first_row, dest_stride, scale,
         bytes_per_row, rows);
   }
@@ -392,16 +394,16 @@ void CopyRowsToP010Buffer(int first_row,
             source_frame->stride(VideoFrame::Plane::kY));
 
   const uint16_t* y_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kY) +
-      first_row * source_frame->stride(VideoFrame::Plane::kY));
+      source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+      first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
   const size_t y_plane_stride = source_frame->stride(VideoFrame::Plane::kY) / 2;
   const uint16_t* u_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kU) +
-      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU));
+      source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU)).data());
   const size_t u_plane_stride = source_frame->stride(VideoFrame::Plane::kU) / 2;
   const uint16_t* v_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kV) +
-      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV));
+      source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV)).data());
   const size_t v_plane_stride = source_frame->stride(VideoFrame::Plane::kV) / 2;
 
   libyuv::I010ToP010(
@@ -448,14 +450,14 @@ void CopyRowsToNV12Buffer(int first_row,
 
     if (source_frame->format() == PIXEL_FORMAT_NV12) {
       libyuv::CopyPlane(
-          source_frame->visible_data(VideoFrame::Plane::kY) +
-              first_row * source_frame->stride(VideoFrame::Plane::kY),
+          source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+              first_row * source_frame->stride(VideoFrame::Plane::kY)).data(),
           source_frame->stride(VideoFrame::Plane::kY),
           dest_y + first_row * dest_stride_y, dest_stride_y, bytes_per_row_y,
           rows_y);
       libyuv::CopyPlane(
-          source_frame->visible_data(VideoFrame::Plane::kUV) +
-              first_row / 2 * source_frame->stride(VideoFrame::Plane::kUV),
+          source_frame->visible_data(VideoFrame::Plane::kUV) .subspan(
+              first_row / 2 * source_frame->stride(VideoFrame::Plane::kUV)).data(),
           source_frame->stride(VideoFrame::Plane::kUV),
           dest_uv + first_row / 2 * dest_stride_uv, dest_stride_uv,
           bytes_per_row_uv, rows_uv);
@@ -464,14 +466,14 @@ void CopyRowsToNV12Buffer(int first_row,
     }
 
     libyuv::I420ToNV12(
-        source_frame->visible_data(VideoFrame::Plane::kY) +
-            first_row * source_frame->stride(VideoFrame::Plane::kY),
+        source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+            first_row * source_frame->stride(VideoFrame::Plane::kY)).data(),
         source_frame->stride(VideoFrame::Plane::kY),
-        source_frame->visible_data(VideoFrame::Plane::kU) +
-            first_row / 2 * source_frame->stride(VideoFrame::Plane::kU),
+        source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+            first_row / 2 * source_frame->stride(VideoFrame::Plane::kU)).data(),
         source_frame->stride(VideoFrame::Plane::kU),
-        source_frame->visible_data(VideoFrame::Plane::kV) +
-            first_row / 2 * source_frame->stride(VideoFrame::Plane::kV),
+        source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+            first_row / 2 * source_frame->stride(VideoFrame::Plane::kV)).data(),
         source_frame->stride(VideoFrame::Plane::kV),
         dest_y + first_row * dest_stride_y, dest_stride_y,
         dest_uv + first_row / 2 * dest_stride_uv, dest_stride_uv,
@@ -481,18 +483,18 @@ void CopyRowsToNV12Buffer(int first_row,
               source_frame->stride(VideoFrame::Plane::kY));
 
     const uint16_t* y_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kY) +
-        first_row * source_frame->stride(VideoFrame::Plane::kY));
+        source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+        first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
     const size_t y_plane_stride =
         source_frame->stride(VideoFrame::Plane::kY) / 2;
     const uint16_t* u_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kU) +
-        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU));
+        source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU)).data());
     const size_t u_plane_stride =
         source_frame->stride(VideoFrame::Plane::kU) / 2;
     const uint16_t* v_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kV) +
-        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV));
+        source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV)).data());
     const size_t v_plane_stride =
         source_frame->stride(VideoFrame::Plane::kV) / 2;
 
@@ -522,14 +524,14 @@ void CopyRowsToRGB10Buffer(bool is_rgba,
   DCHECK_EQ(source_frame->format(), PIXEL_FORMAT_YUV420P10);
 
   const auto* y_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kY) +
-      first_row * source_frame->stride(VideoFrame::Plane::kY));
+      source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+      first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
   const auto* u_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kU) +
-      first_row / 2 * source_frame->stride(VideoFrame::Plane::kU));
+      source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+      first_row / 2 * source_frame->stride(VideoFrame::Plane::kU)).data());
   const auto* v_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kV) +
-      first_row / 2 * source_frame->stride(VideoFrame::Plane::kV));
+      source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+      first_row / 2 * source_frame->stride(VideoFrame::Plane::kV)).data());
 
   size_t y_plane_stride = source_frame->stride(VideoFrame::Plane::kY) / 2;
   size_t u_plane_stride = source_frame->stride(VideoFrame::Plane::kU) / 2;
diff --git a/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc b/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
index dc69aa5b41340..eb95cf123f5a8 100644
--- a/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
+++ b/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -72,11 +75,11 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
     RunUntilIdle();
     mock_gpu_factories_.reset();
 
-    if (y_data_)
+    if (!y_data_.empty())
       delete[] y_data_;
-    if (u_data_)
+    if (!u_data_.empty())
       delete[] u_data_;
-    if (v_data_)
+    if (!v_data_.empty())
       delete[] v_data_;
     if (uv_data_)
       delete[] uv_data_;
@@ -155,9 +158,9 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
         size.width() * multiplier,                         // y_stride
         dimension_aligned * multiplier / 2,                // u_stride
         dimension_aligned * multiplier / 2,                // v_stride
-        y_data_,                                           // y_data
-        u_data_,                                           // u_data
-        v_data_,                                           // v_data
+        y_data_.data(),                                           // y_data
+        u_data_.data(),                                           // u_data
+        v_data_.data(),                                           // v_data
         base::TimeDelta());                                // timestamp
     EXPECT_TRUE(video_frame);
     return video_frame;
@@ -240,7 +243,7 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
                                         size,                // natural_size
                                         size.width(),        // y_stride
                                         dimension_aligned,   // uv_stride
-                                        y_data_,             // y_data
+                                        y_data_.data(),             // y_data
                                         uv_data_,            // uv_data
                                         base::TimeDelta());  // timestamp
     EXPECT_TRUE(video_frame);
@@ -261,9 +264,9 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
   static constexpr uint8_t kUValue = 50;
   static constexpr uint8_t kVValue = 150;
 
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> y_data_ = nullptr;
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> u_data_ = nullptr;
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> v_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> y_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> u_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> v_data_ = nullptr;
   raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> uv_data_ = nullptr;
 
   base::SimpleTestTickClock test_clock_;
@@ -340,11 +343,11 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest, CreateOneHardwareFrameWithOddSize) {
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* u_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>u_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
-    const auto* v_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>v_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(2));
 
     // Y plane = 9x9, U and V plan = 5x5.
@@ -434,18 +437,18 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
     // Copy 10 bpp to I420.
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* u_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>u_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
-    const auto* v_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>v_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(2));
 
-    const uint16_t* y_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>y_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kY));
-    const uint16_t* u_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>u_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kU));
-    const uint16_t* v_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>v_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kV));
 
     // Y plane = 17x17 = 289, U and V plan = 9x9.
@@ -573,9 +576,9 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* uv_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>uv_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
     // Y plane = 5x5, U and V plan = 3x3.
@@ -642,9 +645,9 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* uv_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>uv_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
     // Y plane = 135x135 = 18225, UV plan = 136x68 = 9248.
@@ -722,11 +725,11 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest, CreateOneHardwareP010Frame) {
   EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
   mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-  const uint16_t* y_memory = reinterpret_cast<uint16_t*>(
+  base::span<const uint16_t>y_memory = reinterpret_cast<uint16_t*>(
       mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
   EXPECT_EQ(software_frame->visible_data(VideoFrame::Plane::kY)[0] << 6,
             y_memory[0]);
-  const uint16_t* uv_memory = reinterpret_cast<uint16_t*>(
+  base::span<const uint16_t>uv_memory = reinterpret_cast<uint16_t*>(
       mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
   EXPECT_EQ(software_frame->visible_data(VideoFrame::Plane::kU)[0] << 6,
             uv_memory[0]);
@@ -761,16 +764,16 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
     // Copy I010 To P010.
-    const uint16_t* y_memory = reinterpret_cast<uint16_t*>(
+    base::span<const uint16_t>y_memory = reinterpret_cast<uint16_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const uint16_t* uv_memory = reinterpret_cast<uint16_t*>(
+    base::span<const uint16_t>uv_memory = reinterpret_cast<uint16_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
-    const uint16_t* y_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>y_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kY));
-    const uint16_t* u_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>u_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kU));
-    const uint16_t* v_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>v_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kV));
 
     // Y plane = 7x7 = 49, U and V plan = 4x4 = 16.
diff --git a/media/video/mock_gpu_video_accelerator_factories.cc b/media/video/mock_gpu_video_accelerator_factories.cc
index eea30216af98a..f41d14e8aa2db 100644
--- a/media/video/mock_gpu_video_accelerator_factories.cc
+++ b/media/video/mock_gpu_video_accelerator_factories.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -56,7 +58,7 @@ class GpuMemoryBufferImpl : public gfx::GpuMemoryBuffer {
     mapped_ = true;
     return true;
   }
-  void* memory(size_t plane) override {
+  base::span<void> memory(size_t plane) override {
     DCHECK(mapped_);
     DCHECK_LT(plane, num_planes_);
     return &bytes_[plane][0];
diff --git a/media/video/video_encode_accelerator_adapter_test.cc b/media/video/video_encode_accelerator_adapter_test.cc
index af5410c8455cc..16708c34a0f57 100644
--- a/media/video/video_encode_accelerator_adapter_test.cc
+++ b/media/video/video_encode_accelerator_adapter_test.cc
@@ -125,11 +125,11 @@ class VideoEncodeAcceleratorAdapterTest
                                          gfx::Rect(size), size, timestamp);
 
     // Green I420 frame (Y:0x96, U:0x40, V:0x40)
-    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                      frame->stride(VideoFrame::Plane::kY),
-                     frame->writable_data(VideoFrame::Plane::kU),
+                     frame->writable_data(VideoFrame::Plane::kU).data(),
                      frame->stride(VideoFrame::Plane::kU),
-                     frame->writable_data(VideoFrame::Plane::kV),
+                     frame->writable_data(VideoFrame::Plane::kV).data(),
                      frame->stride(VideoFrame::Plane::kV),
                      0,                               // left
                      0,                               // top
@@ -149,7 +149,7 @@ class VideoEncodeAcceleratorAdapterTest
                                          gfx::Rect(size), size, timestamp);
 
     // Green XRGB frame (R:0x3B, G:0xD9, B:0x24)
-    libyuv::ARGBRect(frame->writable_data(VideoFrame::Plane::kARGB),
+    libyuv::ARGBRect(frame->writable_data(VideoFrame::Plane::kARGB).data(),
                      frame->stride(VideoFrame::Plane::kARGB),
                      0,                               // left
                      0,                               // top
diff --git a/media/video/vpx_video_encoder.cc b/media/video/vpx_video_encoder.cc
index 2380b6c3692be..aa789223624ee 100644
--- a/media/video/vpx_video_encoder.cc
+++ b/media/video/vpx_video_encoder.cc
@@ -314,7 +314,7 @@ void I444ToI410(const VideoFrame& frame, vpx_image_t* vpx_image) {
   auto stride = base::span(vpx_image->stride);
   for (size_t i = 0; i < VideoFrame::NumPlanes(frame.format()); ++i) {
     libyuv::Convert8To16Plane(
-        frame.visible_data(i), frame.stride(i),
+        frame.visible_data(i).data(), frame.stride(i),
         reinterpret_cast<uint16_t*>(planes[i]), stride[i] / 2, 1024,
         VideoFrame::Columns(i, frame.format(),
                             frame.visible_rect().size().width()),
@@ -659,11 +659,11 @@ void VpxVideoEncoder::Encode(scoped_refptr<VideoFrame> frame,
         break;
       }
       RecreateVpxImageIfNeeded(VPX_IMG_FMT_I42016, /*needs_memory=*/true);
-      libyuv::I420ToI010(frame->visible_data(VideoFrame::Plane::kY),
+      libyuv::I420ToI010(frame->visible_data(VideoFrame::Plane::kY).data(),
                          frame->stride(VideoFrame::Plane::kY),
-                         frame->visible_data(VideoFrame::Plane::kU),
+                         frame->visible_data(VideoFrame::Plane::kU).data(),
                          frame->stride(VideoFrame::Plane::kU),
-                         frame->visible_data(VideoFrame::Plane::kV),
+                         frame->visible_data(VideoFrame::Plane::kV).data(),
                          frame->stride(VideoFrame::Plane::kV),
                          reinterpret_cast<uint16_t*>(planes[VPX_PLANE_Y]),
                          stride[VPX_PLANE_Y] / 2,
diff --git a/mojo/core/embedder_unittest.cc b/mojo/core/embedder_unittest.cc
index 56adf67612e23..c974e00b80e3b 100644
--- a/mojo/core/embedder_unittest.cc
+++ b/mojo/core/embedder_unittest.cc
@@ -331,7 +331,7 @@ TEST_F(EmbedderTest, MultiprocessBaseSharedMemory) {
     // expected value.
     auto mapping = shared_memory.Map();
     ASSERT_TRUE(mapping.IsValid());
-    EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory())));
+    EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory().data())));
 
     ASSERT_EQ(MOJO_RESULT_OK, MojoClose(sb1));
 
@@ -368,7 +368,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessSharedMemoryClient,
   auto mapping = shared_memory.Map();
   ASSERT_TRUE(mapping.IsValid());
   EXPECT_NE(buffer, mapping.memory());
-  EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory())));
+  EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory().data())));
 
   EXPECT_EQ("bye", ReadMessage(client_mp));
 
diff --git a/mojo/core/invitation_unittest.cc b/mojo/core/invitation_unittest.cc
index 25058459f37be..acb973073b076 100644
--- a/mojo/core/invitation_unittest.cc
+++ b/mojo/core/invitation_unittest.cc
@@ -1031,7 +1031,7 @@ TEST_F(MAYBE_InvitationTest, MultiBrokerNetwork) {
 MojoHandle CreateMemory(std::string_view contents) {
   auto region = base::WritableSharedMemoryRegion::Create(contents.size());
   auto mapping = region.Map();
-  memcpy(mapping.memory(), contents.data(), contents.size());
+  memcpy(mapping.memory().data(), contents.data(), contents.size());
   auto buffer = WrapReadOnlySharedMemoryRegion(
       base::WritableSharedMemoryRegion::ConvertToReadOnly(std::move(region)));
   return buffer.release().value();
@@ -1041,7 +1041,7 @@ std::string ReadMemory(MojoHandle handle) {
   auto region = UnwrapReadOnlySharedMemoryRegion(
       ScopedSharedBufferHandle{SharedBufferHandle{handle}});
   auto mapping = region.Map();
-  std::string_view contents{reinterpret_cast<const char*>(mapping.memory()),
+  std::string_view contents{reinterpret_cast<const char*>(mapping.memory().data()),
                             region.GetSize()};
   return std::string{contents};
 }
diff --git a/mojo/core/ipcz_driver/transport_test.cc b/mojo/core/ipcz_driver/transport_test.cc
index bf9b37317810a..cb0af688ecf52 100644
--- a/mojo/core/ipcz_driver/transport_test.cc
+++ b/mojo/core/ipcz_driver/transport_test.cc
@@ -475,7 +475,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(TransmitMemoryClient,
       DeserializeObjectFrom<SharedBuffer>(*transport, message)->region()));
   EXPECT_EQ(kMemoryMessage.size(), region.GetSize());
   auto mapping = region.Map();
-  auto contents = std::string_view(static_cast<const char*>(mapping.memory()),
+  auto contents = std::string_view(static_cast<const char*>(mapping.memory().data()),
                                    kMemoryMessage.size());
   EXPECT_EQ(kMemoryMessage, contents);
   EXPECT_EQ(MOJO_RESULT_OK, MojoClose(h));
@@ -488,7 +488,7 @@ TEST_F(MojoIpczTransportTest, TransmitMemory) {
 
     auto region = base::UnsafeSharedMemoryRegion::Create(kMemoryMessage.size());
     auto mapping = region.Map();
-    memcpy(mapping.memory(), kMemoryMessage.data(), kMemoryMessage.size());
+    memcpy(mapping.memory().data(), kMemoryMessage.data(), kMemoryMessage.size());
     auto buffer = SharedBuffer::MakeForRegion(std::move(region));
 
     TransportListener listener(*transport);
diff --git a/mojo/public/cpp/base/big_buffer.h b/mojo/public/cpp/base/big_buffer.h
index 1accfff09c75d..fddd3e6f2a394 100644
--- a/mojo/public/cpp/base/big_buffer.h
+++ b/mojo/public/cpp/base/big_buffer.h
@@ -143,34 +143,34 @@ class COMPONENT_EXPORT(MOJO_BASE) BigBuffer {
   }
 
   iterator begin() {
-    uint8_t* const ptr = data();
+    const base::span<uint8_t>ptr = *data();
     // SAFETY: If this is an invalid buffer, `ptr` is null and `size()` is zero,
     // which results in a well-defined (null) result. Otherwise, the underlying
     // storage (`bytes_` or `shared_memory_`) guarantees that `ptr` points to at
     // least `size()` bytes.
-    return UNSAFE_BUFFERS(iterator(ptr, ptr + size()));
+    return UNSAFE_BUFFERS(iterator(ptr.data(), ptr + size()));
   }
 
   const_iterator begin() const {
-    const uint8_t* const ptr = data();
+    const base::span<const uint8_t>ptr = *data();
     // SAFETY: As in the non-const version above.
-    return UNSAFE_BUFFERS(const_iterator(ptr, ptr + size()));
+    return UNSAFE_BUFFERS(const_iterator(ptr.data(), ptr + size()));
   }
 
   const_iterator cbegin() const { return begin(); }
 
   iterator end() {
-    uint8_t* const ptr = data();
+    const base::span<uint8_t>ptr = *data();
     const size_t len = size();
     // SAFETY: As in `begin()` above.
-    return UNSAFE_BUFFERS(iterator(ptr, ptr + len, ptr + len));
+    return UNSAFE_BUFFERS(iterator(ptr.data(), ptr + len, ptr + len));
   }
 
   const_iterator end() const {
-    const uint8_t* const ptr = data();
+    const base::span<const uint8_t>ptr = *data();
     const size_t len = size();
     // SAFETY: As in the non-const version above.
-    return UNSAFE_BUFFERS(const_iterator(ptr, ptr + len, ptr + len));
+    return UNSAFE_BUFFERS(const_iterator(ptr.data(), ptr + len, ptr + len));
   }
 
   const_iterator cend() const { return end(); }
diff --git a/remoting/host/video_memory_utils.cc b/remoting/host/video_memory_utils.cc
index 988bf031d85f5..57efbd26a202a 100644
--- a/remoting/host/video_memory_utils.cc
+++ b/remoting/host/video_memory_utils.cc
@@ -74,7 +74,7 @@ SharedVideoMemory::SharedVideoMemory(base::ReadOnlySharedMemoryRegion region,
                                      webrtc::SharedMemory::Handle handle,
                                      int id,
                                      base::OnceClosure on_deleted_callback)
-    : SharedMemory(mapping.memory(), mapping.size(), handle, id),
+    : SharedMemory(mapping.memory().data(), mapping.size(), handle, id),
       on_deleted_callback_(std::move(on_deleted_callback))
 #if BUILDFLAG(IS_WIN)
       ,
diff --git a/remoting/host/video_memory_utils.h b/remoting/host/video_memory_utils.h
index 3587e453fca77..1869be85d8dc8 100644
--- a/remoting/host/video_memory_utils.h
+++ b/remoting/host/video_memory_utils.h
@@ -93,7 +93,7 @@ class IpcSharedBufferCore
 
   int id() const { return id_; }
   size_t size() const { return mapping_.size(); }
-  const void* memory() const { return mapping_.memory(); }
+  const void* memory() const { return mapping_.memory().data(); }
 
  private:
   ~IpcSharedBufferCore();
diff --git a/services/audio/input_sync_writer.cc b/services/audio/input_sync_writer.cc
index 0d514271a128f..23535c4c23085 100644
--- a/services/audio/input_sync_writer.cc
+++ b/services/audio/input_sync_writer.cc
@@ -95,15 +95,15 @@ InputSyncWriter::InputSyncWriter(
   audio_buses_.resize(shared_memory_segment_count);
 
   // Create vector of audio buses by wrapping existing blocks of memory.
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
-  CHECK(ptr);
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  CHECK(!ptr.empty());
   for (auto& bus : audio_buses_) {
     CHECK_EQ(0U, reinterpret_cast<uintptr_t>(ptr) &
                      (media::AudioBus::kChannelAlignment - 1));
     media::AudioInputBuffer* buffer =
-        reinterpret_cast<media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
     bus = media::AudioBus::WrapMemory(params, buffer->audio);
-    ptr += shared_memory_segment_size_;
+    ptr=ptr.subspan(shared_memory_segment_size_);
   }
 }
 
@@ -419,10 +419,10 @@ bool InputSyncWriter::SignalDataWrittenAndUpdateCounters() {
 
 media::AudioInputBuffer* InputSyncWriter::GetSharedInputBuffer(
     uint32_t segment_id) {
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
   CHECK_LT(segment_id, audio_buses_.size());
-  ptr += segment_id * shared_memory_segment_size_;
-  return reinterpret_cast<media::AudioInputBuffer*>(ptr);
+  ptr=ptr.subspan(segment_id * shared_memory_segment_size_);
+  return reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
 }
 
 }  // namespace audio
diff --git a/services/audio/input_sync_writer_unittest.cc b/services/audio/input_sync_writer_unittest.cc
index b82efa6f165a8..f0de1d0c4d7a2 100644
--- a/services/audio/input_sync_writer_unittest.cc
+++ b/services/audio/input_sync_writer_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -218,11 +220,11 @@ class InputSyncWriterTest
     socket_->Read(1);
 
     size_t segment_id = current_renderer_side_buffer_ % kSegments;
-    uint8_t* ptr =
+    base::span<uint8_t>ptr =
         static_cast<uint8_t*>(renderer_shared_memory_mapping_.memory());
-    ptr += segment_id * segment_length_;
+    ptr=ptr.subspan(segment_id * segment_length_);
     media::AudioInputBuffer* buffer =
-        reinterpret_cast<media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
     EXPECT_EQ(base::subtle::NoBarrier_Load(&(buffer->params.has_unread_data)),
               1);
     base::subtle::Release_Store(&(buffer->params.has_unread_data), 0);
diff --git a/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc b/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
index d4e0dddac3f1b..1ed2b2f6c03be 100644
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
@@ -150,7 +150,7 @@ TEST_F(PlatformSensorAndProviderTest, SharedBufferDefaultValue) {
       GetSensorReadingSharedBufferOffset(mojom::SensorType::AMBIENT_LIGHT),
       sizeof(SensorReadingSharedBuffer));
 
-  const auto* buffer = mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+  const auto* buffer = mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 0);
 }
 
diff --git a/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc b/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
index 92308b4ced345..24735bfb7142b 100644
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
@@ -551,7 +551,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckAmbientLightReadings) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 50);
 
   EXPECT_TRUE(sensor->StopListening(client.get(), configuration));
@@ -593,7 +593,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest,
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kAccelerometerScalingValue;
   EXPECT_THAT(buffer->reading.accel.x,
               RoundAccelerometerValue(
@@ -647,7 +647,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckLinearAcceleration) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.accel.x, 0.0);
   EXPECT_THAT(buffer->reading.accel.y, 0.0);
   EXPECT_THAT(static_cast<int>(buffer->reading.accel.z),
@@ -690,7 +690,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckGyroscopeReadingConversion) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kGyroscopeScalingValue;
   EXPECT_THAT(buffer->reading.gyro.x,
               RoundGyroscopeValue(scaling *
@@ -740,7 +740,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckMagnetometerReadingConversion) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kMagnetometerScalingValue * kMicroteslaInGauss;
   EXPECT_THAT(buffer->reading.magn.x,
               RoundMagnetometerValue(
@@ -789,7 +789,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest,
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 50);
 
   EXPECT_TRUE(sensor->StopListening(client.get(), configuration));
diff --git a/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc b/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
index 2442ac71de2f7..1dc6bf28223bd 100644
--- a/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
+++ b/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
@@ -44,7 +44,7 @@ SensorReadingSharedBufferReader::Create(base::ReadOnlySharedMemoryRegion region,
 
 bool SensorReadingSharedBufferReader::GetReading(SensorReading* result) {
   DCHECK(mapping_.IsValid());
-  return GetReading(mapping_.GetMemoryAs<device::SensorReadingSharedBuffer>(),
+  return GetReading(mapping_.GetMemoryAs<device::SensorReadingSharedBuffer>().data(),
                     result);
 }
 
diff --git a/services/passage_embeddings/passage_embedder.cc b/services/passage_embeddings/passage_embedder.cc
index f91e7248ce71c..4b52dfaf7bf9a 100644
--- a/services/passage_embeddings/passage_embedder.cc
+++ b/services/passage_embeddings/passage_embedder.cc
@@ -118,7 +118,7 @@ bool PassageEmbedder::LoadSentencePieceModelFile(base::File sp_file) {
   }
 
   auto model_proto = std::make_unique<sentencepiece::ModelProto>();
-  model_proto->ParseFromArray(sp_model.data(), sp_model.length());
+  model_proto->ParseFromArray(sp_model.data().data(), sp_model.length());
   sp_processor_ = std::make_unique<sentencepiece::SentencePieceProcessor>();
   if (!(sp_processor_->Load(std::move(model_proto)).ok())) {
     sp_processor_.reset();
@@ -164,7 +164,7 @@ bool PassageEmbedder::BuildExecutionTask() {
       std::make_unique<PassageEmbeddingsOpResolver>(allow_gpu_execution_));
 
   absl::Status model_load_status = tflite_engine->BuildModelFromFlatBuffer(
-      reinterpret_cast<const char*>(embeddings_model_->data()),
+      reinterpret_cast<const char*>(embeddings_model_->data().data()),
       embeddings_model_->length());
   if (!model_load_status.ok()) {
     return false;
diff --git a/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc b/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
index adbe5b881dc1f..7e9d03d36ffb7 100644
--- a/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
+++ b/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -70,17 +72,17 @@ StructTraits<viz::mojom::BitmapInSharedMemoryDataView,
 
     auto* src_pixels = static_cast<const uint8_t*>(sk_bitmap.getPixels());
     size_t src_stride = sk_bitmap.rowBytes();
-    auto* dst_pixels = static_cast<uint8_t*>(mapping.memory());
+    base::span<uint8_t>dst_pixels = static_cast<uint8_t*>(mapping.memory());
 
     // If source and destination stride are the same use a single copy
     // operation, otherwise do a row-by-row copy.
     if (src_stride == min_row_bytes) {
-      memcpy(dst_pixels, src_pixels, byte_size);
+      memcpy(dst_pixels.data(), src_pixels, byte_size);
     } else {
       for (int y = 0; y < sk_bitmap.height(); ++y) {
-        memcpy(dst_pixels, src_pixels, min_row_bytes);
+        memcpy(dst_pixels.data(), src_pixels, min_row_bytes);
         src_pixels += src_stride;
-        dst_pixels += min_row_bytes;
+        dst_pixels=dst_pixels.subspan(min_row_bytes);
       }
     }
   }
@@ -114,7 +116,7 @@ bool StructTraits<viz::mojom::BitmapInSharedMemoryDataView, SkBitmap>::Read(
     return false;
   }
 
-  if (!sk_bitmap->installPixels(image_info, mapping_ptr->memory(),
+  if (!sk_bitmap->installPixels(image_info, mapping_ptr->memory().data(),
                                 data.row_bytes(), &DeleteSharedMemoryMapping,
                                 mapping_ptr.get())) {
     return false;
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
index ca77fdb152c56..6fee43409f8fa 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
@@ -37,7 +37,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
 
     EXPECT_EQ(expected_leftmost_relation, context.LeftmostRelation())
@@ -74,7 +74,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext argument_context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     for (CheckPseudoHasArgumentTraversalIterator iterator(*has_anchor_element,
                                                           argument_context);
@@ -102,7 +102,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     EXPECT_EQ(selector_list->First()->GetPseudoType(), CSSSelector::kPseudoHas);
 
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     return context.TraversalType();
   }
@@ -127,7 +127,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext argument_context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     for (CheckPseudoHasArgumentTraversalIterator iterator(*has_anchor_element,
                                                           argument_context);
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
index d52d767b77ed4..c69275ff0a720 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
@@ -101,7 +101,7 @@ class CheckPseudoHasCacheScopeContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         CSSSelectorList::AdoptSelectorVector(selector_vector);
     const CSSSelector* selector = nullptr;
-    for (selector = selector_list->First();
+    for (selector = selector_list->First().data();
          selector && selector->GetPseudoType() != CSSSelector::kPseudoHas;
          selector = selector->NextSimpleSelector()) {
     }
@@ -110,7 +110,7 @@ class CheckPseudoHasCacheScopeContextTest : public PageTestBase {
                     << selector_text << ")";
       return;
     }
-    const CSSSelector* argument_selector = selector->SelectorList()->First();
+    const CSSSelector* argument_selector = selector->SelectorList()->First().data();
 
     CheckPseudoHasArgumentContext argument_context(argument_selector,
                                                    /*scope=*/nullptr,
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
index 07d20e24777bb..c415365ed8814 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
@@ -48,7 +48,7 @@ class CheckPseudoHasFastRejectFilterTest : public PageTestBase {
     EXPECT_EQ(selector_list->First()->GetPseudoType(), CSSSelector::kPseudoHas);
 
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(),
+        selector_list->First()->SelectorList()->First().data(),
         /*scope=*/nullptr,
         /* match_in_shadow_tree */ false);
 
diff --git a/third_party/blink/renderer/core/css/css_selector.cc b/third_party/blink/renderer/core/css/css_selector.cc
index 4e78362b71677..e6fcf60bc4af6 100644
--- a/third_party/blink/renderer/core/css/css_selector.cc
+++ b/third_party/blink/renderer/core/css/css_selector.cc
@@ -1101,7 +1101,7 @@ template <bool expand_pseudo_references>
 void CSSSelector::SerializeSelectorList(const CSSSelectorList* selector_list,
                                         StringBuilder& builder,
                                         uintptr_t scope_id) {
-  const CSSSelector* first_sub_selector = selector_list->First();
+  const CSSSelector* first_sub_selector = selector_list->First().data();
   for (const CSSSelector* sub_selector = first_sub_selector; sub_selector;
        sub_selector = CSSSelectorList::Next(*sub_selector)) {
     if (sub_selector != first_sub_selector) {
@@ -1562,7 +1562,7 @@ bool CSSSelector::HasLinkOrVisited() const {
       return true;
     }
     if (const CSSSelectorList* list = current->SelectorList()) {
-      for (const CSSSelector* sub_selector = list->First(); sub_selector;
+      for (const CSSSelector* sub_selector = list->First().data(); sub_selector;
            sub_selector = CSSSelectorList::Next(*sub_selector)) {
         if (sub_selector->HasLinkOrVisited()) {
           return true;
@@ -1860,7 +1860,7 @@ static bool ForAnyInComplexSelector(const Functor& functor,
       return true;
     }
     if (const CSSSelectorList* selector_list = current->SelectorList()) {
-      for (const CSSSelector* sub_selector = selector_list->First();
+      for (const CSSSelector* sub_selector = selector_list->First().data();
            sub_selector; sub_selector = CSSSelectorList::Next(*sub_selector)) {
         if (ForAnyInComplexSelector(functor, *sub_selector)) {
           return true;
@@ -1996,7 +1996,7 @@ const CSSSelector* CSSSelector::SelectorListOrParent() const {
       return nullptr;
     }
   } else if (HasRareData() && data_.rare_data_->selector_list_) {
-    return data_.rare_data_->selector_list_->First();
+    return data_.rare_data_->selector_list_->First().data();
   } else {
     return nullptr;
   }
diff --git a/third_party/blink/renderer/core/css/css_selector_list.cc b/third_party/blink/renderer/core/css/css_selector_list.cc
index 46d9cdbe3d3c5..0869a6353db0a 100644
--- a/third_party/blink/renderer/core/css/css_selector_list.cc
+++ b/third_party/blink/renderer/core/css/css_selector_list.cc
@@ -28,6 +28,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/core/css/css_selector.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
@@ -91,7 +92,7 @@ CSSSelectorList* CSSSelectorList::AdoptSelectorVector(
   CSSSelectorList* list = MakeGarbageCollected<CSSSelectorList>(
       AdditionalBytes(sizeof(CSSSelector) * (selector_vector.size() - 1)),
       base::PassKey<CSSSelectorList>());
-  AdoptSelectorVector(selector_vector, list->first_selector_);
+  AdoptSelectorVector(selector_vector, list->first_selector_.data());
   return list;
 }
 
@@ -99,17 +100,17 @@ unsigned CSSSelectorList::ComputeLength() const {
   if (!IsValid()) {
     return 0;
   }
-  const CSSSelector* current = First();
+  base::span<const CSSSelector>current = First();
   while (!current->IsLastInSelectorList()) {
     UNSAFE_TODO(++current);
   }
-  return SelectorIndex(*current) + 1;
+  return SelectorIndex( current[0]) + 1;
 }
 
 unsigned CSSSelectorList::MaximumSpecificity() const {
   unsigned specificity = 0;
 
-  for (const CSSSelector* s = First(); s; s = Next(*s)) {
+  for (const CSSSelector* s = First().data(); s; s = Next(*s)) {
     specificity = std::max(specificity, s->Specificity());
   }
 
@@ -132,7 +133,7 @@ bool CSSSelectorList::Renest(const CSSSelector* selector_list,
 
 CSSSelectorList* CSSSelectorList::Renest(StyleRule* new_parent) {
   HeapVector<CSSSelector> selectors;
-  if (IsValid() && Renest(First(), new_parent, selectors)) {
+  if (IsValid() && Renest(First().data(), new_parent, selectors)) {
     return AdoptSelectorVector(selectors);
   }
   return this;
diff --git a/third_party/blink/renderer/core/css/css_selector_list.h b/third_party/blink/renderer/core/css/css_selector_list.h
index ff40b98e1570e..bab1adecc8116 100644
--- a/third_party/blink/renderer/core/css/css_selector_list.h
+++ b/third_party/blink/renderer/core/css/css_selector_list.h
@@ -26,6 +26,8 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_CSS_CSS_SELECTOR_LIST_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_CSS_CSS_SELECTOR_LIST_H_
 
+#include <array>
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/types/pass_key.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -77,7 +79,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
   explicit CSSSelectorList(base::PassKey<CSSSelectorList>) {}
 
   CSSSelectorList(CSSSelectorList&& o) {
-    memcpy(this, o.first_selector_, ComputeLength() * sizeof(CSSSelector));
+    memcpy(this, o.first_selector_.data(), ComputeLength() * sizeof(CSSSelector));
   }
   ~CSSSelectorList() = default;
 
@@ -92,9 +94,9 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
   static bool IsValid(const CSSSelector& first) {
     return first.Match() != CSSSelector::kInvalidList;
   }
-  bool IsValid() const { return IsValid(*first_selector_); }
-  const CSSSelector* First() const {
-    return IsValid() ? first_selector_ : nullptr;
+  bool IsValid() const { return IsValid( first_selector_[0]); }
+  const base::span<CSSSelector> First() const {
+    return IsValid() ? first_selector_ : {};
   }
   static const CSSSelector* Next(const CSSSelector&);
   static CSSSelector* Next(CSSSelector&);
@@ -105,7 +107,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
     return IsValid(first) && !Next(first);
   }
   bool IsSingleComplexSelector() const {
-    return IsSingleComplexSelector(*first_selector_);
+    return IsSingleComplexSelector( first_selector_[0]);
   }
   const CSSSelector& SelectorAt(wtf_size_t index) const {
     DCHECK(IsValid());
@@ -126,7 +128,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
     return SelectorIndex(*next);
   }
 
-  String SelectorsText() const { return SelectorsText(First()); }
+  String SelectorsText() const { return SelectorsText(First().data()); }
   static String SelectorsText(const CSSSelector* first);
 
   // Selector lists don't know their length, computing it is O(n) and should be
@@ -165,7 +167,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
   // is not stored explicitly anywhere: End of a multipart selector is
   // indicated by is_last_in_complexlector_ bit in the last item. End of the
   // array is indicated by is_last_in_selector_list_ bit in the last item.
-  CSSSelector first_selector_[1];
+  std::array<CSSSelector, 1> first_selector_;
 };
 
 inline const CSSSelector* CSSSelectorList::Next(const CSSSelector& current) {
diff --git a/third_party/blink/renderer/core/css/css_selector_test.cc b/third_party/blink/renderer/core/css/css_selector_test.cc
index 1c91b13cfc0b3..f1e6565df6460 100644
--- a/third_party/blink/renderer/core/css/css_selector_test.cc
+++ b/third_party/blink/renderer/core/css/css_selector_test.cc
@@ -226,7 +226,7 @@ TEST(CSSSelector, CueDefaultNamespace) {
 
   const CSSSelectorList* cue_arguments = cue_selector.SelectorList();
   ASSERT_TRUE(cue_arguments);
-  const CSSSelector* vtt_type_selector = cue_arguments->First();
+  const CSSSelector* vtt_type_selector = cue_arguments->First().data();
   ASSERT_TRUE(vtt_type_selector);
   EXPECT_EQ(vtt_type_selector->TagQName().LocalName(), "b");
   // Default namespace should not affect VTT node type selector.
@@ -251,7 +251,7 @@ TEST(CSSSelector, FirstInInvalidList) {
   test::TaskEnvironment task_environment;
   CSSSelectorList* list = CSSSelectorList::Empty();
   EXPECT_FALSE(list->IsValid());
-  EXPECT_FALSE(list->First());
+  EXPECT_FALSE(list->First().empty());
 }
 
 TEST(CSSSelector, ImplicitPseudoDescendant) {
diff --git a/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc b/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
index 707ba94e997e5..e575f405c2cbc 100644
--- a/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
+++ b/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
@@ -1169,7 +1169,7 @@ void RuleInvalidationDataVisitor<VisitorType>::CollectValuesInHasArgument(
   const CSSSelectorList* selector_list = has_pseudo_class.SelectorList();
   DCHECK(selector_list);
 
-  for (const CSSSelector* relative_selector = selector_list->First();
+  for (const CSSSelector* relative_selector = selector_list->First().data();
        relative_selector;
        relative_selector = CSSSelectorList::Next(*relative_selector)) {
     DCHECK(relative_selector);
@@ -1232,7 +1232,7 @@ void RuleInvalidationDataVisitor<VisitorType>::
 
   DCHECK(pseudo_has.SelectorList());
 
-  for (const CSSSelector* relative = pseudo_has.SelectorList()->First();
+  for (const CSSSelector* relative = pseudo_has.SelectorList()->First().data();
        relative; relative = CSSSelectorList::Next(*relative)) {
     for (const CSSSelector* simple = relative;
          simple->GetPseudoType() != CSSSelector::kPseudoRelativeAnchor;
@@ -1585,7 +1585,7 @@ void RuleInvalidationDataVisitor<VisitorType>::
           simple_selector->GetPseudoType() == CSSSelector::kPseudoNthChild ||
           simple_selector->GetPseudoType() == CSSSelector::kPseudoNthLastChild;
       MarkInvalidationSetsWithinNthChild(
-          *simple_selector->SelectorList()->First(), sub_in_nth_child);
+           simple_selector->SelectorList()->First()[0], sub_in_nth_child);
     }
   }
 }
diff --git a/third_party/blink/renderer/core/css/parser/css_selector_parser.cc b/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
index 94cc1c8d4abe7..89a042fa58302 100644
--- a/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
+++ b/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
@@ -669,7 +669,7 @@ base::span<CSSSelector> CSSSelectorParser::ConsumeRelativeSelector(
 // A return value of CSSNestingType::kScope means that the list
 // contains the :scope selector.
 static CSSNestingType GetNestingTypeForSelectorList(
-    const CSSSelector* selector) {
+    base::span<const CSSSelector>selector) {
   if (selector == nullptr) {
     return CSSNestingType::kNone;
   }
@@ -2602,7 +2602,7 @@ static void RecordUsageAndDeprecationsOneSelector(
     context->Count(WebFeature::kCSSSelectorIndirectAdjacent);
   }
   if (selector->SelectorList()) {
-    for (const CSSSelector* current = selector->SelectorList()->First();
+    for (const CSSSelector* current = selector->SelectorList()->First().data();
          current; current = current->NextSimpleSelector()) {
       RecordUsageAndDeprecationsOneSelector(current, context,
                                             has_visited_pseudo);
diff --git a/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc b/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
index a42fd61d72769..092736eb24312 100644
--- a/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
+++ b/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
@@ -283,7 +283,7 @@ TEST(CSSSelectorParserTest, TransitionPseudoStyles) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    auto* selector = list->First();
+    auto* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -504,7 +504,7 @@ TEST(CSSSelectorParserTest, ScrollControlPseudos) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -550,7 +550,7 @@ TEST(CSSSelectorParserTest, ColumnPseudo) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -749,7 +749,7 @@ TEST(CSSSelectorParserTest, ASCIILowerHTMLStrict) {
     EXPECT_GT(vector.size(), 0u);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     ASSERT_TRUE(selector);
     EXPECT_EQ(AtomicString(test_case.expected), test_case.getter(selector));
   }
@@ -778,7 +778,7 @@ TEST(CSSSelectorParserTest, ASCIILowerHTMLQuirks) {
     EXPECT_GT(vector.size(), 0u);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     ASSERT_TRUE(selector);
     EXPECT_EQ(AtomicString(test_case.expected), test_case.getter(selector));
   }
@@ -1058,7 +1058,7 @@ TEST(CSSSelectorParserTest, ImplicitShadowCrossingCombinators) {
         /*semicolon_aborts_nested_selector=*/false, sheet, arena);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     for (auto sub_expectation : test_case.expectation) {
       ASSERT_TRUE(selector);
       AtomicString selector_value =
@@ -1173,7 +1173,7 @@ static CSSSelectorList* ParseNested(String inner_rule,
                 css_test_helpers::ParseRule(document, "div {}"));
   CSSSelectorList* list = css_test_helpers::ParseSelectorList(
       inner_rule, nesting_type, parent_rule_for_nesting);
-  if (!list || !list->First()) {
+  if (!list || ).empty()) {
     return nullptr;
   }
   return list;
@@ -1188,7 +1188,7 @@ static std::optional<CSSSelector> GetImplicitlyAddedSelector(
   }
 
   Vector<const CSSSelector*> selectors;
-  for (const CSSSelector* selector = list->First(); selector;
+  for (const CSSSelector* selector = list->First().data(); selector;
        selector = selector->NextSimpleSelector()) {
     selectors.push_back(selector);
   }
@@ -1305,7 +1305,7 @@ static HeapVector<CSSSelector> FlattenSelector(const CSSSelector* selector) {
   while (selector) {
     result.push_back(*selector);
     if (const CSSSelectorList* list = selector->SelectorList()) {
-      for (const CSSSelector* s = list->First(); s;
+      for (const CSSSelector* s = list->First().data(); s;
            s = CSSSelectorList::Next(*s)) {
         result.AppendVector(FlattenSelector(s));
       }
@@ -1463,11 +1463,11 @@ TEST_P(IsScopeContainingTest, RefTest) {
       ParseNested(param.selector_text, CSSNestingType::kNone);
   CSSSelectorList* ref_list = ParseNested(ref, CSSNestingType::kNone);
   ASSERT_TRUE(actual_list);
-  ASSERT_TRUE(actual_list->First());
+  ASSERT_TRUE(actual_list->First().data());
   ASSERT_TRUE(ref_list);
-  ASSERT_TRUE(ref_list->First());
-  EXPECT_TRUE(IsScopeContainingComparison(FlattenSelector(actual_list->First()),
-                                          FlattenSelector(ref_list->First())));
+  ASSERT_TRUE(ref_list->First().data());
+  EXPECT_TRUE(IsScopeContainingComparison(FlattenSelector(actual_list->First().data()),
+                                          FlattenSelector(ref_list->First().data())));
 }
 
 TEST(CSSSelectorParserTest, ImplicitSelectorIsScopeContaining) {
diff --git a/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc b/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
index 109593ea32f85..f06d6984961e8 100644
--- a/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
+++ b/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
@@ -64,7 +64,7 @@ TEST_F(SelectorFilterParentScopeTest, ParentScope) {
       CSSSelectorList* selectors =
           CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-      for (const CSSSelector* selector = selectors->First(); selector;
+      for (const CSSSelector* selector = selectors->First().data(); selector;
            selector = CSSSelectorList::Next(*selector)) {
         Vector<uint16_t> selector_hashes;
         filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
@@ -98,7 +98,7 @@ TEST_F(SelectorFilterParentScopeTest, RootScope) {
   CSSSelectorList* selectors =
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-  for (const CSSSelector* selector = selectors->First(); selector;
+  for (const CSSSelector* selector = selectors->First().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     Vector<uint16_t> selector_hashes;
     filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
@@ -172,7 +172,7 @@ TEST_F(SelectorFilterParentScopeTest, AttributeFilter) {
   CSSSelectorList* selectors =
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-  for (const CSSSelector* selector = selectors->First(); selector;
+  for (const CSSSelector* selector = selectors->First().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     Vector<uint16_t> selector_hashes;
     filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
diff --git a/third_party/blink/renderer/core/css/rule_set.cc b/third_party/blink/renderer/core/css/rule_set.cc
index 2a5c7b0688933..95487fc41ea08 100644
--- a/third_party/blink/renderer/core/css/rule_set.cc
+++ b/third_party/blink/renderer/core/css/rule_set.cc
@@ -989,9 +989,9 @@ const StyleRule* FindParentIfUsed(const CSSSelector* selector) {
         selector->GetPseudoType() == CSSSelector::kPseudoParent) {
       return selector->ParentRule();
     }
-    if (selector->SelectorList() && selector->SelectorList()->First()) {
+    if (selector->SelectorList() && !selector->SelectorList()->First().empty()) {
       const StyleRule* parent =
-          FindParentIfUsed(selector->SelectorList()->First());
+          FindParentIfUsed(selector->SelectorList()->First().data());
       if (parent != nullptr) {
         return parent;
       }
diff --git a/third_party/blink/renderer/core/css/selector_checker.cc b/third_party/blink/renderer/core/css/selector_checker.cc
index 0b337ef3df08e..b031b51d897c7 100644
--- a/third_party/blink/renderer/core/css/selector_checker.cc
+++ b/third_party/blink/renderer/core/css/selector_checker.cc
@@ -978,7 +978,7 @@ ALWAYS_INLINE bool SelectorChecker::CheckOne(
 
 bool SelectorChecker::CheckPseudoNot(const SelectorCheckingContext& context,
                                      MatchResult& result) const {
-  return !MatchesAnyInList(context, context.selector->SelectorList()->First(),
+  return !MatchesAnyInList(context, context.selector->SelectorList()->First().data(),
                            result);
 }
 
@@ -1456,7 +1456,7 @@ bool SelectorChecker::CheckPseudoHas(const SelectorCheckingContext& context,
   }
 
   DCHECK(context.selector->SelectorList());
-  for (const CSSSelector* selector = context.selector->SelectorList()->First();
+  for (const CSSSelector* selector = context.selector->SelectorList()->First().data();
        selector; selector = CSSSelectorList::Next(*selector)) {
     CheckPseudoHasArgumentContext argument_context(selector, context.scope,
                                                    match_in_shadow_tree);
@@ -1713,7 +1713,7 @@ bool SelectorChecker::CheckPseudoClass(const SelectorCheckingContext& context,
         // Check if the element itself matches the of selector.
         // Note that this will also propagate the correct MatchResult flags,
         // so NthIndexCache does not have to do that.
-        if (!MatchesAnyInList(context, selector.SelectorList()->First(),
+        if (!MatchesAnyInList(context, selector.SelectorList()->First().data(),
                               result)) {
           return false;
         }
@@ -1739,7 +1739,7 @@ bool SelectorChecker::CheckPseudoClass(const SelectorCheckingContext& context,
       }
       if (selector.SelectorList()) {
         // Check if the element itself matches the of selector.
-        if (!MatchesAnyInList(context, selector.SelectorList()->First(),
+        if (!MatchesAnyInList(context, selector.SelectorList()->First().data(),
                               result)) {
           return false;
         }
@@ -2475,7 +2475,7 @@ bool SelectorChecker::CheckPseudoElement(const SelectorCheckingContext& context,
       sub_context.scope = nullptr;
       sub_context.tree_scope = nullptr;
 
-      for (sub_context.selector = selector.SelectorList()->First();
+      for (sub_context.selector = selector.SelectorList()->First().data();
            sub_context.selector; sub_context.selector = CSSSelectorList::Next(
                                      *sub_context.selector)) {
         SubResult sub_result(result);
@@ -2523,9 +2523,9 @@ bool SelectorChecker::CheckPseudoElement(const SelectorCheckingContext& context,
       sub_context.tree_scope = nullptr;
 
       // ::slotted() only allows one compound selector.
-      DCHECK(selector.SelectorList()->First());
+      DCHECK(!selector.SelectorList()->First().empty());
       DCHECK(!CSSSelectorList::Next(*selector.SelectorList()->First()));
-      sub_context.selector = selector.SelectorList()->First();
+      sub_context.selector = selector.SelectorList()->First().data();
       SubResult sub_result(result);
       if (MatchSelector(sub_context, sub_result) != kSelectorMatches) {
         return false;
@@ -2685,7 +2685,7 @@ bool SelectorChecker::CheckPseudoHost(const SelectorCheckingContext& context,
 
   SelectorCheckingContext sub_context(context);
   sub_context.is_sub_selector = true;
-  sub_context.selector = selector.SelectorList()->First();
+  sub_context.selector = selector.SelectorList()->First().data();
 
   // "When evaluated in the context of a shadow tree, it matches the shadow
   //  trees shadow host if the shadow host, **in its normal context**,
diff --git a/third_party/blink/renderer/core/css/selector_checker_test.cc b/third_party/blink/renderer/core/css/selector_checker_test.cc
index b9d3f086e3df3..0ba1f4b408960 100644
--- a/third_party/blink/renderer/core/css/selector_checker_test.cc
+++ b/third_party/blink/renderer/core/css/selector_checker_test.cc
@@ -323,7 +323,7 @@ TEST_P(MatchFlagsTest, All) {
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{
       ElementResolveContext(*element)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
 
   SelectorChecker::MatchResult result;
   checker.Match(context, result);
@@ -374,7 +374,7 @@ class ImpactTest : public PageTestBase {
     SelectorChecker checker(SelectorChecker::kResolvingStyle);
     SelectorChecker::SelectorCheckingContext context{
         ElementResolveContext(element)};
-    context.selector = selector_list->First();
+    context.selector = selector_list->First().data();
     context.impact = impact;
 
     SelectorChecker::MatchResult result;
@@ -692,7 +692,7 @@ TEST_P(MatchFlagsShadowTest, Host) {
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{
       ElementResolveContext(*host)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
   context.scope = host->GetShadowRoot();
   context.tree_scope = host->GetShadowRoot();
 
@@ -916,14 +916,14 @@ TEST_F(SelectorCheckerTest, PseudoScopeWithoutScope) {
   CSSSelectorList* selector_list =
       css_test_helpers::ParseSelectorList(":scope #foo");
   ASSERT_TRUE(selector_list);
-  ASSERT_TRUE(selector_list->First());
+  ASSERT_TRUE(selector_list->First().data());
 
   Element* foo = GetDocument().getElementById(AtomicString("foo"));
   ASSERT_TRUE(foo);
 
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{ElementResolveContext(*foo)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
   // We have a selector with :scope, but no context.scope:
   context.scope = nullptr;
 
diff --git a/third_party/blink/renderer/core/css/selector_query.cc b/third_party/blink/renderer/core/css/selector_query.cc
index 1d2f04c920a31..2f3523e79c4ad 100644
--- a/third_party/blink/renderer/core/css/selector_query.cc
+++ b/third_party/blink/renderer/core/css/selector_query.cc
@@ -579,7 +579,7 @@ SelectorQuery::SelectorQuery(CSSSelectorList* selector_list)
       selector_id_is_rightmost_(true),
       selector_id_affected_by_sibling_combinator_(false),
       use_slow_scan_(true) {
-  const CSSSelector* base = selector_list_->First();
+  const CSSSelector* base = selector_list_->First().data();
   for (const CSSSelector* selector = base; selector;
        selector = CSSSelectorList::Next(*selector)) {
     if (selector->MatchesPseudoElement()) {
diff --git a/third_party/blink/renderer/core/css/style_rule.h b/third_party/blink/renderer/core/css/style_rule.h
index de08b37a1f901..d297bb4a42a79 100644
--- a/third_party/blink/renderer/core/css/style_rule.h
+++ b/third_party/blink/renderer/core/css/style_rule.h
@@ -320,7 +320,7 @@ class CORE_EXPORT StyleRule : public StyleRuleBase {
   CSSSelector* SelectorArray() {
     return reinterpret_cast<CSSSelector*>(
         base::bits::AlignUp(UNSAFE_TODO(reinterpret_cast<uint8_t*>(this + 1)),
-                            alignof(CSSSelector)));
+                            alignof(CSSSelector)).data());
   }
   const CSSSelector* SelectorArray() const {
     return const_cast<StyleRule*>(this)->SelectorArray();
@@ -467,7 +467,7 @@ class StyleRulePage : public StyleRuleGroup {
                 HeapVector<Member<StyleRuleBase>> child_rules);
   StyleRulePage(const StyleRulePage&);
 
-  const CSSSelector* Selector() const { return selector_list_->First(); }
+  const CSSSelector* Selector() const { return selector_list_->First().data(); }
   const CSSPropertyValueSet& Properties() const { return *properties_; }
   MutableCSSPropertyValueSet& MutableProperties();
 
diff --git a/third_party/blink/renderer/core/css/style_rule_test.cc b/third_party/blink/renderer/core/css/style_rule_test.cc
index 12993799666df..38e2785be2a75 100644
--- a/third_party/blink/renderer/core/css/style_rule_test.cc
+++ b/third_party/blink/renderer/core/css/style_rule_test.cc
@@ -30,7 +30,7 @@ const CSSSelector* FindPseudoSelector(const CSSSelector* selector,
       return s;
     }
     if (s->SelectorList()) {
-      for (const CSSSelector* complex = s->SelectorList()->First(); complex;
+      for (const CSSSelector* complex = s->SelectorList()->First().data(); complex;
            complex = CSSSelectorList::Next(*complex)) {
         if (const CSSSelector* parent =
                 FindPseudoSelector(complex, pseudo_type)) {
diff --git a/third_party/blink/renderer/core/css/style_scope.cc b/third_party/blink/renderer/core/css/style_scope.cc
index b491b1da8492c..31f33044f0893 100644
--- a/third_party/blink/renderer/core/css/style_scope.cc
+++ b/third_party/blink/renderer/core/css/style_scope.cc
@@ -56,7 +56,7 @@ const CSSSelector* StyleScope::From() const {
 
 const CSSSelector* StyleScope::To() const {
   if (to_) {
-    return to_->First();
+    return to_->First().data();
   }
   return nullptr;
 }
diff --git a/third_party/blink/renderer/core/dom/nth_index_cache.cc b/third_party/blink/renderer/core/dom/nth_index_cache.cc
index 226b3fa349f9d..970262b7cd24d 100644
--- a/third_party/blink/renderer/core/dom/nth_index_cache.cc
+++ b/third_party/blink/renderer/core/dom/nth_index_cache.cc
@@ -99,7 +99,7 @@ bool NthIndexCache::MatchesFilter(
   sub_context.is_sub_selector = true;
   sub_context.in_nested_complex_selector = true;
   sub_context.pseudo_id = kPseudoIdNone;
-  for (sub_context.selector = filter->First(); sub_context.selector;
+  for (sub_context.selector = filter->First().data(); sub_context.selector;
        sub_context.selector = CSSSelectorList::Next(*sub_context.selector)) {
     // NOTE: We don't want to propagate match_result up to the parent;
     // the correct flags were already set when the caller tested that
diff --git a/third_party/blink/renderer/core/exported/web_selector.cc b/third_party/blink/renderer/core/exported/web_selector.cc
index 9d84376556386..fec3a20279a5d 100644
--- a/third_party/blink/renderer/core/exported/web_selector.cc
+++ b/third_party/blink/renderer/core/exported/web_selector.cc
@@ -60,7 +60,7 @@ WebString CanonicalizeSelector(WebString web_selector,
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
   if (restriction == kWebSelectorTypeCompound) {
-    for (const CSSSelector* selector = selector_list->First(); selector;
+    for (const CSSSelector* selector = selector_list->First().data(); selector;
          selector = selector_list->Next(*selector)) {
       if (!selector->IsCompound())
         return {};
diff --git a/third_party/blink/renderer/core/layout/physical_box_fragment.h b/third_party/blink/renderer/core/layout/physical_box_fragment.h
index 3c74e177a18cf..fa3ca2fa5bc77 100644
--- a/third_party/blink/renderer/core/layout/physical_box_fragment.h
+++ b/third_party/blink/renderer/core/layout/physical_box_fragment.h
@@ -680,7 +680,7 @@ class CORE_EXPORT PhysicalBoxFragment final : public PhysicalFragment {
     // TODO(crbug.com/351564777): Resolve a buffer safety issue.
     return reinterpret_cast<const FragmentItems*>(base::bits::AlignUp(
         reinterpret_cast<const uint8_t*>(UNSAFE_TODO(this + 1)),
-        alignof(FragmentItems)));
+        alignof(FragmentItems)).data());
   }
 
   void SetInkOverflow(const PhysicalRect& self, const PhysicalRect& contents);
diff --git a/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc b/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
index 45ca71cfb90aa..62702596b0838 100644
--- a/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
+++ b/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
@@ -67,7 +67,7 @@ void GamepadSharedMemoryReader::Start(blink::GamepadListener* listener) {
   renderer_shared_buffer_mapping_ = renderer_shared_buffer_region_.Map();
   CHECK(renderer_shared_buffer_mapping_.IsValid());
   gamepad_hardware_buffer_ = renderer_shared_buffer_mapping_
-                                 .GetMemoryAs<device::GamepadHardwareBuffer>();
+                                 .GetMemoryAs<device::GamepadHardwareBuffer>().data();
   CHECK(gamepad_hardware_buffer_);
 }
 
diff --git a/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc b/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
index 353758cfdadc6..d8e478dee1d35 100644
--- a/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
+++ b/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
@@ -209,11 +209,11 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
 
       libyuv::NV12ToI420(
           y_plane, y_stride, uv_plane, uv_stride,
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           i420_frame->stride(media::VideoFrame::Plane::kY),
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           i420_frame->stride(media::VideoFrame::Plane::kU),
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           i420_frame->stride(media::VideoFrame::Plane::kV),
           original_size.width(), original_size.height());
     } else {
@@ -259,28 +259,28 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
       }();
 
       libyuv::I420Rotate(
-          i420_frame->visible_data(media::VideoFrame::Plane::kY),
+          i420_frame->visible_data(media::VideoFrame::Plane::kY).data(),
           i420_frame->stride(media::VideoFrame::Plane::kY),
-          i420_frame->visible_data(media::VideoFrame::Plane::kU),
+          i420_frame->visible_data(media::VideoFrame::Plane::kU).data(),
           i420_frame->stride(media::VideoFrame::Plane::kU),
-          i420_frame->visible_data(media::VideoFrame::Plane::kV),
+          i420_frame->visible_data(media::VideoFrame::Plane::kV).data(),
           i420_frame->stride(media::VideoFrame::Plane::kV),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kY),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kU),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kV),
           original_size.width(), original_size.height(), libyuv_rotate);
       i420_frame = std::move(rotated_frame);
     }
 
     libyuv::ConvertFromI420(
-        i420_frame->visible_data(media::VideoFrame::Plane::kY),
+        i420_frame->visible_data(media::VideoFrame::Plane::kY).data(),
         i420_frame->stride(media::VideoFrame::Plane::kY),
-        i420_frame->visible_data(media::VideoFrame::Plane::kU),
+        i420_frame->visible_data(media::VideoFrame::Plane::kU).data(),
         i420_frame->stride(media::VideoFrame::Plane::kU),
-        i420_frame->visible_data(media::VideoFrame::Plane::kV),
+        i420_frame->visible_data(media::VideoFrame::Plane::kV).data(),
         i420_frame->stride(media::VideoFrame::Plane::kV), destination_plane,
         destination_stride, destination_width, destination_height,
         destination_pixel_format);
@@ -289,7 +289,7 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
       DCHECK(!info.isOpaque());
       // This function copies any plane into the alpha channel of an ARGB image.
       libyuv::ARGBCopyYToAlpha(
-          i420_frame->visible_data(media::VideoFrame::Plane::kA),
+          i420_frame->visible_data(media::VideoFrame::Plane::kA).data(),
           i420_frame->stride(media::VideoFrame::Plane::kA), destination_plane,
           destination_stride, destination_width, destination_height);
     }
diff --git a/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc b/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
index 200aab8334b1e..7a87299db7aa1 100644
--- a/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
+++ b/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler.h"
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/run_loop.h"
 #include "base/test/gmock_callback_support.h"
@@ -136,17 +137,17 @@ class CanvasCaptureHandlerTest
     const gfx::Size& size = video_frame->visible_rect().size();
     EXPECT_EQ(expected_width, size.width());
     EXPECT_EQ(expected_height, size.height());
-    const uint8_t* y_plane =
+    base::span<const uint8_t>y_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kY);
     EXPECT_NEAR(74, y_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
-    const uint8_t* u_plane =
+    base::span<const uint8_t>u_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kU);
     EXPECT_NEAR(193, u_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
-    const uint8_t* v_plane =
+    base::span<const uint8_t>v_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kV);
     EXPECT_NEAR(105, v_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
     if (!opaque) {
-      const uint8_t* a_plane =
+      base::span<const uint8_t>a_plane =
           video_frame->visible_data(media::VideoFrame::Plane::kA);
       EXPECT_EQ(kTestAlphaValue, a_plane[0]);
     }
diff --git a/third_party/blink/renderer/modules/mediarecorder/vea_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/vea_encoder.cc
index 2db87ff6c9578..b2bcd1c226d90 100644
--- a/third_party/blink/renderer/modules/mediarecorder/vea_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/vea_encoder.cc
@@ -237,17 +237,17 @@ void VEAEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
       return;
     }
     libyuv::I420Copy(
-        frame->visible_data(media::VideoFrame::Plane::kY),
+        frame->visible_data(media::VideoFrame::Plane::kY).data(),
         frame->stride(media::VideoFrame::Plane::kY),
-        frame->visible_data(media::VideoFrame::Plane::kU),
+        frame->visible_data(media::VideoFrame::Plane::kU).data(),
         frame->stride(media::VideoFrame::Plane::kU),
-        frame->visible_data(media::VideoFrame::Plane::kV),
+        frame->visible_data(media::VideoFrame::Plane::kV).data(),
         frame->stride(media::VideoFrame::Plane::kV),
-        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
         video_frame->stride(media::VideoFrame::Plane::kY),
-        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
         video_frame->stride(media::VideoFrame::Plane::kU),
-        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+        video_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
         video_frame->stride(media::VideoFrame::Plane::kV),
         input_visible_size_.width(), input_visible_size_.height());
     video_frame->BackWithSharedMemory(&input_buffer->region);
diff --git a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
index f81c05f136654..9e7033b658c8e 100644
--- a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
@@ -691,11 +691,11 @@ VideoTrackRecorderImpl::Encoder::MaybeProvideEncodableFrame(
     if (libyuv::ConvertToI420(
             static_cast<uint8_t*>(pixmap.writable_addr()),
             pixmap.computeByteSize(),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
             frame->stride(media::VideoFrame::Plane::kY),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
             frame->stride(media::VideoFrame::Plane::kU),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
             frame->stride(media::VideoFrame::Plane::kV), 0 /* crop_x */,
             0 /* crop_y */, pixmap.width(), pixmap.height(),
             old_visible_size.width(), old_visible_size.height(),
@@ -708,7 +708,7 @@ VideoTrackRecorderImpl::Encoder::MaybeProvideEncodableFrame(
       libyuv::ARGBExtractAlpha(
           static_cast<uint8_t*>(pixmap.writable_addr()),
           static_cast<int>(pixmap.rowBytes()) /* stride */,
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kA),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kA).data(),
           frame->stride(media::VideoFrame::Plane::kA), pixmap.width(),
           pixmap.height());
     }
@@ -740,12 +740,12 @@ VideoTrackRecorderImpl::Encoder::ConvertToI420ForSoftwareEncoder(
       media::VideoPixelFormat::PIXEL_FORMAT_I420, frame->coded_size(),
       frame->visible_rect(), frame->natural_size(), frame->timestamp());
   auto ret = libyuv::NV12ToI420(
-      frame->data(0), frame->stride(0), frame->data(1), frame->stride(1),
-      i420_frame->writable_data(media::VideoFrame::Plane::kY),
+      frame->data(0).data(), frame->stride(0), frame->data(1).data(), frame->stride(1),
+      i420_frame->writable_data(media::VideoFrame::Plane::kY).data(),
       i420_frame->stride(media::VideoFrame::Plane::kY),
-      i420_frame->writable_data(media::VideoFrame::Plane::kU),
+      i420_frame->writable_data(media::VideoFrame::Plane::kU).data(),
       i420_frame->stride(media::VideoFrame::Plane::kU),
-      i420_frame->writable_data(media::VideoFrame::Plane::kV),
+      i420_frame->writable_data(media::VideoFrame::Plane::kV).data(),
       i420_frame->stride(media::VideoFrame::Plane::kV),
       frame->coded_size().width(), frame->coded_size().height());
   if (ret) {
diff --git a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
index 4ac6529a62959..1f5a8f1c1f7e9 100644
--- a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
@@ -378,9 +378,9 @@ class VideoTrackRecorderTest : public VideoTrackRecorderTestBase {
     // Fade to black.
     const uint8_t kBlackY = 0x00;
     const uint8_t kBlackUV = 0x80;
-    memset(video_frame2->writable_data(0), kBlackY,
+    memset(video_frame2->writable_data(0).data(), kBlackY,
            video_frame2->stride(0) * frame_size.height());
-    memset(video_frame2->writable_data(1), kBlackUV,
+    memset(video_frame2->writable_data(1).data(), kBlackUV,
            video_frame2->stride(1) * (frame_size.height() / 2));
     if (frame_type == TestFrameType::kNv12GpuMemoryBuffer) {
       return video_frame;
diff --git a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
index 536a881f88332..bf15e26e0d741 100644
--- a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
@@ -91,10 +91,10 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
   switch (frame->format()) {
     case media::PIXEL_FORMAT_NV12: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kY),
+      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY).data(),
+               frame->visible_data(VideoFrame::Plane::kY).data(),
                frame->stride(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kUV),
+               frame->visible_data(VideoFrame::Plane::kUV).data(),
                frame->stride(VideoFrame::Plane::kUV),
                UNSAFE_TODO(frame->visible_data(VideoFrame::Plane::kUV) + 1),
                frame->stride(VideoFrame::Plane::kUV), duration, force_keyframe,
@@ -103,12 +103,12 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
     }
     case media::PIXEL_FORMAT_I420: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kY),
+      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY).data(),
+               frame->visible_data(VideoFrame::Plane::kY).data(),
                frame->stride(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kU),
+               frame->visible_data(VideoFrame::Plane::kU).data(),
                frame->stride(VideoFrame::Plane::kU),
-               frame->visible_data(VideoFrame::Plane::kV),
+               frame->visible_data(VideoFrame::Plane::kV).data(),
                frame->stride(VideoFrame::Plane::kV), duration, force_keyframe,
                &output_data, /*is_alpha=*/false, VPX_IMG_FMT_I420);
       break;
@@ -143,12 +143,12 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
       force_keyframe = force_keyframe || !last_frame_had_alpha_;
       last_frame_had_alpha_ = true;
 
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kY),
+      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::Plane::kY).data(),
+               frame->visible_data(VideoFrame::Plane::kY).data(),
                frame->stride(VideoFrame::Plane::kY),
-               frame->visible_data(VideoFrame::Plane::kU),
+               frame->visible_data(VideoFrame::Plane::kU).data(),
                frame->stride(VideoFrame::Plane::kU),
-               frame->visible_data(VideoFrame::Plane::kV),
+               frame->visible_data(VideoFrame::Plane::kV).data(),
                frame->stride(VideoFrame::Plane::kV), duration, force_keyframe,
                &output_data, /*is_alpha=*/false, VPX_IMG_FMT_I420);
 
@@ -157,8 +157,8 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
       }
       bool alpha_force_keyframe = output_data->is_key_frame();
       DoEncode(alpha_encoder_.get(), frame_size,
-               frame->data(VideoFrame::Plane::kA),
-               frame->visible_data(VideoFrame::Plane::kA),
+               frame->data(VideoFrame::Plane::kA).data(),
+               frame->visible_data(VideoFrame::Plane::kA).data(),
                frame->stride(VideoFrame::Plane::kA), alpha_dummy_planes_.data(),
                base::checked_cast<int>(u_plane_stride_),
                UNSAFE_TODO(alpha_dummy_planes_.data() + v_plane_offset_),
diff --git a/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc b/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
index df8a5d4a4e362..9b96968fa3880 100644
--- a/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
+++ b/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
@@ -127,41 +127,41 @@ scoped_refptr<media::VideoFrame> CopyFrame(
     }
 
     if (frame->format() == media::PIXEL_FORMAT_NV12) {
-      libyuv::NV12Copy(frame->data(media::VideoFrame::Plane::kY),
+      libyuv::NV12Copy(frame->data(media::VideoFrame::Plane::kY).data(),
                        frame->stride(media::VideoFrame::Plane::kY),
-                       frame->data(media::VideoFrame::Plane::kUV),
+                       frame->data(media::VideoFrame::Plane::kUV).data(),
                        frame->stride(media::VideoFrame::Plane::kUV),
-                       new_frame->writable_data(media::VideoFrame::Plane::kY),
+                       new_frame->writable_data(media::VideoFrame::Plane::kY).data(),
                        new_frame->stride(media::VideoFrame::Plane::kY),
-                       new_frame->writable_data(media::VideoFrame::Plane::kUV),
+                       new_frame->writable_data(media::VideoFrame::Plane::kUV).data(),
                        new_frame->stride(media::VideoFrame::Plane::kUV),
                        coded_size.width(), coded_size.height());
     } else if (frame->format() == media::PIXEL_FORMAT_ARGB) {
       libyuv::ARGBCopy(
-          frame->data(media::VideoFrame::Plane::kARGB),
+          frame->data(media::VideoFrame::Plane::kARGB).data(),
           frame->stride(media::VideoFrame::Plane::kARGB),
-          new_frame->writable_data(media::VideoFrame::Plane::kARGB),
+          new_frame->writable_data(media::VideoFrame::Plane::kARGB).data(),
           new_frame->stride(media::VideoFrame::Plane::kARGB),
           coded_size.width(), coded_size.height());
     } else {
-      libyuv::I420Copy(frame->data(media::VideoFrame::Plane::kY),
+      libyuv::I420Copy(frame->data(media::VideoFrame::Plane::kY).data(),
                        frame->stride(media::VideoFrame::Plane::kY),
-                       frame->data(media::VideoFrame::Plane::kU),
+                       frame->data(media::VideoFrame::Plane::kU).data(),
                        frame->stride(media::VideoFrame::Plane::kU),
-                       frame->data(media::VideoFrame::Plane::kV),
+                       frame->data(media::VideoFrame::Plane::kV).data(),
                        frame->stride(media::VideoFrame::Plane::kV),
-                       new_frame->writable_data(media::VideoFrame::Plane::kY),
+                       new_frame->writable_data(media::VideoFrame::Plane::kY).data(),
                        new_frame->stride(media::VideoFrame::Plane::kY),
-                       new_frame->writable_data(media::VideoFrame::Plane::kU),
+                       new_frame->writable_data(media::VideoFrame::Plane::kU).data(),
                        new_frame->stride(media::VideoFrame::Plane::kU),
-                       new_frame->writable_data(media::VideoFrame::Plane::kV),
+                       new_frame->writable_data(media::VideoFrame::Plane::kV).data(),
                        new_frame->stride(media::VideoFrame::Plane::kV),
                        coded_size.width(), coded_size.height());
     }
     if (frame->format() == media::PIXEL_FORMAT_I420A) {
-      libyuv::CopyPlane(frame->data(media::VideoFrame::Plane::kA),
+      libyuv::CopyPlane(frame->data(media::VideoFrame::Plane::kA).data(),
                         frame->stride(media::VideoFrame::Plane::kA),
-                        new_frame->writable_data(media::VideoFrame::Plane::kA),
+                        new_frame->writable_data(media::VideoFrame::Plane::kA).data(),
                         new_frame->stride(media::VideoFrame::Plane::kA),
                         coded_size.width(), coded_size.height());
     }
diff --git a/third_party/blink/renderer/modules/webcodecs/background_readback.cc b/third_party/blink/renderer/modules/webcodecs/background_readback.cc
index 63e88befd23af..7fabe58b33017 100644
--- a/third_party/blink/renderer/modules/webcodecs/background_readback.cc
+++ b/third_party/blink/renderer/modules/webcodecs/background_readback.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webcodecs/background_readback.h"
 
+#include "base/containers/span.h"
 #include "base/feature_list.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/task/bind_post_task.h"
@@ -200,7 +201,7 @@ void BackgroundReadback::ReadbackRGBTextureBackedFrameToMemory(
       "media", "ReadbackRGBTextureBackedFrameToMemory", txt_frame.get(),
       "timestamp", txt_frame->timestamp());
 
-  uint8_t* dst_pixels =
+  base::span<uint8_t>dst_pixels =
       result->GetWritableVisibleData(media::VideoFrame::Plane::kARGB);
   int rgba_stide = result->stride(media::VideoFrame::Plane::kARGB);
   DCHECK_GT(rgba_stide, 0);
@@ -266,7 +267,7 @@ void BackgroundReadback::ReadbackRGBTextureBackedFrameToBuffer(
   uint32_t offset = dest_layout.Offset(0);
   uint32_t stride = dest_layout.Stride(0);
 
-  uint8_t* dst_pixels = dest_buffer.subspan(offset).data();
+  base::span<uint8_t>dst_pixels = dest_buffer.subspan(offset);
   size_t max_bytes_written = stride * src_rect.height();
   if (stride <= 0 || max_bytes_written > dest_buffer.size()) {
     DLOG(ERROR) << "Buffer is not sufficiently large for readback";
diff --git a/third_party/blink/renderer/modules/webcodecs/video_decoder.cc b/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
index 8584d9c3dde19..afa0b23e910b6 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
@@ -204,7 +204,7 @@ void ParseH265KeyFrame(const media::DecoderBuffer& buffer, bool* is_key_frame) {
 #if BUILDFLAG(USE_PROPRIETARY_CODECS)
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
   auto result = media::mp4::HEVC::AnalyzeAnnexB(
-      buffer.data(), buffer.size(), std::vector<media::SubsampleEntry>());
+      buffer, buffer.size(), std::vector<media::SubsampleEntry>());
   *is_key_frame = result.is_keyframe.value_or(false);
 #endif  // BUILDFLAG(ENABLE_PLATFORM_HEVC)
 #endif  // BUILDFLAG(USE_PROPRIETARY_CODECS)
diff --git a/third_party/blink/renderer/modules/webcodecs/video_frame.cc b/third_party/blink/renderer/modules/webcodecs/video_frame.cc
index 1b4e7e65cb136..98970782dd60b 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_frame.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_frame.cc
@@ -1058,8 +1058,8 @@ VideoFrame* VideoFrame::Create(ScriptState* script_state,
     }
 
     for (wtf_size_t i = 0; i < media::VideoFrame::NumPlanes(media_fmt); i++) {
-      libyuv::CopyPlane(src_frame->visible_data(i), src_frame->stride(i),
-                        frame->GetWritableVisibleData(i), frame->stride(i),
+      libyuv::CopyPlane(src_frame->visible_data(i).data(), src_frame->stride(i),
+                        frame->GetWritableVisibleData(i).data(), frame->stride(i),
                         frame->row_bytes(i), frame->rows(i));
     }
   }
diff --git a/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc b/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
index 8b0aea63f6a66..500e2d22856ad 100644
--- a/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
+++ b/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
@@ -112,7 +112,7 @@ std::vector<scoped_refptr<media::DecoderBuffer>> ReadIVF(const std::string& fnam
   media::IvfParser ivf_parser;
   media::IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
 
   std::vector<scoped_refptr<media::DecoderBuffer>> buffers;
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
index 9fc17b5ccb04e..f841e4012c633 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
@@ -195,7 +195,7 @@ class RefCountedWritableSharedMemoryMapping
     return static_cast<const unsigned char*>(mapping_.memory());
   }
   unsigned char* front() {
-    return static_cast<unsigned char*>(mapping_.memory());
+    return static_cast<unsigned char*>(mapping_.memory().data());
   }
   size_t size() const { return mapping_.size(); }
 
@@ -2110,7 +2110,7 @@ RTCVideoEncoder::Impl::CreateI420SharedMemoryFrameByLibyuv(
   auto frame = media::VideoFrame::WrapExternalData(
       media::PIXEL_FORMAT_I420, input_frame_coded_size_,
       gfx::Rect(input_visible_size_), input_visible_size_,
-      static_cast<uint8_t*>(mapping.memory()), mapping.size(),
+      static_cast<uint8_t*>(mapping.memory().data()), mapping.size(),
       base::TimeDelta());
   if (!frame) {
     NotifyErrorStatus({media::EncoderStatus::Codes::kEncoderFailedEncode,
@@ -2129,11 +2129,11 @@ RTCVideoEncoder::Impl::CreateI420SharedMemoryFrameByLibyuv(
           i420_buffer->DataY(), i420_buffer->StrideY(), i420_buffer->DataU(),
           i420_buffer->StrideU(), i420_buffer->DataV(), i420_buffer->StrideV(),
           i420_buffer->width(), i420_buffer->height(),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           frame->stride(media::VideoFrame::Plane::kY),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           frame->stride(media::VideoFrame::Plane::kU),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           frame->stride(media::VideoFrame::Plane::kV),
           frame->visible_rect().width(), frame->visible_rect().height(),
           libyuv::kFilterBox)) {
diff --git a/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc b/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
index a03e648781a9c..6fe0362573b14 100644
--- a/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
+++ b/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -121,7 +124,7 @@ struct VideoCaptureImpl::BufferContext
   BufferContext& operator=(const BufferContext&) = delete;
 
   VideoFrameBufferHandleType buffer_type() const { return buffer_type_; }
-  const uint8_t* data() const { return data_; }
+  const base::span<uint8_t> data() const { return data_; }
   size_t data_size() const { return data_size_; }
   const base::ReadOnlySharedMemoryRegion* read_only_shmem_region() const {
     return &read_only_shmem_region_;
@@ -197,15 +200,15 @@ struct VideoCaptureImpl::BufferContext
     DCHECK(region.IsValid());
     backup_mapping_ = region.Map();
     DCHECK(backup_mapping_.IsValid());
-    data_ = backup_mapping_.GetMemoryAsSpan<uint8_t>().data();
+    data_ = backup_mapping_.GetMemoryAsSpan<uint8_t>();
     data_size_ = backup_mapping_.size();
   }
 
   void ResetPreMapping() {
     // If it's already mapped previously, then reset the mapping.
-    if (backup_mapping_.IsValid() || data_) {
+    if (backup_mapping_.IsValid() || !data_.empty()) {
       backup_mapping_ = base::WritableSharedMemoryMapping();
-      data_ = nullptr;
+      data_ = {};
       data_size_ = 0;
     }
   }
@@ -216,7 +219,7 @@ struct VideoCaptureImpl::BufferContext
     DCHECK(region.IsValid());
     read_only_mapping_ = region.Map();
     DCHECK(read_only_mapping_.IsValid());
-    data_ = read_only_mapping_.GetMemoryAsSpan<uint8_t>().data();
+    data_ = read_only_mapping_.GetMemoryAsSpan<uint8_t>();
     data_size_ = read_only_mapping_.size();
     read_only_shmem_region_ = std::move(region);
   }
@@ -264,7 +267,7 @@ struct VideoCaptureImpl::BufferContext
 
   // These point into one of the above mappings, which hold the mapping open for
   // the lifetime of this object.
-  raw_ptr<const uint8_t> data_ = nullptr;
+  base::raw_span<const uint8_t> data_ = nullptr;
   size_t data_size_ = 0;
 
   // Only valid for |buffer_type_ == SHARED_IMAGE_HANDLE|.
@@ -312,24 +315,24 @@ bool VideoCaptureImpl::ProcessBuffer(
             (media::VideoFrame::NumPlanes(
                  video_frame_init_data.ready_buffer->info->pixel_format) == 3))
             << "Currently, only YUV formats support custom strides.";
-        uint8_t* y_data = const_cast<uint8_t*>(buffer_context->data());
-        uint8_t* u_data =
-            y_data +
+        base::span<uint8_t>y_data = const_cast<uint8_t*>(buffer_context->data());
+        base::span<uint8_t>u_data =
+            y_data .subspan(
             (media::VideoFrame::Rows(
                  media::VideoFrame::Plane::kY,
                  video_frame_init_data.ready_buffer->info->pixel_format,
                  video_frame_init_data.ready_buffer->info->coded_size
                      .height()) *
-             video_frame_init_data.ready_buffer->info->strides
+             video_frame_init_data).ready_buffer->info->strides
                  ->stride_by_plane[0]);
         uint8_t* v_data =
-            u_data +
+            u_data .subspan(
             (media::VideoFrame::Rows(
                  media::VideoFrame::Plane::kU,
                  video_frame_init_data.ready_buffer->info->pixel_format,
                  video_frame_init_data.ready_buffer->info->coded_size
                      .height()) *
-             video_frame_init_data.ready_buffer->info->strides
+             video_frame_init_data).data().ready_buffer->info->strides
                  ->stride_by_plane[1]);
         video_frame_init_data.frame = media::VideoFrame::WrapExternalYuvData(
             video_frame_init_data.ready_buffer->info->pixel_format,
@@ -342,7 +345,7 @@ bool VideoCaptureImpl::ProcessBuffer(
                 ->stride_by_plane[1],
             video_frame_init_data.ready_buffer->info->strides
                 ->stride_by_plane[2],
-            y_data, u_data, v_data,
+            y_data.data(), u_data.data(), v_data,
             video_frame_init_data.ready_buffer->info->timestamp);
       } else {
         video_frame_init_data.frame = media::VideoFrame::WrapExternalData(
@@ -350,7 +353,7 @@ bool VideoCaptureImpl::ProcessBuffer(
             gfx::Size(video_frame_init_data.ready_buffer->info->coded_size),
             gfx::Rect(video_frame_init_data.ready_buffer->info->visible_rect),
             video_frame_init_data.ready_buffer->info->visible_rect.size(),
-            const_cast<uint8_t*>(buffer_context->data()),
+            const_cast<uint8_t*>(buffer_context->data().data()),
             buffer_context->data_size(),
             video_frame_init_data.ready_buffer->info->timestamp);
       }
@@ -364,7 +367,7 @@ bool VideoCaptureImpl::ProcessBuffer(
               gfx::Size(video_frame_init_data.ready_buffer->info->coded_size),
               gfx::Rect(video_frame_init_data.ready_buffer->info->visible_rect),
               video_frame_init_data.ready_buffer->info->visible_rect.size(),
-              const_cast<uint8_t*>(buffer_context->data()),
+              const_cast<uint8_t*>(buffer_context->data().data()),
               buffer_context->data_size(),
               video_frame_init_data.ready_buffer->info->timestamp);
       frame->BackWithSharedMemory(buffer_context->read_only_shmem_region());
diff --git a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
index 7b0919ad36a4b..f3462389a8a69 100644
--- a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
+++ b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
@@ -54,15 +54,15 @@ class I420FrameAdapter : public webrtc::I420BufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataU() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kU);
+    return frame_->visible_data(media::VideoFrame::Plane::kU).data();
   }
 
   const uint8_t* DataV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kV);
+    return frame_->visible_data(media::VideoFrame::Plane::kV).data();
   }
 
   int StrideY() const override {
@@ -93,19 +93,19 @@ class I420AFrameAdapter : public webrtc::I420ABufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataU() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kU);
+    return frame_->visible_data(media::VideoFrame::Plane::kU).data();
   }
 
   const uint8_t* DataV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kV);
+    return frame_->visible_data(media::VideoFrame::Plane::kV).data();
   }
 
   const uint8_t* DataA() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kA);
+    return frame_->visible_data(media::VideoFrame::Plane::kA).data();
   }
 
   int StrideY() const override {
@@ -140,11 +140,11 @@ class NV12FrameAdapter : public webrtc::NV12BufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataUV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kUV);
+    return frame_->visible_data(media::VideoFrame::Plane::kUV).data();
   }
 
   int StrideY() const override {
diff --git a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
index eb9a944db8d2c..a751612e62c18 100644
--- a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
+++ b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
@@ -299,7 +299,7 @@ TEST_F(ConvertToWebRtcVideoFrameBufferTest,
                       media::VideoPixelFormat::PIXEL_FORMAT_ARGB,
                       base::TimeDelta(), test_sii_.get());
   // fill mock image with whilte color.
-  memset(memory_frame->writable_data(media::VideoFrame::Plane::kARGB), 0xFF,
+  memset(memory_frame->writable_data(media::VideoFrame::Plane::kARGB).data(), 0xFF,
          kCodedSize.GetArea() * 4);
 
   // Should call texture conversion.
diff --git a/third_party/lzma_sdk/google/seven_zip_reader.cc b/third_party/lzma_sdk/google/seven_zip_reader.cc
index 8b217dff20856..9d4f390a45b02 100644
--- a/third_party/lzma_sdk/google/seven_zip_reader.cc
+++ b/third_party/lzma_sdk/google/seven_zip_reader.cc
@@ -93,7 +93,7 @@ class SevenZipReaderImpl {
   base::span<uint8_t> mapped_span() {
     if (!temp_file_mapped_)
       return base::span<uint8_t>();
-    return base::span<uint8_t>(temp_file_mapped_->data(),
+    return base::span<uint8_t>(temp_file_mapped_->data().data(),
                                temp_file_mapped_->length());
   }
   EntryInfo GetEntryInfo(size_t entry_index) const;
@@ -320,7 +320,7 @@ Result SevenZipReaderImpl::ExtractFile(size_t entry_index,
 
     // Copy the range of extracted folder corresponding to `entry_index` into
     // `output`.
-    memcpy(output.data(), temp_file_mapped_->data() + file_offset_in_folder,
+    memcpy(output.data(), temp_file_mapped_->data() .subspan( file_offset_in_folder).data(),
            output.size());
   } else {
     // Extract directly into `output`.
@@ -516,7 +516,7 @@ Result SevenZipReaderImpl::ExtractIntoTempFile(size_t folder_index) {
   }
 
   SRes sz_res = SzAr_DecodeFolder(&db_.db, folder_index, &look_stream_.vt,
-                                  db_.dataPos, temp_file_mapped_->data(),
+                                  db_.dataPos, temp_file_mapped_->data().data(),
                                   folder_unpack_size, &alloc_temp_);
 
   if (sz_res != SZ_OK) {
diff --git a/ui/base/resource/data_pack.cc b/ui/base/resource/data_pack.cc
index d72d8a25eb568..344dc88802751 100644
--- a/ui/base/resource/data_pack.cc
+++ b/ui/base/resource/data_pack.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -122,7 +124,7 @@ class DataPack::MemoryMappedDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return mmap_->length(); }
-  const uint8_t* GetData() const override { return mmap_->data(); }
+  const base::span<uint8_t> GetData() const override { return mmap_->data(); }
 
  private:
   std::unique_ptr<base::MemoryMappedFile> mmap_;
@@ -140,7 +142,7 @@ class DataPack::StringDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return data_.size(); }
-  const uint8_t* GetData() const override {
+  const base::span<uint8_t> GetData() const override {
     return reinterpret_cast<const uint8_t*>(data_.c_str());
   }
 
@@ -160,7 +162,7 @@ class DataPack::BufferDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return buffer_.size(); }
-  const uint8_t* GetData() const override { return buffer_.data(); }
+  const base::span<uint8_t> GetData() const override { return buffer_; }
 
  private:
   base::raw_span<const uint8_t> buffer_;
@@ -201,7 +203,7 @@ std::unique_ptr<DataPack::DataSource> DataPack::LoadFromPathInternal(
     return nullptr;
   }
   if (net::GZipHeader::HasGZipHeader(mmap->bytes())) {
-    std::string_view compressed(reinterpret_cast<char*>(mmap->data()),
+    std::string_view compressed(reinterpret_cast<char*>(mmap->data().data()),
                                 mmap->length());
     std::string data;
     if (!compression::GzipUncompress(compressed, &data)) {
@@ -244,7 +246,7 @@ bool DataPack::LoadFromBuffer(base::span<const uint8_t> buffer) {
 }
 
 bool DataPack::SanityCheckFileAndRegisterResources(size_t margin_to_skip,
-                                                   const uint8_t* data,
+                                                   base::span<const uint8_t>data,
                                                    size_t data_length) {
   // 1) Check we have enough entries. There's an extra entry after the last item
   // which gives the length of the last item.
@@ -297,12 +299,12 @@ bool DataPack::SanityCheckFileAndRegisterResources(size_t margin_to_skip,
 }
 
 bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
-  const uint8_t* data = data_source->GetData();
+  base::span<const uint8_t>data = data_source->GetData();
   size_t data_length = data_source->GetLength();
   // Parse the version and check for truncated header.
   uint32_t version = 0;
   if (data_length > sizeof(version)) {
-    memcpy(&version, data, sizeof(uint32_t));
+    memcpy(&version, data.data(), sizeof(uint32_t));
   }
   size_t header_length =
       version == kFileFormatV4 ? kHeaderLengthV4 : kHeaderLengthV5;
@@ -313,14 +315,14 @@ bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
 
   // Parse the header of the file.
   if (version == kFileFormatV4) {
-    memcpy(&resource_count_, data + 4, sizeof(uint32_t));
+    memcpy(&resource_count_, data .subspan( 4).data(), sizeof(uint32_t));
     alias_count_ = 0;
     text_encoding_type_ = static_cast<TextEncodingType>(data[8]);
   } else if (version == kFileFormatV5) {
     // Version 5 added the alias table and changed the header format.
     text_encoding_type_ = static_cast<TextEncodingType>(data[4]);
-    memcpy(&resource_count_, data + 8, sizeof(uint16_t));
-    memcpy(&alias_count_, data + 10, sizeof(uint16_t));
+    memcpy(&resource_count_, data .subspan( 8).data(), sizeof(uint16_t));
+    memcpy(&alias_count_, data .subspan( 10).data(), sizeof(uint16_t));
   } else {
     LOG(ERROR) << "Bad data pack version: got " << version << ", expected "
                << kFileFormatV4 << " or " << kFileFormatV5;
@@ -366,9 +368,9 @@ bool DataPack::HasResource(uint16_t resource_id) const {
 // static
 std::string_view DataPack::GetStringViewFromOffset(uint32_t target_offset,
                                                    uint32_t next_offset,
-                                                   const uint8_t* data_source) {
+                                                   base::span<const uint8_t>data_source) {
   size_t length = next_offset - target_offset;
-  return {reinterpret_cast<const char*>(data_source + target_offset), length};
+  return {reinterpret_cast<const char*>(data_source .subspan( target_offset).data()), length};
 }
 
 std::optional<std::string_view> DataPack::GetStringView(
diff --git a/ui/base/resource/data_pack.h b/ui/base/resource/data_pack.h
index 369c4e3291d70..d0a09894e4a13 100644
--- a/ui/base/resource/data_pack.h
+++ b/ui/base/resource/data_pack.h
@@ -17,6 +17,8 @@
 #include <string_view>
 #include <vector>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/component_export.h"
 #include "base/files/file.h"
 #include "base/files/memory_mapped_file.h"
@@ -102,14 +104,14 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
 
    private:
     friend class DataPack;
-    explicit Iterator(const uint8_t* data_source, const Entry* entry)
+    explicit Iterator(base::span<const uint8_t>data_source, const Entry* entry)
         : data_source_(data_source), entry_(entry) {
       UpdateResourceData();
     }
 
     void UpdateResourceData();
 
-    raw_ptr<const uint8_t> data_source_;
+    base::raw_span<const uint8_t> data_source_;
     raw_ptr<ResourceData> resource_data_;
     raw_ptr<const Entry, AllowPtrArithmetic> entry_;
   };
@@ -123,7 +125,7 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
     virtual ~DataSource() = default;
 
     virtual size_t GetLength() const = 0;
-    virtual const uint8_t* GetData() const = 0;
+    virtual const base::span<uint8_t> GetData() const = 0;
   };
 
   // Load a pack file from |path|, returning false on error. If the final
@@ -205,13 +207,13 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
   // If there is no extra data in data pack, `margin_to_skip` is equal to the
   // length of file header.
   bool SanityCheckFileAndRegisterResources(size_t margin_to_skip,
-                                           const uint8_t* data,
+                                           base::span<const uint8_t>data,
                                            size_t data_length);
 
   // Returns the string between `target_offset` and `next_offset` in data pack.
   static std::string_view GetStringViewFromOffset(uint32_t target_offset,
                                                   uint32_t next_offset,
-                                                  const uint8_t* data_source);
+                                                  base::span<const uint8_t>data_source);
 
   std::unique_ptr<DataSource> data_source_;
 
diff --git a/ui/gfx/client_native_pixmap.h b/ui/gfx/client_native_pixmap.h
index 01193111f6ce1..3349677ad74ae 100644
--- a/ui/gfx/client_native_pixmap.h
+++ b/ui/gfx/client_native_pixmap.h
@@ -5,6 +5,7 @@
 #ifndef UI_GFX_CLIENT_NATIVE_PIXMAP_H_
 #define UI_GFX_CLIENT_NATIVE_PIXMAP_H_
 
+#include "base/containers/span.h"
 #include "base/component_export.h"
 
 namespace gfx {
@@ -24,7 +25,7 @@ class COMPONENT_EXPORT(GFX) ClientNativePixmap {
   virtual void Unmap() = 0;
 
   virtual size_t GetNumberOfPlanes() const = 0;
-  virtual void* GetMemoryAddress(size_t plane) const = 0;
+  virtual base::span<void> GetMemoryAddress(size_t plane) const = 0;
   virtual int GetStride(size_t plane) const = 0;
   virtual NativePixmapHandle CloneHandleForIPC() const = 0;
 };
diff --git a/ui/gfx/gpu_memory_buffer.h b/ui/gfx/gpu_memory_buffer.h
index d5fe1e43ead01..78f1bcf91b5ee 100644
--- a/ui/gfx/gpu_memory_buffer.h
+++ b/ui/gfx/gpu_memory_buffer.h
@@ -10,6 +10,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/component_export.h"
 #include "base/memory/unsafe_shared_memory_region.h"
 #include "build/build_config.h"
@@ -253,7 +254,7 @@ class COMPONENT_EXPORT(GFX) GpuMemoryBuffer {
 
   // Returns a pointer to the memory address of a plane. Buffer must have been
   // successfully mapped using a call to Map() before calling this function.
-  virtual void* memory(size_t plane) = 0;
+  virtual base::span<void> memory(size_t plane) = 0;
 
   // Unmaps the buffer. It's illegal to use any pointer returned by memory()
   // after this has been called.
diff --git a/ui/gfx/linux/client_native_pixmap_dmabuf.cc b/ui/gfx/linux/client_native_pixmap_dmabuf.cc
index 0862e12cb7806..9bb543ff9bc39 100644
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.cc
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -92,12 +94,12 @@ ClientNativePixmapDmaBuf::PlaneInfo::PlaneInfo() = default;
 ClientNativePixmapDmaBuf::PlaneInfo::PlaneInfo(PlaneInfo&& info)
     : data(info.data), offset(info.offset), size(info.size) {
   // Set nullptr to info.data in order not to call munmap in |info| dtor.
-  info.data = nullptr;
+  info.data = {};
 }
 
 ClientNativePixmapDmaBuf::PlaneInfo::~PlaneInfo() {
-  if (data) {
-    int ret = munmap(data, offset + size);
+  if (!data.empty()) {
+    int ret = munmap(data.data(), offset + size);
     DCHECK(!ret);
   }
 }
@@ -249,11 +251,11 @@ size_t ClientNativePixmapDmaBuf::GetNumberOfPlanes() const {
   return pixmap_handle_.planes.size();
 }
 
-void* ClientNativePixmapDmaBuf::GetMemoryAddress(size_t plane) const {
+base::span<void> ClientNativePixmapDmaBuf::GetMemoryAddress(size_t plane) const {
   DCHECK_LT(plane, pixmap_handle_.planes.size());
   CHECK(mapped_);
-  return static_cast<uint8_t*>(plane_info_[plane].data) +
-         plane_info_[plane].offset;
+  return static_cast<uint8_t*>(plane_info_[plane].data) .subspan(
+         plane_info_[plane].offset);
 }
 
 int ClientNativePixmapDmaBuf::GetStride(size_t plane) const {
diff --git a/ui/gfx/linux/client_native_pixmap_dmabuf.h b/ui/gfx/linux/client_native_pixmap_dmabuf.h
index 90ed56f2ab363..ab805075e1680 100644
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.h
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.h
@@ -10,6 +10,8 @@
 #include <array>
 #include <memory>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/component_export.h"
 #include "base/files/scoped_file.h"
 #include "base/memory/raw_ptr.h"
@@ -45,7 +47,7 @@ class ClientNativePixmapDmaBuf : public gfx::ClientNativePixmap {
   void Unmap() override;
 
   size_t GetNumberOfPlanes() const override;
-  void* GetMemoryAddress(size_t plane) const override;
+  base::span<void> GetMemoryAddress(size_t plane) const override;
   int GetStride(size_t plane) const override;
   NativePixmapHandle CloneHandleForIPC() const override;
 
@@ -57,7 +59,7 @@ class ClientNativePixmapDmaBuf : public gfx::ClientNativePixmap {
     PlaneInfo(PlaneInfo&& plane_info);
     ~PlaneInfo();
 
-    raw_ptr<void> data = nullptr;
+    base::raw_span<void> data = nullptr;
     size_t offset = 0;
     size_t size = 0;
   };
diff --git a/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc b/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
index c65ab9bd87c6c..4781a0d5be85a 100644
--- a/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
+++ b/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/trace_event/trace_event.h"
@@ -32,7 +33,7 @@ class ClientNativePixmapOpaque : public ClientNativePixmap {
   size_t GetNumberOfPlanes() const override {
     return pixmap_handle_.planes.size();
   }
-  void* GetMemoryAddress(size_t plane) const override { NOTREACHED(); }
+  base::span<void> GetMemoryAddress(size_t plane) const override { NOTREACHED(); }
   int GetStride(size_t plane) const override {
     CHECK_LT(plane, pixmap_handle_.planes.size());
     // Even though a ClientNativePixmapOpaque should not be mapped, we may still
diff --git a/ui/gl/test/gl_test_support.cc b/ui/gl/test/gl_test_support.cc
index e5ae5556e36d1..5806653efd6d0 100644
--- a/ui/gl/test/gl_test_support.cc
+++ b/ui/gl/test/gl_test_support.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
 #include "ui/gl/test/gl_test_support.h"
 
 #include <array>
@@ -36,27 +37,27 @@ void rgb_to_yuv(uint8_t r, uint8_t g, uint8_t b, T* y, T* u, T* v) {
   *v = (0.439 * r) - (0.368 * g) - (0.071 * b) + 128;
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint8_t> ToSpan_uint8(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint8_t> ToSpan_uint8(base::span<uint8_t>data,
                                                      size_t start,
                                                      size_t size) {
   return UNSAFE_BUFFERS(base::span<uint8_t>(data + start, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint16_t> ToSpan_uint16(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint16_t> ToSpan_uint16(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint16_t* pointer = reinterpret_cast<uint16_t*>(UNSAFE_BUFFERS(data + start));
   return UNSAFE_BUFFERS(base::span<uint16_t>(pointer, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint32_t> ToSpan_uint32(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint32_t> ToSpan_uint32(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint32_t* pointer = reinterpret_cast<uint32_t*>(UNSAFE_BUFFERS(data + start));
   return UNSAFE_BUFFERS(base::span<uint32_t>(pointer, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint64_t> ToSpan_uint64(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint64_t> ToSpan_uint64(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint64_t* pointer = reinterpret_cast<uint64_t*>(UNSAFE_BUFFERS(data + start));
@@ -108,19 +109,19 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                          int plane,
                                          gfx::BufferFormat format,
                                          base::span<const uint8_t, 4> color,
-                                         uint8_t* data) {
+                                         base::span<uint8_t>data) {
   switch (format) {
     case gfx::BufferFormat::R_8:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint8(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), y * stride, width));
         std::ranges::fill(row, color[0]);  // R
       }
       return;
     case gfx::BufferFormat::RG_88:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, (color[1] << 8) |  // G
                                    color[0]);     // R
       }
@@ -128,14 +129,14 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::R_16:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, color[0] << 8);  // R
       }
       return;
     case gfx::BufferFormat::RG_1616:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[1] << 24) |     // G
                                    (color[0] << 8));  // R
       }
@@ -143,7 +144,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBA_4444:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, ((color[3] & 0xf) << 4) |      // A
                                    (color[2] & 0xf) |         // B
                                    (color[1] << 12) |         // G
@@ -153,7 +154,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGR_565:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, ((color[0] >> 3) << 11) |     // R
                                    ((color[1] >> 2) << 5) |  // G
                                    (color[2] >> 3));         // B
@@ -162,7 +163,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBX_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (0xaa << 24) |          // unused
                                    (color[2] << 16) |  // B
                                    (color[1] << 8) |   // G
@@ -172,7 +173,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBA_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[3] << 24) |      // A
                                    (color[2] << 16) |  // B
                                    (color[1] << 8) |   // G
@@ -182,7 +183,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGRX_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (0xaa << 24) |          // unused
                                    (color[0] << 16) |  // R
                                    (color[1] << 8) |   // G
@@ -195,7 +196,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                       "precision for the supplied value";
       const uint8_t scaled_alpha = color[3] >> 6;
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(
             row,
             (scaled_alpha << 30) |                             // A
@@ -211,7 +212,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                       "precision for the supplied value";
       const uint8_t scaled_alpha = color[3] >> 6;
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(
             row, (scaled_alpha << 30) |                             // A
                      (((color[2] << 2) | (color[2] >> 6)) << 20) |  // B
@@ -223,7 +224,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGRA_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[3] << 24) |      // A
                                    (color[0] << 16) |  // R
                                    (color[1] << 8) |   // G
@@ -241,7 +242,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
       uint16_t half_float_color[4];
       gfx::FloatToHalfFloat(float_color, half_float_color, 4);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint64(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint64(data.data(), y * stride, width));
         std::ranges::fill(row, base::bit_cast<uint64_t>(half_float_color));
       }
       return;
@@ -255,12 +256,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yvu[0]);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width / 2));
           std::ranges::fill(row, yvu[plane]);
         }
       }
@@ -275,12 +276,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[0]);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), stride * y, width / 2));
           std::ranges::fill(row, (yuv[2] << 8) | yuv[1]);
         }
       }
@@ -296,17 +297,17 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[0]);
         }
       } else if (plane == 1) {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), stride * y, width / 2));
           std::ranges::fill(row, (yuv[2] << 8) | yuv[1]);
         }
       } else {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[3]);
         }
       }
@@ -321,12 +322,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
           std::ranges::fill(row, yuv[0] << 2);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width / 2));
           std::ranges::fill(row, (yuv[2] << 18) | (yuv[1] << 2));
         }
       }
diff --git a/ui/gl/test/gl_test_support.h b/ui/gl/test/gl_test_support.h
index 06fe53efd1419..57352129e41b4 100644
--- a/ui/gl/test/gl_test_support.h
+++ b/ui/gl/test/gl_test_support.h
@@ -34,7 +34,7 @@ class GLTestSupport {
                                    int plane,
                                    gfx::BufferFormat format,
                                    base::span<const uint8_t, 4> color,
-                                   uint8_t* data);
+                                   base::span<uint8_t>data);
 };
 
 }  // namespace gl
diff --git a/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc b/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
index 72dd5d8cb2e49..fa51a3f535d8e 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
@@ -91,7 +91,7 @@ class WaylandCanvasSurface::SharedMemoryBuffer {
     SkSurfaceProps props = skia::LegacyDisplayGlobals::GetSkSurfaceProps();
     sk_surface_ = SkSurfaces::WrapPixels(
         SkImageInfo::MakeN32Premul(size.width(), size.height()),
-        shm_mapping_.memory(), CalculateStride(size.width()), &props);
+        shm_mapping_.memory().data(), CalculateStride(size.width()), &props);
     DCHECK(sk_surface_);
 
     dirty_region_.setRect(gfx::RectToSkIRect(gfx::Rect(size)));
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 56a4dfca8c740..25462bfa96e47 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -216,7 +216,7 @@ void WaylandTestBase::MaybeSetUpXkb() {
             std::move(shared_keymap_region));
     ASSERT_TRUE(shared_keymap.IsValid());
 
-    memcpy(shared_keymap.memory(), keymap_string.get(), keymap_size);
+    memcpy(shared_keymap.memory().data(), keymap_string.get(), keymap_size);
 
     auto* const keyboard = server->seat()->keyboard()->resource();
     ASSERT_TRUE(keyboard);
```

## Build Failure Log

```
Overlapping replacements: /usr/local/google/home/nuskos/chromium-team/chromium/src/mojo/public/cpp/base/big_buffer.h at offset 6111, length 8: "" and offset 6113, length 0: "*"

Overlapping replacements: /usr/local/google/home/nuskos/chromium-team/chromium/src/mojo/public/cpp/base/big_buffer.h at offset 5903, length 8: "" and offset 5905, length 0: "*"

Overlapping replacements: /usr/local/google/home/nuskos/chromium-team/chromium/src/mojo/public/cpp/base/big_buffer.h at offset 5681, length 8: "" and offset 5683, length 0: "*"

Overlapping replacements: /usr/local/google/home/nuskos/chromium-team/chromium/src/mojo/public/cpp/base/big_buffer.h at offset 5277, length 8: "" and offset 5279, length 0: "*"

Overlapping replacements: /usr/local/google/home/nuskos/chromium-team/chromium/src/media/base/video_util_unittest.cc at offset 3492, length 15: "base::span<const uint8_t>" and offset 3492, length 31: "base::span<const uint8_t>"

Applied 6 edits (0 errors) to 1 files [0.41%]
Applied 20 edits (0 errors) to 2 files [0.81%]
Applied 24 edits (0 errors) to 3 files [1.22%]
Applied 80 edits (0 errors) to 4 files [1.63%]
Applied 83 edits (0 errors) to 5 files [2.03%]
Applied 97 edits (0 errors) to 6 files [2.44%]
Applied 111 edits (0 errors) to 7 files [2.85%]
Applied 113 edits (0 errors) to 8 files [3.25%]
Applied 120 edits (0 errors) to 9 files [3.66%]
Applied 135 edits (0 errors) to 10 files [4.07%]
Applied 136 edits (0 errors) to 11 files [4.47%]
Applied 141 edits (0 errors) to 12 files [4.88%]
Applied 169 edits (0 errors) to 13 files [5.28%]
Applied 185 edits (0 errors) to 14 files [5.69%]
Applied 198 edits (0 errors) to 15 files [6.10%]
Applied 200 edits (0 errors) to 16 files [6.50%]
Applied 205 edits (0 errors) to 17 files [6.91%]
Applied 218 edits (4 errors) to 18 files [7.32%]
Applied 220 edits (4 errors) to 19 files [7.72%]
Applied 221 edits (4 errors) to 20 files [8.13%]
Applied 233 edits (4 errors) to 21 files [8.54%]
Applied 236 edits (4 errors) to 22 files [8.94%]
Applied 269 edits (4 errors) to 23 files [9.35%]
Applied 276 edits (4 errors) to 24 files [9.76%]
Applied 302 edits (4 errors) to 25 files [10.16%]
Applied 320 edits (4 errors) to 26 files [10.57%]
Applied 324 edits (4 errors) to 27 files [10.98%]
Applied 325 edits (4 errors) to 28 files [11.38%]
Applied 326 edits (4 errors) to 29 files [11.79%]
Applied 356 edits (4 errors) to 30 files [12.20%]
Applied 368 edits (4 errors) to 31 files [12.60%]
Applied 404 edits (4 errors) to 32 files [13.01%]
Applied 405 edits (4 errors) to 33 files [13.41%]
Applied 439 edits (4 errors) to 34 files [13.82%]
Applied 461 edits (4 errors) to 35 files [14.23%]
Applied 472 edits (4 errors) to 36 files [14.63%]
Applied 506 edits (4 errors) to 37 files [15.04%]
Applied 555 edits (4 errors) to 38 files [15.45%]
Applied 562 edits (4 errors) to 39 files [15.85%]
Applied 566 edits (4 errors) to 40 files [16.26%]
Applied 567 edits (4 errors) to 41 files [16.67%]
Applied 572 edits (4 errors) to 42 files [17.07%]
Applied 606 edits (4 errors) to 43 files [17.48%]
Applied 607 edits (4 errors) to 44 files [17.89%]
Applied 609 edits (4 errors) to 45 files [18.29%]
Applied 646 edits (4 errors) to 46 files [18.70%]
Applied 650 edits (4 errors) to 47 files [19.11%]
Applied 651 edits (4 errors) to 48 files [19.51%]
Applied 654 edits (4 errors) to 49 files [19.92%]
Applied 656 edits (4 errors) to 50 files [20.33%]
Applied 675 edits (4 errors) to 51 files [20.73%]
Applied 680 edits (4 errors) to 52 files [21.14%]
Applied 684 edits (4 errors) to 53 files [21.54%]
Applied 688 edits (4 errors) to 54 files [21.95%]
Applied 699 edits (4 errors) to 55 files [22.36%]
Applied 701 edits (4 errors) to 56 files [22.76%]
Applied 703 edits (4 errors) to 57 files [23.17%]
Applied 726 edits (5 errors) to 58 files [23.58%]
Applied 731 edits (5 errors) to 59 files [23.98%]
Applied 752 edits (5 errors) to 60 files [24.39%]
Applied 754 edits (5 errors) to 61 files [24.80%]
Applied 757 edits (5 errors) to 62 files [25.20%]
Applied 759 edits (5 errors) to 63 files [25.61%]
Applied 794 edits (5 errors) to 64 files [26.02%]
Applied 796 edits (5 errors) to 65 files [26.42%]
Applied 801 edits (5 errors) to 66 files [26.83%]
Applied 807 edits (5 errors) to 67 files [27.24%]
Applied 811 edits (5 errors) to 68 files [27.64%]
Applied 817 edits (5 errors) to 69 files [28.05%]
Applied 841 edits (5 errors) to 70 files [28.46%]
Applied 846 edits (5 errors) to 71 files [28.86%]
Applied 848 edits (5 errors) to 72 files [29.27%]
Applied 869 edits (5 errors) to 73 files [29.67%]
Applied 879 edits (5 errors) to 74 files [30.08%]
Applied 886 edits (5 errors) to 75 files [30.49%]
Applied 895 edits (5 errors) to 76 files [30.89%]
Applied 900 edits (5 errors) to 77 files [31.30%]
Applied 909 edits (5 errors) to 78 files [31.71%]
Applied 919 edits (5 errors) to 79 files [32.11%]
Applied 923 edits (5 errors) to 80 files [32.52%]
Applied 928 edits (5 errors) to 81 files [32.93%]
Applied 938 edits (5 errors) to 82 files [33.33%]
Applied 943 edits (5 errors) to 83 files [33.74%]
Applied 948 edits (5 errors) to 84 files [34.15%]
Applied 950 edits (5 errors) to 85 files [34.55%]
Applied 954 edits (5 errors) to 86 files [34.96%]
Applied 958 edits (5 errors) to 87 files [35.37%]
Applied 967 edits (5 errors) to 88 files [35.77%]
Applied 985 edits (5 errors) to 89 files [36.18%]
Applied 996 edits (5 errors) to 90 files [36.59%]
Applied 998 edits (5 errors) to 91 files [36.99%]
Applied 999 edits (5 errors) to 92 files [37.40%]
Applied 1001 edits (5 errors) to 93 files [37.80%]
Applied 1004 edits (5 errors) to 94 files [38.21%]
Applied 1005 edits (5 errors) to 95 files [38.62%]
Applied 1007 edits (5 errors) to 96 files [39.02%]
Applied 1011 edits (5 errors) to 97 files [39.43%]
Applied 1014 edits (5 errors) to 98 files [39.84%]
Applied 1020 edits (5 errors) to 99 files [40.24%]
Applied 1028 edits (5 errors) to 100 files [40.65%]
Applied 1035 edits (5 errors) to 101 files [41.06%]
Applied 1037 edits (5 errors) to 102 files [41.46%]
Applied 1045 edits (5 errors) to 103 files [41.87%]
Applied 1050 edits (5 errors) to 104 files [42.28%]
Applied 1052 edits (5 errors) to 105 files [42.68%]
Applied 1053 edits (5 errors) to 106 files [43.09%]
Applied 1055 edits (5 errors) to 107 files [43.50%]
Applied 1061 edits (5 errors) to 108 files [43.90%]
Applied 1062 edits (5 errors) to 109 files [44.31%]
Applied 1063 edits (5 errors) to 110 files [44.72%]
Applied 1074 edits (5 errors) to 111 files [45.12%]
Applied 1077 edits (5 errors) to 112 files [45.53%]
Applied 1083 edits (5 errors) to 113 files [45.93%]
Applied 1090 edits (5 errors) to 114 files [46.34%]
Applied 1091 edits (5 errors) to 115 files [46.75%]
Applied 1096 edits (5 errors) to 116 files [47.15%]
Applied 1101 edits (5 errors) to 117 files [47.56%]
Applied 1103 edits (5 errors) to 118 files [47.97%]
Applied 1117 edits (5 errors) to 119 files [48.37%]
Applied 1122 edits (5 errors) to 120 files [48.78%]
Applied 1126 edits (5 errors) to 121 files [49.19%]
Applied 1128 edits (5 errors) to 122 files [49.59%]
Applied 1130 edits (5 errors) to 123 files [50.00%]
Applied 1134 edits (5 errors) to 124 files [50.41%]
Applied 1143 edits (5 errors) to 125 files [50.81%]
Applied 1145 edits (5 errors) to 126 files [51.22%]
Applied 1152 edits (5 errors) to 127 files [51.63%]
Applied 1156 edits (5 errors) to 128 files [52.03%]
Applied 1164 edits (5 errors) to 129 files [52.44%]
Applied 1167 edits (5 errors) to 130 files [52.85%]
Applied 1179 edits (5 errors) to 131 files [53.25%]
Applied 1186 edits (5 errors) to 132 files [53.66%]
Applied 1187 edits (5 errors) to 133 files [54.07%]
Applied 1188 edits (5 errors) to 134 files [54.47%]
Applied 1191 edits (5 errors) to 135 files [54.88%]
Applied 1199 edits (5 errors) to 136 files [55.28%]
Applied 1201 edits (5 errors) to 137 files [55.69%]
Applied 1202 edits (5 errors) to 138 files [56.10%]
Applied 1206 edits (5 errors) to 139 files [56.50%]
Applied 1211 edits (5 errors) to 140 files [56.91%]
Applied 1213 edits (5 errors) to 141 files [57.32%]
Applied 1214 edits (5 errors) to 142 files [57.72%]
Applied 1215 edits (5 errors) to 143 files [58.13%]
Applied 1216 edits (5 errors) to 144 files [58.54%]
Applied 1217 edits (5 errors) to 145 files [58.94%]
Applied 1221 edits (5 errors) to 146 files [59.35%]
Applied 1223 edits (5 errors) to 147 files [59.76%]
Applied 1224 edits (5 errors) to 148 files [60.16%]
Applied 1225 edits (5 errors) to 149 files [60.57%]
Applied 1228 edits (5 errors) to 150 files [60.98%]
Applied 1232 edits (5 errors) to 151 files [61.38%]
Applied 1235 edits (5 errors) to 152 files [61.79%]
Applied 1236 edits (5 errors) to 153 files [62.20%]
Applied 1237 edits (5 errors) to 154 files [62.60%]
Applied 1238 edits (5 errors) to 155 files [63.01%]
Applied 1239 edits (5 errors) to 156 files [63.41%]
Applied 1252 edits (5 errors) to 157 files [63.82%]
Applied 1253 edits (5 errors) to 158 files [64.23%]
Applied 1254 edits (5 errors) to 159 files [64.63%]
Applied 1257 edits (5 errors) to 160 files [65.04%]
Applied 1258 edits (5 errors) to 161 files [65.45%]
Applied 1261 edits (5 errors) to 162 files [65.85%]
Applied 1267 edits (5 errors) to 163 files [66.26%]
Applied 1280 edits (5 errors) to 164 files [66.67%]
Applied 1286 edits (5 errors) to 165 files [67.07%]
Applied 1291 edits (5 errors) to 166 files [67.48%]
Applied 1292 edits (5 errors) to 167 files [67.89%]
Applied 1293 edits (5 errors) to 168 files [68.29%]
Applied 1295 edits (5 errors) to 169 files [68.70%]
Applied 1296 edits (5 errors) to 170 files [69.11%]
Applied 1297 edits (5 errors) to 171 files [69.51%]
Applied 1299 edits (5 errors) to 172 files [69.92%]
Applied 1300 edits (5 errors) to 173 files [70.33%]
Applied 1301 edits (5 errors) to 174 files [70.73%]
Applied 1310 edits (5 errors) to 175 files [71.14%]
Applied 1315 edits (5 errors) to 176 files [71.54%]
Applied 1317 edits (5 errors) to 177 files [71.95%]
Applied 1319 edits (5 errors) to 178 files [72.36%]
Applied 1320 edits (5 errors) to 179 files [72.76%]
Applied 1322 edits (5 errors) to 180 files [73.17%]
Applied 1323 edits (5 errors) to 181 files [73.58%]
Applied 1326 edits (5 errors) to 182 files [73.98%]
Applied 1327 edits (5 errors) to 183 files [74.39%]
Applied 1331 edits (5 errors) to 184 files [74.80%]
Applied 1332 edits (5 errors) to 185 files [75.20%]
Applied 1336 edits (5 errors) to 186 files [75.61%]
Applied 1337 edits (5 errors) to 187 files [76.02%]
Applied 1338 edits (5 errors) to 188 files [76.42%]
Applied 1341 edits (5 errors) to 189 files [76.83%]
Applied 1343 edits (5 errors) to 190 files [77.24%]
Applied 1345 edits (5 errors) to 191 files [77.64%]
Applied 1347 edits (5 errors) to 192 files [78.05%]
Applied 1348 edits (5 errors) to 193 files [78.46%]
Applied 1349 edits (5 errors) to 194 files [78.86%]
Applied 1350 edits (5 errors) to 195 files [79.27%]
Applied 1352 edits (5 errors) to 196 files [79.67%]
Applied 1354 edits (5 errors) to 197 files [80.08%]
Applied 1355 edits (5 errors) to 198 files [80.49%]
Applied 1356 edits (5 errors) to 199 files [80.89%]
Applied 1358 edits (5 errors) to 200 files [81.30%]
Applied 1359 edits (5 errors) to 201 files [81.71%]
Applied 1361 edits (5 errors) to 202 files [82.11%]
Applied 1362 edits (5 errors) to 203 files [82.52%]
Applied 1363 edits (5 errors) to 204 files [82.93%]
Applied 1364 edits (5 errors) to 205 files [83.33%]
Applied 1368 edits (5 errors) to 206 files [83.74%]
Applied 1369 edits (5 errors) to 207 files [84.15%]
Applied 1375 edits (5 errors) to 208 files [84.55%]
Applied 1376 edits (5 errors) to 209 files [84.96%]
Applied 1377 edits (5 errors) to 210 files [85.37%]
Applied 1381 edits (5 errors) to 211 files [85.77%]
Applied 1382 edits (5 errors) to 212 files [86.18%]
Applied 1383 edits (5 errors) to 213 files [86.59%]
Applied 1384 edits (5 errors) to 214 files [86.99%]
Applied 1386 edits (5 errors) to 215 files [87.40%]
Applied 1387 edits (5 errors) to 216 files [87.80%]
Applied 1388 edits (5 errors) to 217 files [88.21%]
Applied 1389 edits (5 errors) to 218 files [88.62%]
Applied 1390 edits (5 errors) to 219 files [89.02%]
Applied 1391 edits (5 errors) to 220 files [89.43%]
Applied 1392 edits (5 errors) to 221 files [89.84%]
Applied 1393 edits (5 errors) to 222 files [90.24%]
Applied 1394 edits (5 errors) to 223 files [90.65%]
Applied 1396 edits (5 errors) to 224 files [91.06%]
Applied 1397 edits (5 errors) to 225 files [91.46%]
Applied 1398 edits (5 errors) to 226 files [91.87%]
Applied 1399 edits (5 errors) to 227 files [92.28%]
Applied 1400 edits (5 errors) to 228 files [92.68%]
Applied 1402 edits (5 errors) to 229 files [93.09%]
Applied 1403 edits (5 errors) to 230 files [93.50%]
Applied 1405 edits (5 errors) to 231 files [93.90%]
Applied 1406 edits (5 errors) to 232 files [94.31%]
Applied 1408 edits (5 errors) to 233 files [94.72%]
Applied 1410 edits (5 errors) to 234 files [95.12%]
Applied 1411 edits (5 errors) to 235 files [95.53%]
Applied 1412 edits (5 errors) to 236 files [95.93%]
Applied 1413 edits (5 errors) to 237 files [96.34%]
Applied 1414 edits (5 errors) to 238 files [96.75%]
Applied 1415 edits (5 errors) to 239 files [97.15%]
Applied 1416 edits (5 errors) to 240 files [97.56%]
Applied 1417 edits (5 errors) to 241 files [97.97%]
Applied 1418 edits (5 errors) to 242 files [98.37%]
Applied 1419 edits (5 errors) to 243 files [98.78%]
Applied 1420 edits (5 errors) to 244 files [99.19%]
Applied 1421 edits (5 errors) to 245 files [99.59%]
Applied 1422 edits (5 errors) to 246 files [100.00%]
```

# Build Failure: 2025_03_19_patch_735

## Chromium Revision

`ae47ae4e0c13026d1824b4cf4b9cea834dfd0cf4`

## Code Changes (Diff)

```diff
diff --git a/chrome/services/media_gallery_util/ipc_data_source.cc b/chrome/services/media_gallery_util/ipc_data_source.cc
index df1adae9ad8e9..0d9425dee4ecf 100644
--- a/chrome/services/media_gallery_util/ipc_data_source.cc
+++ b/chrome/services/media_gallery_util/ipc_data_source.cc
@@ -6,6 +6,7 @@
 
 #include <algorithm>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/task/single_thread_task_runner.h"
 
@@ -32,7 +33,7 @@ void IPCDataSource::Abort() {
 
 void IPCDataSource::Read(int64_t position,
                          int size,
-                         uint8_t* destination,
+                         base::span<uint8_t>destination,
                          DataSource::ReadCB callback) {
   DCHECK_CALLED_ON_VALID_THREAD(data_source_thread_checker_);
 
diff --git a/chrome/services/media_gallery_util/ipc_data_source.h b/chrome/services/media_gallery_util/ipc_data_source.h
index d343e446139d1..97ad6ffc36273 100644
--- a/chrome/services/media_gallery_util/ipc_data_source.h
+++ b/chrome/services/media_gallery_util/ipc_data_source.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/memory/ref_counted.h"
 #include "base/threading/thread_checker.h"
 #include "chrome/services/media_gallery_util/public/mojom/media_parser.mojom.h"
@@ -36,7 +37,7 @@ class IPCDataSource : public media::DataSource {
   void Abort() override;
   void Read(int64_t position,
             int size,
-            uint8_t* destination,
+            base::span<uint8_t>destination,
             ReadCB callback) override;
   [[nodiscard]] bool GetSize(int64_t* size_out) override;
   bool IsStreaming() override;
diff --git a/media/base/bit_reader_unittest.cc b/media/base/bit_reader_unittest.cc
index ef20f9b35c08e..a6b2bdc0c5366 100644
--- a/media/base/bit_reader_unittest.cc
+++ b/media/base/bit_reader_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -16,7 +18,7 @@
 
 namespace media {
 
-static void SetBit(uint8_t* buf, size_t size, size_t bit_pos) {
+static void SetBit(base::span<uint8_t>buf, size_t size, size_t bit_pos) {
   size_t byte_pos = bit_pos / 8;
   bit_pos -= byte_pos * 8;
   DCHECK_LT(byte_pos, size);
@@ -104,16 +106,16 @@ TEST(BitReaderTest, VariableSkipBitsTest) {
   for (size_t k = 0; k < std::size(pattern_read_skip); ++k) {
     const size_t read_bit_count = pattern_read_skip[k][0];
     if (read_bit_count > 0) {
-      SetBit(buffer, sizeof(buffer), pos);
-      SetBit(buffer, sizeof(buffer), pos + read_bit_count - 1);
+      SetBit(buffer, (buffer.size() * sizeof(decltype(buffer)::value_type)), pos);
+      SetBit(buffer, (buffer.size() * sizeof(decltype(buffer)::value_type)), pos + read_bit_count - 1);
       pos += read_bit_count;
     }
     pos += pattern_read_skip[k][1];
   }
 
   // Run the test.
-  BitReader bit_reader(buffer, sizeof(buffer));
-  EXPECT_EQ(bit_reader.bits_available(), static_cast<int>(sizeof(buffer) * 8));
+  BitReader bit_reader(buffer.data(), (buffer.size() * sizeof(decltype(buffer)::value_type)));
+  EXPECT_EQ(bit_reader.bits_available(), static_cast<int>((buffer.size() * sizeof(decltype(buffer)::value_type)) * 8));
   for (size_t k = 0; k < std::size(pattern_read_skip); ++k) {
     const size_t read_bit_count = pattern_read_skip[k][0];
     if (read_bit_count > 0) {
diff --git a/media/base/container_names.cc b/media/base/container_names.cc
index 46070c3d56be0..f533be8496fb5 100644
--- a/media/base/container_names.cc
+++ b/media/base/container_names.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -38,22 +40,22 @@ namespace container_names {
 #define UTF8_BYTE_ORDER_MARK "\xef\xbb\xbf"
 
 // Helper function to read 2 bytes (16 bits, big endian) from a buffer.
-static int Read16(const uint8_t* p) {
+static int Read16(base::span<const uint8_t>p) {
   return p[0] << 8 | p[1];
 }
 
 // Helper function to read 3 bytes (24 bits, big endian) from a buffer.
-static uint32_t Read24(const uint8_t* p) {
+static uint32_t Read24(base::span<const uint8_t>p) {
   return p[0] << 16 | p[1] << 8 | p[2];
 }
 
 // Helper function to read 4 bytes (32 bits, big endian) from a buffer.
-static uint32_t Read32(const uint8_t* p) {
+static uint32_t Read32(base::span<const uint8_t>p) {
   return p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
 }
 
 // Helper function to read 4 bytes (32 bits, little endian) from a buffer.
-static uint32_t Read32LE(const uint8_t* p) {
+static uint32_t Read32LE(base::span<const uint8_t>p) {
   return p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
 }
 
@@ -107,14 +109,14 @@ const int kAc3FrameSizeTable[38][3] = {
 };
 
 // Checks for an ADTS AAC container.
-static bool CheckAac(const uint8_t* buffer, int buffer_size) {
+static bool CheckAac(base::span<const uint8_t>buffer, int buffer_size) {
   // Audio Data Transport Stream (ADTS) header is 7 or 9 bytes
   // (from http://wiki.multimedia.cx/index.php?title=ADTS)
   RCHECK(buffer_size > 6);
 
   int offset = 0;
   while (offset + 6 < buffer_size) {
-    BitReader reader(buffer + offset, 6);
+    BitReader reader(buffer .subspan( offset).data(), 6);
 
     // Syncword must be 0xfff.
     RCHECK(ReadBits(&reader, 12) == 0xfff);
@@ -146,7 +148,7 @@ static bool CheckAac(const uint8_t* buffer, int buffer_size) {
 const uint16_t kAc3SyncWord = 0x0b77;
 
 // Checks for an AC3 container.
-static bool CheckAc3(const uint8_t* buffer, int buffer_size) {
+static bool CheckAc3(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ATSC Standard: Digital Audio Compression (AC-3, E-AC-3)
   //            Doc. A/52:2012
   // (http://www.atsc.org/cms/standards/A52-2012(12-17).pdf)
@@ -156,7 +158,7 @@ static bool CheckAc3(const uint8_t* buffer, int buffer_size) {
 
   int offset = 0;
   while (offset + 6 < buffer_size) {
-    BitReader reader(buffer + offset, 6);
+    BitReader reader(buffer .subspan( offset).data(), 6);
 
     // Check syncinfo.
     RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);
@@ -181,7 +183,7 @@ static bool CheckAc3(const uint8_t* buffer, int buffer_size) {
 }
 
 // Checks for an EAC3 container (very similar to AC3)
-static bool CheckEac3(const uint8_t* buffer, int buffer_size) {
+static bool CheckEac3(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ATSC Standard: Digital Audio Compression (AC-3, E-AC-3)
   //            Doc. A/52:2012
   // (http://www.atsc.org/cms/standards/A52-2012(12-17).pdf)
@@ -191,7 +193,7 @@ static bool CheckEac3(const uint8_t* buffer, int buffer_size) {
 
   int offset = 0;
   while (offset + 6 < buffer_size) {
-    BitReader reader(buffer + offset, 6);
+    BitReader reader(buffer .subspan( offset).data(), 6);
 
     // Check syncinfo.
     RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);
@@ -219,7 +221,7 @@ static bool CheckEac3(const uint8_t* buffer, int buffer_size) {
 }
 
 // Additional checks for a BINK container.
-static bool CheckBink(const uint8_t* buffer, int buffer_size) {
+static bool CheckBink(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: http://wiki.multimedia.cx/index.php?title=Bink_Container
   RCHECK(buffer_size >= 44);
 
@@ -227,11 +229,11 @@ static bool CheckBink(const uint8_t* buffer, int buffer_size) {
   RCHECK(Read32LE(buffer + 8) > 0);
 
   // Verify width in range.
-  int width = Read32LE(buffer + 20);
+  int width = Read32LE(buffer .subspan( 20));
   RCHECK(width > 0 && width <= 32767);
 
   // Verify height in range.
-  int height = Read32LE(buffer + 24);
+  int height = Read32LE(buffer .subspan( 24));
   RCHECK(height > 0 && height <= 32767);
 
   // Verify frames per second specified.
@@ -241,7 +243,7 @@ static bool CheckBink(const uint8_t* buffer, int buffer_size) {
   RCHECK(Read32LE(buffer + 32) > 0);
 
   // Number of audio tracks must be 256 or less.
-  return (Read32LE(buffer + 40) <= 256);
+  return (Read32LE(buffer .subspan( 40)) <= 256);
 }
 
 // Additional checks for a CAF container.
@@ -286,14 +288,14 @@ static bool kExtAudioIdValid[8] = { true, false, true, false, false, false,
                                     true, false };
 
 // Additional checks for a DTS container.
-static bool CheckDts(const uint8_t* buffer, int buffer_size) {
+static bool CheckDts(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ETSI TS 102 114 V1.3.1 (2011-08)
   // (http://www.etsi.org/deliver/etsi_ts/102100_102199/102114/01.03.01_60/ts_102114v010301p.pdf)
   RCHECK(buffer_size > 11);
 
   int offset = 0;
   while (offset + 11 < buffer_size) {
-    BitReader reader(buffer + offset, 11);
+    BitReader reader(buffer .subspan( offset).data(), 11);
 
     // Verify sync word.
     RCHECK(ReadBits(&reader, 32) == 0x7ffe8001);
@@ -345,7 +347,7 @@ static bool CheckDts(const uint8_t* buffer, int buffer_size) {
 }
 
 // Checks for a DV container.
-static bool CheckDV(const uint8_t* buffer, int buffer_size) {
+static bool CheckDV(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: SMPTE 314M (Annex A has differences with IEC 61834).
   // (http://standards.smpte.org/content/978-1-61482-454-1/st-314-2005/SEC1.body.pdf)
   RCHECK(buffer_size > 11);
@@ -354,7 +356,7 @@ static bool CheckDV(const uint8_t* buffer, int buffer_size) {
   int current_sequence_number = -1;
   int last_block_number[6] = {};
   while (offset + 11 < buffer_size) {
-    BitReader reader(buffer + offset, 11);
+    BitReader reader(buffer .subspan( offset).data(), 11);
 
     // Decode ID data. Sections 5, 6, and 7 are reserved.
     int section = ReadBits(&reader, 3);
@@ -408,7 +410,7 @@ static bool CheckDV(const uint8_t* buffer, int buffer_size) {
 
 
 // Checks for a GSM container.
-static bool CheckGsm(const uint8_t* buffer, int buffer_size) {
+static bool CheckGsm(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ETSI EN 300 961 V8.1.1
   // (http://www.etsi.org/deliver/etsi_en/300900_300999/300961/08.01.01_60/en_300961v080101p.pdf)
   // also http://tools.ietf.org/html/rfc3551#page-24
@@ -429,7 +431,7 @@ static bool CheckGsm(const uint8_t* buffer, int buffer_size) {
 // number of bytes that must remain in the buffer when |start_code| is found.
 // Returns true if start_code found (and enough space in the buffer after it),
 // false otherwise.
-static bool AdvanceToStartCode(const uint8_t* buffer,
+static bool AdvanceToStartCode(base::span<const uint8_t>buffer,
                                int buffer_size,
                                int* offset,
                                int bytes_needed,
@@ -442,7 +444,7 @@ static bool AdvanceToStartCode(const uint8_t* buffer,
   uint32_t bits_to_shift = 24 - num_bits;
   uint32_t mask = (1 << num_bits) - 1;
   while (*offset + bytes_needed < buffer_size) {
-    uint32_t next = Read24(buffer + *offset);
+    uint32_t next = Read24(buffer .subspan( *)offset);
     if (((next >> bits_to_shift) & mask) == start_code)
       return true;
     ++(*offset);
@@ -451,7 +453,7 @@ static bool AdvanceToStartCode(const uint8_t* buffer,
 }
 
 // Checks for an H.261 container.
-static bool CheckH261(const uint8_t* buffer, int buffer_size) {
+static bool CheckH261(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ITU-T Recommendation H.261 (03/1993)
   // (http://www.itu.int/rec/T-REC-H.261-199303-I/en)
   RCHECK(buffer_size > 16);
@@ -468,7 +470,7 @@ static bool CheckH261(const uint8_t* buffer, int buffer_size) {
 
     // Now verify the block. AdvanceToStartCode() made sure that there are
     // at least 4 bytes remaining in the buffer.
-    BitReader reader(buffer + offset, buffer_size - offset);
+    BitReader reader(buffer .subspan( offset).data(), buffer_size - offset);
     RCHECK(ReadBits(&reader, 20) == 0x10);
 
     // Skip the temporal reference and PTYPE.
@@ -499,7 +501,7 @@ static bool CheckH261(const uint8_t* buffer, int buffer_size) {
 }
 
 // Checks for an H.263 container.
-static bool CheckH263(const uint8_t* buffer, int buffer_size) {
+static bool CheckH263(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ITU-T Recommendation H.263 (01/2005)
   // (http://www.itu.int/rec/T-REC-H.263-200501-I/en)
   // header is PSC(22b) + TR(8b) + PTYPE(8+b).
@@ -517,7 +519,7 @@ static bool CheckH263(const uint8_t* buffer, int buffer_size) {
 
     // Now verify the block. AdvanceToStartCode() made sure that there are
     // at least 9 bytes remaining in the buffer.
-    BitReader reader(buffer + offset, 9);
+    BitReader reader(buffer .subspan( offset).data(), 9);
     RCHECK(ReadBits(&reader, 22) == 0x20);
 
     // Skip the temporal reference.
@@ -567,7 +569,7 @@ static bool CheckH263(const uint8_t* buffer, int buffer_size) {
 }
 
 // Checks for an H.264 container.
-static bool CheckH264(const uint8_t* buffer, int buffer_size) {
+static bool CheckH264(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ITU-T Recommendation H.264 (01/2012)
   // (http://www.itu.int/rec/T-REC-H.264)
   // Section B.1: Byte stream NAL unit syntax and semantics.
@@ -585,7 +587,7 @@ static bool CheckH264(const uint8_t* buffer, int buffer_size) {
 
     // Now verify the block. AdvanceToStartCode() made sure that there are
     // at least 4 bytes remaining in the buffer.
-    BitReader reader(buffer + offset, 4);
+    BitReader reader(buffer .subspan( offset).data(), 4);
     RCHECK(ReadBits(&reader, 24) == 1);
 
     // Verify forbidden_zero_bit.
@@ -623,12 +625,12 @@ static const char kHls2[] = "#EXT-X-TARGETDURATION:";
 static const char kHls3[] = "#EXT-X-MEDIA-SEQUENCE:";
 
 // Additional checks for a HLS container.
-static bool CheckHls(const uint8_t* buffer, int buffer_size) {
+static bool CheckHls(base::span<const uint8_t>buffer, int buffer_size) {
   // HLS is simply a play list used for Apple HTTP Live Streaming.
   // Reference: Apple HTTP Live Streaming Overview
   // (http://goo.gl/MIwxj)
 
-  if (StartsWith(buffer, buffer_size, kHlsSignature)) {
+  if (StartsWith(buffer.data(), buffer_size, kHlsSignature)) {
     // Need to find "#EXT-X-STREAM-INF:", "#EXT-X-TARGETDURATION:", or
     // "#EXT-X-MEDIA-SEQUENCE:" somewhere in the buffer. Other playlists (like
     // WinAmp) only have additional lines with #EXTINF
@@ -636,9 +638,9 @@ static bool CheckHls(const uint8_t* buffer, int buffer_size) {
     int offset = strlen(kHlsSignature);
     while (offset < buffer_size) {
       if (buffer[offset] == '#') {
-        if (StartsWith(buffer + offset, buffer_size - offset, kHls1) ||
-            StartsWith(buffer + offset, buffer_size - offset, kHls2) ||
-            StartsWith(buffer + offset, buffer_size - offset, kHls3)) {
+        if (StartsWith(buffer .subspan( offset).data(), buffer_size - offset, kHls1) ||
+            StartsWith(buffer .subspan( offset).data(), buffer_size - offset, kHls2) ||
+            StartsWith(buffer .subspan( offset).data(), buffer_size - offset, kHls3)) {
           return true;
         }
       }
@@ -649,7 +651,7 @@ static bool CheckHls(const uint8_t* buffer, int buffer_size) {
 }
 
 // Checks for a MJPEG stream.
-static bool CheckMJpeg(const uint8_t* buffer, int buffer_size) {
+static bool CheckMJpeg(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ISO/IEC 10918-1 : 1993(E), Annex B
   // (http://www.w3.org/Graphics/JPEG/itu-t81.pdf)
   RCHECK(buffer_size >= 16);
@@ -686,7 +688,7 @@ static bool CheckMJpeg(const uint8_t* buffer, int buffer_size) {
       offset += 2;
     } else {
       // All remaining marker codes are followed by a length of the header.
-      int length = Read16(buffer + offset + 2) + 2;
+      int length = Read16(buffer .subspan( offset + 2)) + 2;
 
       // Special handling of SOS (start of scan) marker since the entropy
       // coded data follows the SOS. Any xFF byte in the data block must be
@@ -718,13 +720,13 @@ enum Mpeg2StartCodes {
 };
 
 // Checks for a MPEG2 Program Stream.
-static bool CheckMpeg2ProgramStream(const uint8_t* buffer, int buffer_size) {
+static bool CheckMpeg2ProgramStream(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ISO/IEC 13818-1 : 2000 (E) / ITU-T Rec. H.222.0 (2000 E).
   RCHECK(buffer_size > 14);
 
   int offset = 0;
   while (offset + 14 < buffer_size) {
-    BitReader reader(buffer + offset, 14);
+    BitReader reader(buffer .subspan( offset).data(), 14);
 
     // Must start with pack_start_code.
     RCHECK(ReadBits(&reader, 24) == 1);
@@ -787,7 +789,7 @@ static bool CheckMpeg2ProgramStream(const uint8_t* buffer, int buffer_size) {
     }
 
     // Check for system headers and PES_packets.
-    while (offset + 6 < buffer_size && Read24(buffer + offset) == 1) {
+    while (offset + 6 < buffer_size && Read24(buffer .subspan( offset)) == 1) {
       // Next 8 bits determine stream type.
       int stream_id = buffer[offset + 3];
 
@@ -803,7 +805,7 @@ static bool CheckMpeg2ProgramStream(const uint8_t* buffer, int buffer_size) {
       if (stream_id == PROGRAM_END_CODE)  // end of stream.
         return true;
 
-      int pes_length = Read16(buffer + offset + 4);
+      int pes_length = Read16(buffer .subspan( offset + 4));
       RCHECK(pes_length > 0);
       offset = offset + 6 + pes_length;
     }
@@ -816,7 +818,7 @@ static bool CheckMpeg2ProgramStream(const uint8_t* buffer, int buffer_size) {
 const uint8_t kMpeg2SyncWord = 0x47;
 
 // Checks for a MPEG2 Transport Stream.
-static bool CheckMpeg2TransportStream(const uint8_t* buffer, int buffer_size) {
+static bool CheckMpeg2TransportStream(base::span<const uint8_t>buffer, int buffer_size) {
   // Spec: ISO/IEC 13818-1 : 2000 (E) / ITU-T Rec. H.222.0 (2000 E).
   // Normal packet size is 188 bytes. However, some systems add various error
   // correction data at the end, resulting in packet of length 192/204/208
@@ -832,7 +834,7 @@ static bool CheckMpeg2TransportStream(const uint8_t* buffer, int buffer_size) {
   }
 
   while (offset + 6 < buffer_size) {
-    BitReader reader(buffer + offset, 6);
+    BitReader reader(buffer .subspan( offset).data(), 6);
 
     // Must start with sync byte.
     RCHECK(ReadBits(&reader, 8) == kMpeg2SyncWord);
@@ -889,7 +891,7 @@ enum Mpeg4StartCodes {
 };
 
 // Checks for a raw MPEG4 bitstream container.
-static bool CheckMpeg4BitStream(const uint8_t* buffer, int buffer_size) {
+static bool CheckMpeg4BitStream(base::span<const uint8_t>buffer, int buffer_size) {
   // Defined in ISO/IEC 14496-2:2001.
   // However, no length ... simply scan for start code values.
   // Note tags are very similar to H.264.
@@ -910,7 +912,7 @@ static bool CheckMpeg4BitStream(const uint8_t* buffer, int buffer_size) {
 
     // Now verify the block. AdvanceToStartCode() made sure that there are
     // at least 6 bytes remaining in the buffer.
-    BitReader reader(buffer + offset, 6);
+    BitReader reader(buffer .subspan( offset).data(), 6);
     RCHECK(ReadBits(&reader, 24) == 1);
 
     int start_code = ReadBits(&reader, 8);
@@ -965,7 +967,7 @@ static bool CheckMpeg4BitStream(const uint8_t* buffer, int buffer_size) {
 }
 
 // Additional checks for a MOV/QuickTime/MPEG4 container.
-static bool CheckMov(const uint8_t* buffer, int buffer_size) {
+static bool CheckMov(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: ISO/IEC 14496-12:2005(E).
   // (http://standards.iso.org/ittf/PubliclyAvailableStandards/c061988_ISO_IEC_14496-12_2012.zip)
   RCHECK(buffer_size > 8);
@@ -973,8 +975,8 @@ static bool CheckMov(const uint8_t* buffer, int buffer_size) {
   int offset = 0;
   int valid_top_level_boxes = 0;
   while (offset + 8 < buffer_size) {
-    uint32_t atomsize = Read32(buffer + offset);
-    uint32_t atomtype = Read32(buffer + offset + 4);
+    uint32_t atomsize = Read32(buffer .subspan( offset));
+    uint32_t atomtype = Read32(buffer .subspan( offset + 4));
 
     // Only need to check for atoms that are valid at the top level. However,
     // "Boxes with an unrecognized type shall be ignored and skipped." So
@@ -1005,9 +1007,9 @@ static bool CheckMov(const uint8_t* buffer, int buffer_size) {
       // Indicates that the length is the next 64bits.
       if (offset + 16 > buffer_size)
         break;
-      if (Read32(buffer + offset + 8) != 0)
+      if (Read32(buffer .subspan( offset + 8)) != 0)
         break;  // Offset is way past buffer size.
-      atomsize = Read32(buffer + offset + 12);
+      atomsize = Read32(buffer .subspan( offset + 12));
     }
     if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))
       break;  // Indicates the last atom or length too big.
@@ -1106,7 +1108,7 @@ static bool ValidMpegAudioFrameHeader(const uint8_t* header,
 }
 
 // Additional checks for a MP3 container.
-static bool CheckMp3(const uint8_t* buffer, int buffer_size) {
+static bool CheckMp3(base::span<const uint8_t>buffer, int buffer_size) {
   // This function assumes that the ID3 header is not present in the file and
   // simply checks for several valid MPEG audio buffers after skipping any
   // optional padding characters.
@@ -1135,7 +1137,7 @@ static bool CheckMp3(const uint8_t* buffer, int buffer_size) {
 // accepted is optional whitespace followed by 1 or more digits. |max_digits|
 // specifies the maximum number of digits to process. Returns true if a valid
 // number is found, false otherwise.
-static bool VerifyNumber(const uint8_t* buffer,
+static bool VerifyNumber(base::span<const uint8_t>buffer,
                          int buffer_size,
                          int* offset,
                          int max_digits) {
@@ -1163,7 +1165,7 @@ static bool VerifyNumber(const uint8_t* buffer,
 // Check that the next character in |buffer| is one of |c1| or |c2|. |c2| is
 // optional. Returns true if there is a match, false if no match or out of
 // space.
-static inline bool VerifyCharacters(const uint8_t* buffer,
+static inline bool VerifyCharacters(base::span<const uint8_t>buffer,
                                     int buffer_size,
                                     int* offset,
                                     char c1,
@@ -1174,12 +1176,12 @@ static inline bool VerifyCharacters(const uint8_t* buffer,
 }
 
 // Checks for a SRT container.
-static bool CheckSrt(const uint8_t* buffer, int buffer_size) {
+static bool CheckSrt(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: http://en.wikipedia.org/wiki/SubRip
   RCHECK(buffer_size > 20);
 
   // First line should just be the subtitle sequence number.
-  int offset = StartsWith(buffer, buffer_size, UTF8_BYTE_ORDER_MARK) ? 3 : 0;
+  int offset = StartsWith(buffer.data(), buffer_size, UTF8_BYTE_ORDER_MARK) ? 3 : 0;
   RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
   RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '\n', '\r'));
 
@@ -1315,7 +1317,7 @@ enum VC1StartCodes {
 };
 
 // Checks for a VC1 bitstream container.
-static bool CheckVC1(const uint8_t* buffer, int buffer_size) {
+static bool CheckVC1(base::span<const uint8_t>buffer, int buffer_size) {
   // Reference: SMPTE 421M
   // (http://standards.smpte.org/content/978-1-61482-555-5/st-421-2006/SEC1.body.pdf)
   // However, no length ... simply scan for start code values.
@@ -1326,10 +1328,10 @@ static bool CheckVC1(const uint8_t* buffer, int buffer_size) {
 
   // First check for Bitstream Metadata Serialization (Annex L)
   if (buffer[0] == 0xc5 &&
-      Read32(buffer + 4) == 0x04 &&
-      Read32(buffer + 20) == 0x0c) {
+      Read32(buffer .subspan( 4)) == 0x04 &&
+      Read32(buffer .subspan( 20)) == 0x0c) {
     // Verify settings in STRUCT_C and STRUCT_A
-    BitReader reader(buffer + 8, 12);
+    BitReader reader(buffer .subspan( 8).data(), 12);
 
     int profile = ReadBits(&reader, 4);
     if (profile == 0 || profile == 4) {  // simple or main
@@ -1384,7 +1386,7 @@ static bool CheckVC1(const uint8_t* buffer, int buffer_size) {
 
     // Now verify the block. AdvanceToStartCode() made sure that there are
     // at least 5 bytes remaining in the buffer.
-    BitReader reader(buffer + offset, 5);
+    BitReader reader(buffer .subspan( offset).data(), 5);
     RCHECK(ReadBits(&reader, 24) == 1);
 
     // Keep track of the number of certain types received.
@@ -1437,7 +1439,7 @@ static const uint8_t kWtvSignature[] = {0xb7, 0xd8, 0x00, 0x20, 0x37, 0x49,
 // Attempt to determine the container type from the buffer provided. This is
 // a simple pass, that uses the first 4 bytes of the buffer as an index to get
 // a rough idea of the container format.
-static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
+static MediaContainerName LookupContainerByFirst4(base::span<const uint8_t>buffer,
                                                   int buffer_size) {
   // Minimum size that the code expects to exist without checking size.
   if (buffer_size < kMinimumContainerSize)
@@ -1446,12 +1448,12 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
   uint32_t first4 = Read32(buffer);
   switch (first4) {
     case 0x1a45dfa3:
-      if (CheckWebm(buffer, buffer_size))
+      if (CheckWebm(buffer.data(), buffer_size))
         return MediaContainerName::kContainerWEBM;
       break;
 
     case 0x3026b275:
-      if (StartsWith(buffer,
+      if (StartsWith(buffer.data(),
                      buffer_size,
                      kAsfSignature,
                      sizeof(kAsfSignature))) {
@@ -1460,7 +1462,7 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       break;
 
     case TAG('#','!','A','M'):
-      if (StartsWith(buffer, buffer_size, kAmrSignature))
+      if (StartsWith(buffer.data(), buffer_size, kAmrSignature))
         return MediaContainerName::kContainerAMR;
       break;
 
@@ -1488,20 +1490,20 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       break;
 
     case TAG('c','a','f','f'):
-      if (CheckCaf(buffer, buffer_size))
+      if (CheckCaf(buffer.data(), buffer_size))
         return MediaContainerName::kContainerCAF;
       break;
 
     case TAG('D','E','X','A'):
       if (buffer_size > 15 &&
-          Read16(buffer + 11) <= 2048 &&
-          Read16(buffer + 13) <= 2048) {
+          Read16(buffer .subspan( 11)) <= 2048 &&
+          Read16(buffer .subspan( 13)) <= 2048) {
         return MediaContainerName::kContainerDXA;
       }
       break;
 
     case TAG('D','T','S','H'):
-      if (Read32(buffer + 4) == TAG('D','H','D','R'))
+      if (Read32(buffer .subspan( 4)) == TAG('D','H','D','R'))
         return MediaContainerName::kContainerDTSHD;
       break;
 
@@ -1512,7 +1514,7 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
     case 0x0001a364:
     case 0x0002a364:
     case 0x0003a364:
-      if (Read32(buffer + 4) != 0 && Read32(buffer + 8) != 0)
+      if (Read32(buffer .subspan( 4)) != 0 && Read32(buffer .subspan( 8)) != 0)
         return MediaContainerName::kContainerIRCAM;
       break;
 
@@ -1524,12 +1526,12 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
     case TAG('F','L','V',2):
     case TAG('F','L','V',3):
     case TAG('F','L','V',4):
-      if (buffer[5] == 0 && Read32(buffer + 5) > 8)
+      if (buffer[5] == 0 && Read32(buffer .subspan( 5)) > 8)
         return MediaContainerName::kContainerFLV;
       break;
 
     case TAG('F','O','R','M'):
-      switch (Read32(buffer + 8)) {
+      switch (Read32(buffer .subspan( 8))) {
         case TAG('A','I','F','F'):
         case TAG('A','I','F','C'):
           return MediaContainerName::kContainerAIFF;
@@ -1540,7 +1542,7 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       return MediaContainerName::kContainerAPE;
 
     case TAG('O','N','2',' '):
-      if (Read32(buffer + 8) == TAG('O','N','2','f'))
+      if (Read32(buffer .subspan( 8)) == TAG('O','N','2','f'))
         return MediaContainerName::kContainerAVI;
       break;
 
@@ -1550,12 +1552,12 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       break;
 
     case TAG('R','F','6','4'):
-      if (buffer_size > 16 && Read32(buffer + 12) == TAG('d','s','6','4'))
+      if (buffer_size > 16 && Read32(buffer .subspan( 12)) == TAG('d','s','6','4'))
         return MediaContainerName::kContainerWAV;
       break;
 
     case TAG('R','I','F','F'):
-      switch (Read32(buffer + 8)) {
+      switch (Read32(buffer .subspan( 8))) {
         case TAG('A','V','I',' '):
         case TAG('A','V','I','X'):
         case TAG('A','V','I','\x19'):
@@ -1567,12 +1569,12 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       break;
 
     case TAG('[','S','c','r'):
-      if (StartsWith(buffer, buffer_size, kAssSignature))
+      if (StartsWith(buffer.data(), buffer_size, kAssSignature))
         return MediaContainerName::kContainerASS;
       break;
 
     case TAG('\xef','\xbb','\xbf','['):
-      if (StartsWith(buffer, buffer_size, kAssBomSignature))
+      if (StartsWith(buffer.data(), buffer_size, kAssBomSignature))
         return MediaContainerName::kContainerASS;
       break;
 
@@ -1585,7 +1587,7 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
       break;
 
     case 0xb7d80020:
-      if (StartsWith(buffer,
+      if (StartsWith(buffer.data(),
                      buffer_size,
                      kWtvSignature,
                      sizeof(kWtvSignature))) {
@@ -1633,8 +1635,8 @@ static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
 }
 
 // Attempt to determine the container name from the buffer provided.
-MediaContainerName DetermineContainer(const uint8_t* buffer, int buffer_size) {
-  DCHECK(buffer);
+MediaContainerName DetermineContainer(base::span<const uint8_t>buffer, int buffer_size) {
+  DCHECK(!buffer.empty());
 
   // Since MOV/QuickTime/MPEG4 streams are common, check for them first.
   if (CheckMov(buffer, buffer_size))
@@ -1675,9 +1677,9 @@ MediaContainerName DetermineContainer(const uint8_t* buffer, int buffer_size) {
   // so scan for a start code.
   int offset = 1;  // No need to start at byte 0 due to First4 check.
   if (AdvanceToStartCode(buffer, buffer_size, &offset, 4, 16, kAc3SyncWord)) {
-    if (CheckAc3(buffer + offset, buffer_size - offset))
+    if (CheckAc3(buffer .subspan( offset), buffer_size - offset))
       return MediaContainerName::kContainerAC3;
-    if (CheckEac3(buffer + offset, buffer_size - offset))
+    if (CheckEac3(buffer .subspan( offset), buffer_size - offset))
       return MediaContainerName::kContainerEAC3;
   }
 
diff --git a/media/base/container_names.h b/media/base/container_names.h
index 544f4a7b1d725..2d4a8ac5dace3 100644
--- a/media/base/container_names.h
+++ b/media/base/container_names.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "media/base/media_export.h"
 
 namespace media {
@@ -69,7 +70,7 @@ enum class MediaContainerName {
 enum { kMinimumContainerSize = 12 };
 
 // Determine the container type.
-MEDIA_EXPORT MediaContainerName DetermineContainer(const uint8_t* buffer,
+MEDIA_EXPORT MediaContainerName DetermineContainer(base::span<const uint8_t>buffer,
                                                    int buffer_size);
 
 }  // namespace container_names
diff --git a/media/base/container_names_unittest.cc b/media/base/container_names_unittest.cc
index dee21a37baf39..ddf826296f899 100644
--- a/media/base/container_names_unittest.cc
+++ b/media/base/container_names_unittest.cc
@@ -26,7 +26,7 @@ namespace container_names {
 // failed.
 #define VERIFY(buffer, name)                                                   \
   EXPECT_EQ(name, DetermineContainer(reinterpret_cast<const uint8_t*>(buffer), \
-                                     sizeof(buffer)))
+                                     (kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))))
 
 // Test that small buffers are handled correctly.
 TEST(ContainerNamesTest, CheckSmallBuffer) {
@@ -53,11 +53,11 @@ TEST(ContainerNamesTest, CheckSmallBuffer) {
 
   // Try a large buffer all zeros.
   char buffer3[4096];
-  memset(buffer3, 0, sizeof(buffer3));
+  memset(buffer3.data(), 0, (buffer3.size() * sizeof(decltype(buffer3)::value_type)));
   VERIFY(buffer3, MediaContainerName::kContainerUnknown);
 
   // Reuse buffer, but all \n this time.
-  memset(buffer3, '\n', sizeof(buffer3));
+  memset(buffer3.data(), '\n', (buffer3.size() * sizeof(decltype(buffer3)::value_type)));
   VERIFY(buffer3, MediaContainerName::kContainerUnknown);
 }
 
@@ -144,12 +144,12 @@ void TestFile(MediaContainerName expected, const base::FilePath& filename) {
 
   // Windows implementation of ReadFile fails if file smaller than desired size,
   // so use file length if file less than 8192 bytes (http://crbug.com/243885).
-  int read_size = sizeof(buffer);
+  int read_size = (buffer.size() * sizeof(decltype(buffer)::value_type));
   std::optional<int64_t> actual_size = base::GetFileSize(filename);
   if (actual_size.has_value() && actual_size.value() < read_size) {
     read_size = actual_size.value();
   }
-  int read = base::ReadFile(filename, buffer, read_size);
+  int read = base::ReadFile(filename, buffer.data(), read_size);
 
   // Now verify the type.
   EXPECT_EQ(expected,
diff --git a/media/base/data_source.h b/media/base/data_source.h
index 0e0a102740562..a7d1a842b39ab 100644
--- a/media/base/data_source.h
+++ b/media/base/data_source.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/functional/callback_forward.h"
 #include "media/base/media_export.h"
 #include "url/gurl.h"
@@ -65,7 +66,7 @@ class MEDIA_EXPORT DataSource : public DataSourceInfo {
   // kReadError in case of error.
   virtual void Read(int64_t position,
                     int size,
-                    uint8_t* data,
+                    base::span<uint8_t>data,
                     DataSource::ReadCB read_cb) = 0;
 
   // Stops the DataSource. Once this is called all future Read() calls will
diff --git a/media/base/decoder_buffer.h b/media/base/decoder_buffer.h
index f03deade25c8b..ab25348fd221a 100644
--- a/media/base/decoder_buffer.h
+++ b/media/base/decoder_buffer.h
@@ -186,17 +186,17 @@ class MEDIA_EXPORT DecoderBuffer
   // Prefer writable_span(), though it should also be removed.
   //
   // TODO(crbug.com/41383992): Remove writable_data().
-  uint8_t* writable_data() const {
+  base::span<uint8_t> writable_data() const {
     DCHECK(!end_of_stream());
     DCHECK(!external_memory_);
-    return const_cast<uint8_t*>(data_.data());
+    return const_cast<uint8_t*>(data_);
   }
 
   // TODO(crbug.com/41383992): Remove writable_span().
   base::span<uint8_t> writable_span() const {
     // TODO(crbug.com/40284755): `data_` should be converted to HeapArray, then
     // it can give out a span safely.
-    return UNSAFE_TODO(base::span(writable_data(), size()));
+    return UNSAFE_TODO(base::span(writable_data().data(), size()));
   }
 
   bool empty() const {
diff --git a/media/base/decoder_buffer_unittest.cc b/media/base/decoder_buffer_unittest.cc
index f82767f863b26..91df1078537c2 100644
--- a/media/base/decoder_buffer_unittest.cc
+++ b/media/base/decoder_buffer_unittest.cc
@@ -215,7 +215,7 @@ TEST(DecoderBufferTest, ReadingWriting) {
   auto buffer = base::MakeRefCounted<DecoderBuffer>(kDataSize);
   ASSERT_TRUE(buffer.get());
 
-  uint8_t* data = buffer->writable_data();
+  uint8_t* data = buffer->writable_data().data();
   ASSERT_TRUE(data);
   ASSERT_EQ(kDataSize, buffer->size());
   base::span(data, buffer->size()).copy_from(kData);
diff --git a/media/base/test_data_util.cc b/media/base/test_data_util.cc
index 3712af7164d9f..f34d1289e5280 100644
--- a/media/base/test_data_util.cc
+++ b/media/base/test_data_util.cc
@@ -241,7 +241,7 @@ scoped_refptr<DecoderBuffer> ReadTestDataFile(std::string_view name) {
   int file_size = base::checked_cast<int>(tmp.value());
 
   auto buffer = base::MakeRefCounted<DecoderBuffer>(file_size);
-  auto* data = reinterpret_cast<char*>(buffer->writable_data());
+  auto* data = reinterpret_cast<char*>(buffer->writable_data().data());
   CHECK_EQ(file_size, base::ReadFile(file_path, data, file_size))
       << "Failed to read '" << name << "'";
 
diff --git a/media/cdm/aes_decryptor_fuzztests.cc b/media/cdm/aes_decryptor_fuzztests.cc
index 03043761894a9..c54ed82e27fb2 100644
--- a/media/cdm/aes_decryptor_fuzztests.cc
+++ b/media/cdm/aes_decryptor_fuzztests.cc
@@ -255,7 +255,7 @@ void DecryptDoesNotCrash(std::size_t clear_bytes,
   // encrypted buffer.
   auto encrypted_buffer =
       base::MakeRefCounted<media::DecoderBuffer>(data.size());
-  memcpy(encrypted_buffer->writable_data(), data.data(), data.size());
+  memcpy(encrypted_buffer->writable_data().data(), data.data(), data.size());
   std::string key_id_string(std::begin(key_id), std::end(key_id));
   std::string iv_string(std::begin(kIv), std::end(kIv));
   encrypted_buffer->set_decrypt_config(media::DecryptConfig::CreateCencConfig(
diff --git a/media/cdm/aes_decryptor_unittest.cc b/media/cdm/aes_decryptor_unittest.cc
index 7512ff2e77b55..9d5f3953a690a 100644
--- a/media/cdm/aes_decryptor_unittest.cc
+++ b/media/cdm/aes_decryptor_unittest.cc
@@ -213,7 +213,7 @@ scoped_refptr<DecoderBuffer> CreateEncryptedBuffer(
   DCHECK(!data.empty());
   DCHECK(!iv.empty());
   auto encrypted_buffer = base::MakeRefCounted<DecoderBuffer>(data.size());
-  memcpy(encrypted_buffer->writable_data(), data.data(), data.size());
+  memcpy(encrypted_buffer->writable_data().data(), data.data(), data.size());
   std::string key_id_string(key_id.begin(), key_id.end());
   std::string iv_string(iv.begin(), iv.end());
   encrypted_buffer->set_decrypt_config(DecryptConfig::CreateCencConfig(
@@ -225,7 +225,7 @@ scoped_refptr<DecoderBuffer> CreateClearBuffer(
     const std::vector<uint8_t>& data) {
   DCHECK(!data.empty());
   auto encrypted_buffer = base::MakeRefCounted<DecoderBuffer>(data.size());
-  memcpy(encrypted_buffer->writable_data(), data.data(), data.size());
+  memcpy(encrypted_buffer->writable_data().data(), data.data(), data.size());
   return encrypted_buffer;
 }
 
diff --git a/media/filters/blocking_url_protocol.cc b/media/filters/blocking_url_protocol.cc
index d76e7b32fa13f..08541c5a27200 100644
--- a/media/filters/blocking_url_protocol.cc
+++ b/media/filters/blocking_url_protocol.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -42,7 +44,7 @@ void BlockingUrlProtocol::Abort() {
   data_source_ = nullptr;
 }
 
-int BlockingUrlProtocol::Read(int size, uint8_t* data) {
+int BlockingUrlProtocol::Read(int size, base::span<uint8_t>data) {
   {
     // Read errors are unrecoverable.
     base::AutoLock lock(data_source_lock_);
diff --git a/media/filters/blocking_url_protocol.h b/media/filters/blocking_url_protocol.h
index c72ecf31bed07..3ead4a4ef2cc9 100644
--- a/media/filters/blocking_url_protocol.h
+++ b/media/filters/blocking_url_protocol.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/synchronization/lock.h"
@@ -41,7 +42,7 @@ class MEDIA_EXPORT BlockingUrlProtocol : public FFmpegURLProtocol {
   void Abort();
 
   // FFmpegURLProtocol implementation.
-  int Read(int size, uint8_t* data) override;
+  int Read(int size, base::span<uint8_t>data) override;
   bool GetPosition(int64_t* position_out) override;
   bool SetPosition(int64_t position) override;
   bool GetSize(int64_t* size_out) override;
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 5f8ce5ea1d45c..08fb73de7a10c 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -28,7 +30,7 @@ namespace media {
 // with the previous URLProtocol based approach.
 enum { kBufferSize = 32 * 1024 };
 
-static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
+static int AVIOReadOperation(void* opaque, base::span<uint8_t>buf, int buf_size) {
   return reinterpret_cast<FFmpegURLProtocol*>(opaque)->Read(buf_size, buf);
 }
 
@@ -174,11 +176,11 @@ bool FFmpegGlue::OpenContext(bool is_local_file) {
       return false;
 
     const int num_read =
-        AVIOReadOperation(avio_context_->opaque, buffer.data(), buffer.size());
+        AVIOReadOperation(avio_context_->opaque, buffer, buffer.size());
     if (num_read < container_names::kMinimumContainerSize)
       return false;
 
-    container_ = container_names::DetermineContainer(buffer.data(), num_read);
+    container_ = container_names::DetermineContainer(buffer, num_read);
     LogContainer(is_local_file, container_);
 
     detected_hls_ =
diff --git a/media/filters/ffmpeg_glue.h b/media/filters/ffmpeg_glue.h
index 8447225455a5a..106b6ea39bfb7 100644
--- a/media/filters/ffmpeg_glue.h
+++ b/media/filters/ffmpeg_glue.h
@@ -25,6 +25,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/check.h"
 #include "base/memory/raw_ptr.h"
 #include "media/base/container_names.h"
@@ -40,7 +41,7 @@ class MEDIA_EXPORT FFmpegURLProtocol {
  public:
   // Read the given amount of bytes into data, returns the number of bytes read
   // if successful, kReadError otherwise.
-  virtual int Read(int size, uint8_t* data) = 0;
+  virtual int Read(int size, base::span<uint8_t>data) = 0;
 
   // Returns true and the current file position for this file, false if the
   // file position could not be retrieved.
diff --git a/media/filters/ffmpeg_video_decoder_unittest.cc b/media/filters/ffmpeg_video_decoder_unittest.cc
index 06ba8dcfb15db..a3e47aab415aa 100644
--- a/media/filters/ffmpeg_video_decoder_unittest.cc
+++ b/media/filters/ffmpeg_video_decoder_unittest.cc
@@ -67,7 +67,7 @@ class FFmpegVideoDecoderTest : public testing::Test {
     end_of_stream_buffer_ = DecoderBuffer::CreateEOSBuffer();
     i_frame_buffer_ = ReadTestDataFile("h264-320x180-frame-0");
     corrupt_i_frame_buffer_ = ReadTestDataFile("h264-320x180-frame-0");
-    memset(corrupt_i_frame_buffer_->writable_data(), 0,
+    memset(corrupt_i_frame_buffer_->writable_data().data(), 0,
            corrupt_i_frame_buffer_->size() / 2);
   }
 
diff --git a/media/filters/file_data_source.cc b/media/filters/file_data_source.cc
index a853dbbf4dc47..5ede99e7c64ca 100644
--- a/media/filters/file_data_source.cc
+++ b/media/filters/file_data_source.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -39,7 +41,7 @@ void FileDataSource::Abort() {}
 
 void FileDataSource::Read(int64_t position,
                           int size,
-                          uint8_t* data,
+                          base::span<uint8_t>data,
                           DataSource::ReadCB read_cb) {
   if (force_read_errors_ || !file_.IsValid()) {
     std::move(read_cb).Run(kReadError);
@@ -57,7 +59,7 @@ void FileDataSource::Read(int64_t position,
   int64_t clamped_size =
       std::min(static_cast<int64_t>(size), file_size - position);
 
-  memcpy(data, file_.data() + position, clamped_size);
+  memcpy(data.data(), file_.data() + position, clamped_size);
   bytes_read_ += clamped_size;
   std::move(read_cb).Run(clamped_size);
 }
diff --git a/media/filters/file_data_source.h b/media/filters/file_data_source.h
index 0f62384a8cdf0..289cf8357b314 100644
--- a/media/filters/file_data_source.h
+++ b/media/filters/file_data_source.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
 #include "base/files/memory_mapped_file.h"
@@ -33,7 +34,7 @@ class MEDIA_EXPORT FileDataSource : public DataSource {
   void Abort() override;
   void Read(int64_t position,
             int size,
-            uint8_t* data,
+            base::span<uint8_t>data,
             DataSource::ReadCB read_cb) override;
   [[nodiscard]] bool GetSize(int64_t* size_out) override;
   bool IsStreaming() override;
diff --git a/media/filters/hls_data_source_provider.cc b/media/filters/hls_data_source_provider.cc
index 5eb5647ec4f32..a1bdc3132ccd3 100644
--- a/media/filters/hls_data_source_provider.cc
+++ b/media/filters/hls_data_source_provider.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -87,7 +89,7 @@ void HlsDataSourceStream::Clear() {
   write_index_ = 0;
 }
 
-uint8_t* HlsDataSourceStream::LockStreamForWriting(int ensure_minimum_space) {
+base::span<uint8_t> HlsDataSourceStream::LockStreamForWriting(int ensure_minimum_space) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   TRACE_EVENT_NESTABLE_ASYNC_BEGIN1("media", "HLS::Read", this, "minimum space",
                                     ensure_minimum_space);
diff --git a/media/filters/hls_data_source_provider.h b/media/filters/hls_data_source_provider.h
index 3fa0ba36f67ad..bb67258880928 100644
--- a/media/filters/hls_data_source_provider.h
+++ b/media/filters/hls_data_source_provider.h
@@ -10,6 +10,7 @@
 #include <optional>
 #include <string_view>
 
+#include "base/containers/span.h"
 #include "base/containers/queue.h"
 #include "base/functional/callback.h"
 #include "base/types/id_type.h"
@@ -103,7 +104,7 @@ class MEDIA_EXPORT HlsDataSourceStream {
 
   std::optional<size_t> max_read_position() const { return max_read_position_; }
 
-  const uint8_t* raw_data() const { return buffer_.data(); }
+  const base::span<uint8_t> raw_data() const { return buffer_; }
 
   uint64_t memory_usage() const { return memory_usage_; }
 
@@ -150,7 +151,7 @@ class MEDIA_EXPORT HlsDataSourceStream {
   // Used by a HlsDataSourceProvider implementation to start adding new data,
   // which means ensuring that there is enough space for the expected write, as
   // well as returning the correct buffer address to write into.
-  uint8_t* LockStreamForWriting(int ensure_minimum_space);
+  base::span<uint8_t> LockStreamForWriting(int ensure_minimum_space);
 
  private:
   const StreamId stream_id_;
diff --git a/media/filters/hls_data_source_provider_impl.cc b/media/filters/hls_data_source_provider_impl.cc
index ed9c3fa2a8666..b374b3306a86c 100644
--- a/media/filters/hls_data_source_provider_impl.cc
+++ b/media/filters/hls_data_source_provider_impl.cc
@@ -6,6 +6,7 @@
 
 #include <algorithm>
 
+#include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/task/bind_post_task.h"
 #include "base/trace_event/trace_event.h"
@@ -143,7 +144,7 @@ void HlsDataSourceProviderImpl::ReadFromExistingStream(
   }
 
   auto int_read_size = base::checked_cast<int>(read_size);
-  auto* buffer_data = stream->LockStreamForWriting(int_read_size);
+  base::span<uint8_t>buffer_data = stream->LockStreamForWriting(int_read_size);
   auto stream_id = stream->stream_id();
   uint64_t async_event_key = reinterpret_cast<std::uintptr_t>(this);
 
diff --git a/media/filters/hls_manifest_demuxer_engine.cc b/media/filters/hls_manifest_demuxer_engine.cc
index d7b25d92a45dc..439cf9a19d612 100644
--- a/media/filters/hls_manifest_demuxer_engine.cc
+++ b/media/filters/hls_manifest_demuxer_engine.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -129,7 +131,7 @@ HlsDemuxerStatus::Or<RelaxedParserSupportedType> CheckMP4Bytes(
 }
 
 HlsDemuxerStatus::Or<RelaxedParserSupportedType>
-CheckBitstreamForContainerMagic(const uint8_t* data, size_t size) {
+CheckBitstreamForContainerMagic(base::span<const uint8_t>data, size_t size) {
   CHECK_GT(size, 0lu);
 
   constexpr uint8_t kMP4FirstByte = 0x66;
@@ -141,7 +143,7 @@ CheckBitstreamForContainerMagic(const uint8_t* data, size_t size) {
   switch (data[0]) {
     case kMP4FirstByte:
     case kFMP4FirstByte: {
-      return CheckMP4Bytes(data, size);
+      return CheckMP4Bytes(data.data(), size);
     }
     case kID3FirstByte:
     case kAACFirstByte: {
@@ -971,7 +973,7 @@ void HlsManifestDemuxerEngine::DetermineBitstreamContainer(
       case hls::XKeyTagMethod::kAES256: {
         auto maybe_iv = enc_data->GetIVStr(segment->GetMediaSequenceNumber());
         base::span<const uint8_t> stream_data =
-            base::span(stream->raw_data(), stream->buffer_size());
+            base::span(stream->raw_data().data(), stream->buffer_size());
         if (!maybe_iv.has_value() ||
             maybe_iv->size() != crypto::aes_cbc::kBlockSize) {
           std::move(cb).Run(
@@ -988,7 +990,7 @@ void HlsManifestDemuxerEngine::DetermineBitstreamContainer(
           return;
         }
         std::move(cb).Run(CheckBitstreamForContainerMagic(
-            maybe_plaintext->data(), maybe_plaintext->size()));
+            *maybe_plaintext, maybe_plaintext->size()));
         return;
       }
       default: {
diff --git a/media/filters/hls_rendition_impl.cc b/media/filters/hls_rendition_impl.cc
index e39d68286f798..9bc083bef167d 100644
--- a/media/filters/hls_rendition_impl.cc
+++ b/media/filters/hls_rendition_impl.cc
@@ -421,7 +421,7 @@ void HlsRenditionImpl::OnSegmentData(scoped_refptr<hls::MediaSegment> segment,
   // potential use-after-free or stack smash.
   std::vector<uint8_t> plaintext;
   base::span<const uint8_t> stream_data =
-      base::span(stream->raw_data(), stream->buffer_size());
+      base::span(stream->raw_data().data(), stream->buffer_size());
 
   if (auto enc_data = segment->GetEncryptionData()) {
     switch (enc_data->GetMethod()) {
diff --git a/media/filters/hls_test_helpers.cc b/media/filters/hls_test_helpers.cc
index ee3de838f9187..fb70b38858355 100644
--- a/media/filters/hls_test_helpers.cc
+++ b/media/filters/hls_test_helpers.cc
@@ -40,7 +40,7 @@ StringHlsDataSourceStreamFactory::CreateStream(std::string content,
   auto stream = std::make_unique<HlsDataSourceStream>(
       HlsDataSourceStream::StreamId::FromUnsafeValue(42), std::move(segments),
       base::DoNothing());
-  auto* buffer = stream->LockStreamForWriting(content.length());
+  auto* buffer = stream->LockStreamForWriting(content.length()).data();
   memcpy(buffer, content.c_str(), content.length());
   stream->UnlockStreamPostWrite(content.length(), true);
   if (taint_origin) {
@@ -61,7 +61,7 @@ FileHlsDataSourceStreamFactory::CreateStream(std::string filename,
   auto stream = std::make_unique<HlsDataSourceStream>(
       HlsDataSourceStream::StreamId::FromUnsafeValue(42), std::move(segments),
       base::DoNothing());
-  auto* buffer = stream->LockStreamForWriting(file_size.value());
+  auto* buffer = stream->LockStreamForWriting(file_size.value()).data();
   CHECK_EQ(file_size.value(),
            base::ReadFile(file_path, reinterpret_cast<char*>(buffer),
                           file_size.value()));
diff --git a/media/filters/in_memory_url_protocol.cc b/media/filters/in_memory_url_protocol.cc
index ab27c2caf5b77..21866f65c9de6 100644
--- a/media/filters/in_memory_url_protocol.cc
+++ b/media/filters/in_memory_url_protocol.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -23,7 +25,7 @@ InMemoryUrlProtocol::InMemoryUrlProtocol(const uint8_t* data,
 
 InMemoryUrlProtocol::~InMemoryUrlProtocol() = default;
 
-int InMemoryUrlProtocol::Read(int size, uint8_t* data) {
+int InMemoryUrlProtocol::Read(int size, base::span<uint8_t>data) {
   // Not sure this can happen, but it's unclear from the ffmpeg code, so guard
   // against it.
   if (size < 0)
@@ -39,7 +41,7 @@ int InMemoryUrlProtocol::Read(int size, uint8_t* data) {
     size = available_bytes;
 
   if (size > 0) {
-    memcpy(data, data_ + base::checked_cast<size_t>(position_), size);
+    memcpy(data.data(), data_ + base::checked_cast<size_t>(position_), size);
     position_ += size;
   }
 
diff --git a/media/filters/in_memory_url_protocol.h b/media/filters/in_memory_url_protocol.h
index 38591438434ef..60c233336b757 100644
--- a/media/filters/in_memory_url_protocol.h
+++ b/media/filters/in_memory_url_protocol.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "media/filters/ffmpeg_glue.h"
@@ -30,7 +31,7 @@ class MEDIA_EXPORT InMemoryUrlProtocol : public FFmpegURLProtocol {
   virtual ~InMemoryUrlProtocol();
 
   // FFmpegURLProtocol methods.
-  int Read(int size, uint8_t* data) override;
+  int Read(int size, base::span<uint8_t>data) override;
   bool GetPosition(int64_t* position_out) override;
   bool SetPosition(int64_t position) override;
   bool GetSize(int64_t* size_out) override;
diff --git a/media/filters/in_memory_url_protocol_unittest.cc b/media/filters/in_memory_url_protocol_unittest.cc
index 95c2fdde039ee..e984d525700fc 100644
--- a/media/filters/in_memory_url_protocol_unittest.cc
+++ b/media/filters/in_memory_url_protocol_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -22,8 +24,8 @@ TEST(InMemoryUrlProtocolTest, ReadFromLargeBuffer) {
                                false);
 
   uint8_t out[sizeof(kData)];
-  EXPECT_EQ(4, protocol.Read(sizeof(out), out));
-  EXPECT_EQ(0, memcmp(out, kData, sizeof(out)));
+  EXPECT_EQ(4, protocol.Read((out.size() * sizeof(decltype(out)::value_type)), out));
+  EXPECT_EQ(0, memcmp(out.data(), kData, (out.size() * sizeof(decltype(out)::value_type))));
 }
 
 TEST(InMemoryUrlProtocolTest, ReadWithNegativeSize) {
@@ -37,7 +39,7 @@ TEST(InMemoryUrlProtocolTest, ReadWithZeroSize) {
   InMemoryUrlProtocol protocol(kData, sizeof(kData), false);
 
   uint8_t out;
-  EXPECT_EQ(0, protocol.Read(0, &out));
+  EXPECT_EQ(0, protocol.Read(0, base::span<uint8_t, 1>(&out)));
 }
 
 TEST(InMemoryUrlProtocolTest, SetPosition) {
@@ -48,11 +50,11 @@ TEST(InMemoryUrlProtocolTest, SetPosition) {
 
   uint8_t out;
   EXPECT_TRUE(protocol.SetPosition(sizeof(kData)));
-  EXPECT_EQ(AVERROR_EOF, protocol.Read(1, &out));
+  EXPECT_EQ(AVERROR_EOF, protocol.Read(1, base::span<uint8_t, 1>(&out)));
 
   int i = sizeof(kData) / 2;
   EXPECT_TRUE(protocol.SetPosition(i));
-  EXPECT_EQ(1, protocol.Read(1, &out));
+  EXPECT_EQ(1, protocol.Read(1, base::span<uint8_t, 1>(&out)));
   EXPECT_EQ(kData[i], out);
 }
 
diff --git a/media/filters/memory_data_source.cc b/media/filters/memory_data_source.cc
index 23364e7a0958b..a856291cac1cf 100644
--- a/media/filters/memory_data_source.cc
+++ b/media/filters/memory_data_source.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -28,7 +30,7 @@ MemoryDataSource::~MemoryDataSource() = default;
 
 void MemoryDataSource::Read(int64_t position,
                             int size,
-                            uint8_t* data,
+                            base::span<uint8_t>data,
                             DataSource::ReadCB read_cb) {
   DCHECK(read_cb);
 
@@ -43,8 +45,8 @@ void MemoryDataSource::Read(int64_t position,
                                  size_ - static_cast<size_t>(position));
 
   if (clamped_size > 0) {
-    DCHECK(data);
-    memcpy(data, data_ + base::checked_cast<size_t>(position), clamped_size);
+    DCHECK(!data.empty());
+    memcpy(data.data(), data_ + base::checked_cast<size_t>(position), clamped_size);
   }
 
   std::move(read_cb).Run(clamped_size);
diff --git a/media/filters/memory_data_source.h b/media/filters/memory_data_source.h
index 8a00c30d3405f..3c54a40c24566 100644
--- a/media/filters/memory_data_source.h
+++ b/media/filters/memory_data_source.h
@@ -11,6 +11,7 @@
 #include <atomic>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "media/base/data_source.h"
 
@@ -35,7 +36,7 @@ class MEDIA_EXPORT MemoryDataSource final : public DataSource {
   // Implementation of DataSource.
   void Read(int64_t position,
             int size,
-            uint8_t* data,
+            base::span<uint8_t>data,
             DataSource::ReadCB read_cb) final;
   void Stop() final;
   void Abort() final;
diff --git a/media/filters/memory_data_source_unittest.cc b/media/filters/memory_data_source_unittest.cc
index bf407b0327cdb..79c8afdddce37 100644
--- a/media/filters/memory_data_source_unittest.cc
+++ b/media/filters/memory_data_source_unittest.cc
@@ -41,7 +41,7 @@ class MemoryDataSourceTest : public ::testing::Test {
 
     EXPECT_CALL(*this, ReadCB(expected_read_size));
     memory_data_source_->Read(
-        position, size, data.data(),
+        position, size, data,
         base::BindOnce(&MemoryDataSourceTest::ReadCB, base::Unretained(this)));
 
     if (expected_read_size != DataSource::kReadError) {
diff --git a/media/formats/ac3/ac3_util.cc b/media/formats/ac3/ac3_util.cc
index 31d3f6262b62d..d016cb9e33167 100644
--- a/media/formats/ac3/ac3_util.cc
+++ b/media/formats/ac3/ac3_util.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -84,13 +86,13 @@ Ac3Header::Ac3Header(const uint8_t* data, int size) {
 }
 
 // Search for next synchronization word, which is 0x0B-0x77.
-const uint8_t* FindNextSyncWord(const uint8_t* const begin,
+const base::span<uint8_t> FindNextSyncWord(const base::span<const uint8_t>begin,
                                 const uint8_t* const end) {
-  DCHECK(begin);
+  DCHECK(!begin.empty());
   DCHECK(end);
   DCHECK_LE(begin, end);
 
-  const uint8_t* current = begin;
+  base::span<const uint8_t>current = begin;
 
   while (current < end - 1) {
     if (current[0] == 0x0B && current[1] == 0x77) {
@@ -99,13 +101,13 @@ const uint8_t* FindNextSyncWord(const uint8_t* const begin,
 
       return current;
     } else if (current[1] != 0x0B) {
-      current += 2;
+      current=current.subspan(2);
     } else {
       ++current;
     }
   }
 
-  return nullptr;
+  return {};
 }
 
 // Returns the number of audio samples represented by the given E-AC3
@@ -158,19 +160,19 @@ int ParseAc3SyncFrameSize(Ac3Header& header) {
 
 // Returns the total number of audio samples in the given buffer, which contains
 // several complete (E-)AC3 syncframes.
-int ParseTotalSampleCount(const uint8_t* data, size_t size, bool is_eac3) {
-  DCHECK(data);
+int ParseTotalSampleCount(base::span<const uint8_t>data, size_t size, bool is_eac3) {
+  DCHECK(!data.empty());
 
   if (size < kHeaderSizeInByte) {
     return 0;
   }
 
-  const uint8_t* const end = data + size;
-  const uint8_t* current = FindNextSyncWord(data, end);
+  const uint8_t* const end = data .subspan( size).data();
+  base::span<const uint8_t>current = FindNextSyncWord(data, end);
   int total_sample_count = 0;
 
-  while (current && end - current > kHeaderSizeInByte) {
-    Ac3Header header(current, end - current);
+  while (!current.empty() && end - current > kHeaderSizeInByte) {
+    Ac3Header header(current.data(), end - current);
 
     int frame_size = is_eac3 ? ParseEac3SyncFrameSize(header)
                              : ParseAc3SyncFrameSize(header);
@@ -178,7 +180,7 @@ int ParseTotalSampleCount(const uint8_t* data, size_t size, bool is_eac3) {
                                : GetAc3SyncFrameSampleCount();
 
     if (frame_size > 0 && sample_count > 0) {
-      current += frame_size;
+      current=current.subspan(frame_size);
       if (current > end) {
         DVLOG(2) << __func__ << " Incomplete frame, missing " << current - end
                  << " bytes.";
@@ -190,7 +192,7 @@ int ParseTotalSampleCount(const uint8_t* data, size_t size, bool is_eac3) {
       DVLOG(2)
           << __func__
           << " Invalid frame, skip 2 bytes to find next synchronization word.";
-      current += 2;
+      current=current.subspan(2);
     }
 
     current = FindNextSyncWord(current, end);
@@ -202,12 +204,12 @@ int ParseTotalSampleCount(const uint8_t* data, size_t size, bool is_eac3) {
 }  // namespace anonymous
 
 // static
-int Ac3Util::ParseTotalAc3SampleCount(const uint8_t* data, size_t size) {
+int Ac3Util::ParseTotalAc3SampleCount(base::span<const uint8_t>data, size_t size) {
   return ParseTotalSampleCount(data, size, false);
 }
 
 // static
-int Ac3Util::ParseTotalEac3SampleCount(const uint8_t* data, size_t size) {
+int Ac3Util::ParseTotalEac3SampleCount(base::span<const uint8_t>data, size_t size) {
   return ParseTotalSampleCount(data, size, true);
 }
 
diff --git a/media/formats/ac3/ac3_util.h b/media/formats/ac3/ac3_util.h
index 05e2ac343de2e..ab2d982775220 100644
--- a/media/formats/ac3/ac3_util.h
+++ b/media/formats/ac3/ac3_util.h
@@ -8,6 +8,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "media/base/media_export.h"
 
 namespace media {
@@ -19,11 +20,11 @@ class MEDIA_EXPORT Ac3Util {
 
   // Returns the total number of audio samples in the given buffer, which
   // contains several complete AC3 syncframes.
-  static int ParseTotalAc3SampleCount(const uint8_t* data, size_t size);
+  static int ParseTotalAc3SampleCount(base::span<const uint8_t>data, size_t size);
 
   // Returns the total number of audio samples in the given buffer, which
   // contains several complete E-AC3 syncframes.
-  static int ParseTotalEac3SampleCount(const uint8_t* data, size_t size);
+  static int ParseTotalEac3SampleCount(base::span<const uint8_t>data, size_t size);
 };
 
 }  // namespace media
diff --git a/media/formats/ac3/ac3_util_fuzzer.cc b/media/formats/ac3/ac3_util_fuzzer.cc
index 30acb18e6e861..d061c1975938f 100644
--- a/media/formats/ac3/ac3_util_fuzzer.cc
+++ b/media/formats/ac3/ac3_util_fuzzer.cc
@@ -13,7 +13,7 @@
 namespace media {
 
 void ParseTotalAc3SampleCountNeverCrashes(base::span<const uint8_t> buffer) {
-  Ac3Util::ParseTotalAc3SampleCount(buffer.data(), buffer.size());
+  Ac3Util::ParseTotalAc3SampleCount(buffer, buffer.size());
 }
 
 FUZZ_TEST(Ac3UtilTest, ParseTotalAc3SampleCountNeverCrashes)
@@ -21,7 +21,7 @@ FUZZ_TEST(Ac3UtilTest, ParseTotalAc3SampleCountNeverCrashes)
         fuzztest::NonEmpty(fuzztest::Arbitrary<std::vector<uint8_t>>()));
 
 void ParseTotalEac3SampleCountNeverCrashes(base::span<const uint8_t> buffer) {
-  Ac3Util::ParseTotalEac3SampleCount(buffer.data(), buffer.size());
+  Ac3Util::ParseTotalEac3SampleCount(buffer, buffer.size());
 }
 
 FUZZ_TEST(Ac3UtilTest, ParseTotalEac3SampleCountNeverCrashes)
diff --git a/media/formats/ac3/ac3_util_unittest.cc b/media/formats/ac3/ac3_util_unittest.cc
index 98d71eeb30939..1be74837fe706 100644
--- a/media/formats/ac3/ac3_util_unittest.cc
+++ b/media/formats/ac3/ac3_util_unittest.cc
@@ -26,15 +26,15 @@ struct Ac3StreamInfo {
 
 TEST(Ac3UtilTest, ParseTotalAc3SampleCount) {
   char buffer[8192];
-  const int buffer_size = sizeof(buffer);
+  const int buffer_size = (buffer.size() * sizeof(decltype(buffer)::value_type));
   const Ac3StreamInfo ac3StreamInfo[] = {
       {834, 1 * 1536}, {1670, 2 * 1536}, {2506, 3 * 1536},
   };
 
   for (const Ac3StreamInfo& info : ac3StreamInfo) {
-    memset(buffer, 0, buffer_size);
+    memset(buffer.data(), 0, buffer_size);
     int data_size =
-        base::ReadFile(GetTestDataFilePath("bear.ac3"), buffer, info.size);
+        base::ReadFile(GetTestDataFilePath("bear.ac3"), buffer.data(), info.size);
 
     EXPECT_EQ(info.pcm_frame_count,
               ::media::Ac3Util::ParseTotalAc3SampleCount(
@@ -44,15 +44,15 @@ TEST(Ac3UtilTest, ParseTotalAc3SampleCount) {
 
 TEST(Ac3UtilTest, ParseTotalEac3SampleCount) {
   char buffer[8192];
-  const int buffer_size = sizeof(buffer);
+  const int buffer_size = (buffer.size() * sizeof(decltype(buffer)::value_type));
   const Ac3StreamInfo ac3StreamInfo[] = {
       {870, 1 * 1536}, {1742, 2 * 1536}, {2612, 3 * 1536},
   };
 
   for (const Ac3StreamInfo& info : ac3StreamInfo) {
-    memset(buffer, 0, buffer_size);
+    memset(buffer.data(), 0, buffer_size);
     int data_size =
-        base::ReadFile(GetTestDataFilePath("bear.eac3"), buffer, info.size);
+        base::ReadFile(GetTestDataFilePath("bear.eac3"), buffer.data(), info.size);
 
     EXPECT_EQ(info.pcm_frame_count,
               ::media::Ac3Util::ParseTotalEac3SampleCount(
diff --git a/media/formats/mp2t/mp2t_stream_parser.cc b/media/formats/mp2t/mp2t_stream_parser.cc
index 3614f4f6f8f3e..e9686178cb6f8 100644
--- a/media/formats/mp2t/mp2t_stream_parser.cc
+++ b/media/formats/mp2t/mp2t_stream_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -349,7 +351,7 @@ StreamParser::ParseStatus Mp2tStreamParser::Parse(
   DCHECK_GE(max_pending_bytes_to_inspect, 0);
 
   auto queue_data = ts_byte_queue_.Data();
-  const uint8_t* ts_buffer = queue_data.data();
+  base::span<const uint8_t>ts_buffer = queue_data;
   size_t queue_size = queue_data.size();
   CHECK_GE(queue_size, uninspected_pending_bytes_);
 
@@ -384,7 +386,7 @@ StreamParser::ParseStatus Mp2tStreamParser::Parse(
                << " skipped_bytes=" << skipped_bytes;
       CHECK_GE(ts_buffer_size, skipped_bytes);
       ts_buffer_size -= skipped_bytes;
-      ts_buffer += skipped_bytes;
+      ts_buffer=ts_buffer.subspan(skipped_bytes);
       bytes_to_pop += skipped_bytes;
       continue;
     }
@@ -437,7 +439,7 @@ StreamParser::ParseStatus Mp2tStreamParser::Parse(
 
     // Go to the next packet.
     ts_buffer_size -= TsPacket::kPacketSize;
-    ts_buffer += TsPacket::kPacketSize;
+    ts_buffer=ts_buffer.subspan(TsPacket::kPacketSize);
     bytes_to_pop += TsPacket::kPacketSize;
   }
 
diff --git a/media/formats/mp2t/ts_packet.cc b/media/formats/mp2t/ts_packet.cc
index 47bca82c944cf..d704efeb2a2ff 100644
--- a/media/formats/mp2t/ts_packet.cc
+++ b/media/formats/mp2t/ts_packet.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -22,7 +24,7 @@ namespace mp2t {
 static const uint8_t kTsHeaderSyncword = 0x47;
 
 // static
-int TsPacket::Sync(const uint8_t* buf, int size) {
+int TsPacket::Sync(base::span<const uint8_t>buf, int size) {
   int k = 0;
   for (; k < size; k++) {
     // Verify that we have 4 syncwords in a row when possible,
@@ -51,7 +53,7 @@ int TsPacket::Sync(const uint8_t* buf, int size) {
 }
 
 // static
-TsPacket* TsPacket::Parse(const uint8_t* buf, size_t size) {
+TsPacket* TsPacket::Parse(base::span<const uint8_t>buf, size_t size) {
   if (size < kPacketSize) {
     DVLOG(1) << "Buffer does not hold one full TS packet:"
              << " buffer_size=" << size;
@@ -67,7 +69,7 @@ TsPacket* TsPacket::Parse(const uint8_t* buf, size_t size) {
   }
 
   std::unique_ptr<TsPacket> ts_packet(new TsPacket());
-  bool status = ts_packet->ParseHeader(buf);
+  bool status = ts_packet->ParseHeader(buf.data());
   if (!status) {
     DVLOG(1) << "Parsing header failed";
     return NULL;
diff --git a/media/formats/mp2t/ts_packet.h b/media/formats/mp2t/ts_packet.h
index 45126c14583a5..f7a0ad373ff26 100644
--- a/media/formats/mp2t/ts_packet.h
+++ b/media/formats/mp2t/ts_packet.h
@@ -22,12 +22,12 @@ class TsPacket {
 
   // Return the number of bytes to discard
   // to be synchronized on a TS syncword.
-  static int Sync(const uint8_t* buf, int size);
+  static int Sync(base::span<const uint8_t>buf, int size);
 
   // Parse a TS packet.
   // Return a TsPacket only when parsing was successful.
   // Return NULL otherwise.
-  static TsPacket* Parse(const uint8_t* buf, size_t size);
+  static TsPacket* Parse(base::span<const uint8_t>buf, size_t size);
 
   TsPacket(const TsPacket&) = delete;
   TsPacket& operator=(const TsPacket&) = delete;
diff --git a/media/formats/mpeg/mpeg_audio_stream_parser_base.cc b/media/formats/mpeg/mpeg_audio_stream_parser_base.cc
index 66912e84ffdda..9d7502002eefd 100644
--- a/media/formats/mpeg/mpeg_audio_stream_parser_base.cc
+++ b/media/formats/mpeg/mpeg_audio_stream_parser_base.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -40,7 +42,7 @@ static const int kID3v1Size = 128;
 static const int kID3v1ExtendedSize = 227;
 static const uint32_t kID3v2StartCode = 0x49443300;  // 'ID3\0'
 
-static int LocateEndOfHeaders(const uint8_t* buf, int buf_len, int i) {
+static int LocateEndOfHeaders(base::span<const uint8_t>buf, int buf_len, int i) {
   bool was_lf = false;
   char last_c = '\0';
   for (; i < buf_len; ++i) {
@@ -159,7 +161,7 @@ StreamParser::ParseStatus MPEGAudioStreamParserBase::Parse(
   bool end_of_segment = true;
   BufferQueue buffers;
 
-  const uint8_t* data = nullptr;
+  base::span<const uint8_t>data = {};
   int queue_size = 0;
   queue_.Peek(&data, &queue_size);
 
@@ -190,7 +192,7 @@ StreamParser::ParseStatus MPEGAudioStreamParserBase::Parse(
     int bytes_read = 0;
     bool parsed_metadata = true;
     if ((start_code & start_code_mask_) == start_code_mask_) {
-      bytes_read = ParseFrame(data, data_size, &buffers);
+      bytes_read = ParseFrame(data.data(), data_size, &buffers);
 
       // Only allow the current segment to end if a full frame has been parsed.
       end_of_segment = bytes_read > 0;
@@ -198,9 +200,9 @@ StreamParser::ParseStatus MPEGAudioStreamParserBase::Parse(
     } else if (start_code == kICYStartCode) {
       bytes_read = ParseIcecastHeader(data, data_size);
     } else if ((start_code & kID3StartCodeMask) == kID3v1StartCode) {
-      bytes_read = ParseID3v1(data, data_size);
+      bytes_read = ParseID3v1(data.data(), data_size);
     } else if ((start_code & kID3StartCodeMask) == kID3v2StartCode) {
-      bytes_read = ParseID3v2(data, data_size);
+      bytes_read = ParseID3v2(data.data(), data_size);
     } else {
       bytes_read = FindNextValidStartCode(data, data_size);
 
@@ -227,7 +229,7 @@ StreamParser::ParseStatus MPEGAudioStreamParserBase::Parse(
 
     CHECK_GE(data_size, bytes_read);
     data_size -= bytes_read;
-    data += bytes_read;
+    data=data.subspan(bytes_read);
     bytes_to_pop += bytes_read;
     end_of_segment = true;
   }
@@ -333,14 +335,14 @@ int MPEGAudioStreamParserBase::ParseFrame(const uint8_t* data,
   return frame_size;
 }
 
-int MPEGAudioStreamParserBase::ParseIcecastHeader(const uint8_t* data,
+int MPEGAudioStreamParserBase::ParseIcecastHeader(base::span<const uint8_t>data,
                                                   int size) {
   DVLOG(1) << __func__ << "(" << size << ")";
 
   if (size < 4)
     return 0;
 
-  if (memcmp("ICY ", data, 4))
+  if (memcmp("ICY ", data.data(), 4))
     return -1;
 
   int locate_size = std::min(size, kMaxIcecastHeaderSize);
@@ -418,27 +420,27 @@ bool MPEGAudioStreamParserBase::ParseSyncSafeInt(BitReader* reader,
   return true;
 }
 
-int MPEGAudioStreamParserBase::FindNextValidStartCode(const uint8_t* data,
+int MPEGAudioStreamParserBase::FindNextValidStartCode(base::span<const uint8_t>data,
                                                       int size) {
-  const uint8_t* start = data;
-  const uint8_t* end = data + size;
+  const uint8_t* start = data.data();
+  const uint8_t* end = data .subspan( size).data();
 
   while (start < end) {
     int bytes_left = end - start;
-    const uint8_t* candidate_start_code =
+    base::span<const uint8_t>candidate_start_code =
         static_cast<const uint8_t*>(memchr(start, 0xff, bytes_left));
 
-    if (!candidate_start_code)
+    if (candidate_start_code.empty())
       return 0;
 
     bool parse_header_failed = false;
-    const uint8_t* sync = candidate_start_code;
+    base::span<const uint8_t>sync = candidate_start_code;
     // Try to find 3 valid frames in a row. 3 was selected to decrease
     // the probability of false positives.
     for (int i = 0; i < 3; ++i) {
       int sync_size = end - sync;
       int frame_size;
-      int sync_bytes = ParseFrameHeader(sync, sync_size, &frame_size, nullptr,
+      int sync_bytes = ParseFrameHeader(sync.data(), sync_size, &frame_size, nullptr,
                                         nullptr, nullptr, nullptr, nullptr);
 
       if (sync_bytes == 0)
@@ -448,7 +450,7 @@ int MPEGAudioStreamParserBase::FindNextValidStartCode(const uint8_t* data,
         DCHECK_LE(sync_bytes, sync_size);
 
         // Skip over this frame so we can check the next one.
-        sync += frame_size;
+        sync=sync.subspan(frame_size);
 
         // Make sure the next frame starts inside the buffer.
         if (sync >= end)
@@ -464,7 +466,7 @@ int MPEGAudioStreamParserBase::FindNextValidStartCode(const uint8_t* data,
       // One of the frame header parses failed so |candidate_start_code|
       // did not point to the start of a real frame. Move |start| forward
       // so we can find the next candidate.
-      start = candidate_start_code + 1;
+      start = candidate_start_code .subspan( 1).data();
       continue;
     }
 
diff --git a/media/formats/mpeg/mpeg_audio_stream_parser_base.h b/media/formats/mpeg/mpeg_audio_stream_parser_base.h
index 62fa29b745aff..d8401e099250e 100644
--- a/media/formats/mpeg/mpeg_audio_stream_parser_base.h
+++ b/media/formats/mpeg/mpeg_audio_stream_parser_base.h
@@ -11,6 +11,7 @@
 #include <set>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "media/base/audio_decoder_config.h"
@@ -111,7 +112,7 @@ class MEDIA_EXPORT MPEGAudioStreamParserBase : public StreamParser {
   //   0 : If more data is needed to parse the entire element.
   // < 0 : An error was encountered during parsing.
   int ParseFrame(const uint8_t* data, int size, BufferQueue* buffers);
-  int ParseIcecastHeader(const uint8_t* data, int size);
+  int ParseIcecastHeader(base::span<const uint8_t>data, int size);
   int ParseID3v1(const uint8_t* data, int size);
   int ParseID3v2(const uint8_t* data, int size);
 
@@ -131,7 +132,7 @@ class MEDIA_EXPORT MPEGAudioStreamParserBase : public StreamParser {
   //       next start code..
   //   0 : If a valid start code was not found and more data is needed.
   // < 0 : An error was encountered during parsing.
-  int FindNextValidStartCode(const uint8_t* data, int size);
+  int FindNextValidStartCode(base::span<const uint8_t>data, int size);
 
   // Sends the buffers in |buffers| to |new_buffers_cb_| and then clears
   // |buffers|.
diff --git a/media/formats/webm/webm_cluster_parser.cc b/media/formats/webm/webm_cluster_parser.cc
index 717deea99d718..e70c34032332c 100644
--- a/media/formats/webm/webm_cluster_parser.cc
+++ b/media/formats/webm/webm_cluster_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -133,7 +135,7 @@ void WebMClusterParser::GetBuffers(StreamParser::BufferQueueMap* buffers) {
 }
 
 base::TimeDelta WebMClusterParser::TryGetEncodedAudioDuration(
-    const uint8_t* data,
+    base::span<const uint8_t>data,
     int size) {
 
   // Duration is currently read assuming the *entire* stream is unencrypted.
@@ -152,7 +154,7 @@ base::TimeDelta WebMClusterParser::TryGetEncodedAudioDuration(
   return kNoTimestamp;
 }
 
-base::TimeDelta WebMClusterParser::ReadOpusDuration(const uint8_t* data,
+base::TimeDelta WebMClusterParser::ReadOpusDuration(base::span<const uint8_t>data,
                                                     int size) {
   // Masks and constants for Opus packets. See
   // https://tools.ietf.org/html/rfc6716#page-14
@@ -269,7 +271,7 @@ bool WebMClusterParser::OnListEnd(int id) {
     additional = base::span(block_additional_data_.value());
   }
 
-  bool result = ParseBlock(false, data.data(), data.size(), additional.data(),
+  bool result = ParseBlock(false, data, data.size(), additional.data(),
                            additional.size(), block_duration_,
                            discard_padding_set_ ? discard_padding_ : 0,
                            reference_block_set_);
@@ -305,7 +307,7 @@ bool WebMClusterParser::OnUInt(int id, int64_t val) {
 }
 
 bool WebMClusterParser::ParseBlock(bool is_simple_block,
-                                   const uint8_t* buf,
+                                   base::span<const uint8_t>buf,
                                    size_t size,
                                    const uint8_t* additional,
                                    int additional_size,
@@ -346,7 +348,7 @@ bool WebMClusterParser::ParseBlock(bool is_simple_block,
   bool is_keyframe =
       is_simple_block ? (flags & 0x80) != 0 : !reference_block_set;
 
-  const uint8_t* frame_data = buf + kBlockHeaderSize;
+  base::span<const uint8_t>frame_data = buf .subspan( kBlockHeaderSize);
   size_t frame_size = size - kBlockHeaderSize;
   return OnBlock(is_simple_block, track_num, timecode, duration, frame_data,
                  frame_size, additional, additional_size, discard_padding,
@@ -360,7 +362,7 @@ bool WebMClusterParser::OnBinary(int id, const uint8_t* data_ptr, int size) {
       UNSAFE_TODO(base::span(data_ptr, base::checked_cast<size_t>(size)));
   switch (id) {
     case kWebMIdSimpleBlock:
-      return ParseBlock(true, data.data(), data.size(), nullptr, 0, -1, 0,
+      return ParseBlock(true, data, data.size(), nullptr, 0, -1, 0,
                         false);
 
     case kWebMIdBlock:
@@ -425,7 +427,7 @@ bool WebMClusterParser::OnBlock(bool is_simple_block,
                                 int track_num,
                                 int timecode,
                                 int block_duration,
-                                const uint8_t* data,
+                                base::span<const uint8_t>data,
                                 size_t size,
                                 const uint8_t* additional,
                                 size_t additional_size,
@@ -487,7 +489,7 @@ bool WebMClusterParser::OnBlock(bool is_simple_block,
   int data_offset = 0;
   if (!encryption_key_id.empty() &&
       !WebMCreateDecryptConfig(
-          data, size,
+          data.data(), size,
           reinterpret_cast<const uint8_t*>(encryption_key_id.data()),
           encryption_key_id.size(), &decrypt_config, &data_offset)) {
     MEDIA_LOG(ERROR, media_log_) << "Failed to extract decrypt config.";
@@ -498,7 +500,7 @@ bool WebMClusterParser::OnBlock(bool is_simple_block,
   // type with remapped bytestream track numbers and allow multiple tracks as
   // applicable. See https://crbug.com/341581.
   auto buffer =
-      StreamParserBuffer::CopyFrom(data + data_offset, size - data_offset,
+      StreamParserBuffer::CopyFrom(data .subspan( data_offset).data(), size - data_offset,
                                    is_keyframe, buffer_type, track_num);
   if (additional_size) {
     buffer->WritableSideData().alpha_data =
diff --git a/media/formats/webm/webm_cluster_parser.h b/media/formats/webm/webm_cluster_parser.h
index 3702699fb9571..c448c4e04812e 100644
--- a/media/formats/webm/webm_cluster_parser.h
+++ b/media/formats/webm/webm_cluster_parser.h
@@ -14,6 +14,7 @@
 #include <set>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/containers/circular_deque.h"
 #include "base/containers/heap_array.h"
 #include "base/memory/raw_ptr.h"
@@ -206,7 +207,7 @@ class MEDIA_EXPORT WebMClusterParser : public WebMParserClient {
   bool OnBinary(int id, const uint8_t* data, int size) override;
 
   bool ParseBlock(bool is_simple_block,
-                  const uint8_t* buf,
+                  base::span<const uint8_t>buf,
                   size_t size,
                   const uint8_t* additional,
                   int additional_size,
@@ -217,7 +218,7 @@ class MEDIA_EXPORT WebMClusterParser : public WebMParserClient {
                int track_num,
                int timecode,
                int duration,
-               const uint8_t* data,
+               base::span<const uint8_t>data,
                size_t size,
                const uint8_t* additional,
                size_t additional_size,
@@ -243,11 +244,11 @@ class MEDIA_EXPORT WebMClusterParser : public WebMParserClient {
   // Cluster we parse, so we can't simply use the delta of the first Block in
   // the next Cluster). Avoid calling if encrypted; may produce unexpected
   // output. See implementation for supported codecs.
-  base::TimeDelta TryGetEncodedAudioDuration(const uint8_t* data, int size);
+  base::TimeDelta TryGetEncodedAudioDuration(base::span<const uint8_t>data, int size);
 
   // Reads Opus packet header to determine packet duration. Duration returned
   // as TimeDelta or kNoTimestamp upon failure to read duration from packet.
-  base::TimeDelta ReadOpusDuration(const uint8_t* data, int size);
+  base::TimeDelta ReadOpusDuration(base::span<const uint8_t>data, int size);
 
   // Tracks the number of MEDIA_LOGs made in process of reading encoded
   // duration. Useful to prevent log spam.
diff --git a/storage/browser/file_system/file_system_operation_impl_unittest.cc b/storage/browser/file_system/file_system_operation_impl_unittest.cc
index 2606ff1fc98cb..75ec57dfc5866 100644
--- a/storage/browser/file_system/file_system_operation_impl_unittest.cc
+++ b/storage/browser/file_system/file_system_operation_impl_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -842,9 +844,9 @@ TEST_F(FileSystemOperationImplTest, TestCopyInForeignFileSuccess) {
   EXPECT_GT(after_usage, before_usage);
 
   // Compare contents of src and copied file.
-  char buffer[100];
+  std::array<char, 100> buffer;
   EXPECT_EQ(data_size,
-            base::ReadFile(PlatformPath("dest/file"), buffer, data_size));
+            base::ReadFile(PlatformPath("dest/file"), buffer.data(), data_size));
   for (int i = 0; i < data_size; ++i)
     EXPECT_EQ(test_data.at(i), buffer[i]);
 }
@@ -1101,8 +1103,8 @@ TEST_F(FileSystemOperationImplTest, TestTruncate) {
   // Check that its length is now 17 and that it's all zeroes after the test
   // data.
   EXPECT_EQ(length, GetFileSize("file"));
-  char data[100];
-  EXPECT_EQ(length, base::ReadFile(platform_path, data, length));
+  std::array<char, 100> data;
+  EXPECT_EQ(length, base::ReadFile(platform_path, data.data(), length));
   for (int i = 0; i < length; ++i) {
     if (i < static_cast<int>(test_data.size())) {
       EXPECT_EQ(test_data.at(i), data[i]);
@@ -1120,7 +1122,7 @@ TEST_F(FileSystemOperationImplTest, TestTruncate) {
 
   // Check that its length is now 3 and that it contains only bits of test data.
   EXPECT_EQ(length, GetFileSize("file"));
-  EXPECT_EQ(length, base::ReadFile(platform_path, data, length));
+  EXPECT_EQ(length, base::ReadFile(platform_path, data.data(), length));
   for (int i = 0; i < length; ++i)
     EXPECT_EQ(test_data.at(i), data[i]);
 
diff --git a/third_party/blink/renderer/platform/media/multi_buffer_data_source.cc b/third_party/blink/renderer/platform/media/multi_buffer_data_source.cc
index c19436994faa2..44a597e66eb0a 100644
--- a/third_party/blink/renderer/platform/media/multi_buffer_data_source.cc
+++ b/third_party/blink/renderer/platform/media/multi_buffer_data_source.cc
@@ -8,6 +8,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/containers/adapters.h"
 #include "base/location.h"
 #include "base/memory/raw_ptr.h"
@@ -423,7 +424,7 @@ GURL MultiBufferDataSource::GetUrlAfterRedirects() const {
 
 void MultiBufferDataSource::Read(int64_t position,
                                  int size,
-                                 uint8_t* data,
+                                 base::span<uint8_t>data,
                                  media::DataSource::ReadCB read_cb) {
   DVLOG(1) << "Read: " << position << " offset, " << size << " bytes";
   // Reading is not allowed until after initialization.
@@ -459,7 +460,7 @@ void MultiBufferDataSource::Read(int64_t position,
         return;
       }
     }
-    read_op_ = std::make_unique<ReadOperation>(position, size, data,
+    read_op_ = std::make_unique<ReadOperation>(position, size, data.data(),
                                                std::move(read_cb));
   }
 
@@ -504,7 +505,7 @@ void MultiBufferDataSource::ReadTask() {
   if (available) {
     int64_t bytes_read = std::min<int64_t>(available, read_op_->size());
     bytes_read =
-        reader_->TryReadAt(read_op_->position(), read_op_->data(), bytes_read);
+        reader_->TryReadAt(read_op_->position(), *read_op_, bytes_read);
 
     bytes_read_ += bytes_read;
     seek_positions_.push_back(read_op_->position() + bytes_read);
diff --git a/third_party/blink/renderer/platform/media/multi_buffer_data_source.h b/third_party/blink/renderer/platform/media/multi_buffer_data_source.h
index 5277d480ce3ac..f783a3be3d6e4 100644
--- a/third_party/blink/renderer/platform/media/multi_buffer_data_source.h
+++ b/third_party/blink/renderer/platform/media/multi_buffer_data_source.h
@@ -9,6 +9,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/weak_ptr.h"
@@ -110,7 +111,7 @@ class PLATFORM_EXPORT MultiBufferDataSource
 
   void Read(int64_t position,
             int size,
-            uint8_t* data,
+            base::span<uint8_t>data,
             media::DataSource::ReadCB read_cb) override;
   [[nodiscard]] bool GetSize(int64_t* size_out) override;
   bool IsStreaming() override;
diff --git a/third_party/blink/renderer/platform/media/multi_buffer_reader.cc b/third_party/blink/renderer/platform/media/multi_buffer_reader.cc
index f15c8678b96f3..f2f0da7cd5cba 100644
--- a/third_party/blink/renderer/platform/media/multi_buffer_reader.cc
+++ b/third_party/blink/renderer/platform/media/multi_buffer_reader.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -92,7 +94,7 @@ int64_t MultiBufferReader::AvailableAt(int64_t pos) const {
   return std::max<int64_t>(0, unavailable_byte_pos - pos);
 }
 
-int64_t MultiBufferReader::TryReadAt(int64_t pos, uint8_t* data, int64_t len) {
+int64_t MultiBufferReader::TryReadAt(int64_t pos, base::span<uint8_t>data, int64_t len) {
   DCHECK_GT(len, 0);
   std::vector<scoped_refptr<media::DataBuffer>> buffers;
   multibuffer_->GetBlocksThreadsafe(block(pos), block_ceil(pos + len),
@@ -108,8 +110,8 @@ int64_t MultiBufferReader::TryReadAt(int64_t pos, uint8_t* data, int64_t len) {
     }
     const auto tocopy =
         std::min<size_t>(len - bytes_read, buffer->size() - offset);
-    memcpy(data, buffer->data().data() + offset, tocopy);
-    data += tocopy;
+    memcpy(data.data(), buffer->data().data() + offset, tocopy);
+    data=data.subspan(tocopy);
     bytes_read += tocopy;
     if (bytes_read == len) {
       break;
@@ -122,7 +124,7 @@ int64_t MultiBufferReader::TryReadAt(int64_t pos, uint8_t* data, int64_t len) {
   return bytes_read;
 }
 
-int64_t MultiBufferReader::TryRead(uint8_t* data, int64_t len) {
+int64_t MultiBufferReader::TryRead(base::span<uint8_t>data, int64_t len) {
   int64_t bytes_read = TryReadAt(pos_, data, len);
   Seek(pos_ + bytes_read);
   return bytes_read;
diff --git a/third_party/blink/renderer/platform/media/multi_buffer_reader.h b/third_party/blink/renderer/platform/media/multi_buffer_reader.h
index 0926d3f23ad20..c13d2e0386918 100644
--- a/third_party/blink/renderer/platform/media/multi_buffer_reader.h
+++ b/third_party/blink/renderer/platform/media/multi_buffer_reader.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
@@ -65,11 +66,11 @@ class PLATFORM_EXPORT MultiBufferReader : public MultiBuffer::Reader {
   // Tries to read |len| bytes from position |pos|.
   // Returns number of bytes read.
   // Safe to call from any thread.
-  int64_t TryReadAt(int64_t pos, uint8_t* data, int64_t len);
+  int64_t TryReadAt(int64_t pos, base::span<uint8_t>data, int64_t len);
 
   // Tries to read |len| bytes and update current position.
   // Returns number of bytes read.
-  int64_t TryRead(uint8_t* data, int64_t len);
+  int64_t TryRead(base::span<uint8_t>data, int64_t len);
 
   // Wait until |len| bytes are available for reading.
   // Returns net::OK if |len| bytes are already available, otherwise it will
diff --git a/third_party/blink/renderer/platform/media/multi_buffer_unittest.cc b/third_party/blink/renderer/platform/media/multi_buffer_unittest.cc
index 6676aa0fb63eb..c1e983aedadb6 100644
--- a/third_party/blink/renderer/platform/media/multi_buffer_unittest.cc
+++ b/third_party/blink/renderer/platform/media/multi_buffer_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -285,7 +287,7 @@ TEST_F(MultiBufferTest, ReadAll) {
   reader.SetPinRange(2000, 5000);
   reader.SetPreload(1000, 1000);
   while (pos < end) {
-    unsigned char buffer[27];
+    std::array<unsigned char, 27> buffer;
     buffer[17] = 17;
     size_t to_read = std::min<size_t>(end - pos, 17);
     int64_t bytes_read = reader.TryRead(buffer, to_read);
@@ -314,7 +316,7 @@ TEST_F(MultiBufferTest, ReadAllAdvanceFirst) {
   reader.SetPinRange(2000, 5000);
   reader.SetPreload(1000, 1000);
   while (pos < end) {
-    unsigned char buffer[27];
+    std::array<unsigned char, 27> buffer;
     buffer[17] = 17;
     size_t to_read = std::min<size_t>(end - pos, 17);
     while (AdvanceAll()) {
@@ -345,7 +347,7 @@ TEST_F(MultiBufferTest, ReadAllAdvanceFirst_NeverDefer) {
   reader.SetPinRange(2000, 5000);
   reader.SetPreload(1000, 1000);
   while (pos < end) {
-    unsigned char buffer[27];
+    std::array<unsigned char, 27> buffer;
     buffer[17] = 17;
     size_t to_read = std::min<size_t>(end - pos, 17);
     while (AdvanceAll()) {
@@ -377,7 +379,7 @@ TEST_F(MultiBufferTest, ReadAllAdvanceFirst_NeverDefer2) {
   reader.SetPinRange(2000, 5000);
   reader.SetPreload(1000, 1000);
   while (pos < end) {
-    unsigned char buffer[27];
+    std::array<unsigned char, 27> buffer;
     buffer[17] = 17;
     size_t to_read = std::min<size_t>(end - pos, 17);
     while (AdvanceAll()) {
@@ -524,8 +526,8 @@ class ReadHelper {
   bool Read() {
     if (read_size_ == 0)
       return true;
-    unsigned char buffer[4096];
-    CHECK_LE(read_size_, static_cast<int64_t>(sizeof(buffer)));
+    std::array<unsigned char, 4096> buffer;
+    CHECK_LE(read_size_, static_cast<int64_t>((buffer.size() * sizeof(decltype(buffer)::value_type))));
     CHECK_EQ(pos_, reader_.Tell());
     int64_t bytes_read = reader_.TryRead(buffer, read_size_);
     if (bytes_read) {
```

## Build Failure Log

```
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kRm2Buffer.size() * sizeof(decltype(kRm2Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kRm1Buffer.size() * sizeof(decltype(kRm1Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kIrcamBuffer.size() * sizeof(decltype(kIrcamBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kFlvBuffer.size() * sizeof(decltype(kFlvBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kFlacBuffer.size() * sizeof(decltype(kFlacBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kDxaBuffer.size() * sizeof(decltype(kDxaBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kDtshdBuffer.size() * sizeof(decltype(kDtshdBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kCafBuffer.size() * sizeof(decltype(kCafBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kBug585243Buffer.size() * sizeof(decltype(kBug585243Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kBug584401Buffer.size() * sizeof(decltype(kBug584401Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kBug263073Buffer.size() * sizeof(decltype(kBug263073Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kAss2Buffer.size() * sizeof(decltype(kAss2Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kAss1Buffer.size() * sizeof(decltype(kAss1Buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kAsfBuffer.size() * sizeof(decltype(kAsfBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(kAmrBuffer.size() * sizeof(decltype(kAmrBuffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(buffer3.size() * sizeof(decltype(buffer3)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(buffer2.size() * sizeof(decltype(buffer2)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(buffer1.size() * sizeof(decltype(buffer1)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Conflicting replacement text: ./media/base/container_names_unittest.cc at offset 906, length 14: "(buffer.size() * sizeof(decltype(buffer)::value_type))" != "(kWtvBuffer.size() * sizeof(decltype(kWtvBuffer)::value_type))"
Applied 97 edits (0 errors) to 1 files [2.08%]
Applied 99 edits (0 errors) to 2 files [4.17%]
Applied 101 edits (0 errors) to 3 files [6.25%]
Applied 104 edits (0 errors) to 4 files [8.33%]
Applied 109 edits (0 errors) to 5 files [10.42%]
Applied 116 edits (0 errors) to 6 files [12.50%]
Applied 118 edits (0 errors) to 7 files [14.58%]
Applied 125 edits (19 errors) to 8 files [16.67%]
Applied 147 edits (19 errors) to 9 files [18.75%]
Applied 153 edits (19 errors) to 10 files [20.83%]
Applied 158 edits (19 errors) to 11 files [22.92%]
Applied 160 edits (19 errors) to 12 files [25.00%]
Applied 162 edits (19 errors) to 13 files [27.08%]
Applied 165 edits (19 errors) to 14 files [29.17%]
Applied 169 edits (19 errors) to 15 files [31.25%]
Applied 181 edits (19 errors) to 16 files [33.33%]
Applied 184 edits (19 errors) to 17 files [35.42%]
Applied 205 edits (19 errors) to 18 files [37.50%]
Applied 211 edits (19 errors) to 19 files [39.58%]
Applied 212 edits (19 errors) to 20 files [41.67%]
Applied 217 edits (19 errors) to 21 files [43.75%]
Applied 221 edits (19 errors) to 22 files [45.83%]
Applied 227 edits (19 errors) to 23 files [47.92%]
Applied 230 edits (19 errors) to 24 files [50.00%]
Applied 232 edits (19 errors) to 25 files [52.08%]
Applied 237 edits (19 errors) to 26 files [54.17%]
Applied 241 edits (19 errors) to 27 files [56.25%]
Applied 244 edits (19 errors) to 28 files [58.33%]
Applied 248 edits (19 errors) to 29 files [60.42%]
Applied 249 edits (19 errors) to 30 files [62.50%]
Applied 256 edits (19 errors) to 31 files [64.58%]
Applied 258 edits (19 errors) to 32 files [66.67%]
Applied 263 edits (19 errors) to 33 files [68.75%]
Applied 265 edits (19 errors) to 34 files [70.83%]
Applied 266 edits (19 errors) to 35 files [72.92%]
Applied 268 edits (19 errors) to 36 files [75.00%]
Applied 271 edits (19 errors) to 37 files [77.08%]
Applied 281 edits (19 errors) to 38 files [79.17%]
Applied 283 edits (19 errors) to 39 files [81.25%]
Applied 285 edits (19 errors) to 40 files [83.33%]
Applied 287 edits (19 errors) to 41 files [85.42%]
Applied 289 edits (19 errors) to 42 files [87.50%]
Applied 291 edits (19 errors) to 43 files [89.58%]
Applied 292 edits (19 errors) to 44 files [91.67%]
Applied 294 edits (19 errors) to 45 files [93.75%]
Applied 296 edits (19 errors) to 46 files [95.83%]
Applied 297 edits (19 errors) to 47 files [97.92%]
Applied 298 edits (19 errors) to 48 files [100.00%]
```

# Build Failure: 2025_03_19_patch_1136

## Chromium Revision

`ae47ae4e0c13026d1824b4cf4b9cea834dfd0cf4`

## Code Changes (Diff)

```diff
diff --git a/cc/test/layer_tree_json_parser.cc b/cc/test/layer_tree_json_parser.cc
index d049b57b1c102..f2f5eee985312 100644
--- a/cc/test/layer_tree_json_parser.cc
+++ b/cc/test/layer_tree_json_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -167,7 +169,7 @@ scoped_refptr<Layer> ParseTreeFromValue(const base::Value& val,
   if (transform_list->size() < 16)
     return nullptr;
 
-  float transform[16];
+  std::array<float, 16> transform;
   for (int i = 0; i < 16; ++i) {
     // GetDouble can implicitly convert from either double or int; however, it's
     // not clear if "is_double" is sufficient for this check. Given that int is
@@ -179,7 +181,7 @@ scoped_refptr<Layer> ParseTreeFromValue(const base::Value& val,
     transform[i] = (*transform_list)[i].GetDouble();
   }
 
-  new_layer->SetTransform(gfx::Transform::ColMajorF(transform));
+  new_layer->SetTransform(gfx::Transform::ColMajorF(transform.data()));
 
   const base::Value::List* child_list = dict.FindList("Children");
   if (!child_list)
diff --git a/components/viz/common/quads/render_pass_io.cc b/components/viz/common/quads/render_pass_io.cc
index 7445608974f0e..ce892a711aba5 100644
--- a/components/viz/common/quads/render_pass_io.cc
+++ b/components/viz/common/quads/render_pass_io.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -450,13 +452,13 @@ bool TransformFromList(const base::Value::List& list,
   DCHECK(transform);
   if (list.size() != 16)
     return false;
-  float data[16];
+  std::array<float, 16> data;
   for (size_t ii = 0; ii < 16; ++ii) {
     if (!list[ii].is_double())
       return false;
     data[ii] = list[ii].GetDouble();
   }
-  *transform = gfx::Transform::ColMajorF(data);
+  *transform = gfx::Transform::ColMajorF(data.data());
   return true;
 }
 
diff --git a/content/renderer/skia_benchmarking_extension.cc b/content/renderer/skia_benchmarking_extension.cc
index acb136002f3d5..e9a3e55e86f38 100644
--- a/content/renderer/skia_benchmarking_extension.cc
+++ b/content/renderer/skia_benchmarking_extension.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/342213636): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -226,7 +228,7 @@ void SkiaBenchmarking::Rasterize(gin::Arguments* args) {
   blink::WebArrayBuffer buffer =
       blink::WebArrayBuffer::Create(bitmap.computeByteSize(), 1);
   uint32_t* packed_pixels = reinterpret_cast<uint32_t*>(bitmap.getPixels());
-  uint8_t* buffer_pixels = reinterpret_cast<uint8_t*>(buffer.Data());
+  base::span<uint8_t> buffer_pixels = reinterpret_cast<uint8_t*>(buffer.Data());
   // Swizzle from native Skia format to RGBA as we copy out.
   for (size_t i = 0; i < bitmap.computeByteSize(); i += 4) {
     uint32_t c = packed_pixels[i >> 2];
diff --git a/content/web_test/renderer/test_runner.cc b/content/web_test/renderer/test_runner.cc
index 85245f9527fe2..860bed368ff23 100644
--- a/content/web_test/renderer/test_runner.cc
+++ b/content/web_test/renderer/test_runner.cc
@@ -147,7 +147,7 @@ v8::LocalVector<v8::Value> ConvertBitmapToV8(
 
   blink::WebArrayBuffer buffer =
       blink::WebArrayBuffer::Create(info.computeByteSize(row_bytes), 1);
-  bool read = bitmap.readPixels(info, buffer.Data(), row_bytes, 0, 0);
+  bool read = bitmap.readPixels(info, buffer.Data().data(), row_bytes, 0, 0);
   CHECK(read);
 
   args.push_back(blink::WebArrayBufferConverter::ToV8Value(&buffer, isolate));
diff --git a/extensions/renderer/set_icon_natives.cc b/extensions/renderer/set_icon_natives.cc
index 36f5ddc0c54f8..b062e1062f9a8 100644
--- a/extensions/renderer/set_icon_natives.cc
+++ b/extensions/renderer/set_icon_natives.cc
@@ -153,7 +153,7 @@ bool SetIconNatives::ConvertImageDataToBitmapValue(
   // Construct the Value object.
   std::vector<uint8_t> s = skia::mojom::InlineBitmap::Serialize(&bitmap);
   blink::WebArrayBuffer buffer = blink::WebArrayBuffer::Create(s.size(), 1);
-  memcpy(buffer.Data(), s.data(), s.size());
+  memcpy(buffer.Data().data(), s.data(), s.size());
   *image_data_bitmap =
       blink::WebArrayBufferConverter::ToV8Value(&buffer, isolate);
 
diff --git a/media/base/audio_bus.h b/media/base/audio_bus.h
index 4649d2299c7ee..fea821dab30ea 100644
--- a/media/base/audio_bus.h
+++ b/media/base/audio_bus.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -185,9 +187,9 @@ class MEDIA_SHMEM_EXPORT AudioBus {
   // inf, nan, or between [-1.0, 1.0]) values in the channel data.
   // TODO(crbug.com/373960632): Remove these methods, and rename `channel_span`
   // to `channel`.
-  float* channel(int channel) {
+  base::span<float> channel(int channel) {
     CHECK(!is_bitstream_format_);
-    return channel_data_[channel].data();
+    return channel_data_[channel];
   }
   const float* channel(int channel) const {
     CHECK(!is_bitstream_format_);
diff --git a/media/filters/audio_decoder_unittest.cc b/media/filters/audio_decoder_unittest.cc
index faf8ecb54d318..5659edead9a9e 100644
--- a/media/filters/audio_decoder_unittest.cc
+++ b/media/filters/audio_decoder_unittest.cc
@@ -350,8 +350,8 @@ class AudioDecoderTest
     for (int ch = 0; ch < output->channels(); ++ch) {
       base::MD5Update(
           &context,
-          std::string_view(reinterpret_cast<char*>(output->channel(ch)),
-                           output->frames() * sizeof(*output->channel(ch))));
+          std::string_view(reinterpret_cast<char*>(output->channel(ch).data()),
+                           output->frames() * sizeof(output->channel(ch)[0])));
     }
     base::MD5Digest digest;
     base::MD5Final(&digest, &context);
diff --git a/media/filters/audio_renderer_algorithm.cc b/media/filters/audio_renderer_algorithm.cc
index eda1cd6c06963..5a1a1b3950a2e 100644
--- a/media/filters/audio_renderer_algorithm.cc
+++ b/media/filters/audio_renderer_algorithm.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -524,8 +526,9 @@ bool AudioRendererAlgorithm::RunOneWsolaIteration(double playback_rate) {
     if (!channel_mask_[k])
       continue;
 
-    const float* const ch_opt_frame = optimal_block_->channel(k);
-    float* ch_output = wsola_output_->channel(k) + num_complete_frames_;
+    const base::span<const float> ch_opt_frame = optimal_block_->channel(k);
+    base::span<float> ch_output =
+        wsola_output_->channel(k).subspan(num_complete_frames_);
     for (int n = 0; n < ola_hop_size_; ++n) {
       ch_output[n] = ch_output[n] * ola_window_[ola_hop_size_ + n] +
                      ch_opt_frame[n] * ola_window_[n];
@@ -533,7 +536,7 @@ bool AudioRendererAlgorithm::RunOneWsolaIteration(double playback_rate) {
 
     // Copy the second half to the output.
     memcpy(&ch_output[ola_hop_size_], &ch_opt_frame[ola_hop_size_],
-           sizeof(*ch_opt_frame) * ola_hop_size_);
+           sizeof(ch_opt_frame[0]) * ola_hop_size_);
   }
 
   num_complete_frames_ += ola_hop_size_;
@@ -582,8 +585,8 @@ int AudioRendererAlgorithm::WriteCompletedFramesTo(
   for (int k = 0; k < channels_; ++k) {
     if (!channel_mask_[k])
       continue;
-    float* ch = wsola_output_->channel(k);
-    memmove(ch, &ch[rendered_frames], sizeof(*ch) * frames_to_move);
+    base::span<float> ch = wsola_output_->channel(k);
+    memmove(ch.data(), &ch[rendered_frames], sizeof(ch[0]) * frames_to_move);
   }
   num_complete_frames_ -= rendered_frames;
   return rendered_frames;
@@ -638,8 +641,8 @@ void AudioRendererAlgorithm::GetOptimalBlock() {
     for (int k = 0; k < channels_; ++k) {
       if (!channel_mask_[k])
         continue;
-      float* ch_opt = optimal_block_->channel(k);
-      const float* const ch_target = target_block_->channel(k);
+      base::span<float> ch_opt = optimal_block_->channel(k);
+      const base::span<const float> ch_target = target_block_->channel(k);
       for (int n = 0; n < ola_window_size_; ++n) {
         ch_opt[n] = ch_opt[n] * transition_window_[n] +
                     ch_target[n] * transition_window_[ola_window_size_ + n];
@@ -676,8 +679,8 @@ void AudioRendererAlgorithm::CreateSearchWrappers() {
   std::vector<float*> active_search_channels;
   for (int ch = 0; ch < channels_; ++ch) {
     if (channel_mask_[ch]) {
-      active_target_channels.push_back(target_block_->channel(ch));
-      active_search_channels.push_back(search_block_->channel(ch));
+      active_target_channels.push_back(target_block_->channel(ch).data());
+      active_search_channels.push_back(search_block_->channel(ch).data());
     }
   }
 
diff --git a/media/filters/audio_renderer_algorithm_unittest.cc b/media/filters/audio_renderer_algorithm_unittest.cc
index af282a12e926c..df6572ec69c21 100644
--- a/media/filters/audio_renderer_algorithm_unittest.cc
+++ b/media/filters/audio_renderer_algorithm_unittest.cc
@@ -8,6 +8,8 @@
 // correct rate.  We always pass in a very large destination buffer with the
 // expectation that FillBuffer() will fill as much as it can but no more.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -41,8 +43,10 @@ const int kFrameSize = 250;
 const int kSamplesPerSecond = 3000;
 const int kOutputDurationInSec = 10;
 
-static void FillWithSquarePulseTrain(
-    int half_pulse_width, int offset, int num_samples, float* data) {
+static void FillWithSquarePulseTrain(int half_pulse_width,
+                                     int offset,
+                                     int num_samples,
+                                     base::span<float> data) {
   ASSERT_GE(offset, 0);
   ASSERT_LE(offset, num_samples);
 
@@ -417,14 +421,14 @@ class AudioRendererAlgorithmTest : public testing::Test {
       // perfectly. Do not check them.
       if (n > 3) {
          for (int m = 0; m < channels_; ++m) {
-          const float* pulse_ch = pulse_buffer->channel(m);
-
-          // Because of overlap-and-add we might have round off error.
-          for (int k = 0; k < kPulseWidthSamples; ++k) {
-            ASSERT_NEAR(reinterpret_cast<float*>(channel_data[m])[k],
-                        pulse_ch[k], kTolerance) << " loop " << n
-                                << " channel/sample " << m << "/" << k;
-          }
+           base::span<const float> pulse_ch = pulse_buffer->channel(m);
+
+           // Because of overlap-and-add we might have round off error.
+           for (int k = 0; k < kPulseWidthSamples; ++k) {
+             ASSERT_NEAR(reinterpret_cast<float*>(channel_data[m])[k],
+                         pulse_ch[k], kTolerance)
+                 << " loop " << n << " channel/sample " << m << "/" << k;
+           }
         }
       }
 
@@ -700,8 +704,8 @@ TEST_F(AudioRendererAlgorithmTest, MovingBlockEnergy) {
   const int kNumBlocks = kFrames - (kFramesPerBlock - 1);
   std::unique_ptr<AudioBus> a = AudioBus::Create(kChannels, kFrames);
   auto energies = std::make_unique<float[]>(kChannels * kNumBlocks);
-  float* ch_left = a->channel(0);
-  float* ch_right = a->channel(1);
+  base::span<float> ch_left = a->channel(0);
+  base::span<float> ch_right = a->channel(1);
 
   // Fill up both channels.
   for (int n = 0; n < kFrames; ++n) {
@@ -742,9 +746,9 @@ TEST_F(AudioRendererAlgorithmTest, FullAndDecimatedSearch) {
             sizeof(ch_0) / sizeof(*ch_0));
   std::unique_ptr<AudioBus> search_region =
       AudioBus::Create(kChannels, kFramesInSearchRegion);
-  float* ch = search_region->channel(0);
+  float* ch = search_region->channel(0).data();
   memcpy(ch, ch_0, sizeof(float) * kFramesInSearchRegion);
-  ch = search_region->channel(1);
+  ch = search_region->channel(1).data();
   memcpy(ch, ch_1, sizeof(float) * kFramesInSearchRegion);
 
   const int kFramePerBlock = 4;
@@ -756,9 +760,9 @@ TEST_F(AudioRendererAlgorithmTest, FullAndDecimatedSearch) {
 
   std::unique_ptr<AudioBus> target =
       AudioBus::Create(kChannels, kFramePerBlock);
-  ch = target->channel(0);
+  ch = target->channel(0).data();
   memcpy(ch, target_0, sizeof(float) * kFramePerBlock);
-  ch = target->channel(1);
+  ch = target->channel(1).data();
   memcpy(ch, target_1, sizeof(float) * kFramePerBlock);
 
   auto energy_target = std::make_unique<float[]>(kChannels);
diff --git a/media/mojo/clients/mojo_audio_encoder_unittest.cc b/media/mojo/clients/mojo_audio_encoder_unittest.cc
index 13a85a8b36c5c..cf7f50800cd13 100644
--- a/media/mojo/clients/mojo_audio_encoder_unittest.cc
+++ b/media/mojo/clients/mojo_audio_encoder_unittest.cc
@@ -268,10 +268,10 @@ TEST_F(MojoAudioEncoderTest, Encode) {
                                {CHANNEL_LAYOUT_DISCRETE, audio_bus->channels()},
                                options.sample_rate, audio_bus->frames());
 
-        const auto channel_data =
-            base::span(reinterpret_cast<const uint8_t*>(audio_bus->channel(0)),
-                       AudioBus::CalculateMemorySize(
-                           /*channels=*/1, audio_bus->frames()));
+        const auto channel_data = base::span(
+            reinterpret_cast<const uint8_t*>(audio_bus->channel(0).data()),
+            AudioBus::CalculateMemorySize(
+                /*channels=*/1, audio_bus->frames()));
         auto encoded_data = base::HeapArray<uint8_t>::CopiedFrom(channel_data);
 
         EncodedAudioBuffer output(params, std::move(encoded_data),
diff --git a/services/audio/delay_buffer_unittest.cc b/services/audio/delay_buffer_unittest.cc
index ad8f861ea85dc..ae63882234796 100644
--- a/services/audio/delay_buffer_unittest.cc
+++ b/services/audio/delay_buffer_unittest.cc
@@ -33,7 +33,8 @@ TEST(DelayBufferTest, RecordsAMaximumNumberOfFrames) {
 
   constexpr int frames_per_bus = kMaxFrames / 4;
   const auto bus = media::AudioBus::Create(kChannels, frames_per_bus);
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 1.0);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 1.0);
 
   // Fill the buffer.
   DelayBuffer::FrameTicks position = 0;
@@ -68,7 +69,8 @@ TEST(DelayBufferTest, ReadsSilenceIfNothingWasRecorded) {
 
   for (int i = 0; i < 10; ++i) {
     // Set data in the bus to confirm it is all going to be overwritten.
-    std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 1.0);
+    std::fill(bus->channel(0).data(),
+              bus->channel(0).subspan(frames_per_bus).data(), 1.0);
 
     buffer.Read(position, frames_per_bus, bus.get());
     EXPECT_EQ(buffer.GetBeginPosition(), buffer.GetEndPosition());
@@ -84,7 +86,8 @@ TEST(DelayBufferTest, ReadsSilenceIfOutsideRecordedRange) {
 
   constexpr int frames_per_bus = kMaxFrames / 4;
   const auto bus = media::AudioBus::Create(kChannels, frames_per_bus);
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 1.0);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 1.0);
 
   // Fill the buffer.
   DelayBuffer::FrameTicks position = 0;
@@ -96,26 +99,30 @@ TEST(DelayBufferTest, ReadsSilenceIfOutsideRecordedRange) {
   EXPECT_EQ(position, buffer.GetEndPosition());
 
   // Read before the begin position and expect to get silence.
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(-kMaxFrames, frames_per_bus, bus.get());
   EXPECT_BUS_VALUES_EQ(bus, 0, frames_per_bus, 0.0);
 
   // Read at a position one before the begin position. Expect the first sample
   // to be 0.0, and the rest 1.0.
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(buffer.GetBeginPosition() - 1, frames_per_bus, bus.get());
   EXPECT_EQ(0.0, bus->channel(0)[0]);
   EXPECT_BUS_VALUES_EQ(bus, 1, frames_per_bus - 1, 1.0);
 
   // Read at a position where the last sample should be 0.0 and the rest 1.0.
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(buffer.GetEndPosition() - frames_per_bus + 1, frames_per_bus,
               bus.get());
   EXPECT_BUS_VALUES_EQ(bus, 0, frames_per_bus - 1, 1.0);
   EXPECT_EQ(0.0, bus->channel(0)[frames_per_bus - 1]);
 
   // Read after the end position and expect to get silence.
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(kMaxFrames, frames_per_bus, bus.get());
   EXPECT_BUS_VALUES_EQ(bus, 0, frames_per_bus, 0.0);
 }
@@ -126,7 +133,8 @@ TEST(DelayBufferTest, ReadsGapsInRecording) {
 
   constexpr int frames_per_bus = kMaxFrames / 4;
   const auto bus = media::AudioBus::Create(kChannels, frames_per_bus);
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 1.0);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 1.0);
 
   // Fill the buffer, but with a gap in the third quarter of it.
   DelayBuffer::FrameTicks record_position = 0;
@@ -142,25 +150,29 @@ TEST(DelayBufferTest, ReadsGapsInRecording) {
   // Read through the whole range, but offset by one frame early. Confirm the
   // silence gap appears in the right place.
   DelayBuffer::FrameTicks read_position = -1;
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(read_position, frames_per_bus, bus.get());
   read_position += frames_per_bus;
   EXPECT_EQ(0.0, bus->channel(0)[0]);
   EXPECT_BUS_VALUES_EQ(bus, 1, frames_per_bus - 1, 1.0);
 
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(read_position, frames_per_bus, bus.get());
   read_position += frames_per_bus;
   EXPECT_BUS_VALUES_EQ(bus, 0, frames_per_bus, 1.0);
 
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(read_position, frames_per_bus, bus.get());
   read_position += frames_per_bus;
   EXPECT_EQ(1.0, bus->channel(0)[0]);
   // The gap begins.
   EXPECT_BUS_VALUES_EQ(bus, 1, frames_per_bus - 1, 0.0);
 
-  std::fill(bus->channel(0), bus->channel(0) + frames_per_bus, 0.5);
+  std::fill(bus->channel(0).data(),
+            bus->channel(0).subspan(frames_per_bus).data(), 0.5);
   buffer.Read(read_position, frames_per_bus, bus.get());
   read_position += frames_per_bus;
   EXPECT_EQ(0.0, bus->channel(0)[0]);
diff --git a/services/audio/mixing_graph_input_unittest.cc b/services/audio/mixing_graph_input_unittest.cc
index e6a4c823506aa..f953e28c6cb78 100644
--- a/services/audio/mixing_graph_input_unittest.cc
+++ b/services/audio/mixing_graph_input_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -37,7 +39,7 @@ class MixingGraphInputTest : public ::testing::Test {
     for (int i = 0; i < num_runs; i++) {
       mixing_graph_->OnMoreData(base::TimeDelta(), base::TimeTicks::Now(), {},
                                 dest_.get());
-      float* data = dest_.get()->channel(0);
+      base::span<float> data = dest_.get()->channel(0);
       for (int j = 0; j < dest_.get()->frames(); ++j) {
         EXPECT_NEAR(data[j], expected_data, epsilon);
         expected_data += expected_sample_increment;
@@ -67,7 +69,7 @@ class SampleCounter : public media::AudioOutputStream::AudioSourceCallback {
                  media::AudioBus* dest) final {
     // Fill the audio bus with a simple, predictable pattern.
     for (int channel = 0; channel < dest->channels(); ++channel) {
-      float* data = dest->channel(channel);
+      base::span<float> data = dest->channel(channel);
       for (int frame = 0; frame < dest->frames(); frame++) {
         data[frame] = counter_ + increment_ * frame + increment_ * channel;
       }
@@ -94,7 +96,7 @@ class CallbackCounter : public media::AudioOutputStream::AudioSourceCallback {
                  media::AudioBus* dest) final {
     // Fill the audio bus with the counter value.
     for (int channel = 0; channel < dest->channels(); ++channel) {
-      float* data = dest->channel(channel);
+      base::span<float> data = dest->channel(channel);
       for (int frame = 0; frame < dest->frames(); frame++) {
         data[frame] = counter_;
       }
@@ -119,7 +121,7 @@ class ConstantInput : public media::AudioOutputStream::AudioSourceCallback {
                  media::AudioBus* dest) final {
     // Fill the audio bus with the value specified at construction.
     for (int channel = 0; channel < dest->channels(); ++channel) {
-      float* data = dest->channel(channel);
+      base::span<float> data = dest->channel(channel);
       for (int frame = 0; frame < dest->frames(); frame++) {
         data[frame] = value_;
       }
diff --git a/services/audio/public/cpp/output_device_unittest.cc b/services/audio/public/cpp/output_device_unittest.cc
index 6d3de89111474..2ad99f5628b49 100644
--- a/services/audio/public/cpp/output_device_unittest.cc
+++ b/services/audio/public/cpp/output_device_unittest.cc
@@ -246,8 +246,10 @@ TEST_F(AudioServiceOutputDeviceTest, MAYBE_VerifyDataFlow) {
         .WillOnce(WithArg<3>(Invoke([](media::AudioBus* client_bus) -> int {
           // Place some test data in the bus so that we can check that it was
           // copied to the audio service side.
-          std::fill_n(client_bus->channel(0), client_bus->frames(), kAudioData);
-          std::fill_n(client_bus->channel(1), client_bus->frames(), kAudioData);
+          std::fill_n(client_bus->channel(0).data(), client_bus->frames(),
+                      kAudioData);
+          std::fill_n(client_bus->channel(1).data(), client_bus->frames(),
+                      kAudioData);
           return client_bus->frames();
         })));
     env.reader->RequestMoreData(kDelay, env.time_stamp, glitch_info);
diff --git a/services/audio/snooper_node_unittest.cc b/services/audio/snooper_node_unittest.cc
index 3b5a0afcbde26..68432074470ce 100644
--- a/services/audio/snooper_node_unittest.cc
+++ b/services/audio/snooper_node_unittest.cc
@@ -217,7 +217,7 @@ class SnooperNodeTest : public testing::TestWithParam<InputAndOutputParams> {
     // call, confirm that every sample was overwritten in the output AudioBus.
     const auto bus = media::AudioBus::Create(output_params());
     for (int ch = 0; ch < bus->channels(); ++ch) {
-      std::fill_n(bus->channel(ch), bus->frames(), kInvalidAudioSample);
+      std::fill_n(bus->channel(ch).data(), bus->frames(), kInvalidAudioSample);
     }
 
     // If the SnooperNode provides a suggestion, check that |output_time| is
@@ -237,7 +237,7 @@ class SnooperNodeTest : public testing::TestWithParam<InputAndOutputParams> {
 
     for (int ch = 0; ch < bus->channels(); ++ch) {
       EXPECT_FALSE(
-          std::any_of(bus->channel(ch), bus->channel(ch) + bus->frames(),
+          std::any_of(bus->channel(ch).data(), bus->channel(ch) + bus->frames(),
                       [](float x) { return x == kInvalidAudioSample; }))
           << " at output_time=" << output_time << ", ch=" << ch;
     }
diff --git a/services/audio/test/fake_consumer.cc b/services/audio/test/fake_consumer.cc
index 610d1586a3c4e..435a95bbd3102 100644
--- a/services/audio/test/fake_consumer.cc
+++ b/services/audio/test/fake_consumer.cc
@@ -142,7 +142,7 @@ void FakeConsumer::SaveToFile(const base::FilePath& path) const {
   auto writer = media::AudioDebugFileWriter::Create(params, std::move(file));
   auto bus = media::AudioBus::Create(params);
   for (int i = 0; i < params.channels(); ++i) {
-    memcpy(bus->channel(i), recorded_channel_data_[i].data(),
+    memcpy(bus->channel(i).data(), recorded_channel_data_[i].data(),
            sizeof(float) * recorded_channel_data_[i].size());
   }
   writer->Write(*bus);
diff --git a/services/audio/test/fake_loopback_group_member.cc b/services/audio/test/fake_loopback_group_member.cc
index 22d4aac34aed7..a24736143219d 100644
--- a/services/audio/test/fake_loopback_group_member.cc
+++ b/services/audio/test/fake_loopback_group_member.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -53,7 +55,7 @@ void FakeLoopbackGroupMember::RenderMoreAudio(
     for (int ch = 0; ch < params_.channels(); ++ch) {
       const double step = 2.0 * std::numbers::pi * frequency_by_channel_[ch] /
                           params_.sample_rate();
-      float* const samples = audio_bus_->channel(ch);
+      const base::span<float> samples = audio_bus_->channel(ch);
       for (int frame = 0; frame < params_.frames_per_buffer(); ++frame) {
         samples[frame] = std::sin((at_frame_ + frame) * step);
       }
diff --git a/third_party/blink/public/platform/web_content_decryption_module.h b/third_party/blink/public/platform/web_content_decryption_module.h
index 3e42dcb34e7a0..cf2d4f0455244 100644
--- a/third_party/blink/public/platform/web_content_decryption_module.h
+++ b/third_party/blink/public/platform/web_content_decryption_module.h
@@ -33,6 +33,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_result.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_session.h"
@@ -47,7 +48,7 @@ class BLINK_PLATFORM_EXPORT WebContentDecryptionModule {
   virtual std::unique_ptr<WebContentDecryptionModuleSession> CreateSession(
       WebEncryptedMediaSessionType session_type) = 0;
 
-  virtual void SetServerCertificate(const unsigned char* certificate,
+  virtual void SetServerCertificate(base::span<const unsigned char> certificate,
                                     size_t certificate_length,
                                     WebContentDecryptionModuleResult) = 0;
 
diff --git a/third_party/blink/public/platform/web_content_decryption_module_session.h b/third_party/blink/public/platform/web_content_decryption_module_session.h
index 3cf2ce4b867d9..0c5062c11c226 100644
--- a/third_party/blink/public/platform/web_content_decryption_module_session.h
+++ b/third_party/blink/public/platform/web_content_decryption_module_session.h
@@ -33,6 +33,7 @@
 
 #include <vector>
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_exception.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_result.h"
@@ -83,12 +84,12 @@ class BLINK_PLATFORM_EXPORT WebContentDecryptionModuleSession {
   virtual WebString SessionId() const = 0;
 
   virtual void InitializeNewSession(media::EmeInitDataType,
-                                    const unsigned char* init_data,
+                                    base::span<const unsigned char> init_data,
                                     size_t init_data_length,
                                     WebContentDecryptionModuleResult) = 0;
   virtual void Load(const WebString& session_id,
                     WebContentDecryptionModuleResult) = 0;
-  virtual void Update(const unsigned char* response,
+  virtual void Update(base::span<const unsigned char> response,
                       size_t response_length,
                       WebContentDecryptionModuleResult) = 0;
   virtual void Close(WebContentDecryptionModuleResult) = 0;
diff --git a/third_party/blink/public/web/web_array_buffer.h b/third_party/blink/public/web/web_array_buffer.h
index cf875c70ec643..4f4fafd33f819 100644
--- a/third_party/blink/public/web/web_array_buffer.h
+++ b/third_party/blink/public/web/web_array_buffer.h
@@ -31,6 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_PUBLIC_WEB_WEB_ARRAY_BUFFER_H_
 #define THIRD_PARTY_BLINK_PUBLIC_WEB_WEB_ARRAY_BUFFER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_private_ptr.h"
 
@@ -56,7 +57,7 @@ class BLINK_EXPORT WebArrayBuffer {
   void Assign(const WebArrayBuffer&);
 
   bool IsNull() const { return private_.IsNull(); }
-  void* Data() const;
+  base::span<void> Data() const;
   size_t ByteLength() const;
 
 #if INSIDE_BLINK
diff --git a/third_party/blink/renderer/core/exported/web_array_buffer.cc b/third_party/blink/renderer/core/exported/web_array_buffer.cc
index 60a99f9865563..918a76c3043fa 100644
--- a/third_party/blink/renderer/core/exported/web_array_buffer.cc
+++ b/third_party/blink/renderer/core/exported/web_array_buffer.cc
@@ -30,6 +30,7 @@
 
 #include "third_party/blink/public/web/web_array_buffer.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h"
 
 namespace blink {
@@ -48,10 +49,10 @@ void WebArrayBuffer::Assign(const WebArrayBuffer& other) {
   private_ = other.private_;
 }
 
-void* WebArrayBuffer::Data() const {
+base::span<void> WebArrayBuffer::Data() const {
   if (!IsNull())
     return const_cast<void*>(private_->Data());
-  return nullptr;
+  return {};
 }
 
 size_t WebArrayBuffer::ByteLength() const {
diff --git a/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc b/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
index 64f87698f6929..23cfe86827c3e 100644
--- a/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
+++ b/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
@@ -472,7 +472,8 @@ TEST_F(FetchDataLoaderTest, LoadAsArrayBuffer) {
   ASSERT_TRUE(array_buffer);
   ASSERT_EQ(kQuickBrownFoxLengthWithTerminatingNull,
             array_buffer->ByteLength());
-  EXPECT_STREQ(kQuickBrownFox, static_cast<const char*>(array_buffer->Data()));
+  EXPECT_STREQ(kQuickBrownFox,
+               static_cast<const char*>(array_buffer->Data().data()));
 }
 
 TEST_F(FetchDataLoaderTest, LoadAsArrayBufferFailed) {
diff --git a/third_party/blink/renderer/core/layout/shapes/shape.cc b/third_party/blink/renderer/core/layout/shapes/shape.cc
index ecc370b92ed82..de3bf60a7b2f6 100644
--- a/third_party/blink/renderer/core/layout/shapes/shape.cc
+++ b/third_party/blink/renderer/core/layout/shapes/shape.cc
@@ -262,8 +262,9 @@ static bool ExtractImageData(Image* image,
 
   // Set |surface| to draw directly to |contents|.
   const SkSurfaceProps disable_lcd_props;
-  sk_sp<SkSurface> surface = SkSurfaces::WrapPixels(
-      dst_info, contents.Data(), dst_info.minRowBytes(), &disable_lcd_props);
+  sk_sp<SkSurface> surface =
+      SkSurfaces::WrapPixels(dst_info, contents.Data().data(),
+                             dst_info.minRowBytes(), &disable_lcd_props);
   if (!surface)
     return false;
 
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
index b86ac00a77fa3..da8f52be343ee 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
@@ -80,7 +80,7 @@ BlinkTransferableMessage BlinkTransferableMessage::FromTransferableMessage(
       // Check if we allocated the backing store of the ArrayBufferContents
       // correctly.
       CHECK_EQ(contents.DataLength(), big_buffer.size());
-      memcpy(contents.Data(), big_buffer.data(), big_buffer.size());
+      memcpy(contents.Data().data(), big_buffer.data(), big_buffer.size());
       array_buffer_contents_array.push_back(std::move(contents));
     }
     result.message->SetArrayBufferContentsArray(
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
index 50a91ece43256..e5a72126f02ed 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
@@ -182,7 +182,7 @@ bool StructTraits<blink::mojom::blink::SerializedArrayBufferContents::DataView,
   if (contents_data.size() != array_buffer_contents.DataLength()) {
     return false;
   }
-  memcpy(array_buffer_contents.Data(), contents_data.data(),
+  memcpy(array_buffer_contents.Data().data(), contents_data.data(),
          contents_data.size());
   *out = std::move(array_buffer_contents);
   return true;
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
index 6e1fac208b325..50b19cf26a6bd 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
@@ -138,7 +138,7 @@ TEST(BlinkTransferableMessageStructTraitsTest,
   // the original ArrayBufferContents' data (as opposed to a copy of the data).
   ArrayBufferContents& deserialized_contents =
       out.message->GetArrayBufferContentsArray()[0];
-  ASSERT_EQ(originalContentsData, deserialized_contents.Data());
+  ASSERT_EQ(originalContentsData, deserialized_contents.Data().data());
 
   // The original ArrayBufferContents should be detached.
   ASSERT_TRUE(v8_buffer->WasDetached());
diff --git a/third_party/blink/renderer/core/mojo/mojo_handle.cc b/third_party/blink/renderer/core/mojo/mojo_handle.cc
index ee7b886c0e4c8..df26382e246b8 100644
--- a/third_party/blink/renderer/core/mojo/mojo_handle.cc
+++ b/third_party/blink/renderer/core/mojo/mojo_handle.cc
@@ -135,7 +135,7 @@ MojoReadMessageResult* MojoHandle::readMessage(
       DOMArrayBuffer::CreateUninitializedOrNull(num_bytes, 1);
   if (num_bytes) {
     CHECK(buffer);
-    memcpy(buffer->Data(), bytes, num_bytes);
+    memcpy(buffer->Data().data(), bytes, num_bytes);
   }
   result_dict->setBuffer(buffer);
 
diff --git a/third_party/blink/renderer/core/testing/internals.cc b/third_party/blink/renderer/core/testing/internals.cc
index ffb929cd2fcf9..340b88b30031e 100644
--- a/third_party/blink/renderer/core/testing/internals.cc
+++ b/third_party/blink/renderer/core/testing/internals.cc
@@ -3152,7 +3152,7 @@ DOMArrayBuffer* Internals::serializeObject(
   DOMArrayBuffer* buffer = DOMArrayBuffer::CreateUninitializedOrNull(
       base::checked_cast<uint32_t>(span.size()), sizeof(uint8_t));
   if (buffer)
-    memcpy(buffer->Data(), span.data(), span.size());
+    memcpy(buffer->Data().data(), span.data(), span.size());
   return buffer;
 }
 
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
index 3a62ec87435f2..01e8be383c3a7 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
@@ -188,21 +188,21 @@ void ArrayBufferContents::Reset() {
 
 void ArrayBufferContents::Transfer(ArrayBufferContents& other) {
   DCHECK(!IsShared());
-  DCHECK(!other.Data());
+  DCHECK().empty());
   other.backing_store_ = std::move(backing_store_);
 }
 
 void ArrayBufferContents::ShareWith(ArrayBufferContents& other) {
   DCHECK(IsShared());
-  DCHECK(!other.Data());
+  DCHECK().empty());
   other.backing_store_ = backing_store_;
 }
 
 void ArrayBufferContents::ShareNonSharedForInternalUse(
     ArrayBufferContents& other) {
   DCHECK(!IsShared());
-  DCHECK(!other.Data());
-  DCHECK(Data());
+  DCHECK().empty());
+  DCHECK(!Data().empty());
   other.backing_store_ = backing_store_;
 }
 
@@ -211,7 +211,7 @@ void ArrayBufferContents::CopyTo(ArrayBufferContents& other) {
       DataLength(), 1, IsShared() ? kShared : kNotShared, kDontInitialize);
   if (!IsValid() || !other.IsValid())
     return;
-  std::memcpy(other.Data(), Data(), DataLength());
+  std::memcpy(other.Data().data(), Data().data(), DataLength());
 }
 
 template <partition_alloc::AllocFlags flags>
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
index d3ed7d55c634e..14e4d76d1dfa6 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
@@ -114,16 +114,16 @@ class CORE_EXPORT ArrayBufferContents {
   // Resets the internal memory so that the ArrayBufferContents is empty.
   void Reset();
 
-  void* Data() const {
+  base::span<void> Data() const {
     DCHECK(!IsShared());
     return DataMaybeShared();
   }
   void* DataShared() const {
     DCHECK(IsShared());
-    return DataMaybeShared();
+    return DataMaybeShared().data();
   }
-  void* DataMaybeShared() const {
-    return backing_store_ ? backing_store_->Data() : nullptr;
+  base::span<void> DataMaybeShared() const {
+    return backing_store_ ? backing_store_->Data() : {};
   }
   size_t DataLength() const {
     return backing_store_ ? backing_store_->ByteLength() : 0;
@@ -140,13 +140,13 @@ class CORE_EXPORT ArrayBufferContents {
     // SAFETY: `BackingStore` guarantees that `Data()` points to at least
     // `DataLength()` many bytes.
     return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(Data()), DataLength()));
+        base::span(static_cast<uint8_t*>(Data().data()), DataLength()));
   }
   base::span<uint8_t> ByteSpanMaybeShared() const {
     // SAFETY: `BackingStore` guarantees that `Data()` points to at least
     // `DataLength()` many bytes.
-    return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(DataMaybeShared()), DataLength()));
+    return UNSAFE_BUFFERS(base::span(
+        static_cast<uint8_t*>(DataMaybeShared().data()), DataLength()));
   }
 
   std::shared_ptr<v8::BackingStore> BackingStore() const {
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
index 6e4e03b268166..2560d023016bc 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
@@ -30,7 +30,7 @@ TEST_F(ArrayBufferContentsTest, DISABLE_ON_ASAN(AllocationFail)) {
                                blink::ArrayBufferContents::kDontInitialize);
   // Check that no memory got allocated, and that DataLength is set accordingly.
   ASSERT_EQ(content2.DataLength(), 0u);
-  ASSERT_EQ(content2.Data(), nullptr);
+  ASSERT_EQ(content2.Data().data(), nullptr);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
index a8cf2d329011f..fb23330987158 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
@@ -156,9 +156,10 @@ v8::Maybe<bool> DOMArrayBuffer::TransferDetachable(
     return v8::Just(false);
   }
 
-  if (!Content()->Data()) {
+  if () {.empty()) {
     // We transfer an empty ArrayBuffer, we can just allocate an empty content.
     result = ArrayBufferContents(Content()->BackingStore());
+    }
   } else {
     Content()->Transfer(result);
   }
@@ -239,8 +240,9 @@ DOMArrayBuffer* DOMArrayBuffer::CreateOrNull(size_t num_elements,
   ArrayBufferContents contents(num_elements, element_byte_size,
                                ArrayBufferContents::kNotShared,
                                ArrayBufferContents::kZeroInitialize);
-  if (!contents.Data()) {
+  if () {.empty()) {
     return nullptr;
+    }
   }
   return Create(std::move(contents));
 }
@@ -261,8 +263,9 @@ DOMArrayBuffer* DOMArrayBuffer::CreateUninitializedOrNull(
   ArrayBufferContents contents(num_elements, element_byte_size,
                                ArrayBufferContents::kNotShared,
                                ArrayBufferContents::kDontInitialize);
-  if (!contents.Data()) {
+  if () {.empty()) {
     return nullptr;
+    }
   }
   return Create(std::move(contents));
 }
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
index 7f4d5c2c6690e..34a4a57294ad4 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
@@ -20,11 +20,13 @@ class CORE_EXPORT DOMArrayBufferBase : public ScriptWrappable {
   const ArrayBufferContents* Content() const { return &contents_; }
   ArrayBufferContents* Content() { return &contents_; }
 
-  const void* Data() const { return contents_.Data(); }
-  void* Data() { return contents_.Data(); }
+  const base::span<void> Data() const { return contents_.Data(); }
+  base::span<void> Data() { return contents_.Data(); }
 
-  const void* DataMaybeShared() const { return contents_.DataMaybeShared(); }
-  void* DataMaybeShared() { return contents_.DataMaybeShared(); }
+  const void* DataMaybeShared() const {
+    return contents_.DataMaybeShared().data();
+  }
+  base::span<void> DataMaybeShared() { return contents_.DataMaybeShared(); }
 
   size_t ByteLength() const { return contents_.DataLength(); }
 
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
index bc4f5fd64fd51..88c6a36852fc2 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
@@ -95,7 +95,7 @@ class CORE_EXPORT DOMArrayBufferView : public ScriptWrappable {
     }
   }
 
-  void* BaseAddress() const {
+  base::span<void> BaseAddress() const {
     DCHECK(!IsShared());
     return BaseAddressMaybeShared();
   }
@@ -108,20 +108,20 @@ class CORE_EXPORT DOMArrayBufferView : public ScriptWrappable {
   base::span<uint8_t> ByteSpan() const {
     // SAFETY: `byteLength()` returns the number of bytes at `BaseAddress()`.
     return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(BaseAddress()), byteLength()));
+        base::span(static_cast<uint8_t*>(BaseAddress().data()), byteLength()));
   }
 
   virtual unsigned TypeSize() const = 0;
   bool IsShared() const { return dom_array_buffer_->IsShared(); }
 
-  void* BaseAddressMaybeShared() const {
-    return !IsDetached() ? raw_base_address_ : nullptr;
+  base::span<void> BaseAddressMaybeShared() const {
+    return !IsDetached() ? raw_base_address_ : {};
   }
 
   base::span<uint8_t> ByteSpanMaybeShared() const {
     // SAFETY: `byteLength()` returns the number of bytes at `BaseAddress()`.
     return UNSAFE_BUFFERS(base::span(
-        static_cast<uint8_t*>(BaseAddressMaybeShared()), byteLength()));
+        static_cast<uint8_t*>(BaseAddressMaybeShared().data()), byteLength()));
   }
 
   // ScriptWrappable overrides:
@@ -140,8 +140,8 @@ class CORE_EXPORT DOMArrayBufferView : public ScriptWrappable {
   DOMArrayBufferView(DOMArrayBufferBase* dom_array_buffer, size_t byte_offset)
       : raw_byte_offset_(byte_offset), dom_array_buffer_(dom_array_buffer) {
     DCHECK(dom_array_buffer_);
-    raw_base_address_ =
-        static_cast<char*>(dom_array_buffer_->DataMaybeShared()) + byte_offset;
+    raw_base_address_ = static_cast<char*>(dom_array_buffer_->DataMaybeShared())
+                            .subspan(byte_offset);
   }
 
  private:
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h b/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
index 19337e9883146..641c6d0a84c58 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -77,10 +79,12 @@ class DOMTypedArray final : public DOMArrayBufferView {
       : DOMArrayBufferView(dom_array_buffer, byte_offset),
         raw_length_(length) {}
 
-  ValueType* Data() const { return static_cast<ValueType*>(BaseAddress()); }
+  base::span<ValueType> Data() const {
+    return static_cast<ValueType*>(BaseAddress());
+  }
 
   ValueType* DataMaybeShared() const {
-    return reinterpret_cast<ValueType*>(BaseAddressMaybeShared());
+    return reinterpret_cast<ValueType*>(BaseAddressMaybeShared().data());
   }
 
   base::span<ValueType> AsSpan() const {
diff --git a/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc b/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
index b62d1d77a2d46..f0601fca3daaa 100644
--- a/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
+++ b/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -119,7 +121,7 @@ class MediaStreamAudioTrackUnderlyingSourceTest : public testing::Test {
   void SetChannelData(media::AudioBus* bus, int channel, float value) {
     ASSERT_LE(channel, bus->channels());
 
-    float* bus_channel = bus->channel(channel);
+    base::span<float> bus_channel = bus->channel(channel);
     for (int i = 0; i < bus->frames(); ++i) {
       bus_channel[i] = value;
     }
diff --git a/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc b/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
index 420c126f89a14..dee3604c557df 100644
--- a/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
+++ b/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -73,7 +75,8 @@ class FakeMediaStreamAudioSink : public WebMediaStreamAudioSink {
 
       for (int ch = 0; ch < data.channels(); ++ch) {
         const float* actual_channel_data = data.channel(ch);
-        const float* expected_channel_data = expected_data_->channel(ch);
+        base::span<const float> expected_channel_data =
+            expected_data_->channel(ch);
 
         for (int i = 0; i < data.frames(); ++i) {
           // If we use ASSERT_EQ here, the test will hang, since |on_data_| will
@@ -312,8 +315,8 @@ TEST_P(PushableMediaStreamAudioSourceTest, ConvertsFormatInternally) {
 
   // Create reference planar data.
   auto expected_data = media::AudioBus::Create(kChannels, kFrames);
-  float* bus_data_ch_0 = expected_data->channel(0);
-  float* bus_data_ch_1 = expected_data->channel(1);
+  base::span<float> bus_data_ch_0 = expected_data->channel(0);
+  base::span<float> bus_data_ch_1 = expected_data->channel(1);
   for (int i = 0; i < kFrames; ++i) {
     float value = static_cast<float>(i) / kFrames;
     bus_data_ch_0[i] = value;
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
index b68447db4d572..e5fe5409db0f1 100644
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
@@ -2657,7 +2657,7 @@ scoped_refptr<cc::RefCountedBuffer<SkPoint>> MakeSkPointBuffer(
 
   const size_t size = array->length() / 2;
   std::vector<SkPoint> skpoints(size);
-  std::memcpy(skpoints.data(), array->Data(), size * sizeof(SkPoint));
+  std::memcpy(skpoints.data(), array->Data().data(), size * sizeof(SkPoint));
 
   return base::MakeRefCounted<cc::RefCountedBuffer<SkPoint>>(
       std::move(skpoints));
diff --git a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
index 3be83fb60b2d1..f11e2f219a214 100644
--- a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
+++ b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
@@ -393,8 +393,8 @@ void DecodeImageOnDecoderThread(
         void(sk_sp<SkImage>, const ImageOrientationEnum)> result_callback) {
   const bool data_complete = true;
   std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
-      SegmentReader::CreateFromSkData(
-          SkData::MakeWithoutCopy(contents.Data(), contents.DataLength())),
+      SegmentReader::CreateFromSkData(SkData::MakeWithoutCopy(
+          contents.Data().data(), contents.DataLength())),
       data_complete, alpha_option, ImageDecoder::kDefaultBitDepth,
       color_behavior, cc::AuxImage::kDefault,
       Platform::GetMaxDecodedImageBytes());
diff --git a/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc b/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
index 3c105593d4c6d..6eb9147359811 100644
--- a/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
+++ b/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
@@ -66,8 +66,8 @@ class ClipboardImageWriter final : public ClipboardWriter {
       scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
     DCHECK(!IsMainThread());
     std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
-        SegmentReader::CreateFromSkData(
-            SkData::MakeWithoutCopy(png_data.Data(), png_data.DataLength())),
+        SegmentReader::CreateFromSkData(SkData::MakeWithoutCopy(
+            png_data.Data().data(), png_data.DataLength())),
         /*data_complete=*/true, ImageDecoder::kAlphaPremultiplied,
         ImageDecoder::kDefaultBitDepth, ColorBehavior::kTag,
         cc::AuxImage::kDefault, Platform::GetMaxDecodedImageBytes());
diff --git a/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc b/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
index 5e0118d60b72e..72244316e974f 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
@@ -148,8 +148,9 @@ MATCHER_P(UnionDOMArrayBufferOrViewEqualTo, vector, "") {
   if (buffer->ByteLength() != std::size(vector)) {
     return false;
   }
-  uint8_t* data = (uint8_t*)buffer->Data();
-  return std::equal(data, data + buffer->ByteLength(), std::begin(vector));
+  base::span<uint8_t> data = (uint8_t*)buffer->Data();
+  return std::equal(data, data.subspan(buffer->ByteLength()),
+                    std::begin(vector));
 }
 
 TEST(CredentialManagerTypeConvertersTest,
diff --git a/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc b/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
index bf3d858347d52..01fcaba9199a6 100644
--- a/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
+++ b/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
@@ -52,7 +52,7 @@ class MediaKeyStatusMap::MapEntry final
 
     // Compare the bytes.
     int result =
-        memcmp(a->KeyId()->Data(), b->KeyId()->Data(),
+        memcmp(a->KeyId()->Data().data(), b->KeyId()->Data().data(),
                std::min(a->KeyId()->ByteLength(), b->KeyId()->ByteLength()));
     if (result != 0)
       return result < 0;
diff --git a/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc b/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
index 9c18e49537f6b..9dbafa9ddd7b7 100644
--- a/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
+++ b/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -30,7 +32,7 @@ ScriptPromise<IDLUndefined> InternalsFuzzing::runFuzzer(
     const String& fuzzer_id,
     V8BufferSource* fuzzer_data) {
   auto* context = ExecutionContext::From(script_state);
-  const uint8_t* bytes = nullptr;
+  base::span<const uint8_t> bytes = {};
   size_t num_bytes = 0;
 
   switch (fuzzer_data->GetContentType()) {
@@ -48,7 +50,7 @@ ScriptPromise<IDLUndefined> InternalsFuzzing::runFuzzer(
     }
   }
 
-  std::vector<uint8_t> data(bytes, bytes + num_bytes);
+  std::vector<uint8_t> data(bytes.data(), bytes.subspan(num_bytes).data());
 
   auto* resolver =
       MakeGarbageCollected<ScriptPromiseResolver<IDLUndefined>>(script_state);
diff --git a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
index b38f9cab981bc..277261249b19c 100644
--- a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
+++ b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
@@ -7,6 +7,7 @@
 #include <cmath>
 
 #include "base/compiler_specific.h"
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
 #include "base/task/sequenced_task_runner.h"
@@ -258,7 +259,7 @@ double AudioRendererMixerInput::ProvideInput(
     // Apply a perfect linear fade-in. Fading-in in steps (e.g. increasing
     // volume by 10% every 1ms over 10ms) introduces high frequency distortions.
     for (int ch = 0; ch < audio_bus->channels(); ++ch) {
-      float* data = audio_bus->channel(ch);
+      base::span<float> data = audio_bus->channel(ch);
 
       for (int i = 0; i < frames; ++i) {
         UNSAFE_TODO(data[i]) *=
diff --git a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
index 5b61e009e8c1b..f20361ea6985f 100644
--- a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
+++ b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
@@ -202,8 +202,9 @@ class AudioRendererMixerTest
   // Fill |audio_bus_| fully with |value|.
   void FillAudioData(float value) {
     for (int i = 0; i < audio_bus_->channels(); ++i) {
-      std::fill(audio_bus_->channel(i),
-                audio_bus_->channel(i) + audio_bus_->frames(), value);
+      std::fill(audio_bus_->channel(i).data(),
+                audio_bus_->channel(i).subspan(audio_bus_->frames()).data(),
+                value);
     }
   }
 
diff --git a/third_party/blink/renderer/modules/mediastream/webaudio_media_stream_audio_sink_test.cc b/third_party/blink/renderer/modules/mediastream/webaudio_media_stream_audio_sink_test.cc
index e72d3fdd68cc3..b1242d58f8d1a 100644
--- a/third_party/blink/renderer/modules/mediastream/webaudio_media_stream_audio_sink_test.cc
+++ b/third_party/blink/renderer/modules/mediastream/webaudio_media_stream_audio_sink_test.cc
@@ -88,8 +88,8 @@ TEST_F(WebAudioMediaStreamAudioSinkTest, VerifyDataFlow) {
   // Create a source AudioBus with channel data filled with non-zero values.
   const std::unique_ptr<media::AudioBus> source_bus =
       media::AudioBus::Create(source_params_);
-  std::fill(source_bus->channel(0),
-            source_bus->channel(0) + source_bus->frames(), 0.5f);
+  std::fill(source_bus->channel(0).data(),
+            source_bus->channel(0).subspan(source_bus->frames()).data(), 0.5f);
 
   // Deliver data to |source_provider_|.
   base::TimeTicks estimated_capture_time = base::TimeTicks::Now();
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
index 7fd82975d67a7..5f6c67fee0ed1 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
@@ -869,7 +869,7 @@ void RTCDataChannel::BlobReader::DidFinishLoading(FileReaderData data) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DOMArrayBuffer* array_buffer = std::move(data).AsDOMArrayBuffer();
   rtc::CopyOnWriteBuffer buffer(
-      static_cast<const char*>((array_buffer->Data())),
+      static_cast<const char*>((array_buffer->Data().data())),
       array_buffer->ByteLength());
   message_->buffer_ = webrtc::DataBuffer(buffer, true);
   message_->type_ = RTCDataChannel::PendingMessage::Type::kBufferReady;
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc b/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
index f327153c68785..6da5b3f5c965f 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
@@ -161,7 +161,8 @@ void RTCDtlsTransport::OnStateChange(webrtc::DtlsTransportInformation info) {
         // Don't replace the certificate if it's unchanged.
         // Should have been "if (*dab_cert != *remote_certificates_[i])"
         if (dab_cert->ByteLength() != remote_certificates_[i]->ByteLength() ||
-            memcmp(dab_cert->Data(), remote_certificates_[i]->Data(),
+            memcmp(dab_cert->Data().data(),
+                   remote_certificates_[i]->Data().data(),
                    dab_cert->ByteLength()) != 0) {
           remote_certificates_[i] = dab_cert;
         }
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
index 8b9b64559b531..e7486610c0e9c 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
@@ -66,7 +66,7 @@ void RTCEncodedAudioFrameDelegate::SetData(const DOMArrayBuffer* data) {
   base::AutoLock lock(lock_);
   if (webrtc_frame_ && data) {
     webrtc_frame_->SetData(rtc::ArrayView<const uint8_t>(
-        static_cast<const uint8_t*>(data->Data()), data->ByteLength()));
+        static_cast<const uint8_t*>(data->Data().data()), data->ByteLength()));
   }
 }
 
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
index 6ca2891ed70fb..e6c7091869725 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
@@ -79,7 +79,7 @@ void RTCEncodedVideoFrameDelegate::SetData(const DOMArrayBuffer* data) {
   base::AutoLock lock(lock_);
   if (webrtc_frame_ && data) {
     webrtc_frame_->SetData(rtc::ArrayView<const uint8_t>(
-        static_cast<const uint8_t*>(data->Data()), data->ByteLength()));
+        static_cast<const uint8_t*>(data->Data().data()), data->ByteLength()));
   }
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/audio_buffer.cc b/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
index 9e2816b78ed7f..0a591e0ffd823 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
@@ -197,7 +197,7 @@ AudioBuffer::AudioBuffer(AudioBus* bus)
     }
 
     const float* src = bus->Channel(i)->Data();
-    float* dst = channel_data_array->Data();
+    float* dst = channel_data_array->Data().data();
     memmove(dst, src, length_ * sizeof(*dst));
     channels_.push_back(channel_data_array);
   }
@@ -310,7 +310,7 @@ void AudioBuffer::copyToChannel(NotShared<DOMFloat32Array> source,
 void AudioBuffer::Zero() {
   for (unsigned i = 0; i < channels_.size(); ++i) {
     if (NotShared<DOMFloat32Array> array = getChannelData(i)) {
-      float* data = array->Data();
+      float* data = array->Data().data();
       memset(data, 0, length() * sizeof(*data));
     }
   }
@@ -331,7 +331,7 @@ SharedAudioBuffer::SharedAudioBuffer(AudioBuffer* buffer)
 
 void SharedAudioBuffer::Zero() {
   for (auto& channel : channels_) {
-    float* data = static_cast<float*>(channel.Data());
+    float* data = static_cast<float*>(channel.Data().data());
     memset(data, 0, length() * sizeof(*data));
   }
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
index 2bbd4bef3f720..aecd7fd44fc67 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
@@ -79,52 +79,52 @@ AudioListenerHandler::~AudioListenerHandler() {
 const float* AudioListenerHandler::GetPositionXValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return position_x_values_.Data();
+  return position_x_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetPositionYValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return position_y_values_.Data();
+  return position_y_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetPositionZValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return position_z_values_.Data();
+  return position_z_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetForwardXValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return forward_x_values_.Data();
+  return forward_x_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetForwardYValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return forward_y_values_.Data();
+  return forward_y_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetForwardZValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return forward_z_values_.Data();
+  return forward_z_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetUpXValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return up_x_values_.Data();
+  return up_x_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetUpYValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return up_y_values_.Data();
+  return up_y_values_.Data().data();
 }
 
 const float* AudioListenerHandler::GetUpZValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
-  return up_z_values_.Data();
+  return up_z_values_.Data().data();
 }
 
 bool AudioListenerHandler::HasSampleAccurateValues() const {
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
index 2be886019d61f..a2294aff3aec5 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -222,25 +224,25 @@ void AudioParamHandler::SetValue(float value) {
 
 float AudioParamHandler::FinalValue() {
   float value = IntrinsicValue();
-  CalculateFinalValues(&value, 1, false);
+  CalculateFinalValues(base::span<float, 1>(&value), 1, false);
   return value;
 }
 
 void AudioParamHandler::CalculateSampleAccurateValues(
-    float* values,
+    base::span<float> values,
     unsigned number_of_values) {
   DCHECK(GetDeferredTaskHandler().IsAudioThread());
-  DCHECK(values);
+  DCHECK(!values.empty());
   DCHECK_GT(number_of_values, 0u);
 
   CalculateFinalValues(values, number_of_values, IsAudioRate());
 }
 
-void AudioParamHandler::CalculateFinalValues(float* values,
+void AudioParamHandler::CalculateFinalValues(base::span<float> values,
                                              unsigned number_of_values,
                                              bool sample_accurate) {
   DCHECK(GetDeferredTaskHandler().IsAudioThread());
-  DCHECK(values);
+  DCHECK(!values.empty());
   DCHECK_GT(number_of_values, 0u);
 
   // The calculated result will be the "intrinsic" value summed with all
@@ -248,7 +250,7 @@ void AudioParamHandler::CalculateFinalValues(float* values,
 
   if (sample_accurate) {
     // Calculate sample-accurate (a-rate) intrinsic values.
-    CalculateTimelineValues(values, number_of_values);
+    CalculateTimelineValues(values.data(), number_of_values);
   } else {
     // Calculate control-rate (k-rate) intrinsic value.
     float value = IntrinsicValue();
@@ -310,11 +312,11 @@ void AudioParamHandler::CalculateFinalValues(float* values,
       // range between the AudioParam's minValue and maxValue.
       //
       // See https://webaudio.github.io/web-audio-api/#computation-of-value.
-      HandleNaNValues(values, number_of_values, DefaultValue());
+      HandleNaNValues(values.data(), number_of_values, DefaultValue());
     }
 
-    vector_math::Vclip(values, 1, &min_value, &max_value, values, 1,
-                       number_of_values);
+    vector_math::Vclip(values.data(), 1, &min_value, &max_value, values.data(),
+                       1, number_of_values);
   }
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_handler.h b/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
index 31f2d997ff524..e347b4fb1d06b 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
@@ -9,6 +9,7 @@
 
 #include <atomic>
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer_view_helpers.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
@@ -161,7 +162,8 @@ class AudioParamHandler final : public ThreadSafeRefCounted<AudioParamHandler>,
   // Calculates numberOfValues parameter values starting at the context's
   // current time.
   // Must be called in the context's render thread.
-  void CalculateSampleAccurateValues(float* values, unsigned number_of_values);
+  void CalculateSampleAccurateValues(base::span<float> values,
+                                     unsigned number_of_values);
 
   float IntrinsicValue() const {
     return intrinsic_value_.load(std::memory_order_relaxed);
@@ -180,7 +182,7 @@ class AudioParamHandler final : public ThreadSafeRefCounted<AudioParamHandler>,
 
   // sampleAccurate corresponds to a-rate (audio rate) vs. k-rate in the Web
   // Audio specification.
-  void CalculateFinalValues(float* values,
+  void CalculateFinalValues(base::span<float> values,
                             unsigned number_of_values,
                             bool sample_accurate);
   void CalculateTimelineValues(float* values, unsigned number_of_values);
diff --git a/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
index 8a4039031f7e6..2350b9487573d 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
@@ -119,7 +119,7 @@ AudioScheduledSourceHandler::UpdateSchedulingInfo(size_t quantum_frame_size,
   // start time in the middle of the quantum.
   if (quantum_frame_offset) {
     for (unsigned i = 0; i < output_bus->NumberOfChannels(); ++i) {
-      UNSAFE_TODO(memset(output_bus->Channel(i)->MutableData(), 0,
+      UNSAFE_TODO(memset(output_bus->Channel(i)->MutableData().data(), 0,
                          sizeof(float) * quantum_frame_offset));
     }
   }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
index 3a72a57975126..939856d938b06 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
@@ -337,8 +337,10 @@ class AudioWorkletGlobalScopeTest : public PageTestBase, public ModuleTestBase {
     output_buses.push_back(output_bus.get());
 
     // Fill `input_channel` with 1 and zero out `output_bus`.
-    std::fill(input_channel->MutableData(),
-              input_channel->MutableData() + input_channel->length(), 1);
+    std::fill(
+        input_channel->MutableData().data(),
+        input_channel->MutableData().subspan(input_channel->length()).data(),
+        1);
     output_bus->Zero();
 
     // Then invoke the process() method to perform JS buffer manipulation. The
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
index c498a6ad04d96..3d0ce54c5f63f 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
@@ -159,7 +159,7 @@ void AudioWorkletHandler::ProcessInternal(uint32_t frames_to_process) {
       param_handler->CalculateSampleAccurateValues(
           param_values->Data(), static_cast<uint32_t>(frames_to_process));
     } else {
-      std::fill(param_values->Data(),
+      std::fill(param_values->Data().data(),
                 UNSAFE_TODO(param_values->Data() + frames_to_process),
                 param_handler->FinalValue());
     }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
index e35e4d16a32e7..2636c1276152e 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
@@ -395,11 +395,13 @@ void AudioWorkletProcessor::CopyArrayBuffersToPort(
       // An ArrayBuffer might be transferred. So we need to check the byte
       // length and silence the output buffer if needed.
       if (backing_store->ByteLength() == bus_length) {
-        UNSAFE_TODO(memcpy(audio_bus->Channel(channel_index)->MutableData(),
-                           backing_store->Data(), bus_length));
+        UNSAFE_TODO(
+            memcpy(audio_bus->Channel(channel_index)->MutableData().data(),
+                   backing_store->Data(), bus_length));
       } else {
-        UNSAFE_TODO(memset(audio_bus->Channel(channel_index)->MutableData(), 0,
-                           bus_length));
+        UNSAFE_TODO(
+            memset(audio_bus->Channel(channel_index)->MutableData().data(), 0,
+                   bus_length));
       }
     }
   }
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
index b2783cdfa93c0..f94dcaed8d84a 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -46,7 +48,7 @@ namespace blink {
 
 namespace {
 
-bool HasConstantValues(float* values, int frames_to_process) {
+bool HasConstantValues(base::span<float> values, int frames_to_process) {
   // Load the initial value
   const float value = values[0];
   // This initialization ensures that we correctly handle the first frame and
@@ -102,7 +104,7 @@ bool HasConstantValues(float* values, int frames_to_process) {
 
 }  // namespace
 
-bool BiquadDSPKernel::HasConstantValuesForTesting(float* values,
+bool BiquadDSPKernel::HasConstantValuesForTesting(base::span<float> values,
                                                   int frames_to_process) {
   return HasConstantValues(values, frames_to_process);
 }
@@ -155,11 +157,12 @@ void BiquadDSPKernel::UpdateCoefficientsIfNecessary(int frames_to_process) {
   }
 }
 
-void BiquadDSPKernel::UpdateCoefficients(int number_of_frames,
-                                         const float* cutoff_frequency,
-                                         const float* q,
-                                         const float* gain,
-                                         const float* detune) {
+void BiquadDSPKernel::UpdateCoefficients(
+    int number_of_frames,
+    base::span<const float> cutoff_frequency,
+    base::span<const float> q,
+    base::span<const float> gain,
+    base::span<const float> detune) {
   // Convert from Hertz to normalized frequency 0 -> 1.
   double nyquist = Nyquist();
 
@@ -229,10 +232,10 @@ void BiquadDSPKernel::UpdateTailTime(int coef_index) {
 }
 
 void BiquadDSPKernel::Process(const float* source,
-                              float* destination,
+                              base::span<float> destination,
                               uint32_t frames_to_process) {
   DCHECK(source);
-  DCHECK(destination);
+  DCHECK(!destination.empty());
   DCHECK(GetBiquadProcessor());
 
   // Recompute filter coefficients if any of the parameters have changed.
@@ -255,17 +258,17 @@ void BiquadDSPKernel::Process(const float* source,
 
 void BiquadDSPKernel::GetFrequencyResponse(BiquadDSPKernel& kernel,
                                            int n_frequencies,
-                                           const float* frequency_hz,
-                                           float* mag_response,
-                                           float* phase_response) {
+                                           base::span<const float> frequency_hz,
+                                           base::span<float> mag_response,
+                                           base::span<float> phase_response) {
   // Only allow on the main thread because we don't want the audio thread to be
   // updating `kernel` while we're computing the response.
   DCHECK(IsMainThread());
 
   DCHECK_GE(n_frequencies, 0);
-  DCHECK(frequency_hz);
-  DCHECK(mag_response);
-  DCHECK(phase_response);
+  DCHECK(!frequency_hz.empty());
+  DCHECK(!mag_response.empty());
+  DCHECK(!phase_response.empty());
 
   Vector<float> frequency(n_frequencies);
   double nyquist = kernel.Nyquist();
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
index 92a413be11701..38c496492f772 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
+++ b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_BIQUAD_DSP_KERNEL_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_BIQUAD_DSP_KERNEL_H_
 
+#include "base/containers/span.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/renderer/modules/webaudio/biquad_processor.h"
 #include "third_party/blink/renderer/platform/audio/audio_dsp_kernel.h"
@@ -47,7 +48,7 @@ class BiquadDSPKernel final : public AudioDSPKernel {
 
   // AudioDSPKernel
   void Process(const float* source,
-               float* dest,
+               base::span<float> dest,
                uint32_t frames_to_process) override;
   void Reset() override { biquad_.Reset(); }
 
@@ -56,23 +57,24 @@ class BiquadDSPKernel final : public AudioDSPKernel {
   // must be called from the main thread.
   static void GetFrequencyResponse(BiquadDSPKernel& kernel,
                                    int n_frequencies,
-                                   const float* frequency_hz,
-                                   float* mag_response,
-                                   float* phase_response);
+                                   base::span<const float> frequency_hz,
+                                   base::span<float> mag_response,
+                                   base::span<float> phase_response);
 
   bool RequiresTailProcessing() const final;
   double TailTime() const override;
   double LatencyTime() const override;
   // Update the biquad coefficients with the given parameters
   void UpdateCoefficients(int number_of_frames,
-                          const float* frequency,
-                          const float* q,
-                          const float* gain,
-                          const float* detune);
+                          base::span<const float> frequency,
+                          base::span<const float> q,
+                          base::span<const float> gain,
+                          base::span<const float> detune);
 
   // Expose HasConstantValues for unit testing
-  MODULES_EXPORT static bool HasConstantValuesForTesting(float* values,
-                                                         int frames_to_process);
+  MODULES_EXPORT static bool HasConstantValuesForTesting(
+      base::span<float> values,
+      int frames_to_process);
 
  protected:
   Biquad biquad_;
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_processor.cc b/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
index 2b9a9ec17bb3e..63b3324a230d4 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
@@ -27,6 +27,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h"
 #include "third_party/blink/renderer/platform/audio/audio_utilities.h"
@@ -168,9 +169,9 @@ void BiquadProcessor::SetType(FilterType type) {
 }
 
 void BiquadProcessor::GetFrequencyResponse(int n_frequencies,
-                                           const float* frequency_hz,
-                                           float* mag_response,
-                                           float* phase_response) {
+                                           base::span<const float> frequency_hz,
+                                           base::span<float> mag_response,
+                                           base::span<float> phase_response) {
   DCHECK(IsMainThread());
 
   // Compute the frequency response on a separate temporary kernel
@@ -200,7 +201,9 @@ void BiquadProcessor::GetFrequencyResponse(int n_frequencies,
     detune = Parameter4().Value();
   }
 
-  response_kernel->UpdateCoefficients(1, &cutoff_frequency, &q, &gain, &detune);
+  response_kernel->UpdateCoefficients(
+      1, base::span<float, 1>(&cutoff_frequency), base::span<float, 1>(&q),
+      base::span<float, 1>(&gain), base::span<float, 1>(&detune));
   BiquadDSPKernel::GetFrequencyResponse(*response_kernel, n_frequencies,
                                         frequency_hz, mag_response,
                                         phase_response);
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_processor.h b/third_party/blink/renderer/modules/webaudio/biquad_processor.h
index 428ab00e6b667..43354a3745590 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_processor.h
+++ b/third_party/blink/renderer/modules/webaudio/biquad_processor.h
@@ -28,6 +28,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_param.h"
@@ -77,9 +78,9 @@ class BiquadProcessor final : public AudioDSPKernelProcessor {
   // Get the magnitude and phase response of the filter at the given
   // set of frequencies (in Hz). The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
-                            const float* frequency_hz,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<const float> frequency_hz,
+                            base::span<float> mag_response,
+                            base::span<float> phase_response);
 
   void CheckForDirtyCoefficients();
 
diff --git a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
index 65a3dd0c0ea90..8cf26a4ca3dab 100644
--- a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
@@ -7,6 +7,7 @@
 #include <tuple>
 
 #include "base/compiler_specific.h"
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_output.h"
 
 namespace blink {
@@ -78,7 +79,7 @@ void ConstantSourceHandler::Process(uint32_t frames_to_process) {
 
   if (is_sample_accurate && offset_->IsAudioRate()) {
     DCHECK_LE(frames_to_process, sample_accurate_values_.size());
-    float* offsets = sample_accurate_values_.Data();
+    base::span<float> offsets = sample_accurate_values_.Data();
     offset_->CalculateSampleAccurateValues(offsets, frames_to_process);
     if (non_silent_frames_to_process > 0) {
       UNSAFE_TODO(
diff --git a/third_party/blink/renderer/modules/webaudio/delay_handler.cc b/third_party/blink/renderer/modules/webaudio/delay_handler.cc
index 10c68f0e66ffb..3605d5bced8f0 100644
--- a/third_party/blink/renderer/modules/webaudio/delay_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/delay_handler.cc
@@ -73,17 +73,19 @@ void DelayHandler::Process(uint32_t frames_to_process) {
           CHECK(delay_time_->IsAudioRate());
           delay_time_->CalculateSampleAccurateValues(kernels_[i]->DelayTimes(),
                                                      frames_to_process);
-          kernels_[i]->ProcessARate(source_bus->Channel(i)->Data(),
-                                    destination_bus->Channel(i)->MutableData(),
-                                    frames_to_process);
+          kernels_[i]->ProcessARate(
+              source_bus->Channel(i)->Data(),
+              destination_bus->Channel(i)->MutableData().data(),
+              frames_to_process);
         }
       } else {
         for (unsigned i = 0; i < kernels_.size(); ++i) {
           CHECK(!delay_time_->IsAudioRate());
           kernels_[i]->SetDelayTime(delay_time_->FinalValue());
-          kernels_[i]->ProcessKRate(source_bus->Channel(i)->Data(),
-                                    destination_bus->Channel(i)->MutableData(),
-                                    frames_to_process);
+          kernels_[i]->ProcessKRate(
+              source_bus->Channel(i)->Data(),
+              destination_bus->Channel(i)->MutableData().data(),
+              frames_to_process);
         }
       }
     } else {
diff --git a/third_party/blink/renderer/modules/webaudio/gain_handler.cc b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
index b9df503cc1a48..5451ca69e2154 100644
--- a/third_party/blink/renderer/modules/webaudio/gain_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/gain_handler.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_input.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_output.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
@@ -54,10 +55,10 @@ void GainHandler::Process(uint32_t frames_to_process) {
       // Apply sample-accurate gain scaling for precise envelopes, grain
       // windows, etc.
       DCHECK_LE(frames_to_process, sample_accurate_gain_values_.size());
-      float* gain_values = sample_accurate_gain_values_.Data();
+      base::span<float> gain_values = sample_accurate_gain_values_.Data();
       gain_->CalculateSampleAccurateValues(gain_values, frames_to_process);
-      output_bus->CopyWithSampleAccurateGainValuesFrom(*input_bus, gain_values,
-                                                       frames_to_process);
+      output_bus->CopyWithSampleAccurateGainValuesFrom(
+          *input_bus, gain_values.data(), frames_to_process);
 
       return;
     }
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
index d2205c3bb703a..efdbd7597e4e8 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
@@ -7,6 +7,7 @@
 #include <memory>
 
 #include "base/compiler_specific.h"
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
 #include "third_party/blink/renderer/core/inspector/console_message.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node.h"
@@ -43,14 +44,15 @@ IIRFilterHandler::~IIRFilterHandler() {
 
 // Get the magnitude and phase response of the filter at the given set of
 // frequencies (in Hz). The phase response is in radians.
-void IIRFilterHandler::GetFrequencyResponse(int n_frequencies,
-                                            const float* frequency_hz,
-                                            float* mag_response,
-                                            float* phase_response) const {
+void IIRFilterHandler::GetFrequencyResponse(
+    int n_frequencies,
+    base::span<const float> frequency_hz,
+    base::span<float> mag_response,
+    base::span<float> phase_response) const {
   DCHECK_GE(n_frequencies, 0);
-  DCHECK(frequency_hz);
-  DCHECK(mag_response);
-  DCHECK(phase_response);
+  DCHECK(!frequency_hz.empty());
+  DCHECK(!mag_response.empty());
+  DCHECK(!phase_response.empty());
 
   Vector<float> frequency(n_frequencies);
 
@@ -146,7 +148,7 @@ void IIRFilterHandler::Process(uint32_t frames_to_process) {
 
       for (unsigned i = 0; i < kernels_.size(); ++i) {
         kernels_[i]->Process(source_bus->Channel(i)->Data(),
-                             destination_bus->Channel(i)->MutableData(),
+                             destination_bus->Channel(i)->MutableData().data(),
                              frames_to_process);
       }
     } else {
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
index 6199836057826..65c41b804223a 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_IIR_FILTER_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_IIR_FILTER_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/task/single_thread_task_runner.h"
@@ -29,9 +30,9 @@ class IIRFilterHandler final : public AudioHandler {
   // Get the magnitude and phase response of the filter at the given
   // set of frequencies (in Hz). The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
-                            const float* frequency_hz,
-                            float* mag_response,
-                            float* phase_response) const;
+                            base::span<const float> frequency_hz,
+                            base::span<float> mag_response,
+                            base::span<float> phase_response) const;
 
  private:
   IIRFilterHandler(AudioNode&,
diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
index 0b91df171ba50..80bfdc1ddee26 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -293,7 +295,7 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
 
   bool has_sample_accurate_values = false;
   bool has_frequency_changes = false;
-  float* phase_increments = phase_increments_.Data();
+  base::span<float> phase_increments = phase_increments_.Data();
 
   float final_scale = periodic_wave_->RateScale();
 
@@ -315,13 +317,13 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
     has_sample_accurate_values = true;
 
     // Get the sample-accurate detune values.
-    float* detune_values =
+    base::span<float> detune_values =
         has_frequency_changes ? detune_values_.Data() : phase_increments;
     detune_->CalculateSampleAccurateValues(detune_values, frames_to_process);
 
     // Convert from cents to rate scalar.
     float k = 1.0 / 1200;
-    vector_math::Vsmul(detune_values, 1, &k, detune_values, 1,
+    vector_math::Vsmul(detune_values.data(), 1, &k, detune_values.data(), 1,
                        frames_to_process);
     for (unsigned i = 0; i < frames_to_process; ++i) {
       detune_values[i] = std::exp2(detune_values[i]);
@@ -329,8 +331,8 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
 
     if (has_frequency_changes) {
       // Multiply frequencies by detune scalings.
-      vector_math::Vmul(detune_values, 1, phase_increments, 1, phase_increments,
-                        1, frames_to_process);
+      vector_math::Vmul(detune_values.data(), 1, phase_increments.data(), 1,
+                        phase_increments.data(), 1, frames_to_process);
     }
   } else {
     // Handle ordinary parameter changes if there are no scheduled
@@ -341,11 +343,11 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
   }
 
   if (has_sample_accurate_values) {
-    ClampFrequency(phase_increments, frames_to_process,
+    ClampFrequency(phase_increments.data(), frames_to_process,
                    Context()->sampleRate() / 2);
     // Convert from frequency to wavetable increment.
-    vector_math::Vsmul(phase_increments, 1, &final_scale, phase_increments, 1,
-                       frames_to_process);
+    vector_math::Vsmul(phase_increments.data(), 1, &final_scale,
+                       phase_increments.data(), 1, frames_to_process);
   }
 
   return has_sample_accurate_values;
@@ -702,7 +704,7 @@ void OscillatorHandler::Process(uint32_t frames_to_process) {
 
   unsigned periodic_wave_size = periodic_wave_->PeriodicWaveSize();
 
-  float* dest_p = output_bus->Channel(0)->MutableData();
+  float* dest_p = output_bus->Channel(0)->MutableData().data();
 
   DCHECK_LE(quantum_frame_offset, frames_to_process);
 
@@ -729,7 +731,7 @@ void OscillatorHandler::Process(uint32_t frames_to_process) {
                                                     table_interpolation_factor);
   }
 
-  float* phase_increments = phase_increments_.Data();
+  float* phase_increments = phase_increments_.Data().data();
 
   // Start rendering at the correct offset.
   dest_p += quantum_frame_offset;
diff --git a/third_party/blink/renderer/modules/webaudio/panner_handler.cc b/third_party/blink/renderer/modules/webaudio/panner_handler.cc
index e05ddc683a56e..3ea1150b3fb4c 100644
--- a/third_party/blink/renderer/modules/webaudio/panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/panner_handler.cc
@@ -4,6 +4,8 @@
 
 #include "third_party/blink/renderer/modules/webaudio/panner_handler.h"
 
+#include <array>
+
 #include "base/compiler_specific.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/synchronization/lock.h"
@@ -224,15 +226,15 @@ void PannerHandler::ProcessSampleAccurateValues(AudioBus* destination,
   CHECK_EQ(render_quantum_frames, render_quantum_frames_expected);
   CHECK_LE(frames_to_process, render_quantum_frames_expected);
 
-  float panner_x[render_quantum_frames_expected];
-  float panner_y[render_quantum_frames_expected];
-  float panner_z[render_quantum_frames_expected];
-  float orientation_x[render_quantum_frames_expected];
-  float orientation_y[render_quantum_frames_expected];
-  float orientation_z[render_quantum_frames_expected];
+  std::array<float, render_quantum_frames_expected> panner_x;
+  std::array<float, render_quantum_frames_expected> panner_y;
+  std::array<float, render_quantum_frames_expected> panner_z;
+  std::array<float, render_quantum_frames_expected> orientation_x;
+  std::array<float, render_quantum_frames_expected> orientation_y;
+  std::array<float, render_quantum_frames_expected> orientation_z;
   double azimuth[render_quantum_frames_expected];
   double elevation[render_quantum_frames_expected];
-  float total_gain[render_quantum_frames_expected];
+  std::array<float, render_quantum_frames_expected> total_gain;
 
   position_x_->CalculateSampleAccurateValues(panner_x, frames_to_process);
   position_y_->CalculateSampleAccurateValues(panner_y, frames_to_process);
@@ -291,8 +293,8 @@ void PannerHandler::ProcessSampleAccurateValues(AudioBus* destination,
   panner_->PanWithSampleAccurateValues(azimuth, elevation, source, destination,
                                        frames_to_process,
                                        InternalChannelInterpretation());
-  destination->CopyWithSampleAccurateGainValuesFrom(*destination, total_gain,
-                                                    frames_to_process);
+  destination->CopyWithSampleAccurateGainValuesFrom(
+      *destination, total_gain.data(), frames_to_process);
 }
 
 void PannerHandler::ProcessOnlyAudioParams(uint32_t frames_to_process) {
diff --git a/third_party/blink/renderer/modules/webaudio/periodic_wave.cc b/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
index 46dc53a0472e5..0f4489abe727d 100644
--- a/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
+++ b/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
@@ -431,11 +431,11 @@ void PeriodicWaveImpl::CreateBandLimitedTables(const float* real_data,
     // arrays.  Need to scale the data by fftSize to remove the scaling that the
     // inverse IFFT would do.
     float scale = fft_size;
-    vector_math::Vsmul(
-        real_data, 1, &scale, real.Data(), 1, number_of_components);
+    vector_math::Vsmul(real_data, 1, &scale, real.Data().data(), 1,
+                       number_of_components);
     scale = -scale;
-    vector_math::Vsmul(
-        imag_data, 1, &scale, imag.Data(), 1, number_of_components);
+    vector_math::Vsmul(imag_data, 1, &scale, imag.Data().data(), 1,
+                       number_of_components);
 
     // Find the starting bin where we should start culling.  We need to clear
     // out the highest frequencies to band-limit the waveform.
@@ -463,7 +463,7 @@ void PeriodicWaveImpl::CreateBandLimitedTables(const float* real_data,
     band_limited_tables_.push_back(std::move(table));
 
     // Apply an inverse FFT to generate the time-domain table data.
-    float* data = band_limited_tables_[range_index]->Data();
+    float* data = band_limited_tables_[range_index]->Data().data();
     frame.DoInverseFFT(data);
 
     // For the first range (which has the highest power), calculate its peak
@@ -490,8 +490,8 @@ void PeriodicWaveImpl::GenerateBasicWaveform(int shape) {
 
   AudioFloatArray real(half_size);
   AudioFloatArray imag(half_size);
-  float* real_p = real.Data();
-  float* imag_p = imag.Data();
+  float* real_p = real.Data().data();
+  float* imag_p = imag.Data().data();
 
   // Clear DC and Nyquist.
   real_p[0] = 0;
diff --git a/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc b/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
index 7172964ca8363..7b57c6bff504d 100644
--- a/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
+++ b/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -149,8 +151,8 @@ void RealtimeAnalyser::GetFloatTimeDomainData(
     DCHECK_EQ(input_buffer_.size(), kInputBufferSize);
     DCHECK_GT(input_buffer_.size(), fft_size);
 
-    float* input_buffer = input_buffer_.Data();
-    float* destination = destination_array->Data();
+    float* input_buffer = input_buffer_.Data().data();
+    base::span<float> destination = destination_array->Data();
 
     unsigned write_index = GetWriteIndex();
 
@@ -176,8 +178,8 @@ void RealtimeAnalyser::GetByteTimeDomainData(DOMUint8Array* destination_array) {
     DCHECK_EQ(input_buffer_.size(), kInputBufferSize);
     DCHECK_GT(input_buffer_.size(), fft_size);
 
-    float* input_buffer = input_buffer_.Data();
-    unsigned char* destination = destination_array->Data();
+    float* input_buffer = input_buffer_.Data().data();
+    base::span<unsigned char> destination = destination_array->Data();
 
     unsigned write_index = GetWriteIndex();
 
@@ -208,7 +210,7 @@ void RealtimeAnalyser::WriteInput(AudioBus* bus, uint32_t frames_to_process) {
   DCHECK_LE(write_index + frames_to_process, input_buffer_.size());
 
   // Perform real-time analysis
-  float* dest = input_buffer_.Data() + write_index;
+  float* dest = input_buffer_.Data().subspan(write_index).data();
 
   // Clear the bus and downmix the input according to the down mixing rules.
   // Then save the result in the m_inputBuffer at the appropriate place.
@@ -232,8 +234,8 @@ void RealtimeAnalyser::DoFFTAnalysis() {
   uint32_t fft_size = FftSize();
 
   AudioFloatArray temporary_buffer(fft_size);
-  float* input_buffer = input_buffer_.Data();
-  float* temp_p = temporary_buffer.Data();
+  float* input_buffer = input_buffer_.Data().data();
+  float* temp_p = temporary_buffer.Data().data();
 
   // Take the previous fftSize values from the input buffer and copy into the
   // temporary buffer.
@@ -270,12 +272,12 @@ void RealtimeAnalyser::DoFFTAnalysis() {
 
   // Convert the analysis data from complex to magnitude and average with the
   // previous result.
-  float* destination = MagnitudeBuffer().Data();
+  float* destination = MagnitudeBuffer().Data().data();
   size_t n = MagnitudeBuffer().size();
   DCHECK_GE(real.size(), n);
   const float* real_p_data = real.Data();
   DCHECK_GE(imag.size(), n);
-  const float* imag_p_data = imag.Data();
+  const float* imag_p_data = imag.Data().data();
   for (size_t i = 0; i < n; ++i) {
     std::complex<double> c(real_p_data[i], imag_p_data[i]);
     double scalar_magnitude = abs(c) * magnitude_scale;
@@ -294,8 +296,8 @@ void RealtimeAnalyser::ConvertToByteData(DOMUint8Array* destination_array) {
                                           : 1 / (max_decibels_ - min_decibels_);
     const double min_decibels = min_decibels_;
 
-    const float* source = MagnitudeBuffer().Data();
-    unsigned char* destination = destination_array->Data();
+    const float* source = MagnitudeBuffer().Data().data();
+    base::span<unsigned char> destination = destination_array->Data();
 
     for (unsigned i = 0; i < len; ++i) {
       float linear_value = source[i];
@@ -318,8 +320,8 @@ void RealtimeAnalyser::ConvertFloatToDb(DOMFloat32Array* destination_array) {
   size_t source_length = MagnitudeBuffer().size();
   size_t len = std::min(source_length, destination_array->length());
   if (len > 0) {
-    const float* source = MagnitudeBuffer().Data();
-    float* destination = destination_array->Data();
+    const float* source = MagnitudeBuffer().Data().data();
+    base::span<float> destination = destination_array->Data();
 
     for (unsigned i = 0; i < len; ++i) {
       float linear_value = source[i];
diff --git a/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc b/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
index 1f22a92b8303c..8c86871f36e39 100644
--- a/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
@@ -188,7 +188,7 @@ void ScriptProcessorHandler::Process(uint32_t frames_to_process) {
     }
 
     for (uint32_t i = 0; i < number_of_output_channels; ++i) {
-      float* destination = output_bus->Channel(i)->MutableData();
+      float* destination = output_bus->Channel(i)->MutableData().data();
       const float* source = UNSAFE_TODO(
           static_cast<float*>(shared_output_buffer->channels()[i].Data()) +
           buffer_read_write_index_);
diff --git a/third_party/blink/renderer/modules/webaudio/script_processor_node.cc b/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
index 26a011c7d4af8..695e7e735bbd4 100644
--- a/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
@@ -290,10 +290,16 @@ void ScriptProcessorNode::DispatchEvent(double playback_time,
 
       for (unsigned channel = 0;
           channel < backing_input_buffer->numberOfChannels(); ++channel) {
-        const float* source = static_cast<float*>(
-            backing_input_buffer->getChannelData(channel)->buffer()->Data());
-        float* destination = static_cast<float*>(
-            external_input_buffer_->getChannelData(channel)->buffer()->Data());
+        const float* source =
+            static_cast<float*>(backing_input_buffer->getChannelData(channel)
+                                    ->buffer()
+                                    ->Data()
+                                    .data());
+        float* destination =
+            static_cast<float*>(external_input_buffer_->getChannelData(channel)
+                                    ->buffer()
+                                    ->Data()
+                                    .data());
         memcpy(destination, source,
                backing_input_buffer->length() * sizeof(float));
       }
@@ -330,10 +336,16 @@ void ScriptProcessorNode::DispatchEvent(double playback_time,
 
       for (unsigned channel = 0;
           channel < backing_output_buffer->numberOfChannels(); ++channel) {
-        const float* source = static_cast<float*>(
-            external_output_buffer_->getChannelData(channel)->buffer()->Data());
-        float* destination = static_cast<float*>(
-            backing_output_buffer->getChannelData(channel)->buffer()->Data());
+        const float* source =
+            static_cast<float*>(external_output_buffer_->getChannelData(channel)
+                                    ->buffer()
+                                    ->Data()
+                                    .data());
+        float* destination =
+            static_cast<float*>(backing_output_buffer->getChannelData(channel)
+                                    ->buffer()
+                                    ->Data()
+                                    .data());
         memcpy(destination, source,
                backing_output_buffer->length() * sizeof(float));
       }
diff --git a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
index 960530019ecca..0158826945590 100644
--- a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/stereo_panner_handler.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_stereo_panner_options.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_graph_tracer.h"
@@ -74,10 +75,10 @@ void StereoPannerHandler::Process(uint32_t frames_to_process) {
   if (is_sample_accurate && pan_->IsAudioRate()) {
     // Apply sample-accurate panning specified by AudioParam automation.
     DCHECK_LE(frames_to_process, sample_accurate_pan_values_.size());
-    float* pan_values = sample_accurate_pan_values_.Data();
+    base::span<float> pan_values = sample_accurate_pan_values_.Data();
     pan_->CalculateSampleAccurateValues(pan_values, frames_to_process);
-    stereo_panner_->PanWithSampleAccurateValues(input_bus.get(), output_bus,
-                                                pan_values, frames_to_process);
+    stereo_panner_->PanWithSampleAccurateValues(
+        input_bus.get(), output_bus, pan_values.data(), frames_to_process);
     return;
   }
 
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
index 61d3abb4d298e..66ce0eb4558ba 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -46,7 +48,7 @@ constexpr unsigned kDefaultNumberOfOutputChannels = 1;
 
 // Computes value of the WaveShaper
 double WaveShaperCurveValue(float input,
-                            const float* curve_data,
+                            base::span<const float> curve_data,
                             int curve_length) {
   // Calculate a virtual index based on input -1 -> +1 with -1 being
   // curve[0], +1 being curve[curveLength - 1], and 0 being at the center of
@@ -129,20 +131,20 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
     }
   }
 
-  void SetCurve(const float* curve_data, unsigned curve_length) {
+  void SetCurve(base::span<const float> curve_data, unsigned curve_length) {
     DCHECK(IsMainThread());
 
     // This synchronizes with process().
     base::AutoLock process_locker(process_lock_);
 
-    if (curve_length == 0 || !curve_data) {
+    if (curve_length == 0 || curve_data.empty()) {
       curve_ = nullptr;
       return;
     }
 
     // Copy the curve data, if any, to our internal buffer.
     curve_ = std::make_unique<Vector<float>>(curve_length);
-    memcpy(curve_->data(), curve_data, sizeof(float) * curve_length);
+    memcpy(curve_->data(), curve_data.data(), sizeof(float) * curve_length);
 
     DCHECK_GE(kernels_.size(), 1ULL);
 
@@ -199,17 +201,17 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
 
     // AudioDSPKernel
     void Process(const float* source,
-                 float* destination,
+                 base::span<float> destination,
                  uint32_t frames_to_process) override {
       switch (GetWaveShaperProcessor()->Oversample()) {
         case V8OverSampleType::Enum::kNone:
-          ProcessCurve(source, destination, frames_to_process);
+          ProcessCurve(source, destination.data(), frames_to_process);
           break;
         case V8OverSampleType::Enum::k2X:
-          ProcessCurve2x(source, destination, frames_to_process);
+          ProcessCurve2x(source, destination.data(), frames_to_process);
           break;
         case V8OverSampleType::Enum::k4X:
-          ProcessCurve4x(source, destination, frames_to_process);
+          ProcessCurve4x(source, destination.data(), frames_to_process);
           break;
 
         default:
@@ -288,7 +290,7 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
                                int curve_length) const {
       DCHECK_LE(frames_to_process, virtual_index_.size());
       // Index into the array computed from the source value.
-      float* virtual_index = virtual_index_.Data();
+      float* virtual_index = virtual_index_.Data().data();
 
       // virtual_index[k] =
       //   ClampTo(0.5 * (source[k] + 1) * (curve_length - 1),
@@ -308,19 +310,19 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
 
       // index = floor(virtual_index)
       DCHECK_LE(frames_to_process, index_.size());
-      float* index = index_.Data();
+      float* index = index_.Data().data();
 
       // v1 and v2 hold the curve_data corresponding to the closest curve
       // values to the source sample.  To save memory, v1 will use the
       // destination array.
       DCHECK_LE(frames_to_process, v1_.size());
       DCHECK_LE(frames_to_process, v2_.size());
-      float* v1 = v1_.Data();
-      float* v2 = v2_.Data();
+      float* v1 = v1_.Data().data();
+      float* v2 = v2_.Data().data();
 
       // Interpolation factor: virtual_index - index.
       DCHECK_LE(frames_to_process, f_.size());
-      float* f = f_.Data();
+      float* f = f_.Data().data();
 
       int max_index = curve_length - 1;
       unsigned k = 0;
@@ -479,7 +481,7 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
                         uint32_t frames_to_process) {
       DCHECK_EQ(frames_to_process, RenderQuantumFrames());
 
-      float* temp_p = temp_buffer_->Data();
+      float* temp_p = temp_buffer_->Data().data();
 
       up_sampler_->Process(source, temp_p, frames_to_process);
 
@@ -494,8 +496,8 @@ class WaveShaperProcessor final : public AudioDSPKernelProcessor {
                         uint32_t frames_to_process) {
       DCHECK_EQ(frames_to_process, RenderQuantumFrames());
 
-      float* temp_p = temp_buffer_->Data();
-      float* temp_p2 = temp_buffer2_->Data();
+      float* temp_p = temp_buffer_->Data().data();
+      float* temp_p2 = temp_buffer2_->Data().data();
 
       up_sampler_->Process(source, temp_p, frames_to_process);
       up_sampler2_->Process(temp_p, temp_p2, frames_to_process * 2);
@@ -548,7 +550,7 @@ scoped_refptr<WaveShaperHandler> WaveShaperHandler::Create(AudioNode& node,
   return base::AdoptRef(new WaveShaperHandler(node, sample_rate));
 }
 
-void WaveShaperHandler::SetCurve(const float* curve_data,
+void WaveShaperHandler::SetCurve(base::span<const float> curve_data,
                                  unsigned curve_length) {
   DCHECK(IsMainThread());
   GetWaveShaperProcessor()->SetCurve(curve_data, curve_length);
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
index 8a17e6a0d1361..92455e21a37fe 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_over_sample_type.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_basic_processor_handler.h"
@@ -20,7 +21,7 @@ class WaveShaperHandler final : public AudioHandler {
  public:
   static scoped_refptr<WaveShaperHandler> Create(AudioNode&, float sample_rate);
 
-  void SetCurve(const float* curve_data, unsigned curve_length);
+  void SetCurve(base::span<const float> curve_data, unsigned curve_length);
   const Vector<float>* Curve() const;
   void SetOversample(V8OverSampleType::Enum oversample);
   V8OverSampleType::Enum Oversample() const;
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
index fdb40cf87249c..c72ef48f9c995 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -72,14 +74,14 @@ WaveShaperHandler& WaveShaperNode::GetWaveShaperHandler() const {
   return static_cast<WaveShaperHandler&>(Handler());
 }
 
-void WaveShaperNode::SetCurveImpl(const float* curve_data,
+void WaveShaperNode::SetCurveImpl(base::span<const float> curve_data,
                                   size_t curve_length,
                                   ExceptionState& exception_state) {
   DCHECK(IsMainThread());
 
   unsigned length = static_cast<unsigned>(curve_length);
 
-  if (curve_data) {
+  if (!curve_data.empty()) {
     if (!base::CheckedNumeric<unsigned>(curve_length).AssignIfValid(&length)) {
       exception_state.ThrowDOMException(
           DOMExceptionCode::kNotSupportedError,
@@ -110,7 +112,7 @@ void WaveShaperNode::setCurve(NotShared<DOMFloat32Array> curve,
   if (curve) {
     SetCurveImpl(curve->Data(), curve->length(), exception_state);
   } else {
-    SetCurveImpl(nullptr, 0, exception_state);
+    SetCurveImpl({}, 0, exception_state);
   }
 }
 
@@ -118,7 +120,7 @@ void WaveShaperNode::setCurve(const Vector<float>& curve,
                               ExceptionState& exception_state) {
   DCHECK(IsMainThread());
 
-  SetCurveImpl(curve.data(), curve.size(), exception_state);
+  SetCurveImpl(curve, curve.size(), exception_state);
 }
 
 NotShared<DOMFloat32Array> WaveShaperNode::curve() const {
@@ -130,7 +132,7 @@ NotShared<DOMFloat32Array> WaveShaperNode::curve() const {
   unsigned size = curve->size();
 
   NotShared<DOMFloat32Array> result(DOMFloat32Array::Create(size));
-  memcpy(result->Data(), curve->data(), sizeof(float) * size);
+  memcpy(result->Data().data(), curve->data(), sizeof(float) * size);
 
   return result;
 }
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
index 0759311d38ae7..c745948d620e2 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_NODE_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_NODE_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer_view_helpers.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node.h"
@@ -64,7 +65,7 @@ class WaveShaperNode final : public AudioNode {
   void ReportWillBeDestroyed() final;
 
  private:
-  void SetCurveImpl(const float* curve_data,
+  void SetCurveImpl(base::span<const float> curve_data,
                     size_t curve_length,
                     ExceptionState&);
   WaveShaperHandler& GetWaveShaperHandler() const;
diff --git a/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h b/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
index 67bd34d8cd70a..b1d8a11d2c222 100644
--- a/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
+++ b/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
@@ -69,7 +69,8 @@ class ArrayBufferContentsExternalMemory
                                              base::span<const uint8_t> span)
       : contents_(std::move(contents)), span_(span) {
     // Check that `span` refers to the memory inside `contents`.
-    auto* contents_data = static_cast<const uint8_t*>(contents_.Data());
+    base::span<const uint8_t> contents_data =
+        static_cast<const uint8_t*>(contents_.Data());
     CHECK_GE(base::to_address(span.begin()), contents_data);
     CHECK_LE(base::to_address(span.end()),
              UNSAFE_TODO(contents_data + contents_.DataLength()));
diff --git a/third_party/blink/renderer/modules/webcodecs/audio_data.cc b/third_party/blink/renderer/modules/webcodecs/audio_data.cc
index 7462b37a3094e..85dcb21a2e70e 100644
--- a/third_party/blink/renderer/modules/webcodecs/audio_data.cc
+++ b/third_party/blink/renderer/modules/webcodecs/audio_data.cc
@@ -5,6 +5,7 @@
 #include "third_party/blink/renderer/modules/webcodecs/audio_data.h"
 
 #include "base/compiler_specific.h"
+#include "base/containers/span.h"
 #include "base/notreached.h"
 #include "base/numerics/checked_math.h"
 #include "base/numerics/safe_conversions.h"
@@ -191,7 +192,7 @@ class ArrayBufferContentsAsAudioExternalMemory
       : media::AudioBuffer::ExternalMemory(span),
         contents_(std::move(contents)) {
     // Check that `span` refers to the memory inside `contents`.
-    auto* contents_data = static_cast<uint8_t*>(contents_.Data());
+    base::span<uint8_t> contents_data = static_cast<uint8_t*>(contents_.Data());
     CHECK_GE(base::to_address(span.begin()), contents_data);
     CHECK_LE(base::to_address(span.end()),
              UNSAFE_TODO(contents_data + contents_.DataLength()));
@@ -636,7 +637,7 @@ void AudioData::CopyConvert(base::span<uint8_t> dest,
   const int channel = copy_to_options->planeIndex();
 
   CHECK_LT(channel, data_as_f32_bus_->channels());
-  float* src_data = data_as_f32_bus_->channel(channel);
+  base::span<float> src_data = data_as_f32_bus_->channel(channel);
   float* offset_src_data = UNSAFE_TODO(src_data + offset);
   CHECK_LE(UNSAFE_TODO(offset_src_data + frame_count),
            UNSAFE_TODO(src_data + data_as_f32_bus_->frames()));
diff --git a/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc b/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
index 97420b7888f41..a4b1e4553acbd 100644
--- a/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
+++ b/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
@@ -48,7 +48,7 @@ constexpr float kEpsilon = kIncrement / 100;
 
 class AudioDataTest : public testing::Test {
  protected:
-  void VerifyPlanarData(float* data, float start_value, int count) {
+  void VerifyPlanarData(base::span<float> data, float start_value, int count) {
     for (int i = 0; i < count; ++i)
       ASSERT_NEAR(data[i], start_value + i * kIncrement, kEpsilon) << "i=" << i;
   }
@@ -60,8 +60,8 @@ class AudioDataTest : public testing::Test {
   AllowSharedBufferSource* CreateCustomData(int channels, int frames) {
     auto* buffer = DOMArrayBuffer::Create(channels * frames, sizeof(float));
     for (int ch = 0; ch < channels; ++ch) {
-      float* plane_start =
-          reinterpret_cast<float*>(buffer->Data()) + ch * frames;
+      base::span<float> plane_start =
+          reinterpret_cast<float*>(buffer->Data()).subspan(ch * frames);
       for (int i = 0; i < frames; ++i) {
         plane_start[i] = static_cast<float>((i + ch * frames) * kIncrement);
       }
@@ -491,7 +491,7 @@ TEST_F(AudioDataTest, Interleaved) {
   EXPECT_FALSE(scope.GetExceptionState().HadException());
 
   // Verify we retrieved the right samples.
-  int16_t* copy = static_cast<int16_t*>(data_copy->Data());
+  base::span<int16_t> copy = static_cast<int16_t*>(data_copy->Data());
   for (int i = 0; i < kPartialFrameCount; ++i) {
     int block_index = i * kInterleavedChannels;
     int16_t base_value = kOffset + i;
@@ -603,7 +603,8 @@ class AudioDataConversionTest : public testing::Test {
     auto* buffer =
         DOMArrayBuffer::Create(kChannels * kFrames, sizeof(ValueType));
 
-    ValueType* plane_start = reinterpret_cast<ValueType*>(buffer->Data());
+    base::span<ValueType> plane_start =
+        reinterpret_cast<ValueType*>(buffer->Data());
     for (int i = 0; i < kFrames; ++i) {
       plane_start[i] = SourceTraits::kMinValue;
     }
@@ -615,7 +616,7 @@ class AudioDataConversionTest : public testing::Test {
       plane_start[kFrames - 1] = SourceTraits::kZeroPointValue;
     }
 
-    plane_start += kFrames;
+    plane_start = plane_start.subspan(kFrames);
 
     for (int i = 0; i < kFrames; ++i) {
       plane_start[i] = SourceTraits::kMaxValue;
@@ -644,7 +645,8 @@ class AudioDataConversionTest : public testing::Test {
     constexpr int kTotalSamples = kChannels * kFrames;
     auto* buffer = DOMArrayBuffer::Create(kTotalSamples, sizeof(ValueType));
 
-    ValueType* plane_start = reinterpret_cast<ValueType*>(buffer->Data());
+    base::span<ValueType> plane_start =
+        reinterpret_cast<ValueType*>(buffer->Data());
     for (int i = 0; i < kTotalSamples; i += 2) {
       plane_start[i] = SourceTraits::kMinValue;
       plane_start[i + 1] = SourceTraits::kMaxValue;
@@ -709,7 +711,8 @@ class AudioDataConversionTest : public testing::Test {
     EXPECT_FALSE(scope.GetExceptionState().HadException())
         << scope.GetExceptionState().Message();
 
-    TargetType* copied_data = static_cast<TargetType*>(data_copy->Data());
+    base::span<TargetType> copied_data =
+        static_cast<TargetType*>(data_copy->Data());
 
     // `kChannelToCopy` should only contain kMaxValue
     for (int i = 0; i < frames_to_copy; ++i) {
@@ -752,7 +755,8 @@ class AudioDataConversionTest : public testing::Test {
     EXPECT_FALSE(scope.GetExceptionState().HadException())
         << scope.GetExceptionState().Message();
 
-    TargetType* copied_data = static_cast<TargetType*>(data_copy->Data());
+    base::span<TargetType> copied_data =
+        static_cast<TargetType*>(data_copy->Data());
 
     // The interleaved data should have kMinValue in
     // channel 0 and kMaxValue in channel 1.
diff --git a/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc b/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
index 40e6e215e2c5a..791c1bcc2cebb 100644
--- a/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
+++ b/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
@@ -80,7 +80,7 @@ class ArrayBufferContentsSegmentReader : public SegmentReader {
   explicit ArrayBufferContentsSegmentReader(ArrayBufferContents contents)
       : contents_(std::move(contents)),
         segment_reader_(SegmentReader::CreateFromSkData(
-            SkData::MakeWithoutCopy(contents_.Data(),
+            SkData::MakeWithoutCopy(contents_.Data().data(),
                                     contents_.DataLength()))) {}
 
   size_t size() const override { return segment_reader_->size(); }
diff --git a/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc b/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
index 7f1daaaf00766..1a3767116b601 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -134,10 +136,10 @@ TEST_F(VideoFrameTest, CopyToRGB) {
   uint32_t buffer_size =
       blink_frame->allocationSize(options, scope.GetExceptionState());
   auto* buffer = DOMArrayBuffer::Create(buffer_size, 1);
-  uint8_t* data = static_cast<uint8_t*>(buffer->Data());
+  base::span<uint8_t> data = static_cast<uint8_t*>(buffer->Data());
 
   // Set buffer to white pixels.
-  memset(data, 0xff, buffer_size);
+  memset(data.data(), 0xff, buffer_size);
   AllowSharedBufferSource* destination =
       MakeGarbageCollected<AllowSharedBufferSource>(buffer);
 
diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 22f2b7fda1666..f04a6122cae25 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -4991,8 +4991,8 @@ void WebGLRenderingContextBase::ReadPixelsHelper(GLint x,
   }
   ClearIfComposited(kClearCallerOther);
 
-  uint8_t* data = static_cast<uint8_t*>(pixels->BaseAddressMaybeShared()) +
-                  offset_in_bytes.ValueOrDie();
+  uint8_t* data = static_cast<uint8_t*>(pixels->BaseAddressMaybeShared().data())
+                      .subspan(offset_in_bytes.ValueOrDie());
 
   // We add special handling here if the 'ArrayBufferView' is size '0' and the
   // backing store is 'nullptr'. 'ReadPixels' creates an error if the provided
diff --git a/third_party/blink/renderer/modules/webgl/webgl_shader_pixel_local_storage.cc b/third_party/blink/renderer/modules/webgl/webgl_shader_pixel_local_storage.cc
index be588f0dbd000..c9cd7221d9b13 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_shader_pixel_local_storage.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_shader_pixel_local_storage.cc
@@ -277,20 +277,20 @@ WebGLShaderPixelLocalStorage::getFramebufferPixelLocalStorageParameterWEBGL(
     }
     case GL_PIXEL_LOCAL_CLEAR_VALUE_FLOAT_ANGLE: {
       DOMFloat32Array* values = DOMFloat32Array::Create(4);
-      gl->GetFramebufferPixelLocalStorageParameterfvANGLE(plane, pname,
-                                                          values->Data());
+      gl->GetFramebufferPixelLocalStorageParameterfvANGLE(
+          plane, pname, values->Data().data());
       return WebGLAny(script_state, values);
     }
     case GL_PIXEL_LOCAL_CLEAR_VALUE_INT_ANGLE: {
       DOMInt32Array* values = DOMInt32Array::Create(4);
-      gl->GetFramebufferPixelLocalStorageParameterivANGLE(plane, pname,
-                                                          values->Data());
+      gl->GetFramebufferPixelLocalStorageParameterivANGLE(
+          plane, pname, values->Data().data());
       return WebGLAny(script_state, values);
     }
     case GL_PIXEL_LOCAL_CLEAR_VALUE_UNSIGNED_INT_ANGLE: {
       DOMUint32Array* values = DOMUint32Array::Create(4);
       gl->GetFramebufferPixelLocalStorageParameterivANGLE(
-          plane, pname, reinterpret_cast<GLint*>(values->Data()));
+          plane, pname, reinterpret_cast<GLint*>(values->Data().data()));
       return WebGLAny(script_state, values);
     }
   }
diff --git a/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc b/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
index d7f5c10b6f82d..43becfa4f636b 100644
--- a/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
+++ b/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
@@ -461,8 +461,8 @@ WebSocketChannel::SendResult WebSocketChannelImpl::Send(
     size_t byte_offset,
     size_t byte_length,
     base::OnceClosure completion_callback) {
-  DVLOG(1) << this << " Send(" << buffer.Data() << ", " << byte_offset << ", "
-           << byte_length << ") "
+  DVLOG(1) << this << " Send(" << buffer.Data().data() << ", " << byte_offset
+           << ", " << byte_length << ") "
            << "(DOMArrayBuffer argument)";
   probe::DidSendWebSocketMessage(
       execution_context_, identifier_, WebSocketOpCode::kOpCodeBinary, true,
diff --git a/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc b/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
index 18b34e36929d5..3542416421dad 100644
--- a/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
+++ b/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
@@ -255,7 +255,7 @@ void TestWrite(const V8TestingScope& scope,
   auto* writer = bidirectional_stream->writable()->getWriter(
       script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+  chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
diff --git a/third_party/blink/renderer/modules/webtransport/web_transport_test.cc b/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
index 6be7e6902e9ff..eb77a0ed052f0 100644
--- a/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
+++ b/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
@@ -790,7 +790,7 @@ TEST_F(WebTransportTest, SendDatagram) {
   auto* script_state = scope.GetScriptState();
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+  chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
@@ -826,28 +826,28 @@ TEST_F(WebTransportTest, BackpressureForOutgoingDatagrams) {
 
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'A';
+    chunk->Data()[0] = 'A';
     promise1 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'B';
+    chunk->Data()[0] = 'B';
     promise2 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'C';
+    chunk->Data()[0] = 'C';
     promise3 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'D';
+    chunk->Data()[0] = 'D';
     promise4 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
@@ -875,7 +875,7 @@ TEST_F(WebTransportTest, SendDatagramBeforeConnect) {
   auto* script_state = scope.GetScriptState();
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+  chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
@@ -895,7 +895,7 @@ TEST_F(WebTransportTest, SendDatagramBeforeConnect) {
       }));
 
   test::RunPendingTasks();
-  *chunk->Data() = 'N';
+  chunk->Data()[0] = 'N';
   result = writer->write(script_state, ScriptValue::From(script_state, chunk),
                          ASSERT_NO_EXCEPTION);
 
@@ -919,7 +919,7 @@ TEST_F(WebTransportTest, SendDatagramAfterClose) {
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
 
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+  chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
diff --git a/third_party/blink/renderer/modules/xr/xr_ray.cc b/third_party/blink/renderer/modules/xr/xr_ray.cc
index c3c6220fcc8ef..1a40ebd7b2e8f 100644
--- a/third_party/blink/renderer/modules/xr/xr_ray.cc
+++ b/third_party/blink/renderer/modules/xr/xr_ray.cc
@@ -129,7 +129,7 @@ NotShared<DOMFloat32Array> XRRay::matrix() {
   // steps:
   //    Step 1. If the operation IsDetachedBuffer on internal matrix is false,
   //    return transforms internal matrix.
-  if (!matrix_ || !matrix_->Data()) {
+  if (!matrix_ ||) {.empty()) {
     // Returned matrix should represent transformation from ray originating at
     // (0,0,0) with direction (0,0,-1) into ray originating at |origin_| with
     // direction |direction_|.
@@ -183,6 +183,7 @@ NotShared<DOMFloat32Array> XRRay::matrix() {
     } else {
       *raw_matrix_ = matrix;
     }
+    }
   }
 
   // Step 9: Return matrix
diff --git a/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc b/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
index 816c463982851..fc88a886bc772 100644
--- a/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
+++ b/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
@@ -114,11 +114,12 @@ NotShared<DOMFloat32Array> XRRigidTransform::matrix() {
     matrix_array_ = transformationMatrixToDOMFloat32Array(*matrix_);
   }
 
-  if (!matrix_array_ || !matrix_array_->Data()) {
+  if (!matrix_array_ ||) {.empty()) {
     // A page may take the matrix_array_ value and detach it so matrix_array_ is
     // a detached array buffer.  This breaks the inspector, so return null
     // instead.
     return NotShared<DOMFloat32Array>();
+    }
   }
 
   return matrix_array_;
diff --git a/third_party/blink/renderer/modules/xr/xr_utils.cc b/third_party/blink/renderer/modules/xr/xr_utils.cc
index bb1b7afd15418..dc6e5896fc6b2 100644
--- a/third_party/blink/renderer/modules/xr/xr_utils.cc
+++ b/third_party/blink/renderer/modules/xr/xr_utils.cc
@@ -24,7 +24,7 @@ NotShared<DOMFloat32Array> transformationMatrixToDOMFloat32Array(
 
 gfx::Transform DOMFloat32ArrayToTransform(NotShared<DOMFloat32Array> m) {
   DCHECK_EQ(m->length(), 16u);
-  return gfx::Transform::ColMajorF(m->Data());
+  return gfx::Transform::ColMajorF(m->Data().data());
 }
 
 gfx::Transform WTFFloatVectorToTransform(const Vector<float>& m) {
diff --git a/third_party/blink/renderer/modules/xr/xr_view.cc b/third_party/blink/renderer/modules/xr/xr_view.cc
index 3e034b9652413..e3ea83cb6c4dc 100644
--- a/third_party/blink/renderer/modules/xr/xr_view.cc
+++ b/third_party/blink/renderer/modules/xr/xr_view.cc
@@ -78,11 +78,12 @@ XRSession* XRView::session() const {
 }
 
 NotShared<DOMFloat32Array> XRView::projectionMatrix() const {
-  if (!projection_matrix_ || !projection_matrix_->Data()) {
+  if (!projection_matrix_ ||) {.empty()) {
     // A page may take the projection matrix value and detach it so
     // projection_matrix_ is a detached array buffer.  This breaks the
     // inspector, so return null instead.
     return NotShared<DOMFloat32Array>();
+    }
   }
 
   return projection_matrix_;
diff --git a/third_party/blink/renderer/platform/audio/audio_array.h b/third_party/blink/renderer/platform/audio/audio_array.h
index 88c69ddde0ed0..6c392184fb81c 100644
--- a/third_party/blink/renderer/platform/audio/audio_array.h
+++ b/third_party/blink/renderer/platform/audio/audio_array.h
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -96,7 +98,7 @@ class AudioArray final {
     size_ = static_cast<uint32_t>(n);
   }
 
-  T* Data() { return aligned_data_; }
+  base::span<T> Data() { return aligned_data_; }
   const T* Data() const { return aligned_data_; }
   uint32_t size() const { return size_; }
 
diff --git a/third_party/blink/renderer/platform/audio/audio_bus.cc b/third_party/blink/renderer/platform/audio/audio_bus.cc
index 87edd3a095dc7..34c597c5dd64a 100644
--- a/third_party/blink/renderer/platform/audio/audio_bus.cc
+++ b/third_party/blink/renderer/platform/audio/audio_bus.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -82,7 +84,7 @@ AudioBus::AudioBus(unsigned number_of_channels, uint32_t length, bool allocate)
 }
 
 void AudioBus::SetChannelMemory(unsigned channel_index,
-                                float* storage,
+                                base::span<float> storage,
                                 uint32_t length) {
   if (channel_index < channels_.size()) {
     Channel(channel_index)->Set(storage, length);
@@ -388,7 +390,7 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
     const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    float* destination = ChannelByType(kChannelLeft)->MutableData().data();
     float scale = 0.5;
 
     Vsma(source_l, 1, &scale, destination, 1, length());
@@ -404,7 +406,7 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    float* destination = ChannelByType(kChannelLeft)->MutableData().data();
     float scale = 0.25;
 
     Vsma(source_l, 1, &scale, destination, 1, length());
@@ -424,7 +426,7 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    float* destination = ChannelByType(kChannelLeft)->MutableData().data();
     float scale_sqrt_half = sqrtf(0.5);
     float scale_half = 0.5;
 
@@ -445,8 +447,8 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    float* destination_l = ChannelByType(kChannelLeft)->MutableData().data();
+    float* destination_r = ChannelByType(kChannelRight)->MutableData().data();
     float scale_half = 0.5;
 
     Vsma(source_l, 1, &scale_half, destination_l, 1, length());
@@ -466,8 +468,8 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    float* destination_l = ChannelByType(kChannelLeft)->MutableData().data();
+    float* destination_r = ChannelByType(kChannelRight)->MutableData().data();
     float scale_sqrt_half = sqrtf(0.5);
 
     Vadd(source_l, 1, destination_l, 1, destination_l, 1, length());
@@ -487,8 +489,8 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
     const float* source_c = source_bus.ChannelByType(kChannelCenter)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    float* destination_l = ChannelByType(kChannelLeft)->MutableData().data();
+    float* destination_r = ChannelByType(kChannelRight)->MutableData().data();
     float scale_sqrt_half = sqrtf(0.5);
 
     Vadd(source_l, 1, destination_l, 1, destination_l, 1, length());
@@ -584,7 +586,7 @@ void AudioBus::CopyWithSampleAccurateGainValuesFrom(
     if (source_bus.NumberOfChannels() == NumberOfChannels()) {
       source = source_bus.Channel(channel_index)->Data();
     }
-    float* destination = Channel(channel_index)->MutableData();
+    float* destination = Channel(channel_index)->MutableData().data();
     vector_math::Vmul(source, 1, gain_values, 1, destination, 1,
                       number_of_gain_values);
   }
@@ -651,7 +653,7 @@ scoped_refptr<AudioBus> AudioBus::CreateBySampleRateConverting(
   // Sample-rate convert each channel.
   for (unsigned i = 0; i < number_of_destination_channels; ++i) {
     const float* source = resampler_source_bus->Channel(i)->Data();
-    float* destination = destination_bus->Channel(i)->MutableData();
+    float* destination = destination_bus->Channel(i)->MutableData().data();
 
     SincResampler resampler(sample_rate_ratio);
     resampler.Process(source, destination, source_length);
@@ -679,7 +681,7 @@ scoped_refptr<AudioBus> AudioBus::CreateByMixingToMono(
 
       const float* source_l = source_bus->Channel(0)->Data();
       const float* source_r = source_bus->Channel(1)->Data();
-      float* destination = destination_bus->Channel(0)->MutableData();
+      float* destination = destination_bus->Channel(0)->MutableData().data();
 
       // Do the mono mixdown.
       for (unsigned i = 0; i < n; ++i) {
diff --git a/third_party/blink/renderer/platform/audio/audio_bus.h b/third_party/blink/renderer/platform/audio/audio_bus.h
index bfc6432d93f5f..72630cb91018a 100644
--- a/third_party/blink/renderer/platform/audio/audio_bus.h
+++ b/third_party/blink/renderer/platform/audio/audio_bus.h
@@ -29,6 +29,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_BUS_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_BUS_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_channel.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/thread_safe_ref_counted.h"
@@ -85,7 +86,7 @@ class PLATFORM_EXPORT AudioBus final : public ThreadSafeRefCounted<AudioBus> {
 
   // Tells the given channel to use an externally allocated buffer.
   void SetChannelMemory(unsigned channel_index,
-                        float* storage,
+                        base::span<float> storage,
                         uint32_t length);
 
   // Channels
diff --git a/third_party/blink/renderer/platform/audio/audio_channel.cc b/third_party/blink/renderer/platform/audio/audio_channel.cc
index 472686d58d399..2151074973318 100644
--- a/third_party/blink/renderer/platform/audio/audio_channel.cc
+++ b/third_party/blink/renderer/platform/audio/audio_channel.cc
@@ -50,7 +50,7 @@ void AudioChannel::Scale(float scale) {
     return;
   }
 
-  vector_math::Vsmul(Data(), 1, &scale, MutableData(), 1, length());
+  vector_math::Vsmul(Data(), 1, &scale, MutableData().data(), 1, length());
 }
 
 void AudioChannel::CopyFrom(const AudioChannel* source_channel) {
@@ -61,7 +61,7 @@ void AudioChannel::CopyFrom(const AudioChannel* source_channel) {
     Zero();
     return;
   }
-  memcpy(MutableData(), source_channel->Data(),
+  memcpy(MutableData().data(), source_channel->Data(),
          base::CheckMul(sizeof(float), length()).ValueOrDie());
 }
 
@@ -82,7 +82,7 @@ void AudioChannel::CopyFromRange(const AudioChannel* source_channel,
   DCHECK_LE(range_length, length());
 
   const float* source = source_channel->Data();
-  float* destination = MutableData();
+  float* destination = MutableData().data();
 
   const size_t safe_length =
       base::CheckMul(sizeof(float), range_length).ValueOrDie();
@@ -108,8 +108,8 @@ void AudioChannel::SumFrom(const AudioChannel* source_channel) {
   if (IsSilent()) {
     CopyFrom(source_channel);
   } else {
-    vector_math::Vadd(Data(), 1, source_channel->Data(), 1, MutableData(), 1,
-                      length());
+    vector_math::Vadd(Data(), 1, source_channel->Data(), 1,
+                      MutableData().data(), 1, length());
   }
 }
 
diff --git a/third_party/blink/renderer/platform/audio/audio_channel.h b/third_party/blink/renderer/platform/audio/audio_channel.h
index 909d525de5105..62588e64c1f45 100644
--- a/third_party/blink/renderer/platform/audio/audio_channel.h
+++ b/third_party/blink/renderer/platform/audio/audio_channel.h
@@ -26,6 +26,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -51,21 +54,21 @@ class PLATFORM_EXPORT AudioChannel final {
   // AudioFloatArray.
 
   // Reference an external buffer.
-  AudioChannel(float* storage, uint32_t length)
+  AudioChannel(base::span<float> storage, uint32_t length)
       : length_(length), raw_pointer_(storage), silent_(false) {}
 
   // Manage storage for us.
   explicit AudioChannel(uint32_t length)
-      : length_(length), raw_pointer_(nullptr), silent_(true) {
+      : length_(length), raw_pointer_({}), silent_(true) {
     mem_buffer_ = std::make_unique<AudioFloatArray>(length);
   }
 
   // A "blank" audio channel -- must call Set() before it's useful...
-  AudioChannel() : length_(0), raw_pointer_(nullptr), silent_(true) {}
+  AudioChannel() : length_(0), raw_pointer_({}), silent_(true) {}
 
   // Redefine the memory for this channel. |storage| represents external memory
   // not managed by this object.
-  void Set(float* storage, uint32_t length) {
+  void Set(base::span<float> storage, uint32_t length) {
     mem_buffer_.reset();  // cleanup managed storage
     raw_pointer_ = storage;
     length_ = length;
@@ -80,13 +83,14 @@ class PLATFORM_EXPORT AudioChannel final {
   void ResizeSmaller(uint32_t new_length);
 
   // Direct access to PCM sample data. Non-const accessor clears silent flag.
-  float* MutableData() {
+  base::span<float> MutableData() {
     ClearSilentFlag();
-    return raw_pointer_ ? raw_pointer_.get() : mem_buffer_->Data();
+    return !raw_pointer_.empty() ? raw_pointer_ : mem_buffer_->Data();
   }
 
   const float* Data() const {
-    return raw_pointer_ ? raw_pointer_.get() : mem_buffer_->Data();
+    return !raw_pointer_.empty() ? raw_pointer_.data()
+                                 : mem_buffer_->Data().data();
   }
 
   // Zeroes out all sample values in buffer.
@@ -100,7 +104,7 @@ class PLATFORM_EXPORT AudioChannel final {
     if (mem_buffer_.get()) {
       mem_buffer_->Zero();
     } else {
-      memset(raw_pointer_, 0,
+      memset(raw_pointer_.data(), 0,
              base::CheckMul(sizeof(float), length_).ValueOrDie());
     }
   }
@@ -130,7 +134,7 @@ class PLATFORM_EXPORT AudioChannel final {
  private:
   uint32_t length_;
 
-  raw_ptr<float, DanglingUntriaged> raw_pointer_;
+  base::raw_span<float, DanglingUntriaged> raw_pointer_;
   std::unique_ptr<AudioFloatArray> mem_buffer_;
   bool silent_;
 };
diff --git a/third_party/blink/renderer/platform/audio/audio_destination.cc b/third_party/blink/renderer/platform/audio/audio_destination.cc
index 853a0be990cb0..d588528cde2c5 100644
--- a/third_party/blink/renderer/platform/audio/audio_destination.cc
+++ b/third_party/blink/renderer/platform/audio/audio_destination.cc
@@ -497,7 +497,7 @@ AudioDestination::AudioDestination(
       // TODO(crbug.com/375449662): Spanify `AudioChannel::MuteableData`.
       resampler_bus_->SetChannelData(
           i, UNSAFE_TODO(base::span(
-                 render_bus_->Channel(i)->MutableData(),
+                 render_bus_->Channel(i)->MutableData().data(),
                  base::checked_cast<size_t>(render_bus_->length()))));
     }
   } else {
diff --git a/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h b/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
index 4cea7bb96671e..f030163f82a5c 100644
--- a/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
+++ b/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
@@ -31,6 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_DSP_KERNEL_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_DSP_KERNEL_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_dsp_kernel_processor.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -60,7 +61,7 @@ class PLATFORM_EXPORT AudioDSPKernel {
   // Subclasses must override process() to do the processing and reset() to
   // reset DSP state.
   virtual void Process(const float* source,
-                       float* destination,
+                       base::span<float> destination,
                        uint32_t frames_to_process) = 0;
   // Subclasses that have AudioParams must override this to process the
   // AudioParams.
diff --git a/third_party/blink/renderer/platform/audio/biquad.cc b/third_party/blink/renderer/platform/audio/biquad.cc
index f14f24e8f2e55..dcd5a2ce61fa8 100644
--- a/third_party/blink/renderer/platform/audio/biquad.cc
+++ b/third_party/blink/renderer/platform/audio/biquad.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -82,7 +84,7 @@ Biquad::Biquad(unsigned render_quantum_frames)
 Biquad::~Biquad() = default;
 
 void Biquad::Process(const float* source_p,
-                     float* dest_p,
+                     base::span<float> dest_p,
                      uint32_t frames_to_process) {
   // WARNING: sourceP and destP may be pointing to the same area of memory!
   // Be sure to read from sourceP before writing to destP!
@@ -95,18 +97,18 @@ void Biquad::Process(const float* source_p,
     double y1 = y1_;
     double y2 = y2_;
 
-    const double* b0 = b0_.Data();
-    const double* b1 = b1_.Data();
-    const double* b2 = b2_.Data();
-    const double* a1 = a1_.Data();
-    const double* a2 = a2_.Data();
+    const double* b0 = b0_.Data().data();
+    const double* b1 = b1_.Data().data();
+    const double* b2 = b2_.Data().data();
+    const double* a1 = a1_.Data().data();
+    const double* a2 = a2_.Data().data();
 
     for (int k = 0; k < n; ++k) {
       // FIXME: this can be optimized by pipelining the multiply adds...
       float x = *source_p++;
       float y = b0[k] * x + b1[k] * x1 + b2[k] * x2 - a1[k] * y1 - a2[k] * y2;
 
-      *dest_p++ = y;
+      (dest_p++)[0] = y;
 
       // Update state variables
       x2 = x1;
@@ -177,7 +179,7 @@ void Biquad::Process(const float* source_p,
       float x = *source_p++;
       float y = b0 * x + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
 
-      *dest_p++ = y;
+      (dest_p++)[0] = y;
 
       // Update state variables
       x2 = x1;
@@ -561,8 +563,8 @@ void Biquad::SetBandpassParams(int index, double frequency, double q) {
 
 void Biquad::GetFrequencyResponse(int n_frequencies,
                                   const float* frequency,
-                                  float* mag_response,
-                                  float* phase_response) {
+                                  base::span<float> mag_response,
+                                  base::span<float> phase_response) {
   // Evaluate the Z-transform of the filter at given normalized
   // frequency from 0 to 1.  (1 corresponds to the Nyquist
   // frequency.)
diff --git a/third_party/blink/renderer/platform/audio/biquad.h b/third_party/blink/renderer/platform/audio/biquad.h
index e2aee02dab501..e8f12b47fb2e4 100644
--- a/third_party/blink/renderer/platform/audio/biquad.h
+++ b/third_party/blink/renderer/platform/audio/biquad.h
@@ -30,7 +30,10 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_BIQUAD_H_
 
 #include <sys/types.h>
+
 #include <complex>
+
+#include "base/containers/span.h"
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -51,7 +54,7 @@ class PLATFORM_EXPORT Biquad final {
   ~Biquad();
 
   void Process(const float* source_p,
-               float* dest_p,
+               base::span<float> dest_p,
                uint32_t frames_to_process);
 
   bool HasSampleAccurateValues() const { return has_sample_accurate_values_; }
@@ -85,8 +88,8 @@ class PLATFORM_EXPORT Biquad final {
   // The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
                             const float* frequency,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<float> mag_response,
+                            base::span<float> phase_response);
 
  private:
   void SetNormalizedCoefficients(int,
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
index d948e1d480b2b..d0162c80b17fe 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
@@ -52,7 +52,8 @@ void PrepareFilterForConv(const float* filter_p,
   // Reverse the filter and repeat each value across a vector
   prepared_filter->Allocate(kReversedFilterStride * kPackedFloatsPerRegister *
                             filter_size);
-  MType* reversed_filter = reinterpret_cast<MType*>(prepared_filter->Data());
+  MType* reversed_filter =
+      reinterpret_cast<MType*>(prepared_filter->Data().data());
   for (size_t i = 0; i < filter_size; ++i) {
     reversed_filter[kReversedFilterStride * i] = MM_PS(set1)(*(filter_p - i));
   }
diff --git a/third_party/blink/renderer/platform/audio/delay.cc b/third_party/blink/renderer/platform/audio/delay.cc
index 2e5662e923c45..e176c6577e28c 100644
--- a/third_party/blink/renderer/platform/audio/delay.cc
+++ b/third_party/blink/renderer/platform/audio/delay.cc
@@ -179,7 +179,7 @@ void Delay::ProcessARate(const float* source,
                          float* destination,
                          uint32_t frames_to_process) {
   int buffer_length = buffer_.size();
-  float* buffer = buffer_.Data();
+  float* buffer = buffer_.Data().data();
 
   DCHECK(buffer_length);
   DCHECK(source);
@@ -187,7 +187,7 @@ void Delay::ProcessARate(const float* source,
   DCHECK_GE(write_index_, 0);
   DCHECK_LT(write_index_, buffer_length);
 
-  float* delay_times = delay_times_.Data();
+  float* delay_times = delay_times_.Data().data();
 
   // Any NaN's get converted to max time
   // TODO(crbug.com/1013345): Don't need this if that bug is fixed
@@ -211,7 +211,7 @@ void Delay::ProcessKRate(const float* source,
                          float* destination,
                          uint32_t frames_to_process) {
   int buffer_length = buffer_.size();
-  float* buffer = buffer_.Data();
+  float* buffer = buffer_.Data().data();
 
   DCHECK(buffer_length);
   DCHECK(source);
@@ -278,7 +278,7 @@ void Delay::ProcessKRate(const float* source,
     DCHECK_LE(frames_to_process, temp_buffer_.size());
 
     int read_index2 = (read_index1 + 1) % buffer_length;
-    float* sample2 = temp_buffer_.Data();
+    float* sample2 = temp_buffer_.Data().data();
 
     read_pointer = &buffer[read_index2];
     remainder = static_cast<uint32_t>(buffer_end - read_pointer);
diff --git a/third_party/blink/renderer/platform/audio/delay.h b/third_party/blink/renderer/platform/audio/delay.h
index 692d1c6e972fd..fdf0ac4974d91 100644
--- a/third_party/blink/renderer/platform/audio/delay.h
+++ b/third_party/blink/renderer/platform/audio/delay.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DELAY_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DELAY_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 
@@ -66,7 +67,7 @@ class PLATFORM_EXPORT Delay final {
   }
 
   // Fill the return value of this before calling `ProcessARate()`
-  float* DelayTimes() { return delay_times_.Data(); }
+  base::span<float> DelayTimes() { return delay_times_.Data(); }
 
  protected:
   // Main processing loop for ProcessARate using scalar operations.  Returns the
diff --git a/third_party/blink/renderer/platform/audio/direct_convolver.cc b/third_party/blink/renderer/platform/audio/direct_convolver.cc
index 811ede286ba2a..bf0e84d813f03 100644
--- a/third_party/blink/renderer/platform/audio/direct_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/direct_convolver.cc
@@ -60,8 +60,9 @@ DirectConvolver::DirectConvolver(
       buffer_(input_block_size * 2),
       convolution_kernel_(std::move(convolution_kernel)) {
   size_t kernel_size = ConvolutionKernelSize();
-  PrepareFilterForConv(convolution_kernel_->Data() + kernel_size - 1, -1,
-                       kernel_size, &prepared_convolution_kernel_);
+  PrepareFilterForConv(
+      convolution_kernel_->Data().subspan(kernel_size - 1).data(), -1,
+      kernel_size, &prepared_convolution_kernel_);
 }
 
 void DirectConvolver::Process(const float* source_p,
@@ -72,14 +73,14 @@ void DirectConvolver::Process(const float* source_p,
   size_t kernel_size = ConvolutionKernelSize();
   DCHECK_LE(kernel_size, input_block_size_);
 
-  float* kernel_p = convolution_kernel_->Data();
+  float* kernel_p = convolution_kernel_->Data().data();
 
   DCHECK(kernel_p);
   DCHECK(source_p);
   DCHECK(dest_p);
-  DCHECK(buffer_.Data());
+  DCHECK(!buffer_.Data().empty());
 
-  float* input_p = buffer_.Data() + input_block_size_;
+  float* input_p = buffer_.Data().subspan(input_block_size_).data();
 
   // Copy samples to 2nd half of input buffer.
   memcpy(input_p, source_p, sizeof(float) * frames_to_process);
@@ -88,7 +89,7 @@ void DirectConvolver::Process(const float* source_p,
        frames_to_process, kernel_size, &prepared_convolution_kernel_);
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(buffer_.Data(), input_p, sizeof(float) * frames_to_process);
+  memcpy(buffer_.Data().data(), input_p, sizeof(float) * frames_to_process);
 }
 
 void DirectConvolver::Reset() {
diff --git a/third_party/blink/renderer/platform/audio/down_sampler.cc b/third_party/blink/renderer/platform/audio/down_sampler.cc
index 7db5739545d5d..3d25cbcbcd3ba 100644
--- a/third_party/blink/renderer/platform/audio/down_sampler.cc
+++ b/third_party/blink/renderer/platform/audio/down_sampler.cc
@@ -111,13 +111,14 @@ void DownSampler::Process(const float* source_p,
   DCHECK_EQ(input_buffer_.size(), source_frames_to_process * 2);
   DCHECK_LE(half_size, source_frames_to_process);
 
-  float* input_p = input_buffer_.Data() + source_frames_to_process;
+  float* input_p =
+      input_buffer_.Data().subspan(source_frames_to_process).data();
   memcpy(input_p, source_p, sizeof(float) * source_frames_to_process);
 
   // Copy the odd sample-frames from sourceP, delayed by one sample-frame
   // (destination sample-rate) to match shifting forward in time in
   // m_reducedKernel.
-  float* odd_samples_p = temp_buffer_.Data();
+  float* odd_samples_p = temp_buffer_.Data().data();
   for (unsigned i = 0; i < dest_frames_to_process; ++i) {
     odd_samples_p[i] = *((input_p - 1) + i * 2);
   }
@@ -137,7 +138,7 @@ void DownSampler::Process(const float* source_p,
   }
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(input_buffer_.Data(), input_p,
+  memcpy(input_buffer_.Data().data(), input_p,
          sizeof(float) * source_frames_to_process);
 }
 
diff --git a/third_party/blink/renderer/platform/audio/dynamics_compressor.cc b/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
index 992c4d4736229..c46445d5b03b4 100644
--- a/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
+++ b/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
@@ -293,7 +293,7 @@ void DynamicsCompressor::Process(const AudioBus* source_bus,
       // Predelay signal, computing compression amount from un-delayed
       // version.
       for (unsigned j = 0; j < number_of_channels; ++j) {
-        float* const delay_buffer = pre_delay_buffers_[j]->Data();
+        float* const delay_buffer = pre_delay_buffers_[j]->Data().data();
         const float undelayed_source = source_channels[j][frame_index];
         delay_buffer[pre_delay_write_index] = undelayed_source;
 
@@ -366,7 +366,7 @@ void DynamicsCompressor::Process(const AudioBus* source_bus,
 
       // Apply final gain.
       for (unsigned j = 0; j < number_of_channels; ++j) {
-        const float* const delay_buffer = pre_delay_buffers_[j]->Data();
+        const float* const delay_buffer = pre_delay_buffers_[j]->Data().data();
         destination_channels[j][frame_index] =
             delay_buffer[pre_delay_read_index] * total_gain;
       }
diff --git a/third_party/blink/renderer/platform/audio/equal_power_panner.cc b/third_party/blink/renderer/platform/audio/equal_power_panner.cc
index 16624db1c7eaa..68404e0245d5a 100644
--- a/third_party/blink/renderer/platform/audio/equal_power_panner.cc
+++ b/third_party/blink/renderer/platform/audio/equal_power_panner.cc
@@ -62,9 +62,9 @@ void EqualPowerPanner::Pan(double azimuth,
   const float* source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
   float* destination_l =
-      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData().data();
   float* destination_r =
-      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData().data();
 
   if (!source_l || !source_r || !destination_l || !destination_r) {
     return;
@@ -160,9 +160,9 @@ void EqualPowerPanner::PanWithSampleAccurateValues(
   const float* source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
   float* destination_l =
-      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData().data();
   float* destination_r =
-      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData().data();
 
   DCHECK(source_l);
   DCHECK(source_r);
diff --git a/third_party/blink/renderer/platform/audio/fft_convolver.cc b/third_party/blink/renderer/platform/audio/fft_convolver.cc
index 3ba18b2dfe6ee..94d5d860a50e5 100644
--- a/third_party/blink/renderer/platform/audio/fft_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/fft_convolver.cc
@@ -65,7 +65,7 @@ void FFTConvolver::Process(const FFTFrame* fft_kernel,
   for (size_t i = 0; i < number_of_divisions;
        ++i, source_p += division_size, dest_p += division_size) {
     // Copy samples to input buffer (note contraint above!)
-    float* input_p = input_buffer_.Data();
+    float* input_p = input_buffer_.Data().data();
 
     DCHECK(source_p);
     DCHECK(input_p);
@@ -75,7 +75,7 @@ void FFTConvolver::Process(const FFTFrame* fft_kernel,
            sizeof(float) * division_size);
 
     // Copy samples from output buffer
-    float* output_p = output_buffer_.Data();
+    float* output_p = output_buffer_.Data().data();
 
     DCHECK(dest_p);
     DCHECK(output_p);
@@ -87,19 +87,21 @@ void FFTConvolver::Process(const FFTFrame* fft_kernel,
     // Check if it's time to perform the next FFT
     if (read_write_index_ == half_size) {
       // The input buffer is now filled (get frequency-domain version)
-      frame_.DoFFT(input_buffer_.Data());
+      frame_.DoFFT(input_buffer_.Data().data());
       frame_.Multiply(*fft_kernel);
-      frame_.DoInverseFFT(output_buffer_.Data());
+      frame_.DoInverseFFT(output_buffer_.Data().data());
 
       // Overlap-add 1st half from previous time
-      vector_math::Vadd(output_buffer_.Data(), 1, last_overlap_buffer_.Data(),
-                        1, output_buffer_.Data(), 1, half_size);
+      vector_math::Vadd(output_buffer_.Data().data(), 1,
+                        last_overlap_buffer_.Data().data(), 1,
+                        output_buffer_.Data().data(), 1, half_size);
 
       // Finally, save 2nd half of result
       DCHECK_EQ(output_buffer_.size(), 2 * half_size);
       DCHECK_EQ(last_overlap_buffer_.size(), half_size);
 
-      memcpy(last_overlap_buffer_.Data(), output_buffer_.Data() + half_size,
+      memcpy(last_overlap_buffer_.Data().data(),
+             output_buffer_.Data().subspan(half_size).data(),
              sizeof(float) * half_size);
 
       // Reset index back to start for next time
diff --git a/third_party/blink/renderer/platform/audio/fft_frame.cc b/third_party/blink/renderer/platform/audio/fft_frame.cc
index d584d590e31f8..ebcf321f25a19 100644
--- a/third_party/blink/renderer/platform/audio/fft_frame.cc
+++ b/third_party/blink/renderer/platform/audio/fft_frame.cc
@@ -51,7 +51,7 @@ void FFTFrame::DoPaddedFFT(const float* data, unsigned data_size) {
   padded_response.CopyToRange(data, 0, data_size);
 
   // Get the frequency-domain version of padded response
-  DoFFT(padded_response.Data());
+  DoFFT(padded_response.Data().data());
 }
 
 std::unique_ptr<FFTFrame> FFTFrame::CreateInterpolatedFrame(
@@ -67,20 +67,20 @@ std::unique_ptr<FFTFrame> FFTFrame::CreateInterpolatedFrame(
   // circular convolution aliasing...
   int fft_size = new_frame->FftSize();
   AudioFloatArray buffer(fft_size);
-  new_frame->DoInverseFFT(buffer.Data());
+  new_frame->DoInverseFFT(buffer.Data().data());
   buffer.ZeroRange(fft_size / 2, fft_size);
 
   // Put back into frequency domain.
-  new_frame->DoFFT(buffer.Data());
+  new_frame->DoFFT(buffer.Data().data());
 
   return new_frame;
 }
 
 void FFTFrame::ScaleFFT(float factor) {
-  vector_math::Vsmul(real_data_.Data(), 1, &factor, real_data_.Data(), 1,
-                     real_data_.size());
-  vector_math::Vsmul(imag_data_.Data(), 1, &factor, imag_data_.Data(), 1,
-                     imag_data_.size());
+  vector_math::Vsmul(real_data_.Data().data(), 1, &factor,
+                     real_data_.Data().data(), 1, real_data_.size());
+  vector_math::Vsmul(imag_data_.Data().data(), 1, &factor,
+                     imag_data_.Data().data(), 1, imag_data_.size());
 }
 
 void FFTFrame::InterpolateFrequencyComponents(const FFTFrame& frame1,
@@ -304,8 +304,8 @@ void FFTFrame::Multiply(const FFTFrame& frame) {
   DCHECK_GE(real2.size(), half_size);
   DCHECK_GE(imag2.size(), half_size);
 
-  vector_math::Zvmul(real1.Data(), imag1.Data(), real2.Data(),
-                     imag2.Data(), real1.Data(), imag1.Data(),
+  vector_math::Zvmul(real1.Data().data(), imag1.Data().data(), real2.Data(),
+                     imag2.Data(), real1.Data().data(), imag1.Data().data(),
                      half_size);
 
   // Multiply the packed DC/nyquist component
diff --git a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
index 11aee4cc28c3a..b6828253e242d 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
@@ -222,7 +222,7 @@ bool HRTFElevation::CalculateKernelsForAzimuthElevation(
         AudioBus::Create(response->NumberOfChannels(), fft_size / 2));
     for (unsigned channel = 0; channel < response->NumberOfChannels();
          ++channel) {
-      memcpy(padded_response->Channel(channel)->MutableData(),
+      memcpy(padded_response->Channel(channel)->MutableData().data(),
              response->Channel(channel)->Data(),
              response->length() * sizeof(float));
     }
diff --git a/third_party/blink/renderer/platform/audio/hrtf_kernel.cc b/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
index 7f3b85879148e..28c7a896295f9 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
@@ -53,7 +53,7 @@ float ExtractAverageGroupDelay(AudioChannel* channel,
                                unsigned analysis_fft_size) {
   DCHECK(channel);
 
-  float* impulse_p = channel->MutableData();
+  float* impulse_p = channel->MutableData().data();
 
   DCHECK_GE(channel->length(), analysis_fft_size);
 
@@ -82,7 +82,7 @@ HRTFKernel::HRTFKernel(AudioChannel* channel,
   // Determine the leading delay (average group delay) for the response.
   frame_delay_ = ExtractAverageGroupDelay(channel, fft_size / 2);
 
-  float* impulse_response = channel->MutableData();
+  float* impulse_response = channel->MutableData().data();
   const uint32_t response_length = channel->length();
 
   // We need to truncate to fit into 1/2 the FFT size (with zero padding) in
diff --git a/third_party/blink/renderer/platform/audio/hrtf_panner.cc b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
index b5bfe65edd5e4..ef17a265fc0d3 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_panner.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
@@ -187,9 +187,9 @@ void HRTFPanner::Pan(double desired_azimuth,
   const float* source_r =
       num_input_channels > 1 ? input_channel_r->Data() : source_l;
   float* destination_l =
-      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData().data();
   float* destination_r =
-      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData().data();
 
   double azimuth_blend;
   const int desired_azimuth_index =
@@ -289,13 +289,13 @@ void HRTFPanner::Pan(double desired_azimuth,
     // Have the convolvers render directly to the final destination if we're not
     // cross-fading.
     float* convolution_destination_l1 =
-        needs_crossfading ? temp_l1_.Data() : segment_destination_l;
+        needs_crossfading ? temp_l1_.Data().data() : segment_destination_l;
     float* convolution_destination_r1 =
-        needs_crossfading ? temp_r1_.Data() : segment_destination_r;
+        needs_crossfading ? temp_r1_.Data().data() : segment_destination_r;
     float* convolution_destination_l2 =
-        needs_crossfading ? temp_l2_.Data() : segment_destination_l;
+        needs_crossfading ? temp_l2_.Data().data() : segment_destination_l;
     float* convolution_destination_r2 =
-        needs_crossfading ? temp_r2_.Data() : segment_destination_r;
+        needs_crossfading ? temp_r2_.Data().data() : segment_destination_r;
 
     // Now do the convolutions.
     // Note that we avoid doing convolutions on both sets of convolvers if we're
diff --git a/third_party/blink/renderer/platform/audio/iir_filter.cc b/third_party/blink/renderer/platform/audio/iir_filter.cc
index 0cc719de76abf..e8977ec7e6664 100644
--- a/third_party/blink/renderer/platform/audio/iir_filter.cc
+++ b/third_party/blink/renderer/platform/audio/iir_filter.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -83,8 +85,8 @@ void IIRFilter::Process(const float* source_p,
   int feedforward_length = feedforward_->size();
   int min_length = std::min(feedback_length, feedforward_length);
 
-  double* x_buffer = x_buffer_.Data();
-  double* y_buffer = y_buffer_.Data();
+  double* x_buffer = x_buffer_.Data().data();
+  double* y_buffer = y_buffer_.Data().data();
 
   for (size_t n = 0; n < frames_to_process; ++n) {
     // To help minimize roundoff, we compute using double's, even though the
@@ -121,8 +123,8 @@ void IIRFilter::Process(const float* source_p,
 
 void IIRFilter::GetFrequencyResponse(int n_frequencies,
                                      const float* frequency,
-                                     float* mag_response,
-                                     float* phase_response) {
+                                     base::span<float> mag_response,
+                                     base::span<float> phase_response) {
   // Evaluate the z-transform of the filter at the given normalized frequencies
   // from 0 to 1. (One corresponds to the Nyquist frequency.)
   //
@@ -206,16 +208,17 @@ double IIRFilter::TailTime(double sample_rate,
   input[0] = 1;
 
   // Process the first block and get the max magnitude of the output.
-  Process(input.Data(), output.Data(), render_quantum_frames);
-  vector_math::Vmaxmgv(output.Data(), 1, &magnitudes[0], render_quantum_frames);
+  Process(input.Data().data(), output.Data().data(), render_quantum_frames);
+  vector_math::Vmaxmgv(output.Data().data(), 1, &magnitudes[0],
+                       render_quantum_frames);
 
   // Process the rest of the signal, getting the max magnitude of the
   // output for each block.
   input[0] = 0;
 
   for (int k = 1; k < number_of_blocks; ++k) {
-    Process(input.Data(), output.Data(), render_quantum_frames);
-    vector_math::Vmaxmgv(output.Data(), 1, &magnitudes[k],
+    Process(input.Data().data(), output.Data().data(), render_quantum_frames);
+    vector_math::Vmaxmgv(output.Data().data(), 1, &magnitudes[k],
                          render_quantum_frames);
   }
 
diff --git a/third_party/blink/renderer/platform/audio/iir_filter.h b/third_party/blink/renderer/platform/audio/iir_filter.h
index 8938ec66a720c..d157684cfeefd 100644
--- a/third_party/blink/renderer/platform/audio/iir_filter.h
+++ b/third_party/blink/renderer/platform/audio/iir_filter.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_IIR_FILTER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_IIR_FILTER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -29,8 +30,8 @@ class PLATFORM_EXPORT IIRFilter final {
 
   void GetFrequencyResponse(int n_frequencies,
                             const float* frequency,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<float> mag_response,
+                            base::span<float> phase_response);
 
   // Compute the tail time of the IIR filter
   double TailTime(double sample_rate,
diff --git a/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc b/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
index 3b60efc3281f7..f961260503664 100644
--- a/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
+++ b/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
@@ -39,7 +39,7 @@ void MediaMultiChannelResampler::Resample(
     // TODO(crbug.com/375449662): Spanify `AudioChannel::MuteableData`.
     resampler_input_bus_wrapper_->SetChannelData(
         i, UNSAFE_TODO(base::span(
-               resampler_input_bus->Channel(i)->MutableData(),
+               resampler_input_bus->Channel(i)->MutableData().data(),
                base::checked_cast<size_t>(resampler_input_bus->length()))));
   }
   ResampleInternal(frames, resampler_input_bus_wrapper_.get());
diff --git a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
index 891f425a0561b..481fc0601f749 100644
--- a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
+++ b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
@@ -151,8 +151,8 @@ FFTFrame::FFTFrame(const FFTFrame& frame)
 
   // Copy/setup frame data.
   unsigned nbytes = sizeof(float) * (fft_size_ / 2);
-  memcpy(RealData().Data(), frame.RealData().Data(), nbytes);
-  memcpy(ImagData().Data(), frame.ImagData().Data(), nbytes);
+  memcpy(RealData().Data().data(), frame.RealData().Data(), nbytes);
+  memcpy(ImagData().Data().data(), frame.ImagData().Data(), nbytes);
 }
 
 unsigned FFTFrame::MinFFTSize() {
@@ -199,17 +199,17 @@ void FFTFrame::DoFFT(const float* data) {
   PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
-  pffft_transform_ordered(setup, data, complex_data_.Data(), pffft_work_.Data(),
-                          PFFFT_FORWARD);
+  pffft_transform_ordered(setup, data, complex_data_.Data().data(),
+                          pffft_work_.Data().data(), PFFFT_FORWARD);
 
   unsigned len = fft_size_ / 2;
 
   // Split FFT data into real and imaginary arrays.  PFFFT transform already
   // uses the desired format; we just need to split out the real and imaginary
   // parts.
-  const float* c = complex_data_.Data();
-  float* real = real_data_.Data();
-  float* imag = imag_data_.Data();
+  const float* c = complex_data_.Data().data();
+  float* real = real_data_.Data().data();
+  float* imag = imag_data_.Data().data();
   for (unsigned k = 0; k < len; ++k) {
     int index = 2 * k;
     real[k] = c[index];
@@ -224,9 +224,9 @@ void FFTFrame::DoInverseFFT(float* data) {
 
   // Pack the real and imaginary data into the complex array format.  PFFFT
   // already uses the desired format; we just need to pack the parts together.
-  float* fft_data = complex_data_.Data();
-  const float* real = real_data_.Data();
-  const float* imag = imag_data_.Data();
+  float* fft_data = complex_data_.Data().data();
+  const float* real = real_data_.Data().data();
+  const float* imag = imag_data_.Data().data();
   for (unsigned k = 0; k < len; ++k) {
     int index = 2 * k;
     fft_data[index] = real[k];
@@ -236,7 +236,7 @@ void FFTFrame::DoInverseFFT(float* data) {
   PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
-  pffft_transform_ordered(setup, fft_data, data, pffft_work_.Data(),
+  pffft_transform_ordered(setup, fft_data, data, pffft_work_.Data().data(),
                           PFFFT_BACKWARD);
 
   // The inverse transform needs to be scaled because PFFFT doesn't.
diff --git a/third_party/blink/renderer/platform/audio/push_pull_fifo.cc b/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
index cd0e1723a7799..888d6544c47df 100644
--- a/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
+++ b/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
@@ -77,7 +77,7 @@ void PushPullFIFO::Push(const AudioBus* input_bus) {
   const size_t remainder = fifo_length_ - index_write_;
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-    float* fifo_bus_channel = fifo_bus_->Channel(i)->MutableData();
+    float* fifo_bus_channel = fifo_bus_->Channel(i)->MutableData().data();
     const float* input_bus_channel = input_bus->Channel(i)->Data();
     if (remainder >= input_bus_length) {
       // The remainder is big enough for the input data.
@@ -166,7 +166,7 @@ size_t PushPullFIFO::Pull(AudioBus* output_bus, uint32_t frames_requested) {
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
     const float* fifo_bus_channel = fifo_bus_->Channel(i)->Data();
-    float* output_bus_channel = output_bus->Channel(i)->MutableData();
+    float* output_bus_channel = output_bus->Channel(i)->MutableData().data();
 
     // Fill up the output bus with the available frames first.
     if (remainder >= frames_to_fill) {
@@ -271,7 +271,7 @@ PushPullFIFO::PullResult PushPullFIFO::PullAndUpdateEarmark(
     // Note that it silences when underrun happens now, and ship the remaining
     // frames in subsequent callbacks without silence in between.
     for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-      float* output_bus_channel = output_bus->Channel(i)->MutableData();
+      float* output_bus_channel = output_bus->Channel(i)->MutableData().data();
       memset(output_bus_channel, 0,
              frames_requested * sizeof(*output_bus_channel));
     }
@@ -287,7 +287,7 @@ PushPullFIFO::PullResult PushPullFIFO::PullAndUpdateEarmark(
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
     const float* fifo_bus_channel = fifo_bus_->Channel(i)->Data();
-    float* output_bus_channel = output_bus->Channel(i)->MutableData();
+    float* output_bus_channel = output_bus->Channel(i)->MutableData().data();
 
     // Fill up the output bus with the available frames first.
     if (remainder >= frames_to_fill) {
diff --git a/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc b/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
index c980b58d90b0f..fa4f06e24fb81 100644
--- a/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
+++ b/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
@@ -64,7 +64,7 @@ TEST(PushPullFIFOBasicTest, BasicTests) {
 // value will be |starting_value| + |bus_length|.
 size_t FillBusWithLinearRamp(AudioBus* target_bus, size_t starting_value) {
   for (unsigned c = 0; c < target_bus->NumberOfChannels(); ++c) {
-    float* bus_channel = target_bus->Channel(c)->MutableData();
+    float* bus_channel = target_bus->Channel(c)->MutableData().data();
     for (size_t i = 0; i < target_bus->Channel(c)->length(); ++i) {
       bus_channel[i] = static_cast<float>(starting_value + i);
     }
@@ -78,7 +78,7 @@ bool VerifyBusValueAtIndex(AudioBus* target_bus,
                            int index,
                            float expected_value) {
   for (unsigned c = 0; c < target_bus->NumberOfChannels(); ++c) {
-    float* bus_channel = target_bus->Channel(c)->MutableData();
+    float* bus_channel = target_bus->Channel(c)->MutableData().data();
     if (bus_channel[index] != expected_value) {
       LOG(ERROR) << ">> [FAIL] expected " << expected_value << " at index "
                  << index << " but got " << bus_channel[index] << ".";
diff --git a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
index 5f38586a29f02..bef34b7edd3ce 100644
--- a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
@@ -53,7 +53,7 @@ void ReverbAccumulationBuffer::ReadAndClear(float* destination,
   uint32_t number_of_frames1 = std::min(number_of_frames, frames_available);
   uint32_t number_of_frames2 = number_of_frames - number_of_frames1;
 
-  float* source = buffer_.Data();
+  float* source = buffer_.Data().data();
   memcpy(destination, source + read_index_, sizeof(float) * number_of_frames1);
   memset(source + read_index_, 0, sizeof(float) * number_of_frames1);
 
@@ -90,7 +90,7 @@ uint32_t ReverbAccumulationBuffer::Accumulate(float* source,
   uint32_t number_of_frames1 = std::min(number_of_frames, frames_available);
   uint32_t number_of_frames2 = number_of_frames - number_of_frames1;
 
-  float* destination = buffer_.Data();
+  float* destination = buffer_.Data().data();
 
   DCHECK_LE(write_index, buffer_length);
   DCHECK_LE(number_of_frames1 + write_index, buffer_length);
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver.cc b/third_party/blink/renderer/platform/audio/reverb_convolver.cc
index 3c22ec815b540..9adf5fc0a67d1 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver.cc
@@ -179,7 +179,7 @@ void ReverbConvolver::Process(const AudioChannel* source_channel,
   DCHECK_GE(destination_channel->length(), frames_to_process);
 
   const float* source = source_channel->Data();
-  float* destination = destination_channel->MutableData();
+  float* destination = destination_channel->MutableData().data();
   DCHECK(source);
   DCHECK(destination);
 
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
index 94fab48f0a9f8..66569473427fc 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,7 +47,7 @@
 namespace blink {
 
 ReverbConvolverStage::ReverbConvolverStage(
-    const float* impulse_response,
+    base::span<const float> impulse_response,
     size_t,
     size_t reverb_total_latency,
     size_t stage_offset,
@@ -60,12 +62,13 @@ ReverbConvolverStage::ReverbConvolverStage(
       accumulation_read_index_(0),
       input_read_index_(0),
       direct_mode_(direct_mode) {
-  DCHECK(impulse_response);
+  DCHECK(!impulse_response.empty());
   DCHECK(accumulation_buffer);
 
   if (!direct_mode_) {
     fft_kernel_ = std::make_unique<FFTFrame>(fft_size);
-    fft_kernel_->DoPaddedFFT(impulse_response + stage_offset, stage_length);
+    fft_kernel_->DoPaddedFFT(impulse_response.subspan(stage_offset).data(),
+                             stage_length);
     // Account for the normalization (if any) of the convolver.  By linearity,
     // we can scale the FFT by the factor instead of the input.  We do it this
     // way so we don't need to create a temporary for the scaled result before
@@ -79,11 +82,11 @@ ReverbConvolverStage::ReverbConvolverStage(
     DCHECK_LE(stage_length, fft_size / 2);
 
     auto direct_kernel = std::make_unique<AudioFloatArray>(fft_size / 2);
-    direct_kernel->CopyToRange(impulse_response, 0, stage_length);
+    direct_kernel->CopyToRange(impulse_response.data(), 0, stage_length);
     // Account for the normalization (if any) of the convolver node.
     if (scale != 1) {
-      vector_math::Vsmul(direct_kernel->Data(), 1, &scale,
-                         direct_kernel->Data(), 1, stage_length);
+      vector_math::Vsmul(direct_kernel->Data().data(), 1, &scale,
+                         direct_kernel->Data().data(), 1, stage_length);
     }
     direct_convolver_ = std::make_unique<DirectConvolver>(
         render_slice_size, std::move(direct_kernel));
@@ -158,14 +161,15 @@ void ReverbConvolverStage::Process(const float* source,
 
     is_temporary_buffer_safe = frames_to_process <= temporary_buffer_.size();
 
-    pre_delayed_destination = pre_delay_buffer_.Data() + pre_read_write_index_;
+    pre_delayed_destination =
+        pre_delay_buffer_.Data().subspan(pre_read_write_index_).data();
     pre_delayed_source = pre_delayed_destination;
-    temporary_buffer = temporary_buffer_.Data();
+    temporary_buffer = temporary_buffer_.Data().data();
   } else {
     // Zero delay
     pre_delayed_destination = nullptr;
     pre_delayed_source = source;
-    temporary_buffer = pre_delay_buffer_.Data();
+    temporary_buffer = pre_delay_buffer_.Data().data();
 
     is_temporary_buffer_safe = frames_to_process <= pre_delay_buffer_.size();
   }
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
index bdccb18cbd2f9..9713029b3665e 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
@@ -30,6 +30,8 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_REVERB_CONVOLVER_STAGE_H_
 
 #include <memory>
+
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/fft_frame.h"
@@ -53,7 +55,7 @@ class ReverbConvolverStage final {
   // renderPhase is useful to know so that we can manipulate the pre versus post
   // delay so that stages will perform their heavy work (FFT processing) on
   // different slices to balance the load in a real-time thread.
-  ReverbConvolverStage(const float* impulse_response,
+  ReverbConvolverStage(base::span<const float> impulse_response,
                        size_t response_length,
                        size_t reverb_total_latency,
                        size_t stage_offset,
diff --git a/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc b/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
index b1b40d58a8c83..6c42c5d05f5b6 100644
--- a/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
@@ -45,7 +45,8 @@ void ReverbInputBuffer::Write(const float* source_p, size_t number_of_frames) {
 
   CHECK_LE(new_index, buffer_length);
 
-  memcpy(buffer_.Data() + index, source_p, sizeof(float) * number_of_frames);
+  memcpy(buffer_.Data().subspan(index).data(), source_p,
+         sizeof(float) * number_of_frames);
 
   if (new_index >= buffer_length) {
     new_index = 0;
@@ -60,7 +61,7 @@ float* ReverbInputBuffer::DirectReadFrom(size_t* read_index,
   DCHECK(read_index);
   DCHECK_LE(*read_index + number_of_frames, buffer_length);
 
-  float* source_p = buffer_.Data();
+  float* source_p = buffer_.Data().data();
   float* p = source_p + *read_index;
 
   // Update readIndex
diff --git a/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc b/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
index ddc1f6b7805af..5e91b272100d8 100644
--- a/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
@@ -27,7 +27,8 @@ SimpleFFTConvolver::SimpleFFTConvolver(
   // Do padded FFT to get frequency-domain version of the convolution kernel.
   // This FFT and caching is done once in here so that it does not have to be
   // done repeatedly in |Process|.
-  fft_kernel_.DoPaddedFFT(convolution_kernel->Data(), convolution_kernel_size_);
+  fft_kernel_.DoPaddedFFT(convolution_kernel->Data().data(),
+                          convolution_kernel_size_);
 }
 
 void SimpleFFTConvolver::Process(const float* source_p,
@@ -44,18 +45,19 @@ void SimpleFFTConvolver::Process(const float* source_p,
   // half of the input buffer (the second half is always zero), multiply in
   // frequency-domain and do inverse FFT to get output samples.
   input_buffer_.CopyToRange(source_p, 0, half_size);
-  frame_.DoFFT(input_buffer_.Data());
+  frame_.DoFFT(input_buffer_.Data().data());
   frame_.Multiply(fft_kernel_);
-  frame_.DoInverseFFT(output_buffer_.Data());
+  frame_.DoInverseFFT(output_buffer_.Data().data());
 
   // Overlap-add 1st half with 2nd half from previous time and write
   // to destination.
-  vector_math::Vadd(output_buffer_.Data(), 1, last_overlap_buffer_.Data(), 1,
-                    dest_p, 1, half_size);
+  vector_math::Vadd(output_buffer_.Data().data(), 1,
+                    last_overlap_buffer_.Data().data(), 1, dest_p, 1,
+                    half_size);
 
   // Finally, save 2nd half for the next time.
-  last_overlap_buffer_.CopyToRange(output_buffer_.Data() + half_size, 0,
-                                   half_size);
+  last_overlap_buffer_.CopyToRange(
+      output_buffer_.Data().subspan(half_size).data(), 0, half_size);
 }
 
 void SimpleFFTConvolver::Reset() {
diff --git a/third_party/blink/renderer/platform/audio/sinc_resampler.cc b/third_party/blink/renderer/platform/audio/sinc_resampler.cc
index 63418db6c27af..97ad19e4b4497 100644
--- a/third_party/blink/renderer/platform/audio/sinc_resampler.cc
+++ b/third_party/blink/renderer/platform/audio/sinc_resampler.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -139,7 +141,7 @@ void SincResampler::InitializeKernel() {
   }
 }
 
-void SincResampler::ConsumeSource(float* buffer,
+void SincResampler::ConsumeSource(base::span<float> buffer,
                                   unsigned number_of_source_frames) {
   DCHECK(source_provider_);
 
@@ -171,7 +173,7 @@ class BufferSourceProvider final : public AudioSourceProvider {
       return;
     }
 
-    float* buffer = bus->Channel(0)->MutableData();
+    float* buffer = bus->Channel(0)->MutableData().data();
 
     // Clamp to number of frames available and zero-pad.
     int frames_to_copy = std::min(source_frames_available_, frames_to_process);
@@ -228,12 +230,12 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
   unsigned number_of_destination_frames = frames_to_process;
 
   // Setup various region pointers in the buffer (see diagram above).
-  float* r0 = input_buffer_.Data() + kernel_size_ / 2;
-  float* r1 = input_buffer_.Data();
-  float* r2 = r0;
-  float* r3 = r0 + block_size_ - kernel_size_ / 2;
-  float* r4 = r0 + block_size_;
-  float* r5 = r0 + kernel_size_ / 2;
+  base::span<float> r0 = input_buffer_.Data().subspan(kernel_size_ / 2);
+  float* r1 = input_buffer_.Data().data();
+  float* r2 = r0.data();
+  float* r3 = r0.subspan(block_size_ - kernel_size_ / 2).data();
+  float* r4 = r0.subspan(block_size_).data();
+  base::span<float> r5 = r0.subspan(kernel_size_ / 2);
 
   // Step (1)
   // Prime the input buffer at the start of the input stream.
@@ -255,7 +257,8 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
           subsample_remainder * number_of_kernel_offsets_;
       int offset_index = static_cast<int>(virtual_offset_index);
 
-      float* k1 = kernel_storage_.Data() + offset_index * kernel_size_;
+      float* k1 =
+          kernel_storage_.Data().subspan(offset_index * kernel_size_).data();
       float* k2 = k1 + kernel_size_;
 
       // Initialize input pointer based on quantized m_virtualSourceIndex.
diff --git a/third_party/blink/renderer/platform/audio/sinc_resampler.h b/third_party/blink/renderer/platform/audio/sinc_resampler.h
index 0360ea8907c6a..f7976c1b1dae4 100644
--- a/third_party/blink/renderer/platform/audio/sinc_resampler.h
+++ b/third_party/blink/renderer/platform/audio/sinc_resampler.h
@@ -29,6 +29,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_SINC_RESAMPLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_SINC_RESAMPLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/audio_source_provider.h"
@@ -66,7 +67,8 @@ class SincResampler final {
 
  protected:
   void InitializeKernel();
-  void ConsumeSource(float* buffer, unsigned number_of_source_frames);
+  void ConsumeSource(base::span<float> buffer,
+                     unsigned number_of_source_frames);
 
   double scale_factor_;
   unsigned kernel_size_;
diff --git a/third_party/blink/renderer/platform/audio/stereo_panner.cc b/third_party/blink/renderer/platform/audio/stereo_panner.cc
index 6cb6630d202bd..643fc7cf2b8f3 100644
--- a/third_party/blink/renderer/platform/audio/stereo_panner.cc
+++ b/third_party/blink/renderer/platform/audio/stereo_panner.cc
@@ -44,9 +44,9 @@ void StereoPanner::PanWithSampleAccurateValues(const AudioBus* input_bus,
   const float* source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
   float* destination_l =
-      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData().data();
   float* destination_r =
-      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData().data();
 
   if (!source_l || !source_r || !destination_l || !destination_r) {
     return;
@@ -106,9 +106,9 @@ void StereoPanner::PanToTargetValue(const AudioBus* input_bus,
   const float* source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
   float* destination_l =
-      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData().data();
   float* destination_r =
-      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
+      output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData().data();
 
   if (!source_l || !source_r || !destination_l || !destination_r) {
     return;
diff --git a/third_party/blink/renderer/platform/audio/up_sampler.cc b/third_party/blink/renderer/platform/audio/up_sampler.cc
index e24c025bf234a..f749e626cd88d 100644
--- a/third_party/blink/renderer/platform/audio/up_sampler.cc
+++ b/third_party/blink/renderer/platform/audio/up_sampler.cc
@@ -116,7 +116,8 @@ void UpSampler::Process(const float* source_p,
   DCHECK_LE(half_size, source_frames_to_process);
 
   // Copy source samples to 2nd half of input buffer.
-  float* input_p = input_buffer_.Data() + source_frames_to_process;
+  float* input_p =
+      input_buffer_.Data().subspan(source_frames_to_process).data();
   memcpy(input_p, source_p, sizeof(float) * source_frames_to_process);
 
   // Copy even sample-frames 0,2,4,6... (delayed by the linear phase delay)
@@ -126,7 +127,7 @@ void UpSampler::Process(const float* source_p,
   }
 
   // Compute odd sample-frames 1,3,5,7...
-  float* odd_samples_p = temp_buffer_.Data();
+  float* odd_samples_p = temp_buffer_.Data().data();
   if (direct_convolver_) {
     direct_convolver_->Process(source_p, odd_samples_p,
                                source_frames_to_process);
@@ -140,7 +141,7 @@ void UpSampler::Process(const float* source_p,
   }
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(input_buffer_.Data(), input_p,
+  memcpy(input_buffer_.Data().data(), input_p,
          sizeof(float) * source_frames_to_process);
 }
 
diff --git a/third_party/blink/renderer/platform/exported/web_audio_bus.cc b/third_party/blink/renderer/platform/exported/web_audio_bus.cc
index c62ef4c5511d9..804f3079e5815 100644
--- a/third_party/blink/renderer/platform/exported/web_audio_bus.cc
+++ b/third_party/blink/renderer/platform/exported/web_audio_bus.cc
@@ -80,7 +80,7 @@ float* WebAudioBus::ChannelData(unsigned channel_index) {
   if (!private_)
     return nullptr;
   DCHECK_LT(channel_index, NumberOfChannels());
-  return private_->Channel(channel_index)->MutableData();
+  return private_->Channel(channel_index)->MutableData().data();
 }
 
 scoped_refptr<AudioBus> WebAudioBus::Release() {
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
index 3acbfc966fc11..5907dbcfa42c8 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -105,13 +107,14 @@ WebContentDecryptionModuleImpl::CreateSession(
 }
 
 void WebContentDecryptionModuleImpl::SetServerCertificate(
-    const uint8_t* server_certificate,
+    base::span<const uint8_t> server_certificate,
     size_t server_certificate_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(server_certificate);
+  DCHECK(!server_certificate.empty());
   adapter_->SetServerCertificate(
-      std::vector<uint8_t>(server_certificate,
-                           server_certificate + server_certificate_length),
+      std::vector<uint8_t>(
+          server_certificate.data(),
+          server_certificate.subspan(server_certificate_length).data()),
       std::make_unique<CdmResultPromise<>>(result,
                                            adapter_->GetKeySystemUMAPrefix(),
                                            kSetServerCertificateUMAName));
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
index 1e2e6f1409cf6..219e13c6b488c 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
@@ -11,6 +11,7 @@
 #include <memory>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/functional/callback_forward.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/types/pass_key.h"
@@ -57,7 +58,7 @@ class PLATFORM_EXPORT WebContentDecryptionModuleImpl
   // WebContentDecryptionModule implementation.
   std::unique_ptr<WebContentDecryptionModuleSession> CreateSession(
       WebEncryptedMediaSessionType session_type) override;
-  void SetServerCertificate(const uint8_t* server_certificate,
+  void SetServerCertificate(base::span<const uint8_t> server_certificate,
                             size_t server_certificate_length,
                             WebContentDecryptionModuleResult result) override;
   void GetStatusForPolicy(const WebString& min_hdcp_version_string,
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
index 7f85968096eb4..c7cec4981cea6 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -63,7 +65,7 @@ media::CdmSessionType ConvertSessionType(
 }
 
 bool SanitizeInitData(media::EmeInitDataType init_data_type,
-                      const unsigned char* init_data,
+                      base::span<const unsigned char> init_data,
                       size_t init_data_length,
                       std::vector<uint8_t>* sanitized_init_data,
                       std::string* error_message) {
@@ -80,11 +82,13 @@ bool SanitizeInitData(media::EmeInitDataType init_data_type,
         error_message->assign("Initialization data for WebM is too long.");
         return false;
       }
-      sanitized_init_data->assign(init_data, init_data + init_data_length);
+      sanitized_init_data->assign(init_data.data(),
+                                  init_data.subspan(init_data_length).data());
       return true;
 
     case media::EmeInitDataType::CENC:
-      sanitized_init_data->assign(init_data, init_data + init_data_length);
+      sanitized_init_data->assign(init_data.data(),
+                                  init_data.subspan(init_data_length).data());
       if (!media::ValidatePsshInput(*sanitized_init_data)) {
         error_message->assign("Initialization data for CENC is incorrect.");
         return false;
@@ -94,7 +98,8 @@ bool SanitizeInitData(media::EmeInitDataType init_data_type,
     case media::EmeInitDataType::KEYIDS: {
       // Extract the keys and then rebuild the message. This ensures that any
       // extra data in the provided JSON is dropped.
-      std::string init_data_string(init_data, init_data + init_data_length);
+      std::string init_data_string(init_data.data(),
+                                   init_data.subspan(init_data_length).data());
       media::KeyIdList key_ids;
       if (!media::ExtractKeyIdsFromKeyIdsInitData(init_data_string, &key_ids,
                                                   error_message))
@@ -144,7 +149,7 @@ bool SanitizeSessionId(const WebString& session_id,
 }
 
 bool SanitizeResponse(const std::string& key_system,
-                      const uint8_t* response,
+                      base::span<const uint8_t> response,
                       size_t response_length,
                       std::vector<uint8_t>* sanitized_response) {
   // The user agent should thoroughly validate the response before passing it
@@ -157,7 +162,8 @@ bool SanitizeResponse(const std::string& key_system,
     return false;
 
   if (media::IsClearKey(key_system) || media::IsExternalClearKey(key_system)) {
-    std::string key_string(response, response + response_length);
+    std::string key_string(response.data(),
+                           response.subspan(response_length).data());
     media::KeyIdAndKeyPairs keys;
     auto session_type = media::CdmSessionType::kTemporary;
     if (!ExtractKeysFromJWKSet(key_string, &keys, &session_type))
@@ -180,7 +186,8 @@ bool SanitizeResponse(const std::string& key_system,
   }
 
   // TODO(jrummell): Verify responses for Widevine.
-  sanitized_response->assign(response, response + response_length);
+  sanitized_response->assign(response.data(),
+                             response.subspan(response_length).data());
   return true;
 }
 
@@ -289,10 +296,10 @@ WebString WebContentDecryptionModuleSessionImpl::SessionId() const {
 
 void WebContentDecryptionModuleSessionImpl::InitializeNewSession(
     media::EmeInitDataType eme_init_data_type,
-    const unsigned char* init_data,
+    base::span<const unsigned char> init_data,
     size_t init_data_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(init_data);
+  DCHECK(!init_data.empty());
   DCHECK(session_id_.empty());
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
@@ -399,10 +406,10 @@ void WebContentDecryptionModuleSessionImpl::Load(
 }
 
 void WebContentDecryptionModuleSessionImpl::Update(
-    const uint8_t* response,
+    base::span<const uint8_t> response,
     size_t response_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(response);
+  DCHECK(!response.empty());
   DCHECK(!session_id_.empty());
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
index eac2f48cdb98b..799bd4bd830a9 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
@@ -11,6 +11,7 @@
 #include <string>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
@@ -44,12 +45,12 @@ class PLATFORM_EXPORT WebContentDecryptionModuleSessionImpl
   WebString SessionId() const override;
 
   void InitializeNewSession(media::EmeInitDataType init_data_type,
-                            const unsigned char* initData,
+                            base::span<const unsigned char> initData,
                             size_t initDataLength,
                             WebContentDecryptionModuleResult result) override;
   void Load(const WebString& session_id,
             WebContentDecryptionModuleResult result) override;
-  void Update(const uint8_t* response,
+  void Update(base::span<const uint8_t> response,
               size_t response_length,
               WebContentDecryptionModuleResult result) override;
   void Close(WebContentDecryptionModuleResult result) override;
diff --git a/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc b/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
index a6e197801df3f..35ed1f0982f4e 100644
--- a/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
+++ b/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -115,7 +117,7 @@ class FakeMediaStreamAudioSource final : public MediaStreamAudioSource,
 
       // Deliver the next chunk of audio data. Each sample value is its offset
       // from the very first sample.
-      float* const data = audio_bus_->channel(0);
+      const base::span<float> data = audio_bus_->channel(0);
       for (int i = 0; i < buffer_size; ++i)
         data[i] = ++sample_count_;
       CHECK_LT(sample_count_, kMaxValueSafelyConvertableToFloat);
diff --git a/ui/gfx/geometry/transform_unittest.cc b/ui/gfx/geometry/transform_unittest.cc
index f40b4761eb5cf..b04bb75eaa337 100644
--- a/ui/gfx/geometry/transform_unittest.cc
+++ b/ui/gfx/geometry/transform_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -1633,10 +1635,10 @@ double ComputeDecompRecompError(const Transform& transform) {
   DecomposedTransform decomp = *transform.Decompose();
   Transform composed = Transform::Compose(decomp);
 
-  float expected[16];
-  float actual[16];
-  transform.GetColMajorF(expected);
-  composed.GetColMajorF(actual);
+  std::array<float, 16> expected;
+  std::array<float, 16> actual;
+  transform.GetColMajorF(expected.data());
+  composed.GetColMajorF(actual.data());
   double sse = 0;
   for (int i = 0; i < 16; i++) {
     double diff = expected[i] - actual[i];
@@ -2023,19 +2025,36 @@ TEST(XFormTest, MakeRotation) {
 }
 
 TEST(XFormTest, ColMajorF) {
-  float data[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
-  auto transform = Transform::ColMajorF(data);
+  auto data = std::to_array<float>({
+      2,
+      3,
+      4,
+      5,
+      6,
+      7,
+      8,
+      9,
+      10,
+      11,
+      12,
+      13,
+      14,
+      15,
+      16,
+      17,
+  });
+  auto transform = Transform::ColMajorF(data.data());
 
   EXPECT_ROW0_EQ(2.0, 6.0, 10.0, 14.0, transform);
   EXPECT_ROW1_EQ(3.0, 7.0, 11.0, 15.0, transform);
   EXPECT_ROW2_EQ(4.0, 8.0, 12.0, 16.0, transform);
   EXPECT_ROW3_EQ(5.0, 9.0, 13.0, 17.0, transform);
 
-  float data1[16];
-  transform.GetColMajorF(data1);
+  std::array<float, 16> data1;
+  transform.GetColMajorF(data1.data());
   for (int i = 0; i < 16; i++)
     EXPECT_EQ(data1[i], data[i]);
-  EXPECT_EQ(transform, Transform::ColMajorF(data1));
+  EXPECT_EQ(transform, Transform::ColMajorF(data1.data()));
 }
 
 TEST(XFormTest, FromQuaternion) {
```

## Build Failure Log

```

18.46s Build Failure: 13 done 1 failed 32244 remaining - 0.70/s
 1 steps failed: remote-exec b36a471e45976dba4f9e2153f4fe1202030b5fbd3103ad5f2f74482843c68cf1/355 failed: exit=1
see ./out/linux/siso_output for full command line and output
 or ./out/linux/siso.INFO
use ./out/linux/siso_failed_commands.sh to re-run failed commands
real	0m18.929s
user	5m5.977s
sys	3m31.414s
ninja: Entering directory `out/linux'
init credentials done 37.770557ms
reapi instance: projects/rbe-chrome-untrusted/instances/default_instance
loading fs state done 1.240096583s
loading/recompacting deps log done 505.021005ms
load siso config done 383.151982ms
load build.ninja done 1.096975523s
schedule pending:0+ready:1 (node:310590 edge:2)
build start: Ready 1 Pending 1
rebuild manifest finished	
schedule pending:0+ready:1 (node:310590 edge:9)
build start: Ready 15287 Pending 102644
FAILED: d4993e6b-75a1-4556-8be8-d6be934f9f11 "./obj/media/filters/filters/audio_renderer_algorithm.o" CXX obj/media/filters/filters/audio_renderer_algorithm.o
err: remote-exec b36a471e45976dba4f9e2153f4fe1202030b5fbd3103ad5f2f74482843c68cf1/355 failed: exit=1
../../third_party/llvm-build/Release+Asserts/bin/clang++ -MMD -MF obj/media/filters/filters/audio_renderer_algorithm.o.d -DDCHECK_ALWAYS_ON=1 -DUSE_UDEV -DUSE_AURA=1 -DUSE_GLIB=1 -DUSE_OZONE=1 -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -DCR_CLANG_REVISION=\"llvmorg-21-init-5118-g52cd27e6-2\" -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_EXTENSIVE -DCOMPONENT_BUILD -D_LIBCPP_INSTRUMENTED_WITH_ASAN=0 -DCR_LIBCXX_REVISION=4f05e20cbe1d02fa0871ac88b30eead9e38cab3a -DTMP_REBUILD_HACK -DCR_SYSROOT_KEY=20250129T203412Z-1 -D_DEBUG -DDYNAMIC_ANNOTATIONS_ENABLED=1 -DIS_MEDIA_IMPL -DUSE_PULSEAUDIO -DDLOPEN_PULSEAUDIO -DGLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_56 -DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_56 -DSK_ENABLE_SKSL -DSK_UNTIL_CRBUG_1187654_IS_FIXED -DSK_USER_CONFIG_HEADER=\"../../skia/config/SkUserConfig.h\" -DSK_WIN_FONTMGR_NO_SIMULATIONS -DSK_DISABLE_LEGACY_INIT_DECODERS -DSK_CODEC_DECODES_JPEG -DSK_CODEC_ENCODES_JPEG -DSKIA_DLL -DSKCMS_API=__attribute__\(\(visibility\(\"default\"\)\)\) -DSK_GAMMA_EXPONENT=1.2 -DSK_GAMMA_CONTRAST=0.2 -DSK_GANESH -DSK_GPU_WORKAROUNDS_HEADER=\"gpu/config/gpu_driver_bug_workaround_autogen.h\" -DSK_GL -DSK_VULKAN=1 -DSK_GRAPHITE -DSK_DAWN -DVK_USE_PLATFORM_XCB_KHR -DVK_USE_PLATFORM_XLIB_KHR -DVK_USE_PLATFORM_WAYLAND_KHR -DCHROMIUM -DLIBYUV_DISABLE_NEON -DLIBYUV_DISABLE_SVE -DLIBYUV_DISABLE_SME -DLIBYUV_DISABLE_LSX -DLIBYUV_DISABLE_LASX -DABSL_CONSUME_DLL -DABSL_FLAGS_STRIP_NAMES=0 -DCR_CXX_INCLUDE=\"third_party/rust/chromium_crates_io/vendor/cxx-1.0.146/include/cxx.h\" -DBORINGSSL_SHARED_LIBRARY -DWGPU_SHARED_LIBRARY -DU_USING_ICU_NAMESPACE=0 -DU_ENABLE_DYLOAD=0 -DUSE_CHROMIUM_ICU=1 -DU_ENABLE_TRACING=1 -DU_ENABLE_RESOURCE_TRACING=0 -DICU_UTIL_DATA_IMPL=ICU_UTIL_DATA_FILE -DCRASHPAD_ZLIB_SOURCE_EXTERNAL -DGOOGLE_PROTOBUF_NO_RTTI -DHAVE_PTHREAD -DPROTOBUF_USE_DLLS -DCONFIG_LOG=1 -DHAVE_PTHREAD_GETAFFINITY_NP=1 -DHAVE_PTHREAD_SETAFFINITY_NP=1 -DDAV1D_API= -I../.. -Igen -I../../buildtools/third_party/libc++ -I../../third_party/perfetto/include -Igen/third_party/perfetto/build_config -Igen/third_party/perfetto -I../../third_party/skia -Igen/third_party/skia -I../../third_party/wuffs/src/release/c -I../../third_party/vulkan/include -I../../third_party/vulkan-headers/src/include -I../../third_party/wayland/src/src -I../../third_party/wayland/include/src -Igen/third_party/dawn/include -I../../third_party/dawn/include -I../../net/third_party/quiche/overrides -I../../net/third_party/quiche/src/quiche/common/platform/default -I../../net/third_party/quiche/src -I../../third_party/khronos -I../../gpu -I../../third_party/libyuv/include -I../../base/allocator/partition_allocator/src -Igen/base/allocator/partition_allocator/src -I../../third_party/abseil-cpp -I../../third_party/boringssl/src/include -I../../third_party/protobuf/src -I../../third_party/angle/include -I../../third_party/mesa_headers -I../../third_party/icu/source/common -I../../third_party/icu/source/i18n -I../../third_party/ipcz/include -I../../third_party/ced/src -I../../third_party/crashpad/crashpad -I../../third_party/crashpad/crashpad/compat/linux -I../../third_party/crashpad/crashpad/compat/non_win -I../../third_party/zlib -I../../third_party/libaom/source/libaom -I../../third_party/libaom/source/config/linux/x64 -Igen/net/third_party/quiche/src -I../../third_party/ffmpeg/chromium/config/Chromium/linux/x64 -I../../third_party/ffmpeg -I../../third_party/opus/src/include -I../../third_party/libvpx/source/libvpx -I../../third_party/libvpx/source/config/linux/x64 -I../../third_party/dav1d/version -Wall -Wextra -Wimplicit-fallthrough -Wextra-semi -Wunreachable-code-aggressive -Wthread-safety -Wgnu -Wno-gnu-anonymous-struct -Wno-gnu-conditional-omitted-operand -Wno-gnu-include-next -Wno-gnu-label-as-value -Wno-gnu-redeclared-enum -Wno-gnu-statement-expression -Wno-gnu-zero-variadic-macro-arguments -Wno-zero-length-array -Wno-missing-field-initializers -Wno-unused-parameter -Wno-psabi -Wloop-analysis -Wno-unneeded-internal-declaration -Wno-cast-function-type -Wno-thread-safety-reference-return -Wno-nontrivial-memcall -Wshadow -Werror -fno-delete-null-pointer-checks -fno-strict-overflow -fno-ident -fno-strict-aliasing -fstack-protector -funwind-tables -fPIC -pthread -fcolor-diagnostics -fmerge-all-constants -fno-sized-deallocation -fcrash-diagnostics-dir=../../tools/clang/crashreports -mllvm -instcombine-lower-dbg-declare=0 -mllvm -split-threshold-for-reg-with-hint=0 -ffp-contract=off -Wa,--crel,--allow-experimental-crel -fcomplete-member-pointers -m64 -msse3 -Wno-builtin-macro-redefined -D__DATE__= -D__TIME__= -D__TIMESTAMP__= -ffile-compilation-dir=. -no-canonical-prefixes -ftrivial-auto-var-init=pattern -O0 -fno-omit-frame-pointer -gdwarf-4 -g2 -gdwarf-aranges -gsplit-dwarf -ggnu-pubnames -Xclang -fuse-ctor-homing -fvisibility=hidden -Wheader-hygiene -Wstring-conversion -Wtautological-overlap-compare -Xclang -add-plugin -Xclang find-bad-constructs -Xclang -plugin-arg-find-bad-constructs -Xclang span-ctor-from-string-literal -Xclang -plugin-arg-find-bad-constructs -Xclang raw-ref-template-as-trivial-member -Xclang -plugin-arg-find-bad-constructs -Xclang raw-span-template-as-trivial-member -Xclang -plugin-arg-find-bad-constructs -Xclang check-stack-allocated -Xclang -plugin-arg-find-bad-constructs -Xclang check-ipc -Xclang -add-plugin -Xclang raw-ptr-plugin -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ptr-to-stack-allocated -Xclang -plugin-arg-raw-ptr-plugin -Xclang disable-check-raw-ptr-to-stack-allocated-error -Xclang -plugin-arg-raw-ptr-plugin -Xclang raw-ptr-exclude-path=../../third_party/dawn/ -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ptr-fields -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-span-fields -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ref-fields -DUNSAFE_BUFFERS_BUILD -Xclang -add-plugin -Xclang unsafe-buffers -Xclang -plugin-arg-unsafe-buffers -Xclang ../../build/config/unsafe_buffers_paths.txt -Wexit-time-destructors -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/include/glib-2.0 -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/lib/x86_64-linux-gnu/glib-2.0/include -Wno-redundant-parens -Wno-redundant-parens -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/include/nss -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/include/nspr -Wno-invalid-offsetof -Wenum-compare-conditional -Wno-c++11-narrowing-const-reference -Wno-missing-template-arg-list-after-template-kw -Wno-undefined-bool-conversion -Wno-tautological-undefined-compare -std=c++20 -Wno-trigraphs -gsimple-template-names -fno-exceptions -fno-rtti -nostdinc++ -isystem../../third_party/libc++/src/include -isystem../../third_party/libc++abi/src/include --sysroot=../../build/linux/debian_bullseye_amd64-sysroot -fvisibility-inlines-hidden  -c ../../media/filters/audio_renderer_algorithm.cc -o obj/media/filters/filters/audio_renderer_algorithm.o
build step: cxx "./obj/media/filters/filters/audio_renderer_algorithm.o"
siso_rule: clang/cxx
stdout:
In file included from ../../media/filters/audio_renderer_algorithm.cc:5:
In file included from ../../base/containers/span.h:37:
../../base/numerics/safe_conversions.h:271:47: error: no matching function for call to 'strict_cast'
  271 |   constexpr StrictNumeric(Src value) : value_(strict_cast<T>(value)) {}
      |                                               ^~~~~~~~~~~~~~
../../media/filters/audio_renderer_algorithm.cc:531:43: note: in instantiation of function template specialization 'base::internal::StrictNumeric<unsigned long>::StrictNumeric<int>' requested here
  531 |         wsola_output_->channel(k).subspan(num_complete_frames_);
      |                                           ^
../../base/numerics/safe_conversions.h:229:15: note: candidate template ignored: constraints not satisfied [with Dst = unsigned long, Src = int, SrcType = UnderlyingType<int>]
  229 | constexpr Dst strict_cast(Src value) {
      |               ^
../../base/numerics/safe_conversions.h:227:7: note: because 'kStaticDstRangeRelationToSrcRange<unsigned long, int> == NumericRangeRepresentation::kContained' evaluated to false
  227 |       kStaticDstRangeRelationToSrcRange<Dst, SrcType> ==
      |       ^
1 error generated.
build failed	
local:7 remote:6 cache:0 fallback:0 retry:0 skip:85674
reapi: ops: 4673(err:3157) / r:33(err:0) 290.03KiB / w:5511(err:239) 6.63MiB
fs: ops: 415207(err:156395) / r:16426(err:0) 140.78MiB / w:9(err:6) 144.95KiB
```

# Build Failure: 2025_03_19_patch_1137

## Chromium Revision

`ae47ae4e0c13026d1824b4cf4b9cea834dfd0cf4`

## Code Changes (Diff)

```diff
diff --git a/mojo/core/core_ipcz_test.cc b/mojo/core/core_ipcz_test.cc
index 52dc173da592b..385412972611e 100644
--- a/mojo/core/core_ipcz_test.cc
+++ b/mojo/core/core_ipcz_test.cc
@@ -130,7 +130,7 @@ class CoreIpczTest : public test::MojoTestBase {
   static void ReceiveInvitationTransport(MojoHandle pipe,
                                          InvitationDetails& details) {
     MojoHandle handle;
-    ReadMessageWithHandles(pipe, &handle, 1);
+    ReadMessageWithHandles(pipe, base::span<MojoHandle, 1>(&handle), 1);
 
     details.handle.struct_size = sizeof(details.handle);
     PlatformHandle::ToMojoPlatformHandle(
diff --git a/mojo/core/data_pipe_unittest.cc b/mojo/core/data_pipe_unittest.cc
index 9a311d56e9fa8..62f473d5c628f 100644
--- a/mojo/core/data_pipe_unittest.cc
+++ b/mojo/core/data_pipe_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -1795,7 +1797,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(NoSpuriousEventsHost, DataPipeTest, parent) {
   const std::vector<uint8_t> kData(512, 'x');
 
   MojoHandle client;
-  EXPECT_EQ("x", ReadMessageWithHandles(parent, &client, 1));
+  EXPECT_EQ("x", ReadMessageWithHandles(parent,
+                                        base::span<MojoHandle, 1>(&client), 1));
 
   for (size_t j = 0; j < kNoSpuriousEvents_NumIterations; ++j) {
     ScopedDataPipeProducerHandle producer;
@@ -1825,12 +1828,14 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(NoSpuriousEventsClient,
   base::test::TaskEnvironment task_environment;
 
   MojoHandle host;
-  EXPECT_EQ("x", ReadMessageWithHandles(parent, &host, 1));
+  EXPECT_EQ(
+      "x", ReadMessageWithHandles(parent, base::span<MojoHandle, 1>(&host), 1));
 
   size_t num_spurious_events = 0;
   for (size_t j = 0; j < kNoSpuriousEvents_NumIterations; ++j) {
     MojoHandle ch;
-    ASSERT_EQ("hi", ReadMessageWithHandles(host, &ch, 1));
+    ASSERT_EQ("hi",
+              ReadMessageWithHandles(host, base::span<MojoHandle, 1>(&ch), 1));
     ScopedDataPipeConsumerHandle consumer(DataPipeConsumerHandle{ch});
 
     SimpleWatcher watcher(FROM_HERE, SimpleWatcher::ArmingPolicy::MANUAL);
@@ -1988,7 +1993,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessClient, DataPipeTest, client_mp) {
 
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(WriteAndCloseProducer, DataPipeTest, h) {
   MojoHandle p;
-  std::string message = ReadMessageWithHandles(h, &p, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1);
 
   // Write some data to the producer and close it.
   uint32_t num_bytes = static_cast<uint32_t>(message.size());
@@ -2006,7 +2012,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(WriteAndCloseProducer, DataPipeTest, h) {
 
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadAndCloseConsumer, DataPipeTest, h) {
   MojoHandle c;
-  std::string expected_message = ReadMessageWithHandles(h, &c, 1);
+  std::string expected_message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&c), 1);
 
   // Wait for the consumer to become readable.
   EXPECT_EQ(MOJO_RESULT_OK, WaitForSignals(c, MOJO_HANDLE_SIGNAL_READABLE));
@@ -2074,7 +2081,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(CreateAndWrite, DataPipeTest, h) {
 TEST_F(DataPipeTest, CreateInChild) {
   RunTestClient("CreateAndWrite", [&](MojoHandle child) {
     MojoHandle c;
-    std::string expected_message = ReadMessageWithHandles(child, &c, 1);
+    std::string expected_message =
+        ReadMessageWithHandles(child, base::span<MojoHandle, 1>(&c), 1);
 
     // Wait for the consumer to become readable.
     EXPECT_EQ(MOJO_RESULT_OK, WaitForSignals(c, MOJO_HANDLE_SIGNAL_READABLE));
@@ -2100,7 +2108,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(DataPipeStatusChangeInTransitClient,
   // This test verifies that peer closure is detectable through various
   // mechanisms when it races with handle transfer.
 
-  MojoHandle handles[6];
+  std::array<MojoHandle, 6> handles;
   EXPECT_EQ("o_O", ReadMessageWithHandles(parent, handles, 6));
   MojoHandle* producers = &handles[0];
   MojoHandle* consumers = &handles[3];
@@ -2370,7 +2378,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(StressTestRacyTrapsClient, DataPipeTest, h) {
 
   constexpr uint32_t kChunkSize = 4096;
   MojoHandle p;
-  EXPECT_EQ("sup", ReadMessageWithHandles(h, &p, 1));
+  EXPECT_EQ("sup", ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1));
   base::RunLoop loop;
   TestDataProducer producer(
       ScopedDataPipeProducerHandle{DataPipeProducerHandle{p}},
diff --git a/mojo/core/embedder_unittest.cc b/mojo/core/embedder_unittest.cc
index 56adf67612e23..dabaa1da56631 100644
--- a/mojo/core/embedder_unittest.cc
+++ b/mojo/core/embedder_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -137,7 +139,8 @@ TEST_F(EmbedderTest, SendMessagePipeWithWriteQueue) {
   client_mp2 = MOJO_HANDLE_INVALID;
 
   // Read client2 just so we can close it later.
-  EXPECT_EQ("hey", ReadMessageWithHandles(client_mp, &client_mp2, 1));
+  EXPECT_EQ("hey", ReadMessageWithHandles(
+                       client_mp, base::span<MojoHandle, 1>(&client_mp2), 1));
   EXPECT_NE(MOJO_HANDLE_INVALID, client_mp2);
 
   // Now verify that all the messages that were written were sent correctly.
@@ -173,7 +176,8 @@ TEST_F(EmbedderTest, ChannelsHandlePassing) {
   WriteMessage(h0, kFoo);
 
   // Wait for |client_mp| to become readable and read a message from it.
-  EXPECT_EQ(kWorld, ReadMessageWithHandles(client_mp, &h1, 1));
+  EXPECT_EQ(kWorld, ReadMessageWithHandles(client_mp,
+                                           base::span<MojoHandle, 1>(&h1), 1));
   EXPECT_NE(h1, MOJO_HANDLE_INVALID);
 
   // Wait for |h1| to become readable and read a message from it.
@@ -233,7 +237,8 @@ TEST_F(EmbedderTest, MultiprocessChannels) {
 
     // 6. Read a message from |mp0|, which should have |mp2| attached.
     MojoHandle mp2 = MOJO_HANDLE_INVALID;
-    EXPECT_EQ("quux", ReadMessageWithHandles(mp0, &mp2, 1));
+    EXPECT_EQ("quux",
+              ReadMessageWithHandles(mp0, base::span<MojoHandle, 1>(&mp2), 1));
 
     // 7. Read a message from |mp2|.
     EXPECT_EQ("baz", ReadMessage(mp2));
@@ -267,7 +272,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessChannelsClient,
 
   // 4. Read a message from |client_mp|, which should have |mp1| attached.
   MojoHandle mp1;
-  EXPECT_EQ("Bar", ReadMessageWithHandles(client_mp, &mp1, 1));
+  EXPECT_EQ("Bar", ReadMessageWithHandles(client_mp,
+                                          base::span<MojoHandle, 1>(&mp1), 1));
 
   // 5. Create a new message pipe (endpoints |mp2| and |mp3|).
   MojoHandle mp2, mp3;
@@ -346,7 +352,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessSharedMemoryClient,
   // 1. Read the first message from |client_mp|, which should have |sb1| which
   // should be a shared buffer handle.
   MojoHandle sb1;
-  EXPECT_EQ("hello", ReadMessageWithHandles(client_mp, &sb1, 1));
+  EXPECT_EQ("hello", ReadMessageWithHandles(
+                         client_mp, base::span<MojoHandle, 1>(&sb1), 1));
 
   // 2. Map |sb1|.
   char* buffer = nullptr;
diff --git a/mojo/core/invitation_unittest.cc b/mojo/core/invitation_unittest.cc
index 25058459f37be..aed70e1960fe4 100644
--- a/mojo/core/invitation_unittest.cc
+++ b/mojo/core/invitation_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -951,7 +953,8 @@ DEFINE_TEST_CLIENT(NonBrokerToNonBrokerHost) {
   MojoHandle test = ExtractPipeFromInvitation(invitation);
 
   MojoHandle pipe_for_client;
-  EXPECT_EQ("aaa", ReadMessageWithHandles(test, &pipe_for_client, 1));
+  EXPECT_EQ("aaa", ReadMessageWithHandles(
+                       test, base::span<MojoHandle, 1>(&pipe_for_client), 1));
 
   MojoHandle client;
   base::Process client_process =
@@ -978,7 +981,8 @@ DEFINE_TEST_CLIENT(NonBrokerToNonBrokerClient) {
   MojoHandle host = ExtractPipeFromInvitation(invitation);
 
   MojoHandle pipe_to_test;
-  EXPECT_EQ("ddd", ReadMessageWithHandles(host, &pipe_to_test, 1));
+  EXPECT_EQ("ddd", ReadMessageWithHandles(
+                       host, base::span<MojoHandle, 1>(&pipe_to_test), 1));
 
   EXPECT_EQ("bbb", ReadMessage(pipe_to_test));
   WriteMessage(pipe_to_test, "ccc");
@@ -1055,7 +1059,8 @@ DEFINE_TEST_CLIENT(SecondaryBroker) {
   MojoHandle test_runner = ExtractPipeFromInvitation(invitation);
 
   MojoHandle client;
-  EXPECT_EQ("hi", ReadMessageWithHandles(test_runner, &client, 1));
+  EXPECT_EQ("hi", ReadMessageWithHandles(
+                      test_runner, base::span<MojoHandle, 1>(&client), 1));
 
   // Note that handle passing can succeed even if communication is broken
   // between non-brokers and secondary brokers, as long as no direct link
@@ -1064,7 +1069,8 @@ DEFINE_TEST_CLIENT(SecondaryBroker) {
   for (size_t i = 0; i < kNumMultiBrokerMessageIterations; ++i) {
     MojoHandle buffer = CreateMemory("lol");
     WriteMessageWithHandles(client, "aaa", &buffer, 1);
-    EXPECT_EQ("bbb", ReadMessageWithHandles(client, &buffer, 1));
+    EXPECT_EQ("bbb", ReadMessageWithHandles(
+                         client, base::span<MojoHandle, 1>(&buffer), 1));
     EXPECT_EQ("lmao", ReadMemory(buffer));
   }
 
@@ -1080,12 +1086,16 @@ DEFINE_TEST_CLIENT(MultiBrokerNetworkClient) {
   MojoHandle test_runner = ExtractPipeFromInvitation(invitation);
 
   MojoHandle secondary_broker;
-  EXPECT_EQ("hi", ReadMessageWithHandles(test_runner, &secondary_broker, 1));
+  EXPECT_EQ("hi",
+            ReadMessageWithHandles(
+                test_runner, base::span<MojoHandle, 1>(&secondary_broker), 1));
 
   for (size_t i = 0; i < kNumMultiBrokerMessageIterations; ++i) {
     MojoHandle buffer = CreateMemory("lmao");
     WriteMessageWithHandles(secondary_broker, "bbb", &buffer, 1);
-    EXPECT_EQ("aaa", ReadMessageWithHandles(secondary_broker, &buffer, 1));
+    EXPECT_EQ("aaa",
+              ReadMessageWithHandles(secondary_broker,
+                                     base::span<MojoHandle, 1>(&buffer), 1));
     EXPECT_EQ("lol", ReadMemory(buffer));
   }
 
diff --git a/mojo/core/ipcz_driver/transport_test.cc b/mojo/core/ipcz_driver/transport_test.cc
index bf9b37317810a..0887fe0e4d7de 100644
--- a/mojo/core/ipcz_driver/transport_test.cc
+++ b/mojo/core/ipcz_driver/transport_test.cc
@@ -88,7 +88,8 @@ class MojoIpczTransportTest : public test::MojoTestBase {
   // constructed Transport over it.
   static scoped_refptr<Transport> ReceiveTransport(MojoHandle pipe) {
     MojoHandle transport_for_client;
-    ReadMessageWithHandles(pipe, &transport_for_client, 1);
+    ReadMessageWithHandles(pipe,
+                           base::span<MojoHandle, 1>(&transport_for_client), 1);
     PlatformHandle handle =
         UnwrapPlatformHandle(ScopedHandle(Handle(transport_for_client)));
     return Transport::Create(
diff --git a/mojo/core/message_pipe_unittest.cc b/mojo/core/message_pipe_unittest.cc
index b8c51c3435d20..5561643a374e7 100644
--- a/mojo/core/message_pipe_unittest.cc
+++ b/mojo/core/message_pipe_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -329,7 +331,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(HandlePingPong, MessagePipeTest, h) {
   for (size_t i = 0; i < kPingPongIterations; i++) {
     MojoHandle handles[kPingPongHandlesPerIteration];
     ReadMessageWithHandles(h, handles, kPingPongHandlesPerIteration);
-    WriteMessageWithHandles(h, "", handles, kPingPongHandlesPerIteration);
+    WriteMessageWithHandles(h, "", handles.data(),
+                            kPingPongHandlesPerIteration);
   }
 
   EXPECT_EQ(MOJO_RESULT_OK, WaitForSignals(h, MOJO_HANDLE_SIGNAL_READABLE));
@@ -340,7 +343,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(HandlePingPong, MessagePipeTest, h) {
 }
 
 TEST_F(MessagePipeTest, DataPipeConsumerHandlePingPong) {
-  MojoHandle p, c[kPingPongHandlesPerIteration];
+  std::array<MojoHandle, kPingPongHandlesPerIteration> c;
   for (size_t i = 0; i < kPingPongHandlesPerIteration; ++i) {
     EXPECT_EQ(MOJO_RESULT_OK, MojoCreateDataPipe(nullptr, &p, &c[i]));
     MojoClose(p);
@@ -348,7 +351,7 @@ TEST_F(MessagePipeTest, DataPipeConsumerHandlePingPong) {
 
   RunTestClient("HandlePingPong", [&](MojoHandle h) {
     for (size_t i = 0; i < kPingPongIterations; i++) {
-      WriteMessageWithHandles(h, "", c, kPingPongHandlesPerIteration);
+      WriteMessageWithHandles(h, "", c.data(), kPingPongHandlesPerIteration);
       ReadMessageWithHandles(h, c, kPingPongHandlesPerIteration);
     }
     WriteMessage(h, "quit", 4);
@@ -358,7 +361,7 @@ TEST_F(MessagePipeTest, DataPipeConsumerHandlePingPong) {
 }
 
 TEST_F(MessagePipeTest, DataPipeProducerHandlePingPong) {
-  MojoHandle p[kPingPongHandlesPerIteration], c;
+  std::array<MojoHandle, kPingPongHandlesPerIteration> p, c;
   for (size_t i = 0; i < kPingPongHandlesPerIteration; ++i) {
     EXPECT_EQ(MOJO_RESULT_OK, MojoCreateDataPipe(nullptr, &p[i], &c));
     MojoClose(c);
@@ -366,7 +369,7 @@ TEST_F(MessagePipeTest, DataPipeProducerHandlePingPong) {
 
   RunTestClient("HandlePingPong", [&](MojoHandle h) {
     for (size_t i = 0; i < kPingPongIterations; i++) {
-      WriteMessageWithHandles(h, "", p, kPingPongHandlesPerIteration);
+      WriteMessageWithHandles(h, "", p.data(), kPingPongHandlesPerIteration);
       ReadMessageWithHandles(h, p, kPingPongHandlesPerIteration);
     }
     WriteMessage(h, "quit", 4);
@@ -382,13 +385,14 @@ TEST_F(MessagePipeTest, DataPipeProducerHandlePingPong) {
 #define MAYBE_SharedBufferHandlePingPong SharedBufferHandlePingPong
 #endif  // BUILDFLAG(IS_IOS)
 TEST_F(MessagePipeTest, MAYBE_SharedBufferHandlePingPong) {
-  MojoHandle buffers[kPingPongHandlesPerIteration];
+  std::array<MojoHandle, kPingPongHandlesPerIteration> buffers;
   for (size_t i = 0; i < kPingPongHandlesPerIteration; ++i)
     EXPECT_EQ(MOJO_RESULT_OK, MojoCreateSharedBuffer(1, nullptr, &buffers[i]));
 
   RunTestClient("HandlePingPong", [&](MojoHandle h) {
     for (size_t i = 0; i < kPingPongIterations; i++) {
-      WriteMessageWithHandles(h, "", buffers, kPingPongHandlesPerIteration);
+      WriteMessageWithHandles(h, "", buffers.data(),
+                              kPingPongHandlesPerIteration);
       ReadMessageWithHandles(h, buffers, kPingPongHandlesPerIteration);
     }
     WriteMessage(h, "quit", 4);
diff --git a/mojo/core/message_unittest.cc b/mojo/core/message_unittest.cc
index 20822a42008b0..a39874d047a3e 100644
--- a/mojo/core/message_unittest.cc
+++ b/mojo/core/message_unittest.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -309,7 +313,8 @@ TEST_F(MessageTest, MAYBE_SerializeDynamicallySizedMessage) {
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReceiveMessageOneHandle, MessageTest, h) {
   MojoTestBase::WaitForSignals(h, MOJO_HANDLE_SIGNAL_READABLE);
   MojoHandle h1;
-  auto m = MojoTestBase::ReadMessageWithHandles(h, &h1, 1);
+  auto m = MojoTestBase::ReadMessageWithHandles(
+      h, base::span<MojoHandle, 1>(&h1), 1);
   EXPECT_EQ(kTestMessageWithContext1, m);
   MojoTestBase::WriteMessage(h1, kTestMessageWithContext2);
   EXPECT_EQ(kTestQuitMessage, MojoTestBase::ReadMessage(h));
@@ -1076,7 +1081,7 @@ TEST_F(MessageTest, MAYBE_ExtendPayloadWithHandlesAttached) {
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadAndIgnoreMessage, MessageTest, h) {
   MojoTestBase::WaitForSignals(h, MOJO_HANDLE_SIGNAL_READABLE);
 
-  MojoHandle handles[5];
+  std::array<MojoHandle, 5> handles;
   MojoTestBase::ReadMessageWithHandles(h, handles, 5);
   for (size_t i = 0; i < 5; ++i)
     EXPECT_EQ(MOJO_RESULT_OK, MojoClose(handles[i]));
@@ -1139,7 +1144,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadMessageAndCheckPipe, MessageTest, h) {
   MojoTestBase::WaitForSignals(h, MOJO_HANDLE_SIGNAL_READABLE);
 
   const std::string kTestMessage("hey pipe");
-  MojoHandle handles[5];
+  std::array<MojoHandle, 5> handles;
   MojoTestBase::ReadMessageWithHandles(h, handles, 5);
   MojoTestBase::WriteMessage(handles[0], kTestMessage);
   MojoTestBase::WaitForSignals(handles[4], MOJO_HANDLE_SIGNAL_READABLE);
diff --git a/mojo/core/multiprocess_message_pipe_unittest.cc b/mojo/core/multiprocess_message_pipe_unittest.cc
index 3139e6d18d598..e4ff8aa36b874 100644
--- a/mojo/core/multiprocess_message_pipe_unittest.cc
+++ b/mojo/core/multiprocess_message_pipe_unittest.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -111,7 +115,8 @@ class MultiprocessMessagePipeTest : public test::MojoTestBase {
     MojoHandle RetrieveHandle(const std::string& name) {
       WriteMessage(h_, "return:" + name);
       MojoHandle p;
-      EXPECT_EQ("ok", ReadMessageWithHandles(h_, &p, 1));
+      EXPECT_EQ("ok",
+                ReadMessageWithHandles(h_, base::span<MojoHandle, 1>(&p), 1));
       return p;
     }
 
@@ -738,7 +743,8 @@ TEST_P(MultiprocessMessagePipeTestWithPeerSupport, PassMessagePipeLocal) {
   // Pass p2 over p0 to p1.
   const std::string message = "ceci n'est pas une pipe";
   WriteMessageWithHandles(p0, message, &p2, 1);
-  EXPECT_EQ(message, ReadMessageWithHandles(p1, &p2, 1));
+  EXPECT_EQ(message,
+            ReadMessageWithHandles(p1, base::span<MojoHandle, 1>(&p2), 1));
 
   CloseHandle(p0);
   CloseHandle(p1);
@@ -780,7 +786,7 @@ DEFINE_TEST_CLIENT_WITH_PIPE(EchoServiceClient,
                              MultiprocessMessagePipeTest,
                              h) {
   MojoHandle p;
-  ReadMessageWithHandles(h, &p, 1);
+  ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1);
   for (;;) {
     std::string message = ReadMessage(p);
     if (message == "exit")
@@ -814,7 +820,7 @@ DEFINE_TEST_CLIENT_WITH_PIPE(EchoServiceFactoryClient,
                              MultiprocessMessagePipeTest,
                              h) {
   MojoHandle p;
-  ReadMessageWithHandles(h, &p, 1);
+  ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1);
 
   std::vector<Handle> handles(2);
   handles[0] = Handle(h);
@@ -833,7 +839,7 @@ DEFINE_TEST_CLIENT_WITH_PIPE(EchoServiceFactoryClient,
     } else if (index == 1) {
       // If the second pipe, it should be a new handle requesting echo service.
       MojoHandle echo_request;
-      ReadMessageWithHandles(p, &echo_request, 1);
+      ReadMessageWithHandles(p, base::span<MojoHandle, 1>(&echo_request), 1);
       handles.push_back(Handle(echo_request));
       signals.push_back(MOJO_HANDLE_SIGNAL_READABLE);
     } else {
@@ -921,11 +927,11 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(PingPongPipeClient,
                                   h) {
   const size_t kNumBounces = 50;
   MojoHandle p0, p1;
-  ReadMessageWithHandles(h, &p0, 1);
-  ReadMessageWithHandles(h, &p1, 1);
+  ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p0), 1);
+  ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p1), 1);
   for (size_t i = 0; i < kNumBounces; ++i) {
     WriteMessageWithHandles(h, "", &p1, 1);
-    ReadMessageWithHandles(h, &p1, 1);
+    ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p1), 1);
   }
   WriteMessageWithHandles(h, "", &p0, 1);
   WriteMessage(p1, "bye");
@@ -943,10 +949,10 @@ TEST_P(MultiprocessMessagePipeTestWithPeerSupport, PingPongPipe) {
     WriteMessageWithHandles(h, "", &p0, 1);
     WriteMessageWithHandles(h, "", &p1, 1);
     for (size_t i = 0; i < kNumBounces; ++i) {
-      ReadMessageWithHandles(h, &p1, 1);
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p1), 1);
       WriteMessageWithHandles(h, "", &p1, 1);
     }
-    ReadMessageWithHandles(h, &p0, 1);
+    ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p0), 1);
     EXPECT_EQ("bye", ReadMessage(p0));
     WriteMessage(h, "quit");
   });
@@ -1016,7 +1022,7 @@ DEFINE_TEST_CLIENT_WITH_PIPE(CommandDrivenClient,
       CHECK_EQ(p, MOJO_HANDLE_INVALID);
       MojoHandle carrier = named_pipes[parts[2]];
       CHECK_NE(carrier, MOJO_HANDLE_INVALID);
-      ReadMessageWithHandles(carrier, &p, 1);
+      ReadMessageWithHandles(carrier, base::span<MojoHandle, 1>(&p), 1);
       CHECK_NE(p, MOJO_HANDLE_INVALID);
       named_pipes[parts[1]] = p;
       WriteMessage(h, "ok");
@@ -1138,7 +1144,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReceivePipeWithClosedPeer,
                                   MultiprocessMessagePipeTest,
                                   h) {
   MojoHandle p;
-  EXPECT_EQ("foo", ReadMessageWithHandles(h, &p, 1));
+  EXPECT_EQ("foo", ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1));
   EXPECT_EQ(MOJO_RESULT_OK, WaitForSignals(p, MOJO_HANDLE_SIGNAL_PEER_CLOSED));
   MojoClose(p);
   MojoClose(h);
@@ -1183,12 +1189,14 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReceivePipeWithClosedPeerFromOtherChild,
                                   h) {
   // Receive a pipe from the parent. This is akin to an "application request".
   MojoHandle application_client;
-  EXPECT_EQ("c2a", ReadMessageWithHandles(h, &application_client, 1));
+  EXPECT_EQ("c2a", ReadMessageWithHandles(
+                       h, base::span<MojoHandle, 1>(&application_client), 1));
 
   // Receive a pipe from the "application" "client".
   MojoHandle service_client;
-  EXPECT_EQ("c2s lol",
-            ReadMessageWithHandles(application_client, &service_client, 1));
+  EXPECT_EQ("c2s lol", ReadMessageWithHandles(
+                           application_client,
+                           base::span<MojoHandle, 1>(&service_client), 1));
 
   // Wait for the service client to signal closure.
   EXPECT_EQ(MOJO_RESULT_OK,
@@ -1215,8 +1223,10 @@ TEST_F(MultiprocessMessagePipeTest,
           // Receive an "application request" from the first child and forward
           // it to the second child.
           MojoHandle application_request;
-          EXPECT_EQ("c2a plz",
-                    ReadMessageWithHandles(kid_a, &application_request, 1));
+          EXPECT_EQ(
+              "c2a plz",
+              ReadMessageWithHandles(
+                  kid_a, base::span<MojoHandle, 1>(&application_request), 1));
 
           WriteMessageWithHandles(kid_b, "c2a", &application_request, 1);
         });
@@ -1234,9 +1244,9 @@ TEST_P(MultiprocessMessagePipeTestWithPeerSupport, SendClosePeerSend) {
 
   // Send |a| over |c|, immediately close |b|, then send |a| back over |d|.
   WriteMessageWithHandles(c, "foo", &a, 1);
-  EXPECT_EQ("foo", ReadMessageWithHandles(d, &a, 1));
+  EXPECT_EQ("foo", ReadMessageWithHandles(d, base::span<MojoHandle, 1>(&a), 1));
   WriteMessageWithHandles(d, "bar", &a, 1);
-  EXPECT_EQ("bar", ReadMessageWithHandles(c, &a, 1));
+  EXPECT_EQ("bar", ReadMessageWithHandles(c, base::span<MojoHandle, 1>(&a), 1));
   EXPECT_EQ(MOJO_RESULT_OK, MojoClose(b));
 
   // We should be able to detect peer closure on |a|.
@@ -1263,7 +1273,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(WriteCloseSendPeerClient,
   // Pass the orphaned endpoint over another pipe before passing it back to
   // the parent, just for some extra proxying goodness.
   WriteMessageWithHandles(c, "foo", &pipe[1], 1);
-  EXPECT_EQ("foo", ReadMessageWithHandles(d, &pipe[1], 1));
+  EXPECT_EQ("foo", ReadMessageWithHandles(
+                       d, base::span<MojoHandle>(pipe).subspan(1), 1));
 
   // And finally pass it back to the parent.
   WriteMessageWithHandles(h, "bar", &pipe[1], 1);
@@ -1284,7 +1295,8 @@ TEST_P(MultiprocessMessagePipeTestWithPeerSupport, WriteCloseSendPeer) {
 
     // Read back an endpoint which should have messages on it.
     MojoHandle p;
-    EXPECT_EQ("bar", ReadMessageWithHandles(h, &p, 1));
+    EXPECT_EQ("bar",
+              ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&p), 1));
 
     EXPECT_EQ("baz", ReadMessage(p));
     EXPECT_EQ("qux", ReadMessage(p));
@@ -1303,7 +1315,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MessagePipeStatusChangeInTransitClient,
                                   parent) {
   // This test verifies that peer closure is detectable through various
   // mechanisms when it races with handle transfer.
-  MojoHandle handles[4];
+  std::array<MojoHandle, 4> handles;
   EXPECT_EQ("o_O", ReadMessageWithHandles(parent, handles, 4));
 
   EXPECT_EQ(MOJO_RESULT_OK,
@@ -1354,7 +1366,8 @@ TEST_P(MultiprocessMessagePipeTestWithPeerSupport,
   RunTestClient("SpotaneouslyDyingProcess", [&](MojoHandle child) {
     MojoHandle receiver;
     VerifyEcho(child, "!");
-    EXPECT_EQ("receiver", ReadMessageWithHandles(child, &receiver, 1));
+    EXPECT_EQ("receiver", ReadMessageWithHandles(
+                              child, base::span<MojoHandle, 1>(&receiver), 1));
     EXPECT_EQ("ok", ReadMessage(receiver));
     EXPECT_EQ(MOJO_RESULT_OK, MojoClose(receiver));
   });
@@ -1388,7 +1401,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(SpotaneouslyDyingProcess,
 
 TEST_F(MultiprocessMessagePipeTest, MessagePipeStatusChangeInTransit) {
   MojoHandle local_handles[4];
-  MojoHandle sent_handles[4];
+  std::array<MojoHandle, 4> sent_handles;
   for (size_t i = 0; i < 4; ++i)
     CreateMessagePipe(&local_handles[i], &sent_handles[i]);
 
@@ -1396,7 +1409,7 @@ TEST_F(MultiprocessMessagePipeTest, MessagePipeStatusChangeInTransit) {
                 [&](MojoHandle child) {
                   // Send 4 handles and let their transfer race with their
                   // peers' closure.
-                  WriteMessageWithHandles(child, "o_O", sent_handles, 4);
+                  WriteMessageWithHandles(child, "o_O", sent_handles.data(), 4);
                   for (size_t i = 0; i < 4; ++i)
                     CloseHandle(local_handles[i]);
                 });
@@ -1406,7 +1419,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(BadMessageClient,
                                   MultiprocessMessagePipeTest,
                                   parent) {
   MojoHandle pipe;
-  EXPECT_EQ("hi", ReadMessageWithHandles(parent, &pipe, 1));
+  EXPECT_EQ("hi", ReadMessageWithHandles(parent,
+                                         base::span<MojoHandle, 1>(&pipe), 1));
   WriteMessage(pipe, "derp");
   EXPECT_EQ("bye", ReadMessage(parent));
 }
diff --git a/mojo/core/platform_wrapper_unittest.cc b/mojo/core/platform_wrapper_unittest.cc
index 555397d017161..7bb9afd342f4d 100644
--- a/mojo/core/platform_wrapper_unittest.cc
+++ b/mojo/core/platform_wrapper_unittest.cc
@@ -109,7 +109,8 @@ TEST_F(PlatformWrapperTest, MAYBE_WrapPlatformHandle) {
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadPlatformFile, PlatformWrapperTest, h) {
   // Read a message and a wrapped file handle; unwrap the handle.
   MojoHandle wrapped_handle;
-  std::string message = ReadMessageWithHandles(h, &wrapped_handle, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&wrapped_handle), 1);
 
   MojoPlatformHandle platform_handle;
   platform_handle.struct_size = sizeof(MojoPlatformHandle);
@@ -188,7 +189,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadPlatformSharedBuffer,
                                   h) {
   // Read a message and a wrapped shared buffer handle.
   MojoHandle wrapped_handle;
-  std::string message = ReadMessageWithHandles(h, &wrapped_handle, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&wrapped_handle), 1);
 
   // Check the message in the buffer
   ExpectBufferContents(wrapped_handle, 0, message);
diff --git a/mojo/core/shared_buffer_unittest.cc b/mojo/core/shared_buffer_unittest.cc
index c5f9188af6aef..79358faa6a075 100644
--- a/mojo/core/shared_buffer_unittest.cc
+++ b/mojo/core/shared_buffer_unittest.cc
@@ -10,6 +10,7 @@
 #include <string>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/memory/platform_shared_memory_region.h"
 #include "base/notreached.h"
 #include "build/blink_buildflags.h"
@@ -58,7 +59,8 @@ TEST_F(SharedBufferTest, PassSharedBufferLocal) {
   CreateMessagePipe(&p0, &p1);
 
   WriteMessageWithHandles(p0, "...", &dupe, 1);
-  EXPECT_EQ("...", ReadMessageWithHandles(p1, &dupe, 1));
+  EXPECT_EQ("...",
+            ReadMessageWithHandles(p1, base::span<MojoHandle, 1>(&dupe), 1));
 
   ExpectBufferContents(dupe, 0, message);
   EXPECT_EQ(MOJO_RESULT_OK, MojoClose(h));
@@ -73,7 +75,8 @@ TEST_F(SharedBufferTest, PassSharedBufferLocal) {
 // the message contents into it, then exits.
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(CopyToBufferClient, SharedBufferTest, h) {
   MojoHandle b;
-  std::string message = ReadMessageWithHandles(h, &b, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1);
   WriteToBuffer(b, 0, message);
 
   EXPECT_EQ("quit", ReadMessage(h));
@@ -124,7 +127,7 @@ TEST_F(SharedBufferTest, MAYBE_PassSharedBufferFromChild) {
   MojoHandle b;
   RunTestClient("CreateBufferClient", [&](MojoHandle h) {
     WriteMessage(h, message);
-    ReadMessageWithHandles(h, &b, 1);
+    ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1);
     WriteMessage(h, "quit");
   });
 
@@ -136,7 +139,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(CreateAndPassBuffer, SharedBufferTest, h) {
   // Receive a pipe handle over the primordial pipe. This will be connected to
   // another child process.
   MojoHandle other_child;
-  std::string message = ReadMessageWithHandles(h, &other_child, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&other_child), 1);
 
   // Create a new shared buffer.
   MojoHandle b = CreateBuffer(message.size());
@@ -155,11 +159,12 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReceiveAndEditBuffer, SharedBufferTest, h) {
   // Receive a pipe handle over the primordial pipe. This will be connected to
   // another child process (running CreateAndPassBuffer).
   MojoHandle other_child;
-  std::string message = ReadMessageWithHandles(h, &other_child, 1);
+  std::string message =
+      ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&other_child), 1);
 
   // Receive a shared buffer from the other child.
   MojoHandle b;
-  ReadMessageWithHandles(other_child, &b, 1);
+  ReadMessageWithHandles(other_child, base::span<MojoHandle, 1>(&b), 1);
 
   // Write the message from the parent into the buffer and exit.
   WriteToBuffer(b, 0, message);
@@ -191,7 +196,7 @@ TEST_F(SharedBufferTest, MAYBE_PassSharedBufferFromChildToChild) {
       WriteMessageWithHandles(h1, message, &p1, 1);
 
       // Receive the buffer back from the first child.
-      ReadMessageWithHandles(h0, &b, 1);
+      ReadMessageWithHandles(h0, base::span<MojoHandle, 1>(&b), 1);
 
       WriteMessage(h1, "quit");
     });
@@ -209,13 +214,15 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(CreateAndPassBufferParent,
   RunTestClient("CreateAndPassBuffer", [&](MojoHandle child) {
     // Read a pipe from the parent and forward it to our child.
     MojoHandle pipe;
-    std::string message = ReadMessageWithHandles(parent, &pipe, 1);
+    std::string message =
+        ReadMessageWithHandles(parent, base::span<MojoHandle, 1>(&pipe), 1);
 
     WriteMessageWithHandles(child, message, &pipe, 1);
 
     // Read a buffer handle from the child and pass it back to the parent.
     MojoHandle buffer;
-    EXPECT_EQ("", ReadMessageWithHandles(child, &buffer, 1));
+    EXPECT_EQ("", ReadMessageWithHandles(
+                      child, base::span<MojoHandle, 1>(&buffer), 1));
     WriteMessageWithHandles(parent, "", &buffer, 1);
 
     EXPECT_EQ("quit", ReadMessage(parent));
@@ -230,7 +237,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReceiveAndEditBufferParent,
   RunTestClient("ReceiveAndEditBuffer", [&](MojoHandle child) {
     // Read a pipe from the parent and forward it to our child.
     MojoHandle pipe;
-    std::string message = ReadMessageWithHandles(parent, &pipe, 1);
+    std::string message =
+        ReadMessageWithHandles(parent, base::span<MojoHandle, 1>(&pipe), 1);
     WriteMessageWithHandles(child, message, &pipe, 1);
 
     EXPECT_EQ("quit", ReadMessage(parent));
@@ -267,7 +275,7 @@ TEST_F(SharedBufferTest, MAYBE_PassHandleBetweenCousins) {
       WriteMessageWithHandles(child2, message, &pipe[1], 1);
 
       // Receive the buffer back from the first child.
-      ReadMessageWithHandles(child1, &b, 1);
+      ReadMessageWithHandles(child1, base::span<MojoHandle, 1>(&b), 1);
 
       WriteMessage(child2, "quit");
     });
@@ -284,7 +292,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadAndMapWriteSharedBuffer,
                                   h) {
   // Receive the shared buffer.
   MojoHandle b;
-  EXPECT_EQ("hello", ReadMessageWithHandles(h, &b, 1));
+  EXPECT_EQ("hello",
+            ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
 
   // Read from the bufer.
   ExpectBufferContents(b, 0, "hello");
@@ -363,7 +372,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(CreateAndPassReadOnlyBuffer,
 TEST_F(SharedBufferTest, MAYBE_CreateAndPassFromChildReadOnlyBuffer) {
   RunTestClient("CreateAndPassReadOnlyBuffer", [&](MojoHandle h) {
     MojoHandle b;
-    EXPECT_EQ("", ReadMessageWithHandles(h, &b, 1));
+    EXPECT_EQ("", ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
     ExpectBufferContents(b, 0, "hello");
 
     // Extract the shared memory handle and verify that it is read-only.
diff --git a/mojo/core/signals_unittest.cc b/mojo/core/signals_unittest.cc
index 55af00c0be267..b31a8a9d93dbc 100644
--- a/mojo/core/signals_unittest.cc
+++ b/mojo/core/signals_unittest.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
 #include "build/build_config.h"
 #include "mojo/core/embedder/embedder.h"
 #include "mojo/core/test/mojo_test_base.h"
@@ -112,7 +113,8 @@ TEST_F(SignalsTest, LocalPeers) {
   // perceived locality of the peer.
   const char kMessage[] = "ayyy";
   WriteMessageWithHandles(a, kMessage, &c, 1);
-  EXPECT_EQ(kMessage, ReadMessageWithHandles(b, &c, 1));
+  EXPECT_EQ(kMessage,
+            ReadMessageWithHandles(b, base::span<MojoHandle, 1>(&c), 1));
 
   WriteMessage(c, kMessage);
   EXPECT_EQ(kMessage, ReadMessage(d));
@@ -191,7 +193,8 @@ TEST_F(SignalsTest, RemotePeers) {
     WriteMessage(h, "OK!");
 
     // Read |b| back before joining the client.
-    EXPECT_EQ("O_O", ReadMessageWithHandles(h, &b, 1));
+    EXPECT_EQ("O_O",
+              ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
 
     // Wait for |a| to see its peer as local again.
     EXPECT_EQ(MOJO_RESULT_OK,
@@ -211,7 +214,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(RemotePeersClient, SignalsTest, h) {
                            MOJO_TRIGGER_CONDITION_SIGNALS_SATISFIED));
 
   MojoHandle b;
-  EXPECT_EQ(":)", ReadMessageWithHandles(h, &b, 1));
+  EXPECT_EQ(":)", ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
 
   // And so should |b|.
   EXPECT_EQ(MOJO_RESULT_OK,
diff --git a/mojo/core/test/mojo_test_base.cc b/mojo/core/test/mojo_test_base.cc
index f1a7c91391f9b..50677ee2c5791 100644
--- a/mojo/core/test/mojo_test_base.cc
+++ b/mojo/core/test/mojo_test_base.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -93,7 +95,7 @@ void MojoTestBase::WriteMessage(MojoHandle mp, const std::string& message) {
 // static
 std::string MojoTestBase::ReadMessageWithHandles(
     MojoHandle mp,
-    MojoHandle* out_handles,
+    base::span<MojoHandle> out_handles,
     uint32_t expected_num_handles) {
   for (;;) {
     CHECK_EQ(WaitForSignals(mp, MOJO_HANDLE_SIGNAL_READABLE), MOJO_RESULT_OK);
@@ -148,7 +150,7 @@ std::string MojoTestBase::ReadMessageWithOptionalHandle(MojoHandle mp,
 
 // static
 std::string MojoTestBase::ReadMessage(MojoHandle mp) {
-  return ReadMessageWithHandles(mp, nullptr, 0);
+  return ReadMessageWithHandles(mp, {}, 0);
 }
 
 // static
diff --git a/mojo/core/test/mojo_test_base.h b/mojo/core/test/mojo_test_base.h
index 27b8390b91c06..ddee5b520c0b2 100644
--- a/mojo/core/test/mojo_test_base.h
+++ b/mojo/core/test/mojo_test_base.h
@@ -10,6 +10,7 @@
 #include <string_view>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "build/blink_buildflags.h"
@@ -111,7 +112,7 @@ class MojoTestBase : public testing::Test {
   // Reads a string from the pipe, expecting to read an exact number of handles
   // in the process. Returns the read string.
   static std::string ReadMessageWithHandles(MojoHandle mp,
-                                            MojoHandle* handles,
+                                            base::span<MojoHandle> handles,
                                             uint32_t expected_num_handles);
 
   // Reads a string from the pipe, expecting either zero or one handles.
diff --git a/mojo/public/cpp/bindings/tests/direct_receiver_unittest.cc b/mojo/public/cpp/bindings/tests/direct_receiver_unittest.cc
index bdd244771cf17..f7f2d7bb644b2 100644
--- a/mojo/public/cpp/bindings/tests/direct_receiver_unittest.cc
+++ b/mojo/public/cpp/bindings/tests/direct_receiver_unittest.cc
@@ -7,6 +7,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/raw_ref.h"
@@ -225,7 +226,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(NoIOThreadHopInBroker_Child,
   // Before binding to a Remote, wait for the pipe's portal to have a direct
   // link to the service.
   MojoHandle handle;
-  ReadMessageWithHandles(test_pipe->value(), &handle, 1);
+  ReadMessageWithHandles(test_pipe->value(), base::span<MojoHandle, 1>(&handle),
+                         1);
   WaitForDirectRemoteLink(handle);
 
   Remote<mojom::Service> service{PendingRemote<mojom::Service>{
@@ -275,7 +277,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(NoIOThreadHopInNonBroker_Child,
 
   // First get the service pipe from the test process.
   MojoHandle service_pipe;
-  ReadMessageWithHandles(test_pipe->value(), &service_pipe, 1);
+  ReadMessageWithHandles(test_pipe->value(),
+                         base::span<MojoHandle, 1>(&service_pipe), 1);
   PendingReceiver<mojom::Service> receiver{
       ScopedMessagePipeHandle{MessagePipeHandle{service_pipe}}};
 
diff --git a/mojo/public/cpp/bindings/tests/e2e_perftest.cc b/mojo/public/cpp/bindings/tests/e2e_perftest.cc
index 08b424fa3bf05..ba25eda8366db 100644
--- a/mojo/public/cpp/bindings/tests/e2e_perftest.cc
+++ b/mojo/public/cpp/bindings/tests/e2e_perftest.cc
@@ -5,6 +5,7 @@
 #include <string>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "base/memory/ptr_util.h"
@@ -164,7 +165,8 @@ void CreateAndRunService(PendingReceiver<test::EchoService> receiver,
 
 DEFINE_TEST_CLIENT_TEST_WITH_PIPE(PingService, MojoE2EPerftest, mp) {
   MojoHandle service_mp;
-  EXPECT_EQ("hello", ReadMessageWithHandles(mp, &service_mp, 1));
+  EXPECT_EQ("hello", ReadMessageWithHandles(
+                         mp, base::span<MojoHandle, 1>(&service_mp), 1));
 
   auto receiver = PendingReceiver<test::EchoService>(
       ScopedMessagePipeHandle(MessagePipeHandle(service_mp)));
diff --git a/mojo/public/cpp/bindings/tests/receiver_unittest.cc b/mojo/public/cpp/bindings/tests/receiver_unittest.cc
index f6f5d2db4b8d3..8ccf26347b4ba 100644
--- a/mojo/public/cpp/bindings/tests/receiver_unittest.cc
+++ b/mojo/public/cpp/bindings/tests/receiver_unittest.cc
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
 #include "base/memory/ptr_util.h"
@@ -976,7 +977,8 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessReceiverClient,
   // terminates when the InterfaceDropper is disconnected, which happens once
   // the test is done throwing remotes at it.
   MojoHandle dropper_pipe;
-  ReadMessageWithHandles(test_pipe, &dropper_pipe, 1);
+  ReadMessageWithHandles(test_pipe, base::span<MojoHandle, 1>(&dropper_pipe),
+                         1);
   base::RunLoop loop;
   InterfaceDropper dropper{PendingReceiver<mojom::InterfaceDropper>(
       MakeScopedHandle(MessagePipeHandle(dropper_pipe)))};
```

## Build Failure Log

```

17.83s Build Failure: 39 done 1 failed 9044 remaining - 2.19/s
 1 steps failed: remote-exec e7ebeb2d32a4272407ec5057312a17cfe95976bc9e87ba00fcc186df2fd7644c/355 failed: exit=1
see ./out/linux/siso_output for full command line and output
 or ./out/linux/siso.INFO
use ./out/linux/siso_failed_commands.sh to re-run failed commands
real	0m18.144s
user	3m3.216s
sys	1m2.698s
ninja: Entering directory `out/linux'
init credentials done 38.474745ms
reapi instance: projects/rbe-chrome-untrusted/instances/default_instance
loading fs state done 1.288252121s
loading/recompacting deps log done 684.132618ms
load siso config done 143.579301ms
load build.ninja done 863.652708ms
schedule pending:0+ready:1 (node:310590 edge:2)
build start: Ready 1 Pending 1
rebuild manifest finished	
schedule pending:0+ready:1 (node:310590 edge:9)
build start: Ready 15287 Pending 102644
FAILED: df25d613-e799-4f7b-95b4-6114cd183e20 "./obj/mojo/core/test_sources/shared_buffer_unittest.o" CXX obj/mojo/core/test_sources/shared_buffer_unittest.o
err: remote-exec e7ebeb2d32a4272407ec5057312a17cfe95976bc9e87ba00fcc186df2fd7644c/355 failed: exit=1
../../third_party/llvm-build/Release+Asserts/bin/clang++ -MMD -MF obj/mojo/core/test_sources/shared_buffer_unittest.o.d -DDCHECK_ALWAYS_ON=1 -DUSE_UDEV -DUSE_AURA=1 -DUSE_GLIB=1 -DUSE_OZONE=1 -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -DCR_CLANG_REVISION=\"llvmorg-21-init-5118-g52cd27e6-2\" -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_EXTENSIVE -DCOMPONENT_BUILD -D_LIBCPP_INSTRUMENTED_WITH_ASAN=0 -DCR_LIBCXX_REVISION=4f05e20cbe1d02fa0871ac88b30eead9e38cab3a -DTMP_REBUILD_HACK -DCR_SYSROOT_KEY=20250129T203412Z-1 -D_DEBUG -DDYNAMIC_ANNOTATIONS_ENABLED=1 -DGLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_56 -DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_56 -DABSL_CONSUME_DLL -DABSL_FLAGS_STRIP_NAMES=0 -DCR_CXX_INCLUDE=\"third_party/rust/chromium_crates_io/vendor/cxx-1.0.146/include/cxx.h\" -DBORINGSSL_SHARED_LIBRARY -DU_USING_ICU_NAMESPACE=0 -DU_ENABLE_DYLOAD=0 -DUSE_CHROMIUM_ICU=1 -DU_ENABLE_TRACING=1 -DU_ENABLE_RESOURCE_TRACING=0 -DICU_UTIL_DATA_IMPL=ICU_UTIL_DATA_FILE -DGTEST_API_= -DGTEST_HAS_POSIX_RE=0 -DGTEST_LANG_CXX11=1 -DGTEST_HAS_TR1_TUPLE=0 -DGTEST_HAS_ABSL -DGTEST_NO_ABSL_FLAGS -DUNIT_TEST -I../.. -Igen -I../../buildtools/third_party/libc++ -I../../third_party/perfetto/include -Igen/third_party/perfetto/build_config -Igen/third_party/perfetto -I../../third_party/google_benchmark/src/include -I../../net/third_party/quiche/overrides -I../../net/third_party/quiche/src/quiche/common/platform/default -I../../net/third_party/quiche/src -I../../base/allocator/partition_allocator/src -Igen/base/allocator/partition_allocator/src -I../../third_party/abseil-cpp -I../../third_party/boringssl/src/include -I../../third_party/protobuf/src -I../../third_party/ced/src -I../../third_party/icu/source/common -I../../third_party/icu/source/i18n -I../../third_party/googletest/custom -I../../third_party/googletest/src/googlemock/include -I../../third_party/googletest/src/googletest/include -I../../third_party/re2/src -I../../third_party/ipcz/include -Wall -Wextra -Wimplicit-fallthrough -Wextra-semi -Wunreachable-code-aggressive -Wthread-safety -Wgnu -Wno-gnu-anonymous-struct -Wno-gnu-conditional-omitted-operand -Wno-gnu-include-next -Wno-gnu-label-as-value -Wno-gnu-redeclared-enum -Wno-gnu-statement-expression -Wno-gnu-zero-variadic-macro-arguments -Wno-zero-length-array -Wno-missing-field-initializers -Wno-unused-parameter -Wno-psabi -Wloop-analysis -Wno-unneeded-internal-declaration -Wno-cast-function-type -Wno-thread-safety-reference-return -Wno-nontrivial-memcall -Wshadow -Werror -fno-delete-null-pointer-checks -fno-strict-overflow -fno-ident -fno-strict-aliasing -fstack-protector -funwind-tables -fPIC -pthread -fcolor-diagnostics -fmerge-all-constants -fno-sized-deallocation -fcrash-diagnostics-dir=../../tools/clang/crashreports -mllvm -instcombine-lower-dbg-declare=0 -mllvm -split-threshold-for-reg-with-hint=0 -ffp-contract=off -Wa,--crel,--allow-experimental-crel -fcomplete-member-pointers -m64 -msse3 -Wno-builtin-macro-redefined -D__DATE__= -D__TIME__= -D__TIMESTAMP__= -ffile-compilation-dir=. -no-canonical-prefixes -ftrivial-auto-var-init=pattern -O0 -fno-omit-frame-pointer -gdwarf-4 -g2 -gdwarf-aranges -gsplit-dwarf -ggnu-pubnames -Xclang -fuse-ctor-homing -fvisibility=hidden -Wheader-hygiene -Wstring-conversion -Wtautological-overlap-compare -Xclang -add-plugin -Xclang find-bad-constructs -Xclang -plugin-arg-find-bad-constructs -Xclang span-ctor-from-string-literal -Xclang -plugin-arg-find-bad-constructs -Xclang raw-ref-template-as-trivial-member -Xclang -plugin-arg-find-bad-constructs -Xclang raw-span-template-as-trivial-member -Xclang -plugin-arg-find-bad-constructs -Xclang check-stack-allocated -Xclang -plugin-arg-find-bad-constructs -Xclang check-ipc -Xclang -add-plugin -Xclang raw-ptr-plugin -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ptr-to-stack-allocated -Xclang -plugin-arg-raw-ptr-plugin -Xclang disable-check-raw-ptr-to-stack-allocated-error -Xclang -plugin-arg-raw-ptr-plugin -Xclang raw-ptr-exclude-path=../../third_party/dawn/ -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ptr-fields -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-span-fields -Xclang -plugin-arg-raw-ptr-plugin -Xclang check-raw-ref-fields -DUNSAFE_BUFFERS_BUILD -Xclang -add-plugin -Xclang unsafe-buffers -Xclang -plugin-arg-unsafe-buffers -Xclang ../../build/config/unsafe_buffers_paths.txt -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/include/glib-2.0 -isystem../../build/linux/debian_bullseye_amd64-sysroot/usr/lib/x86_64-linux-gnu/glib-2.0/include -Wno-inconsistent-missing-override -Wno-invalid-offsetof -Wenum-compare-conditional -Wno-c++11-narrowing-const-reference -Wno-missing-template-arg-list-after-template-kw -Wno-undefined-bool-conversion -Wno-tautological-undefined-compare -std=c++20 -Wno-trigraphs -gsimple-template-names -fno-exceptions -fno-rtti -nostdinc++ -isystem../../third_party/libc++/src/include -isystem../../third_party/libc++abi/src/include --sysroot=../../build/linux/debian_bullseye_amd64-sysroot -fvisibility-inlines-hidden  -c ../../mojo/core/shared_buffer_unittest.cc -o obj/mojo/core/test_sources/shared_buffer_unittest.o
build step: cxx "./obj/mojo/core/test_sources/shared_buffer_unittest.o"
siso_rule: clang/cxx
stdout:
../../mojo/core/shared_buffer_unittest.cc:63:40: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
   63 |             ReadMessageWithHandles(p1, base::span<MojoHandle, 1>(&dupe), 1));
      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../third_party/googletest/src/googletest/include/gtest/gtest.h:1885:69: note: expanded from macro 'EXPECT_EQ'
 1885 |   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |                                                                     ^~~~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:144:40: note: expanded from macro 'EXPECT_PRED_FORMAT2'
  144 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)
      |                                        ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:134:43: note: expanded from macro 'GTEST_PRED_FORMAT2_'
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |                                           ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:79:52: note: expanded from macro 'GTEST_ASSERT_'
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |                                                    ^~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:79:33: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
   79 |       ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1);
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:130:31: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  130 |     ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1);
      |                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:143:33: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  143 |       ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&other_child), 1);
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:163:33: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  163 |       ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&other_child), 1);
      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:167:39: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  167 |   ReadMessageWithHandles(other_child, base::span<MojoHandle, 1>(&b), 1);
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:199:34: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  199 |       ReadMessageWithHandles(h0, base::span<MojoHandle, 1>(&b), 1);
      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:218:40: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  218 |         ReadMessageWithHandles(parent, base::span<MojoHandle, 1>(&pipe), 1);
      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:225:30: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  225 |                       child, base::span<MojoHandle, 1>(&buffer), 1));
      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../third_party/googletest/src/googletest/include/gtest/gtest.h:1885:69: note: expanded from macro 'EXPECT_EQ'
 1885 |   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |                                                                     ^~~~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:144:40: note: expanded from macro 'EXPECT_PRED_FORMAT2'
  144 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)
      |                                        ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:134:43: note: expanded from macro 'GTEST_PRED_FORMAT2_'
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |                                           ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:79:52: note: expanded from macro 'GTEST_ASSERT_'
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |                                                    ^~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:241:40: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  241 |         ReadMessageWithHandles(parent, base::span<MojoHandle, 1>(&pipe), 1);
      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:278:38: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  278 |       ReadMessageWithHandles(child1, base::span<MojoHandle, 1>(&b), 1);
      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:296:39: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  296 |             ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../third_party/googletest/src/googletest/include/gtest/gtest.h:1885:69: note: expanded from macro 'EXPECT_EQ'
 1885 |   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |                                                                     ^~~~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:144:40: note: expanded from macro 'EXPECT_PRED_FORMAT2'
  144 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)
      |                                        ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:134:43: note: expanded from macro 'GTEST_PRED_FORMAT2_'
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |                                           ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:79:52: note: expanded from macro 'GTEST_ASSERT_'
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |                                                    ^~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
../../mojo/core/shared_buffer_unittest.cc:375:45: error: no matching conversion for functional-style cast from 'MojoHandle *' (aka 'unsigned long *') to 'base::span<MojoHandle, 1>' (aka 'span<unsigned long, 1>')
  375 |     EXPECT_EQ("", ReadMessageWithHandles(h, base::span<MojoHandle, 1>(&b), 1));
      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../third_party/googletest/src/googletest/include/gtest/gtest.h:1885:69: note: expanded from macro 'EXPECT_EQ'
 1885 |   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
      |                                                                     ^~~~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:144:40: note: expanded from macro 'EXPECT_PRED_FORMAT2'
  144 |   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)
      |                                        ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:134:43: note: expanded from macro 'GTEST_PRED_FORMAT2_'
  134 |   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), on_failure)
      |                                           ^~
../../third_party/googletest/src/googletest/include/gtest/gtest_pred_impl.h:79:52: note: expanded from macro 'GTEST_ASSERT_'
   79 |   if (const ::testing::AssertionResult gtest_ar = (expression)) \
      |                                                    ^~~~~~~~~~
../../base/containers/span.h:516:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'std::type_identity_t<element_type> (&)[1]' (aka 'unsigned long (&)[1]') for 1st argument
  516 |   constexpr span(
      |             ^
  517 |       std::type_identity_t<element_type> (&arr LIFETIME_BOUND)[extent]) noexcept
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:553:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'const span<unsigned long, 1>' for 1st argument
  553 |   constexpr span(const span& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~~~~~~
../../base/containers/span.h:565:13: note: candidate constructor not viable: no known conversion from 'MojoHandle *' (aka 'unsigned long *') to 'span<unsigned long, 1>' for 1st argument
  565 |   constexpr span(span&& other) noexcept = default;
      |             ^    ~~~~~~~~~~~~
../../base/containers/span.h:526:35: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  526 |   constexpr explicit(N != extent) span(R&& range LIFETIME_BOUND)
      |                                   ^
../../base/containers/span.h:523:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  523 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:537:22: note: candidate template ignored: constraints not satisfied [with R = MojoHandle *, N = 18446744073709551615]
  537 |   constexpr explicit span(R&& range)
      |                      ^
../../base/containers/span.h:533:14: note: because 'internal::CompatibleRange<element_type, unsigned long *>' evaluated to false
  533 |     requires(internal::CompatibleRange<element_type, R> &&
      |              ^
../../base/containers/span.h:373:5: note: because 'unsigned long *' does not satisfy 'contiguous_range'
  373 |     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
      |     ^
../../third_party/libc++/src/include/__ranges/concepts.h:115:28: note: because 'unsigned long *' does not satisfy 'random_access_range'
  115 | concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
      |                            ^
../../third_party/libc++/src/include/__ranges/concepts.h:112:31: note: because 'unsigned long *' does not satisfy 'bidirectional_range'
  112 | concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:109:31: note: because 'unsigned long *' does not satisfy 'forward_range'
  109 | concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
      |                               ^
../../third_party/libc++/src/include/__ranges/concepts.h:106:25: note: because 'unsigned long *' does not satisfy 'input_range'
  106 | concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
      |                         ^
../../third_party/libc++/src/include/__ranges/concepts.h:53:23: note: because 'unsigned long *' does not satisfy 'range'
   53 | concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
      |                       ^
../../third_party/libc++/src/include/__ranges/concepts.h:48:3: note: because 'ranges::begin(__t)' would be invalid: call to deleted function call operator in type 'const __begin::__fn'
   48 |   ranges::begin(__t); // sometimes equality-preserving
      |   ^
../../base/containers/span.h:560:7: note: candidate template ignored: could not match 'span<OtherElementType, OtherExtent, OtherInternalPtrType>' against 'MojoHandle *' (aka 'unsigned long *')
  560 |       span(const span<OtherElementType, OtherExtent, OtherInternalPtrType>&
      |       ^
../../base/containers/span.h:546:22: note: candidate constructor not viable: constraints not satisfied
  546 |   constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
      |                      ^
../../base/containers/span.h:547:14: note: because 'std::is_const_v<element_type>' evaluated to false
  547 |     requires(std::is_const_v<element_type>)
      |              ^
../../base/containers/span.h:472:13: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
  472 |   constexpr span() noexcept
      |             ^
../../base/containers/span.h:482:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  482 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first,
      |                                          ^    ~~~~~~~~~
  483 |                                               StrictNumeric<size_type> count)
      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../base/containers/span.h:500:42: note: candidate constructor template not viable: requires 2 arguments, but 1 was provided
  500 |   UNSAFE_BUFFER_USAGE constexpr explicit span(It first, End last)
      |                                          ^    ~~~~~~~~~~~~~~~~~~
13 errors generated.
build failed	
local:4 remote:1 cache:34 fallback:0 retry:0 skip:108848
reapi: ops: 125(err:49) / r:62(err:0) 14.93MiB / w:117(err:0) 436.49KiB
fs: ops: 8590(err:3166) / r:2341(err:0) 63.05MiB / w:27(err:0) 14.17MiB
```

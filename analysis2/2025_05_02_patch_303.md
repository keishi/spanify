# Build Failure: 2025_05_02_patch_303

## Chromium Revision

`a3ffac36a0fd4cbdc95cd5ec879816b9634a1d56`

## Code Changes (Diff)

```diff
diff --git a/cc/test/layer_tree_json_parser.cc b/cc/test/layer_tree_json_parser.cc
index eeeaf5d50de4a..72eaabfafa339 100644
--- a/cc/test/layer_tree_json_parser.cc
+++ b/cc/test/layer_tree_json_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -167,7 +169,7 @@ scoped_refptr<Layer> ParseTreeFromValue(const base::Value& val,
   if (transform_list->size() < 16)
     return nullptr;
 
-  float transform[16];
+  std::array<float, 16> transform;
   for (int i = 0; i < 16; ++i) {
     // GetDouble can implicitly convert from either double or int; however, it's
     // not clear if "is_double" is sufficient for this check. Given that int is
diff --git a/chrome/services/media_gallery_util/public/mojom/media_parser_mojom_traits.cc b/chrome/services/media_gallery_util/public/mojom/media_parser_mojom_traits.cc
index 4bd5b2660de83..f54a4b8f32282 100644
--- a/chrome/services/media_gallery_util/public/mojom/media_parser_mojom_traits.cc
+++ b/chrome/services/media_gallery_util/public/mojom/media_parser_mojom_traits.cc
@@ -24,7 +24,7 @@ bool StructTraits<TypeImageDataView, TypeImage>::Read(TypeImageDataView view,
   ArrayDataView<uint8_t> data;
   view.GetDataDataView(&data);
 
-  out->data.assign(reinterpret_cast<const char*>(data.data()), data.size());
+  out->data.assign(reinterpret_cast<const char*>(data.data().data()), data.size());
   return true;
 }
 
diff --git a/components/viz/common/quads/render_pass_io.cc b/components/viz/common/quads/render_pass_io.cc
index 8e767eaab701a..ef3cfbf1e0a40 100644
--- a/components/viz/common/quads/render_pass_io.cc
+++ b/components/viz/common/quads/render_pass_io.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -460,7 +462,7 @@ bool TransformFromList(const base::Value::List& list,
   DCHECK(transform);
   if (list.size() != 16)
     return false;
-  float data[16];
+  std::array<float, 16> data;
   for (size_t ii = 0; ii < 16; ++ii) {
     if (!list[ii].is_double())
       return false;
diff --git a/content/renderer/skia_benchmarking_extension.cc b/content/renderer/skia_benchmarking_extension.cc
index acb136002f3d5..92a16c2928413 100644
--- a/content/renderer/skia_benchmarking_extension.cc
+++ b/content/renderer/skia_benchmarking_extension.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/342213636): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -226,7 +228,7 @@ void SkiaBenchmarking::Rasterize(gin::Arguments* args) {
   blink::WebArrayBuffer buffer =
       blink::WebArrayBuffer::Create(bitmap.computeByteSize(), 1);
   uint32_t* packed_pixels = reinterpret_cast<uint32_t*>(bitmap.getPixels());
-  uint8_t* buffer_pixels = reinterpret_cast<uint8_t*>(buffer.Data());
+  base::span<uint8_t>buffer_pixels = reinterpret_cast<uint8_t*>(buffer.Data());
   // Swizzle from native Skia format to RGBA as we copy out.
   for (size_t i = 0; i < bitmap.computeByteSize(); i += 4) {
     uint32_t c = packed_pixels[i >> 2];
diff --git a/content/web_test/renderer/test_runner.cc b/content/web_test/renderer/test_runner.cc
index 01240d73a7f03..37618f7d69972 100644
--- a/content/web_test/renderer/test_runner.cc
+++ b/content/web_test/renderer/test_runner.cc
@@ -147,7 +147,7 @@ v8::LocalVector<v8::Value> ConvertBitmapToV8(
 
   blink::WebArrayBuffer buffer =
       blink::WebArrayBuffer::Create(info.computeByteSize(row_bytes), 1);
-  bool read = bitmap.readPixels(info, buffer.Data(), row_bytes, 0, 0);
+  bool read = bitmap.readPixels(info, buffer.Data().data(), row_bytes, 0, 0);
   CHECK(read);
 
   args.push_back(blink::WebArrayBufferConverter::ToV8Value(&buffer, isolate));
diff --git a/extensions/renderer/set_icon_natives.cc b/extensions/renderer/set_icon_natives.cc
index 36f5ddc0c54f8..b062e1062f9a8 100644
--- a/extensions/renderer/set_icon_natives.cc
+++ b/extensions/renderer/set_icon_natives.cc
@@ -153,7 +153,7 @@ bool SetIconNatives::ConvertImageDataToBitmapValue(
   // Construct the Value object.
   std::vector<uint8_t> s = skia::mojom::InlineBitmap::Serialize(&bitmap);
   blink::WebArrayBuffer buffer = blink::WebArrayBuffer::Create(s.size(), 1);
-  memcpy(buffer.Data(), s.data(), s.size());
+  memcpy(buffer.Data().data(), s.data(), s.size());
   *image_data_bitmap =
       blink::WebArrayBufferConverter::ToV8Value(&buffer, isolate);
 
diff --git a/media/base/audio_bus.h b/media/base/audio_bus.h
index 4649d2299c7ee..fea821dab30ea 100644
--- a/media/base/audio_bus.h
+++ b/media/base/audio_bus.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -185,9 +187,9 @@ class MEDIA_SHMEM_EXPORT AudioBus {
   // inf, nan, or between [-1.0, 1.0]) values in the channel data.
   // TODO(crbug.com/373960632): Remove these methods, and rename `channel_span`
   // to `channel`.
-  float* channel(int channel) {
+  base::span<float> channel(int channel) {
     CHECK(!is_bitstream_format_);
-    return channel_data_[channel].data();
+    return channel_data_[channel];
   }
   const float* channel(int channel) const {
     CHECK(!is_bitstream_format_);
diff --git a/media/filters/audio_decoder_unittest.cc b/media/filters/audio_decoder_unittest.cc
index 4cb801107e0eb..ef3999ec1d753 100644
--- a/media/filters/audio_decoder_unittest.cc
+++ b/media/filters/audio_decoder_unittest.cc
@@ -349,8 +349,8 @@ class AudioDecoderTest
     for (int ch = 0; ch < output->channels(); ++ch) {
       base::MD5Update(
           &context,
-          std::string_view(reinterpret_cast<char*>(output->channel(ch)),
-                           output->frames() * sizeof(*output->channel(ch))));
+          std::string_view(reinterpret_cast<char*>(output->channel(ch).data()),
+                           output->frames() * sizeof( output->channel(ch)[0])));
     }
     base::MD5Digest digest;
     base::MD5Final(&digest, &context);
diff --git a/media/filters/audio_renderer_algorithm_unittest.cc b/media/filters/audio_renderer_algorithm_unittest.cc
index 2ca53d09e0553..c6e589a5be06c 100644
--- a/media/filters/audio_renderer_algorithm_unittest.cc
+++ b/media/filters/audio_renderer_algorithm_unittest.cc
@@ -8,6 +8,8 @@
 // correct rate.  We always pass in a very large destination buffer with the
 // expectation that FillBuffer() will fill as much as it can but no more.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -43,7 +45,7 @@ const int kSamplesPerSecond = 3000;
 const int kOutputDurationInSec = 10;
 
 static void FillWithSquarePulseTrain(
-    int half_pulse_width, int offset, int num_samples, float* data) {
+    int half_pulse_width, int offset, int num_samples, base::span<float>data) {
   ASSERT_GE(offset, 0);
   ASSERT_LE(offset, num_samples);
 
@@ -418,7 +420,7 @@ class AudioRendererAlgorithmTest : public testing::Test {
       // perfectly. Do not check them.
       if (n > 3) {
          for (int m = 0; m < channels_; ++m) {
-          const float* pulse_ch = pulse_buffer->channel(m);
+          base::span<const float>pulse_ch = pulse_buffer->channel(m);
 
           // Because of overlap-and-add we might have round off error.
           for (int k = 0; k < kPulseWidthSamples; ++k) {
@@ -701,8 +703,8 @@ TEST_F(AudioRendererAlgorithmTest, MovingBlockEnergy) {
   const int kNumBlocks = kFrames - (kFramesPerBlock - 1);
   std::unique_ptr<AudioBus> a = AudioBus::Create(kChannels, kFrames);
   auto energies = std::make_unique<float[]>(kChannels * kNumBlocks);
-  float* ch_left = a->channel(0);
-  float* ch_right = a->channel(1);
+  base::span<float>ch_left = a->channel(0);
+  base::span<float>ch_right = a->channel(1);
 
   // Fill up both channels.
   for (int n = 0; n < kFrames; ++n) {
@@ -743,9 +745,9 @@ TEST_F(AudioRendererAlgorithmTest, FullAndDecimatedSearch) {
             sizeof(ch_0) / sizeof(*ch_0));
   std::unique_ptr<AudioBus> search_region =
       AudioBus::Create(kChannels, kFramesInSearchRegion);
-  float* ch = search_region->channel(0);
+  float* ch = search_region->channel(0).data();
   memcpy(ch, ch_0, sizeof(float) * kFramesInSearchRegion);
-  ch = search_region->channel(1);
+  ch = search_region->channel(1).data();
   memcpy(ch, ch_1, sizeof(float) * kFramesInSearchRegion);
 
   const int kFramePerBlock = 4;
@@ -757,9 +759,9 @@ TEST_F(AudioRendererAlgorithmTest, FullAndDecimatedSearch) {
 
   std::unique_ptr<AudioBus> target =
       AudioBus::Create(kChannels, kFramePerBlock);
-  ch = target->channel(0);
+  ch = target->channel(0).data();
   memcpy(ch, target_0, sizeof(float) * kFramePerBlock);
-  ch = target->channel(1);
+  ch = target->channel(1).data();
   memcpy(ch, target_1, sizeof(float) * kFramePerBlock);
 
   auto energy_target = std::make_unique<float[]>(kChannels);
diff --git a/media/mojo/clients/mojo_audio_encoder_unittest.cc b/media/mojo/clients/mojo_audio_encoder_unittest.cc
index 13a85a8b36c5c..e07289b0a0c05 100644
--- a/media/mojo/clients/mojo_audio_encoder_unittest.cc
+++ b/media/mojo/clients/mojo_audio_encoder_unittest.cc
@@ -269,7 +269,7 @@ TEST_F(MojoAudioEncoderTest, Encode) {
                                options.sample_rate, audio_bus->frames());
 
         const auto channel_data =
-            base::span(reinterpret_cast<const uint8_t*>(audio_bus->channel(0)),
+            base::span(reinterpret_cast<const uint8_t*>(audio_bus->channel(0).data()),
                        AudioBus::CalculateMemorySize(
                            /*channels=*/1, audio_bus->frames()));
         auto encoded_data = base::HeapArray<uint8_t>::CopiedFrom(channel_data);
diff --git a/media/mojo/mojom/cdm_key_information_mojom_traits.cc b/media/mojo/mojom/cdm_key_information_mojom_traits.cc
index 33af33f9a0dcb..3f677bb1a4011 100644
--- a/media/mojo/mojom/cdm_key_information_mojom_traits.cc
+++ b/media/mojo/mojom/cdm_key_information_mojom_traits.cc
@@ -81,7 +81,7 @@ bool StructTraits<media::mojom::CdmKeyInformationDataView,
     return false;
 
   *output = std::make_unique<media::CdmKeyInformation>(
-      key_id.data(), key_id.size(), status, input.system_code());
+      key_id.data().data(), key_id.size(), status, input.system_code());
   return true;
 }
 
diff --git a/mojo/public/cpp/base/byte_string_mojom_traits.cc b/mojo/public/cpp/base/byte_string_mojom_traits.cc
index a783a063386a9..be40ac916a72a 100644
--- a/mojo/public/cpp/base/byte_string_mojom_traits.cc
+++ b/mojo/public/cpp/base/byte_string_mojom_traits.cc
@@ -14,7 +14,7 @@ bool StructTraits<mojo_base::mojom::ByteStringDataView, std::string>::Read(
     std::string* out) {
   mojo::ArrayDataView<uint8_t> bytes;
   data.GetDataDataView(&bytes);
-  out->assign(reinterpret_cast<const char*>(bytes.data()),
+  out->assign(reinterpret_cast<const char*>(bytes.data().data()),
               bytes.size() / sizeof(char));
   return true;
 }
diff --git a/mojo/public/cpp/base/string16_mojom_traits.cc b/mojo/public/cpp/base/string16_mojom_traits.cc
index 60e4064db8e01..7b031c98b544c 100644
--- a/mojo/public/cpp/base/string16_mojom_traits.cc
+++ b/mojo/public/cpp/base/string16_mojom_traits.cc
@@ -19,7 +19,7 @@ bool StructTraits<mojo_base::mojom::String16DataView, std::u16string>::Read(
     std::u16string* out) {
   ArrayDataView<uint16_t> view;
   data.GetDataDataView(&view);
-  out->assign(reinterpret_cast<const char16_t*>(view.data()), view.size());
+  out->assign(reinterpret_cast<const char16_t*>(view.data().data()), view.size());
   return true;
 }
 
diff --git a/mojo/public/cpp/bindings/array_data_view.h b/mojo/public/cpp/bindings/array_data_view.h
index 5b022afdcbb03..49bac21421e7b 100644
--- a/mojo/public/cpp/bindings/array_data_view.h
+++ b/mojo/public/cpp/bindings/array_data_view.h
@@ -7,6 +7,7 @@
 
 #include <type_traits>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/containers/checked_iterators.h"
 #include "base/memory/raw_ptr_exclusion.h"
@@ -36,7 +37,7 @@ class ArrayDataViewImpl<
 
   T operator[](size_t index) const { return data_->at(index); }
 
-  const T* data() const { return data_->storage(); }
+  const base::span<T> data() const { return data_->storage(); }
 
  protected:
   // RAW_PTR_EXCLUSION: Performance reasons: based on analysis of sampling
diff --git a/remoting/host/mojom/remoting_mojom_traits.cc b/remoting/host/mojom/remoting_mojom_traits.cc
index 8d9b098be996d..5c854f0d01527 100644
--- a/remoting/host/mojom/remoting_mojom_traits.cc
+++ b/remoting/host/mojom/remoting_mojom_traits.cc
@@ -333,7 +333,7 @@ bool mojo::StructTraits<
 
   std::unique_ptr<::webrtc::DesktopFrame> new_frame(
       new ::webrtc::BasicDesktopFrame(image_size));
-  memcpy(new_frame->data(), image_data.data(), image_data.size());
+  memcpy(new_frame->data(), image_data.data().data(), image_data.size());
 
   // ::webrtc::MouseCursor methods take a raw pointer *and* take ownership.
   // TODO(joedow): Update webrtc::MouseCursor to use std::unique_ptr.
diff --git a/services/audio/public/cpp/output_device_unittest.cc b/services/audio/public/cpp/output_device_unittest.cc
index 6d3de89111474..5fbd71c532cca 100644
--- a/services/audio/public/cpp/output_device_unittest.cc
+++ b/services/audio/public/cpp/output_device_unittest.cc
@@ -246,8 +246,8 @@ TEST_F(AudioServiceOutputDeviceTest, MAYBE_VerifyDataFlow) {
         .WillOnce(WithArg<3>(Invoke([](media::AudioBus* client_bus) -> int {
           // Place some test data in the bus so that we can check that it was
           // copied to the audio service side.
-          std::fill_n(client_bus->channel(0), client_bus->frames(), kAudioData);
-          std::fill_n(client_bus->channel(1), client_bus->frames(), kAudioData);
+          std::fill_n(client_bus->channel(0).data(), client_bus->frames(), kAudioData);
+          std::fill_n(client_bus->channel(1).data(), client_bus->frames(), kAudioData);
           return client_bus->frames();
         })));
     env.reader->RequestMoreData(kDelay, env.time_stamp, glitch_info);
diff --git a/services/audio/snooper_node_unittest.cc b/services/audio/snooper_node_unittest.cc
index 3b5a0afcbde26..68432074470ce 100644
--- a/services/audio/snooper_node_unittest.cc
+++ b/services/audio/snooper_node_unittest.cc
@@ -217,7 +217,7 @@ class SnooperNodeTest : public testing::TestWithParam<InputAndOutputParams> {
     // call, confirm that every sample was overwritten in the output AudioBus.
     const auto bus = media::AudioBus::Create(output_params());
     for (int ch = 0; ch < bus->channels(); ++ch) {
-      std::fill_n(bus->channel(ch), bus->frames(), kInvalidAudioSample);
+      std::fill_n(bus->channel(ch).data(), bus->frames(), kInvalidAudioSample);
     }
 
     // If the SnooperNode provides a suggestion, check that |output_time| is
@@ -237,7 +237,7 @@ class SnooperNodeTest : public testing::TestWithParam<InputAndOutputParams> {
 
     for (int ch = 0; ch < bus->channels(); ++ch) {
       EXPECT_FALSE(
-          std::any_of(bus->channel(ch), bus->channel(ch) + bus->frames(),
+          std::any_of(bus->channel(ch).data(), bus->channel(ch) + bus->frames(),
                       [](float x) { return x == kInvalidAudioSample; }))
           << " at output_time=" << output_time << ", ch=" << ch;
     }
diff --git a/services/audio/test/fake_consumer.cc b/services/audio/test/fake_consumer.cc
index 610d1586a3c4e..435a95bbd3102 100644
--- a/services/audio/test/fake_consumer.cc
+++ b/services/audio/test/fake_consumer.cc
@@ -142,7 +142,7 @@ void FakeConsumer::SaveToFile(const base::FilePath& path) const {
   auto writer = media::AudioDebugFileWriter::Create(params, std::move(file));
   auto bus = media::AudioBus::Create(params);
   for (int i = 0; i < params.channels(); ++i) {
-    memcpy(bus->channel(i), recorded_channel_data_[i].data(),
+    memcpy(bus->channel(i).data(), recorded_channel_data_[i].data(),
            sizeof(float) * recorded_channel_data_[i].size());
   }
   writer->Write(*bus);
diff --git a/services/media_session/public/cpp/media_session_mojom_traits.cc b/services/media_session/public/cpp/media_session_mojom_traits.cc
index e4bf97398fb7a..5d3240ff6372e 100644
--- a/services/media_session/public/cpp/media_session_mojom_traits.cc
+++ b/services/media_session/public/cpp/media_session_mojom_traits.cc
@@ -105,7 +105,7 @@ bool StructTraits<media_session::mojom::MediaImageBitmapDataView, SkBitmap>::
   // Create the SkBitmap object which wraps the media image bitmap pixels.
   // This doesn't copy and |data| and |bitmap| share the buffer.
   SkBitmap bitmap;
-  if (!bitmap.installPixels(info, const_cast<uint8_t*>(pixel_data.data()),
+  if (!bitmap.installPixels(info, const_cast<uint8_t*>(pixel_data.data().data()),
                             info.minRowBytes())) {
     // Error in installing pixels.
     return false;
diff --git a/services/network/public/cpp/network_interface_mojom_traits.cc b/services/network/public/cpp/network_interface_mojom_traits.cc
index ed38a7434aa40..66bafeeb5bd58 100644
--- a/services/network/public/cpp/network_interface_mojom_traits.cc
+++ b/services/network/public/cpp/network_interface_mojom_traits.cc
@@ -28,7 +28,7 @@ bool StructTraits<
     if (view.size() != out->mac_address->size()) {
       return false;
     }
-    std::copy_n(view.data(), out->mac_address->size(),
+    std::copy_n(view.data().data(), out->mac_address->size(),
                 out->mac_address->begin());
   } else {
     out->mac_address.reset();
diff --git a/services/on_device_model/ml/chrome_ml_types_traits.cc b/services/on_device_model/ml/chrome_ml_types_traits.cc
index c3b8e864dfc1f..f5d22bcee96f2 100644
--- a/services/on_device_model/ml/chrome_ml_types_traits.cc
+++ b/services/on_device_model/ml/chrome_ml_types_traits.cc
@@ -183,7 +183,7 @@ bool StructTraits<on_device_model::mojom::AudioDataDataView, ml::AudioBuffer>::R
   mojo::ArrayDataView<float> data_view;
   in.GetDataDataView(&data_view);
   out->data.reserve(data_view.size());
-  std::copy_n(data_view.data(), data_view.size(),
+  std::copy_n(data_view.data().data(), data_view.size(),
               std::back_inserter(out->data));
   return true;
 }
diff --git a/skia/public/mojom/bitmap_skbitmap_mojom_traits.cc b/skia/public/mojom/bitmap_skbitmap_mojom_traits.cc
index 0ade14da59833..cde38c74fa9f0 100644
--- a/skia/public/mojom/bitmap_skbitmap_mojom_traits.cc
+++ b/skia/public/mojom/bitmap_skbitmap_mojom_traits.cc
@@ -195,7 +195,7 @@ bool StructTraits<skia::mojom::InlineBitmapDataView, SkBitmap>::Read(
   mojo::ArrayDataView<uint8_t> pixel_data_view;
   data.GetPixelDataDataView(&pixel_data_view);
 
-  base::span<const uint8_t> pixel_data_bytes(pixel_data_view.data(),
+  base::span<const uint8_t> pixel_data_bytes(pixel_data_view.data().data(),
                                              pixel_data_view.size());
 
   return CreateSkBitmapForPixelData(b, std::move(image_info),
diff --git a/skia/public/mojom/image_info_mojom_traits.cc b/skia/public/mojom/image_info_mojom_traits.cc
index 5ead45e9b9746..2db035d5d084a 100644
--- a/skia/public/mojom/image_info_mojom_traits.cc
+++ b/skia/public/mojom/image_info_mojom_traits.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -34,7 +36,7 @@ std::optional<SkImageInfo> MakeSkImageInfo(
   }
   sk_sp<SkColorSpace> color_space;
   if (!color_transfer_function.is_null() && !color_to_xyz_matrix.is_null()) {
-    const float* data = color_transfer_function.data();
+    base::span<const float>data = color_transfer_function.data();
     skcms_TransferFunction transfer_function;
     // TODO(crbug.com/40061960): Mojo should validate this array size. We can
     // CHECK it instead when it does.
@@ -55,7 +57,7 @@ std::optional<SkImageInfo> MakeSkImageInfo(
     if (color_to_xyz_matrix.size() != 9u) {
       return std::nullopt;
     }
-    memcpy(to_xyz_matrix.vals, color_to_xyz_matrix.data(), 9 * sizeof(float));
+    memcpy(to_xyz_matrix.vals, color_to_xyz_matrix.data().data(), 9 * sizeof(float));
     color_space = SkColorSpace::MakeRGB(transfer_function, to_xyz_matrix);
   }
 
diff --git a/third_party/blink/public/platform/web_content_decryption_module.h b/third_party/blink/public/platform/web_content_decryption_module.h
index 3e42dcb34e7a0..c091aa88cef1a 100644
--- a/third_party/blink/public/platform/web_content_decryption_module.h
+++ b/third_party/blink/public/platform/web_content_decryption_module.h
@@ -33,6 +33,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_result.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_session.h"
@@ -47,7 +48,7 @@ class BLINK_PLATFORM_EXPORT WebContentDecryptionModule {
   virtual std::unique_ptr<WebContentDecryptionModuleSession> CreateSession(
       WebEncryptedMediaSessionType session_type) = 0;
 
-  virtual void SetServerCertificate(const unsigned char* certificate,
+  virtual void SetServerCertificate(base::span<const unsigned char>certificate,
                                     size_t certificate_length,
                                     WebContentDecryptionModuleResult) = 0;
 
diff --git a/third_party/blink/public/platform/web_content_decryption_module_session.h b/third_party/blink/public/platform/web_content_decryption_module_session.h
index 3cf2ce4b867d9..2fb626cb6177b 100644
--- a/third_party/blink/public/platform/web_content_decryption_module_session.h
+++ b/third_party/blink/public/platform/web_content_decryption_module_session.h
@@ -33,6 +33,7 @@
 
 #include <vector>
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_exception.h"
 #include "third_party/blink/public/platform/web_content_decryption_module_result.h"
@@ -83,12 +84,12 @@ class BLINK_PLATFORM_EXPORT WebContentDecryptionModuleSession {
   virtual WebString SessionId() const = 0;
 
   virtual void InitializeNewSession(media::EmeInitDataType,
-                                    const unsigned char* init_data,
+                                    base::span<const unsigned char>init_data,
                                     size_t init_data_length,
                                     WebContentDecryptionModuleResult) = 0;
   virtual void Load(const WebString& session_id,
                     WebContentDecryptionModuleResult) = 0;
-  virtual void Update(const unsigned char* response,
+  virtual void Update(base::span<const unsigned char>response,
                       size_t response_length,
                       WebContentDecryptionModuleResult) = 0;
   virtual void Close(WebContentDecryptionModuleResult) = 0;
diff --git a/third_party/blink/public/web/web_array_buffer.h b/third_party/blink/public/web/web_array_buffer.h
index cf875c70ec643..4f4fafd33f819 100644
--- a/third_party/blink/public/web/web_array_buffer.h
+++ b/third_party/blink/public/web/web_array_buffer.h
@@ -31,6 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_PUBLIC_WEB_WEB_ARRAY_BUFFER_H_
 #define THIRD_PARTY_BLINK_PUBLIC_WEB_WEB_ARRAY_BUFFER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/public/platform/web_common.h"
 #include "third_party/blink/public/platform/web_private_ptr.h"
 
@@ -56,7 +57,7 @@ class BLINK_EXPORT WebArrayBuffer {
   void Assign(const WebArrayBuffer&);
 
   bool IsNull() const { return private_.IsNull(); }
-  void* Data() const;
+  base::span<void> Data() const;
   size_t ByteLength() const;
 
 #if INSIDE_BLINK
diff --git a/third_party/blink/renderer/core/exported/web_array_buffer.cc b/third_party/blink/renderer/core/exported/web_array_buffer.cc
index 60a99f9865563..918a76c3043fa 100644
--- a/third_party/blink/renderer/core/exported/web_array_buffer.cc
+++ b/third_party/blink/renderer/core/exported/web_array_buffer.cc
@@ -30,6 +30,7 @@
 
 #include "third_party/blink/public/web/web_array_buffer.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h"
 
 namespace blink {
@@ -48,10 +49,10 @@ void WebArrayBuffer::Assign(const WebArrayBuffer& other) {
   private_ = other.private_;
 }
 
-void* WebArrayBuffer::Data() const {
+base::span<void> WebArrayBuffer::Data() const {
   if (!IsNull())
     return const_cast<void*>(private_->Data());
-  return nullptr;
+  return {};
 }
 
 size_t WebArrayBuffer::ByteLength() const {
diff --git a/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc b/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
index 64f87698f6929..cd004d9ae11ad 100644
--- a/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
+++ b/third_party/blink/renderer/core/fetch/fetch_data_loader_test.cc
@@ -472,7 +472,7 @@ TEST_F(FetchDataLoaderTest, LoadAsArrayBuffer) {
   ASSERT_TRUE(array_buffer);
   ASSERT_EQ(kQuickBrownFoxLengthWithTerminatingNull,
             array_buffer->ByteLength());
-  EXPECT_STREQ(kQuickBrownFox, static_cast<const char*>(array_buffer->Data()));
+  EXPECT_STREQ(kQuickBrownFox, static_cast<const char*>(array_buffer->Data().data()));
 }
 
 TEST_F(FetchDataLoaderTest, LoadAsArrayBufferFailed) {
diff --git a/third_party/blink/renderer/core/layout/shapes/shape.cc b/third_party/blink/renderer/core/layout/shapes/shape.cc
index ecc370b92ed82..8d3ef2f8ba658 100644
--- a/third_party/blink/renderer/core/layout/shapes/shape.cc
+++ b/third_party/blink/renderer/core/layout/shapes/shape.cc
@@ -263,7 +263,7 @@ static bool ExtractImageData(Image* image,
   // Set |surface| to draw directly to |contents|.
   const SkSurfaceProps disable_lcd_props;
   sk_sp<SkSurface> surface = SkSurfaces::WrapPixels(
-      dst_info, contents.Data(), dst_info.minRowBytes(), &disable_lcd_props);
+      dst_info, contents.Data().data(), dst_info.minRowBytes(), &disable_lcd_props);
   if (!surface)
     return false;
 
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
index fd9baa29e7aa5..804b9d733b2ca 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message.cc
@@ -78,7 +78,7 @@ BlinkTransferableMessage BlinkTransferableMessage::FromTransferableMessage(
       // correctly.
       CHECK_EQ(contents.DataLength(), big_buffer.size());
       UNSAFE_TODO(
-          memcpy(contents.Data(), big_buffer.data(), big_buffer.size()));
+          memcpy(contents.Data().data(), big_buffer.data(), big_buffer.size()));
       array_buffer_contents_array.push_back(std::move(contents));
     }
     result.message->SetArrayBufferContentsArray(
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
index a011eaedcba2d..964b2f4b8b405 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits.cc
@@ -175,7 +175,7 @@ bool StructTraits<blink::mojom::blink::SerializedArrayBufferContents::DataView,
   if (contents_data.size() != array_buffer_contents.DataLength()) {
     return false;
   }
-  UNSAFE_TODO(memcpy(array_buffer_contents.Data(), contents_data.data(),
+  UNSAFE_TODO(memcpy(array_buffer_contents.Data().data(), contents_data.data(),
                      contents_data.size()));
   *out = std::move(array_buffer_contents);
   return true;
diff --git a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
index 6e1fac208b325..50b19cf26a6bd 100644
--- a/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
+++ b/third_party/blink/renderer/core/messaging/blink_transferable_message_mojom_traits_test.cc
@@ -138,7 +138,7 @@ TEST(BlinkTransferableMessageStructTraitsTest,
   // the original ArrayBufferContents' data (as opposed to a copy of the data).
   ArrayBufferContents& deserialized_contents =
       out.message->GetArrayBufferContentsArray()[0];
-  ASSERT_EQ(originalContentsData, deserialized_contents.Data());
+  ASSERT_EQ(originalContentsData, deserialized_contents.Data().data());
 
   // The original ArrayBufferContents should be detached.
   ASSERT_TRUE(v8_buffer->WasDetached());
diff --git a/third_party/blink/renderer/core/mojo/mojo_handle.cc b/third_party/blink/renderer/core/mojo/mojo_handle.cc
index 5b832e56f6888..0d00ce6249ec1 100644
--- a/third_party/blink/renderer/core/mojo/mojo_handle.cc
+++ b/third_party/blink/renderer/core/mojo/mojo_handle.cc
@@ -131,7 +131,7 @@ MojoReadMessageResult* MojoHandle::readMessage(
       DOMArrayBuffer::CreateUninitializedOrNull(num_bytes, 1);
   if (num_bytes) {
     CHECK(buffer);
-    UNSAFE_TODO(memcpy(buffer->Data(), bytes, num_bytes));
+    UNSAFE_TODO(memcpy(buffer->Data().data(), bytes, num_bytes));
   }
   result_dict->setBuffer(buffer);
 
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
index a062d70d160f9..3db0a81bf5d82 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
@@ -185,21 +185,21 @@ void ArrayBufferContents::Reset() {
 
 void ArrayBufferContents::Transfer(ArrayBufferContents& other) {
   DCHECK(!IsShared());
-  DCHECK(!other.Data());
+  DCHECK().empty());
   other.backing_store_ = std::move(backing_store_);
 }
 
 void ArrayBufferContents::ShareWith(ArrayBufferContents& other) {
   DCHECK(IsShared());
-  DCHECK(!other.Data());
+  DCHECK().empty());
   other.backing_store_ = backing_store_;
 }
 
 void ArrayBufferContents::ShareNonSharedForInternalUse(
     ArrayBufferContents& other) {
   DCHECK(!IsShared());
-  DCHECK(!other.Data());
-  DCHECK(Data());
+  DCHECK().empty());
+  DCHECK(!Data().empty());
   other.backing_store_ = backing_store_;
 }
 
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
index d3ed7d55c634e..69f6be64fa167 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
@@ -114,16 +114,16 @@ class CORE_EXPORT ArrayBufferContents {
   // Resets the internal memory so that the ArrayBufferContents is empty.
   void Reset();
 
-  void* Data() const {
+  base::span<void> Data() const {
     DCHECK(!IsShared());
     return DataMaybeShared();
   }
   void* DataShared() const {
     DCHECK(IsShared());
-    return DataMaybeShared();
+    return DataMaybeShared().data();
   }
-  void* DataMaybeShared() const {
-    return backing_store_ ? backing_store_->Data() : nullptr;
+  base::span<void> DataMaybeShared() const {
+    return backing_store_ ? backing_store_->Data() : {};
   }
   size_t DataLength() const {
     return backing_store_ ? backing_store_->ByteLength() : 0;
@@ -140,13 +140,13 @@ class CORE_EXPORT ArrayBufferContents {
     // SAFETY: `BackingStore` guarantees that `Data()` points to at least
     // `DataLength()` many bytes.
     return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(Data()), DataLength()));
+        base::span(static_cast<uint8_t*>(Data().data()), DataLength()));
   }
   base::span<uint8_t> ByteSpanMaybeShared() const {
     // SAFETY: `BackingStore` guarantees that `Data()` points to at least
     // `DataLength()` many bytes.
     return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(DataMaybeShared()), DataLength()));
+        base::span(static_cast<uint8_t*>(DataMaybeShared().data()), DataLength()));
   }
 
   std::shared_ptr<v8::BackingStore> BackingStore() const {
diff --git a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
index 6e4e03b268166..2560d023016bc 100644
--- a/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
+++ b/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents_test.cc
@@ -30,7 +30,7 @@ TEST_F(ArrayBufferContentsTest, DISABLE_ON_ASAN(AllocationFail)) {
                                blink::ArrayBufferContents::kDontInitialize);
   // Check that no memory got allocated, and that DataLength is set accordingly.
   ASSERT_EQ(content2.DataLength(), 0u);
-  ASSERT_EQ(content2.Data(), nullptr);
+  ASSERT_EQ(content2.Data().data(), nullptr);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
index a8cf2d329011f..a93dded8a39c4 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.cc
@@ -156,7 +156,7 @@ v8::Maybe<bool> DOMArrayBuffer::TransferDetachable(
     return v8::Just(false);
   }
 
-  if (!Content()->Data()) {
+  if ().empty()) {
     // We transfer an empty ArrayBuffer, we can just allocate an empty content.
     result = ArrayBufferContents(Content()->BackingStore());
   } else {
@@ -239,7 +239,7 @@ DOMArrayBuffer* DOMArrayBuffer::CreateOrNull(size_t num_elements,
   ArrayBufferContents contents(num_elements, element_byte_size,
                                ArrayBufferContents::kNotShared,
                                ArrayBufferContents::kZeroInitialize);
-  if (!contents.Data()) {
+  if ().empty()) {
     return nullptr;
   }
   return Create(std::move(contents));
@@ -261,7 +261,7 @@ DOMArrayBuffer* DOMArrayBuffer::CreateUninitializedOrNull(
   ArrayBufferContents contents(num_elements, element_byte_size,
                                ArrayBufferContents::kNotShared,
                                ArrayBufferContents::kDontInitialize);
-  if (!contents.Data()) {
+  if ().empty()) {
     return nullptr;
   }
   return Create(std::move(contents));
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
index 7f4d5c2c6690e..d9fdbacf3e119 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
@@ -20,11 +20,11 @@ class CORE_EXPORT DOMArrayBufferBase : public ScriptWrappable {
   const ArrayBufferContents* Content() const { return &contents_; }
   ArrayBufferContents* Content() { return &contents_; }
 
-  const void* Data() const { return contents_.Data(); }
-  void* Data() { return contents_.Data(); }
+  const base::span<void> Data() const { return contents_.Data(); }
+  base::span<void> Data() { return contents_.Data(); }
 
-  const void* DataMaybeShared() const { return contents_.DataMaybeShared(); }
-  void* DataMaybeShared() { return contents_.DataMaybeShared(); }
+  const void* DataMaybeShared() const { return contents_.DataMaybeShared().data(); }
+  base::span<void> DataMaybeShared() { return contents_.DataMaybeShared(); }
 
   size_t ByteLength() const { return contents_.DataLength(); }
 
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
index 501df74360ea5..0f8d677d20460 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h
@@ -90,7 +90,7 @@ class CORE_EXPORT DOMArrayBufferView : public ScriptWrappable {
     }
   }
 
-  void* BaseAddress() const {
+  base::span<void> BaseAddress() const {
     DCHECK(!IsShared());
     return BaseAddressMaybeShared();
   }
@@ -103,20 +103,20 @@ class CORE_EXPORT DOMArrayBufferView : public ScriptWrappable {
   base::span<uint8_t> ByteSpan() const {
     // SAFETY: `byteLength()` returns the number of bytes at `BaseAddress()`.
     return UNSAFE_BUFFERS(
-        base::span(static_cast<uint8_t*>(BaseAddress()), byteLength()));
+        base::span(static_cast<uint8_t*>(BaseAddress().data()), byteLength()));
   }
 
   virtual unsigned TypeSize() const = 0;
   bool IsShared() const { return dom_array_buffer_->IsShared(); }
 
-  void* BaseAddressMaybeShared() const {
-    return !IsDetached() ? raw_base_address_ : nullptr;
+  base::span<void> BaseAddressMaybeShared() const {
+    return !IsDetached() ? raw_base_address_ : {};
   }
 
   base::span<uint8_t> ByteSpanMaybeShared() const {
     // SAFETY: `byteLength()` returns the number of bytes at `BaseAddress()`.
     return UNSAFE_BUFFERS(base::span(
-        static_cast<uint8_t*>(BaseAddressMaybeShared()), byteLength()));
+        static_cast<uint8_t*>(BaseAddressMaybeShared().data()), byteLength()));
   }
 
   // ScriptWrappable overrides:
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h b/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
index 53352a42e1d9c..48d68e9944974 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_typed_array.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_TYPED_ARRAYS_DOM_TYPED_ARRAY_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_TYPED_ARRAYS_DOM_TYPED_ARRAY_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/core_export.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h"
 #include "v8/include/v8.h"
@@ -72,10 +73,10 @@ class DOMTypedArray final : public DOMArrayBufferView {
     CHECK(VerifySubRange(dom_array_buffer, byte_offset, length));
   }
 
-  ValueType* Data() const { return static_cast<ValueType*>(BaseAddress()); }
+  base::span<ValueType> Data() const { return static_cast<ValueType*>(BaseAddress()); }
 
   ValueType* DataMaybeShared() const {
-    return reinterpret_cast<ValueType*>(BaseAddressMaybeShared());
+    return reinterpret_cast<ValueType*>(BaseAddressMaybeShared().data());
   }
 
   base::span<ValueType> AsSpan() const {
diff --git a/third_party/blink/renderer/modules/ai/language_model.cc b/third_party/blink/renderer/modules/ai/language_model.cc
index 5879dda39a106..752c936ce40fd 100644
--- a/third_party/blink/renderer/modules/ai/language_model.cc
+++ b/third_party/blink/renderer/modules/ai/language_model.cc
@@ -226,7 +226,7 @@ ToMojo(base::span<uint8_t> audio_bytes, ExecutionContext* execution_context) {
   CHECK_EQ(audio_data->channel_count, 1);
   // TODO(crbug.com/382180351): Avoid a copy.
   audio_data->data = WTF::Vector<float>(bus->length());
-  std::copy_n(bus->Channel(0)->Data(), bus->Channel(0)->length(),
+  std::copy_n(bus->Channel(0)->Data().data(), bus->Channel(0)->length(),
               audio_data->data.begin());
   return mojom::blink::AILanguageModelPromptContent::NewAudio(
       std::move(audio_data));
diff --git a/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc b/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
index b62d1d77a2d46..9bbfe90ef8749 100644
--- a/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
+++ b/third_party/blink/renderer/modules/breakout_box/media_stream_audio_track_underlying_source_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -119,7 +121,7 @@ class MediaStreamAudioTrackUnderlyingSourceTest : public testing::Test {
   void SetChannelData(media::AudioBus* bus, int channel, float value) {
     ASSERT_LE(channel, bus->channels());
 
-    float* bus_channel = bus->channel(channel);
+    base::span<float>bus_channel = bus->channel(channel);
     for (int i = 0; i < bus->frames(); ++i) {
       bus_channel[i] = value;
     }
diff --git a/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc b/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
index 420c126f89a14..7820c30a6d9c2 100644
--- a/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
+++ b/third_party/blink/renderer/modules/breakout_box/pushable_media_stream_audio_source_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -73,7 +75,7 @@ class FakeMediaStreamAudioSink : public WebMediaStreamAudioSink {
 
       for (int ch = 0; ch < data.channels(); ++ch) {
         const float* actual_channel_data = data.channel(ch);
-        const float* expected_channel_data = expected_data_->channel(ch);
+        base::span<const float>expected_channel_data = expected_data_->channel(ch);
 
         for (int i = 0; i < data.frames(); ++i) {
           // If we use ASSERT_EQ here, the test will hang, since |on_data_| will
@@ -312,8 +314,8 @@ TEST_P(PushableMediaStreamAudioSourceTest, ConvertsFormatInternally) {
 
   // Create reference planar data.
   auto expected_data = media::AudioBus::Create(kChannels, kFrames);
-  float* bus_data_ch_0 = expected_data->channel(0);
-  float* bus_data_ch_1 = expected_data->channel(1);
+  base::span<float>bus_data_ch_0 = expected_data->channel(0);
+  base::span<float>bus_data_ch_1 = expected_data->channel(1);
   for (int i = 0; i < kFrames; ++i) {
     float value = static_cast<float>(i) / kFrames;
     bus_data_ch_0[i] = value;
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
index fed7459ffce55..14f155164f1dd 100644
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_2d_recorder_context.cc
@@ -2684,7 +2684,7 @@ scoped_refptr<cc::RefCountedBuffer<SkPoint>> MakeSkPointBuffer(
   const size_t size = array->length() / 2;
   std::vector<SkPoint> skpoints(size);
   UNSAFE_TODO(
-      std::memcpy(skpoints.data(), array->Data(), size * sizeof(SkPoint)));
+      std::memcpy(skpoints.data(), array->Data().data(), size * sizeof(SkPoint)));
 
   return base::MakeRefCounted<cc::RefCountedBuffer<SkPoint>>(
       std::move(skpoints));
diff --git a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
index 3be83fb60b2d1..bbe8653584d34 100644
--- a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
+++ b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc
@@ -394,7 +394,7 @@ void DecodeImageOnDecoderThread(
   const bool data_complete = true;
   std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
       SegmentReader::CreateFromSkData(
-          SkData::MakeWithoutCopy(contents.Data(), contents.DataLength())),
+          SkData::MakeWithoutCopy(contents.Data().data(), contents.DataLength())),
       data_complete, alpha_option, ImageDecoder::kDefaultBitDepth,
       color_behavior, cc::AuxImage::kDefault,
       Platform::GetMaxDecodedImageBytes());
diff --git a/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc b/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
index 68dbba3c8d69b..d1bc18960a22d 100644
--- a/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
+++ b/third_party/blink/renderer/modules/clipboard/clipboard_writer.cc
@@ -66,7 +66,7 @@ class ClipboardImageWriter final : public ClipboardWriter {
     DCHECK(!IsMainThread());
     std::unique_ptr<ImageDecoder> decoder = ImageDecoder::Create(
         SegmentReader::CreateFromSkData(
-            SkData::MakeWithoutCopy(png_data.Data(), png_data.DataLength())),
+            SkData::MakeWithoutCopy(png_data.Data().data(), png_data.DataLength())),
         /*data_complete=*/true, ImageDecoder::kAlphaPremultiplied,
         ImageDecoder::kDefaultBitDepth, ColorBehavior::kTag,
         cc::AuxImage::kDefault, Platform::GetMaxDecodedImageBytes());
diff --git a/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc b/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
index b2c0d5e883720..f49b4e001116d 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/credential_manager_type_converters_unittest.cc
@@ -148,8 +148,8 @@ MATCHER_P(UnionDOMArrayBufferOrViewEqualTo, vector, "") {
   if (buffer->ByteLength() != std::size(vector)) {
     return false;
   }
-  uint8_t* data = (uint8_t*)buffer->Data();
-  return std::equal(data, data + buffer->ByteLength(), std::begin(vector));
+  base::span<uint8_t>data = (uint8_t*)buffer->Data();
+  return std::equal(data, data .subspan( buffer->ByteLength()), std::begin(vector));
 }
 
 TEST(CredentialManagerTypeConvertersTest,
diff --git a/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc b/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
index 3effedaeea420..9ec6e406be477 100644
--- a/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
+++ b/third_party/blink/renderer/modules/encryptedmedia/media_key_status_map.cc
@@ -48,7 +48,7 @@ class MediaKeyStatusMap::MapEntry final
 
     // Compare the bytes.
     int result = UNSAFE_TODO(
-        memcmp(a->KeyId()->Data(), b->KeyId()->Data(),
+        memcmp(a->KeyId()->Data().data(), b->KeyId()->Data().data(),
                std::min(a->KeyId()->ByteLength(), b->KeyId()->ByteLength())));
     if (result != 0)
       return result < 0;
diff --git a/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc b/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
index 9c18e49537f6b..a2a8b6794149d 100644
--- a/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
+++ b/third_party/blink/renderer/modules/fuzzing/internals_fuzzing.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -30,7 +32,7 @@ ScriptPromise<IDLUndefined> InternalsFuzzing::runFuzzer(
     const String& fuzzer_id,
     V8BufferSource* fuzzer_data) {
   auto* context = ExecutionContext::From(script_state);
-  const uint8_t* bytes = nullptr;
+  base::span<const uint8_t>bytes = {};
   size_t num_bytes = 0;
 
   switch (fuzzer_data->GetContentType()) {
@@ -48,7 +50,7 @@ ScriptPromise<IDLUndefined> InternalsFuzzing::runFuzzer(
     }
   }
 
-  std::vector<uint8_t> data(bytes, bytes + num_bytes);
+  std::vector<uint8_t> data(bytes.data(), bytes .subspan( num_bytes).data());
 
   auto* resolver =
       MakeGarbageCollected<ScriptPromiseResolver<IDLUndefined>>(script_state);
diff --git a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
index b38f9cab981bc..714ee60ae2bac 100644
--- a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
+++ b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_input.cc
@@ -6,6 +6,7 @@
 
 #include <cmath>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -258,7 +259,7 @@ double AudioRendererMixerInput::ProvideInput(
     // Apply a perfect linear fade-in. Fading-in in steps (e.g. increasing
     // volume by 10% every 1ms over 10ms) introduces high frequency distortions.
     for (int ch = 0; ch < audio_bus->channels(); ++ch) {
-      float* data = audio_bus->channel(ch);
+      base::span<float>data = audio_bus->channel(ch);
 
       for (int i = 0; i < frames; ++i) {
         UNSAFE_TODO(data[i]) *=
diff --git a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
index 5b61e009e8c1b..4869254388a2b 100644
--- a/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
+++ b/third_party/blink/renderer/modules/media/audio/audio_renderer_mixer_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -202,8 +204,8 @@ class AudioRendererMixerTest
   // Fill |audio_bus_| fully with |value|.
   void FillAudioData(float value) {
     for (int i = 0; i < audio_bus_->channels(); ++i) {
-      std::fill(audio_bus_->channel(i),
-                audio_bus_->channel(i) + audio_bus_->frames(), value);
+      std::fill(audio_bus_->channel(i).data(),
+                audio_bus_->channel(i) .subspan( audio_bus_->frames()).data(), value);
     }
   }
 
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
index b342a3a9367f2..31a83f0a5fa5e 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
@@ -869,7 +869,7 @@ void RTCDataChannel::BlobReader::DidFinishLoading(FileReaderData data) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DOMArrayBuffer* array_buffer = std::move(data).AsDOMArrayBuffer();
   webrtc::CopyOnWriteBuffer buffer(
-      static_cast<const char*>((array_buffer->Data())),
+      static_cast<const char*>((array_buffer->Data().data())),
       array_buffer->ByteLength());
   message_->buffer_ = webrtc::DataBuffer(buffer, true);
   message_->type_ = RTCDataChannel::PendingMessage::Type::kBufferReady;
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc b/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
index 96a5869a710fb..40f3b4056871f 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_dtls_transport.cc
@@ -158,8 +158,8 @@ void RTCDtlsTransport::OnStateChange(webrtc::DtlsTransportInformation info) {
         // Don't replace the certificate if it's unchanged.
         // Should have been "if (*dab_cert != *remote_certificates_[i])"
         if (dab_cert->ByteLength() != remote_certificates_[i]->ByteLength() ||
-            UNSAFE_TODO(memcmp(dab_cert->Data(),
-                               remote_certificates_[i]->Data(),
+            UNSAFE_TODO(memcmp(dab_cert->Data().data(),
+                               remote_certificates_[i]->Data().data(),
                                dab_cert->ByteLength())) != 0) {
           remote_certificates_[i] = dab_cert;
         }
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
index 59e70385bf08f..7e0d828aa2346 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_frame_delegate.cc
@@ -66,7 +66,7 @@ void RTCEncodedAudioFrameDelegate::SetData(const DOMArrayBuffer* data) {
   base::AutoLock lock(lock_);
   if (webrtc_frame_ && data) {
     webrtc_frame_->SetData(webrtc::ArrayView<const uint8_t>(
-        static_cast<const uint8_t*>(data->Data()), data->ByteLength()));
+        static_cast<const uint8_t*>(data->Data().data()), data->ByteLength()));
   }
 }
 
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
index e59dadee8972b..0410617c3ddc9 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_delegate.cc
@@ -79,7 +79,7 @@ void RTCEncodedVideoFrameDelegate::SetData(const DOMArrayBuffer* data) {
   base::AutoLock lock(lock_);
   if (webrtc_frame_ && data) {
     webrtc_frame_->SetData(webrtc::ArrayView<const uint8_t>(
-        static_cast<const uint8_t*>(data->Data()), data->ByteLength()));
+        static_cast<const uint8_t*>(data->Data().data()), data->ByteLength()));
   }
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/audio_buffer.cc b/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
index 1708409e4c63d..cdc9f53bcf4f7 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
@@ -192,8 +192,8 @@ AudioBuffer::AudioBuffer(AudioBus* bus)
       return;
     }
 
-    const float* src = bus->Channel(i)->Data();
-    float* dst = channel_data_array->Data();
+    const float* src = bus->Channel(i)->Data().data();
+    float* dst = channel_data_array->Data().data();
     UNSAFE_TODO(memmove(dst, src, length_ * sizeof(*dst)));
     channels_.push_back(channel_data_array);
   }
@@ -306,7 +306,7 @@ void AudioBuffer::copyToChannel(NotShared<DOMFloat32Array> source,
 void AudioBuffer::Zero() {
   for (unsigned i = 0; i < channels_.size(); ++i) {
     if (NotShared<DOMFloat32Array> array = getChannelData(i)) {
-      float* data = array->Data();
+      float* data = array->Data().data();
       UNSAFE_TODO(memset(data, 0, length() * sizeof(*data)));
     }
   }
@@ -327,7 +327,7 @@ SharedAudioBuffer::SharedAudioBuffer(AudioBuffer* buffer)
 
 void SharedAudioBuffer::Zero() {
   for (auto& channel : channels_) {
-    float* data = static_cast<float*>(channel.Data());
+    float* data = static_cast<float*>(channel.Data().data());
     UNSAFE_TODO(memset(data, 0, length() * sizeof(*data)));
   }
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_context.cc b/third_party/blink/renderer/modules/webaudio/audio_context.cc
index e27966fa1d9fd..ffe9717158105 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_context.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_context.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/audio_context.h"
 
+#include "base/containers/span.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/to_string.h"
@@ -138,7 +139,7 @@ bool IsAudible(const AudioBus* rendered_data) {
 
   uint32_t data_size = rendered_data->length();
   for (uint32_t k = 0; k < rendered_data->NumberOfChannels(); ++k) {
-    const float* data = rendered_data->Channel(k)->Data();
+    base::span<const float>data = rendered_data->Channel(k)->Data();
     float channel_energy;
     vector_math::Vsvesq(data, 1, &channel_energy, data_size);
     energy += channel_energy;
diff --git a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
index 114a8f231f94d..5019fbead55f1 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/audio_listener_handler.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/modules/webaudio/panner_handler.h"
 #include "third_party/blink/renderer/platform/audio/hrtf_database_loader.h"
 
@@ -76,53 +77,53 @@ AudioListenerHandler::~AudioListenerHandler() {
   panner_handlers_.clear();
 }
 
-const float* AudioListenerHandler::GetPositionXValues(
+const base::span<float> AudioListenerHandler::GetPositionXValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return position_x_values_.Data();
 }
 
-const float* AudioListenerHandler::GetPositionYValues(
+const base::span<float> AudioListenerHandler::GetPositionYValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return position_y_values_.Data();
 }
 
-const float* AudioListenerHandler::GetPositionZValues(
+const base::span<float> AudioListenerHandler::GetPositionZValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return position_z_values_.Data();
 }
 
-const float* AudioListenerHandler::GetForwardXValues(
+const base::span<float> AudioListenerHandler::GetForwardXValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return forward_x_values_.Data();
 }
 
-const float* AudioListenerHandler::GetForwardYValues(
+const base::span<float> AudioListenerHandler::GetForwardYValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return forward_y_values_.Data();
 }
 
-const float* AudioListenerHandler::GetForwardZValues(
+const base::span<float> AudioListenerHandler::GetForwardZValues(
     uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return forward_z_values_.Data();
 }
 
-const float* AudioListenerHandler::GetUpXValues(uint32_t frames_to_process) {
+const base::span<float> AudioListenerHandler::GetUpXValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return up_x_values_.Data();
 }
 
-const float* AudioListenerHandler::GetUpYValues(uint32_t frames_to_process) {
+const base::span<float> AudioListenerHandler::GetUpYValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return up_y_values_.Data();
 }
 
-const float* AudioListenerHandler::GetUpZValues(uint32_t frames_to_process) {
+const base::span<float> AudioListenerHandler::GetUpZValues(uint32_t frames_to_process) {
   UpdateValuesIfNeeded(frames_to_process);
   return up_z_values_.Data();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.h b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.h
index 01caabfff299f..cf8d8b7b11e39 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_listener_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_listener_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_AUDIO_LISTENER_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_AUDIO_LISTENER_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_param.h"
 #include "ui/gfx/geometry/point3_f.h"
 #include "ui/gfx/geometry/vector3d_f.h"
@@ -49,15 +50,15 @@ class AudioListenerHandler final
                           up_z_handler_->Value());
   }
 
-  const float* GetPositionXValues(uint32_t frames_to_process);
-  const float* GetPositionYValues(uint32_t frames_to_process);
-  const float* GetPositionZValues(uint32_t frames_to_process);
-  const float* GetForwardXValues(uint32_t frames_to_process);
-  const float* GetForwardYValues(uint32_t frames_to_process);
-  const float* GetForwardZValues(uint32_t frames_to_process);
-  const float* GetUpXValues(uint32_t frames_to_process);
-  const float* GetUpYValues(uint32_t frames_to_process);
-  const float* GetUpZValues(uint32_t frames_to_process);
+  const base::span<float> GetPositionXValues(uint32_t frames_to_process);
+  const base::span<float> GetPositionYValues(uint32_t frames_to_process);
+  const base::span<float> GetPositionZValues(uint32_t frames_to_process);
+  const base::span<float> GetForwardXValues(uint32_t frames_to_process);
+  const base::span<float> GetForwardYValues(uint32_t frames_to_process);
+  const base::span<float> GetForwardZValues(uint32_t frames_to_process);
+  const base::span<float> GetUpXValues(uint32_t frames_to_process);
+  const base::span<float> GetUpYValues(uint32_t frames_to_process);
+  const base::span<float> GetUpZValues(uint32_t frames_to_process);
 
   // True if any of AudioParams have automations.
   bool HasSampleAccurateValues() const;
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
index 90df9dd298426..35d17e34bb247 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -32,7 +34,7 @@ namespace blink {
 namespace {
 
 // Replace NaN values in `values` with `default_value`.
-void HandleNaNValues(float* values,
+void HandleNaNValues(base::span<float>values,
                      unsigned number_of_values,
                      float default_value) {
   unsigned k = 0;
@@ -40,14 +42,14 @@ void HandleNaNValues(float* values,
   if (number_of_values >= 4) {
     __m128 defaults = _mm_set1_ps(default_value);
     for (k = 0; k < number_of_values; k += 4) {
-      __m128 v = _mm_loadu_ps(values + k);
+      __m128 v = _mm_loadu_ps(values .subspan( k).data());
       // cmpuord returns all 1's if v is NaN for each elmeent of v.
       __m128 isnan = _mm_cmpunord_ps(v, v);
       // Replace NaN parts with default.
       __m128 result = _mm_and_ps(isnan, defaults);
       // Merge in the parts that aren't NaN
       result = _mm_or_ps(_mm_andnot_ps(isnan, v), result);
-      _mm_storeu_ps(values + k, result);
+      _mm_storeu_ps(values .subspan( k).data(), result);
     }
   }
 #elif defined(CPU_ARM_NEON)
@@ -222,7 +224,7 @@ void AudioParamHandler::SetValue(float value) {
 
 float AudioParamHandler::FinalValue() {
   float value = IntrinsicValue();
-  CalculateFinalValues(&value, 1, false);
+  CalculateFinalValues(base::span<float, 1>(&value, 1u), 1, false);
   return value;
 }
 
@@ -231,14 +233,14 @@ void AudioParamHandler::CalculateSampleAccurateValues(
   DCHECK(GetDeferredTaskHandler().IsAudioThread());
   DCHECK(!values.empty());
 
-  CalculateFinalValues(values.data(), values.size(), IsAudioRate());
+  CalculateFinalValues(values, values.size(), IsAudioRate());
 }
 
-void AudioParamHandler::CalculateFinalValues(float* values,
+void AudioParamHandler::CalculateFinalValues(base::span<float>values,
                                              unsigned number_of_values,
                                              bool sample_accurate) {
   DCHECK(GetDeferredTaskHandler().IsAudioThread());
-  DCHECK(values);
+  DCHECK(!values.empty());
   DCHECK_GT(number_of_values, 0u);
 
   // The calculated result will be the "intrinsic" value summed with all
@@ -316,7 +318,7 @@ void AudioParamHandler::CalculateFinalValues(float* values,
   }
 }
 
-void AudioParamHandler::CalculateTimelineValues(float* values,
+void AudioParamHandler::CalculateTimelineValues(base::span<float>values,
                                                 unsigned number_of_values) {
   // Calculate values for this render quantum.  Normally
   // `number_of_values` will equal to
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_handler.h b/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
index 8f9ca0fccbef5..f88e220c80730 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_handler.h
@@ -9,6 +9,7 @@
 
 #include <atomic>
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer_view_helpers.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
@@ -180,10 +181,10 @@ class AudioParamHandler final : public ThreadSafeRefCounted<AudioParamHandler>,
 
   // sampleAccurate corresponds to a-rate (audio rate) vs. k-rate in the Web
   // Audio specification.
-  void CalculateFinalValues(float* values,
+  void CalculateFinalValues(base::span<float>values,
                             unsigned number_of_values,
                             bool sample_accurate);
-  void CalculateTimelineValues(float* values, unsigned number_of_values);
+  void CalculateTimelineValues(base::span<float>values, unsigned number_of_values);
 
   // The type of AudioParam, indicating what this AudioParam represents and what
   // node it belongs to.  Mostly for informational purposes and doesn't affect
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
index de5407b5f6a21..4771d1076b600 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.cc
@@ -23,6 +23,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -972,7 +974,7 @@ std::tuple<bool, float> AudioParamTimeline::ValueForContextTime(
   // One parameter change per render quantum.
   double control_rate = sample_rate / render_quantum_frames;
   value = ValuesForFrameRange(start_frame, start_frame + 1, default_value,
-                              &value, 1, sample_rate, control_rate, min_value,
+                              base::span<float, 1>(&value, 1u), 1, sample_rate, control_rate, min_value,
                               max_value, render_quantum_frames);
 
   return std::make_tuple(true, value);
@@ -981,7 +983,7 @@ std::tuple<bool, float> AudioParamTimeline::ValueForContextTime(
 float AudioParamTimeline::ValuesForFrameRange(size_t start_frame,
                                               size_t end_frame,
                                               float default_value,
-                                              float* values,
+                                              base::span<float>values,
                                               unsigned number_of_values,
                                               double sample_rate,
                                               double control_rate,
@@ -991,7 +993,7 @@ float AudioParamTimeline::ValuesForFrameRange(size_t start_frame,
   // We can't contend the lock in the realtime audio thread.
   base::AutoTryLock try_locker(events_lock_);
   if (!try_locker.is_acquired()) {
-    if (values) {
+    if (!values.empty()) {
       for (unsigned i = 0; i < number_of_values; ++i) {
         values[i] = default_value;
       }
@@ -1014,12 +1016,12 @@ float AudioParamTimeline::ValuesForFrameRangeImpl(
     size_t start_frame,
     size_t end_frame,
     float default_value,
-    float* values,
+    base::span<float>values,
     unsigned number_of_values,
     double sample_rate,
     double control_rate,
     unsigned render_quantum_frames) {
-  DCHECK(values);
+  DCHECK(!values.empty());
   DCHECK_GE(number_of_values, 1u);
 
   // Return default value if there are no events matching the desired time
@@ -1218,7 +1220,7 @@ float AudioParamTimeline::ValuesForFrameRangeImpl(
 }
 
 std::tuple<size_t, unsigned> AudioParamTimeline::HandleFirstEvent(
-    float* values,
+    base::span<float>values,
     float default_value,
     unsigned number_of_values,
     size_t start_frame,
@@ -1314,7 +1316,7 @@ bool AudioParamTimeline::HandleAllEventsInThePast(
     double sample_rate,
     float& default_value,
     unsigned number_of_values,
-    float* values,
+    base::span<float>values,
     unsigned render_quantum_frames) {
   // Optimize the case where the last event is in the past.
   ParamEvent* last_event = events_[events_.size() - 1].get();
@@ -1510,7 +1512,7 @@ AudioParamTimeline::HandleCancelValues(const ParamEvent* current_event,
 
 std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessLinearRamp(
     const AutomationState& current_state,
-    float* values,
+    base::span<float>values,
     size_t current_frame,
     float value,
     unsigned write_index) {
@@ -1561,7 +1563,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessLinearRamp(
 
     // Process 4 loop steps.
     for (; write_index < fill_to_frame_trunc; write_index += 4) {
-      _mm_storeu_ps(values + write_index, v_value);
+      _mm_storeu_ps(values .subspan( write_index).data(), v_value);
       v_value = _mm_add_ps(v_value, v_inc);
     }
   }
@@ -1586,7 +1588,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessLinearRamp(
 
 std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessExponentialRamp(
     const AutomationState& current_state,
-    float* values,
+    base::span<float>values,
     size_t current_frame,
     float value,
     unsigned write_index) {
@@ -1658,7 +1660,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessExponentialRamp(
 
 std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetTarget(
     const AutomationState& current_state,
-    float* values,
+    base::span<float>values,
     size_t current_frame,
     float value,
     unsigned write_index) {
@@ -1746,7 +1748,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetTarget(
         v_value = _mm_set_ps1(value);
 
         v_result = _mm_add_ps(v_value, _mm_mul_ps(v_delta, v_c));
-        _mm_storeu_ps(values + write_index, v_result);
+        _mm_storeu_ps(values .subspan( write_index).data(), v_result);
 
         // Update value for next iteration.
         value += delta * c3;
@@ -1771,7 +1773,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetTarget(
 
 std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetValueCurve(
     const AutomationState& current_state,
-    float* values,
+    base::span<float>values,
     size_t current_frame,
     float value,
     unsigned write_index) {
@@ -1906,7 +1908,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetValueCurve(
       __m128 v_value =
           _mm_add_ps(v_c0, _mm_mul_ps(_mm_sub_ps(v_c1, v_c0), v_delta));
 
-      _mm_storeu_ps(values + write_index, v_value);
+      _mm_storeu_ps(values .subspan( write_index).data(), v_value);
     }
     // Pass along k to the serial loop.
     k = truncated_steps;
@@ -1965,7 +1967,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessSetValueCurve(
 
 std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessCancelValues(
     const AutomationState& current_state,
-    float* values,
+    base::span<float>values,
     size_t current_frame,
     float value,
     unsigned write_index) {
@@ -2009,7 +2011,7 @@ std::tuple<size_t, float, unsigned> AudioParamTimeline::ProcessCancelValues(
   return std::make_tuple(current_frame, value, write_index);
 }
 
-uint32_t AudioParamTimeline::FillWithDefault(float* values,
+uint32_t AudioParamTimeline::FillWithDefault(base::span<float>values,
                                              float default_value,
                                              uint32_t end_frame,
                                              uint32_t write_index) {
diff --git a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.h b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.h
index 57e8cad686360..e6263998e847f 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_param_timeline.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_param_timeline.h
@@ -31,6 +31,7 @@
 
 #include <tuple>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
@@ -93,7 +94,7 @@ class AudioParamTimeline {
   float ValuesForFrameRange(size_t start_frame,
                             size_t end_frame,
                             float default_value,
-                            float* values,
+                            base::span<float>values,
                             unsigned number_of_values,
                             double sample_rate,
                             double control_rate,
@@ -307,7 +308,7 @@ class AudioParamTimeline {
   float ValuesForFrameRangeImpl(size_t start_frame,
                                 size_t end_frame,
                                 float default_value,
-                                float* values,
+                                base::span<float>values,
                                 unsigned number_of_values,
                                 double sample_rate,
                                 double control_rate,
@@ -344,7 +345,7 @@ class AudioParamTimeline {
   // starts after `start_frame`.  These initial values are filled using
   // `default_value`.  The updated `current_frame` and `write_index` is
   // returned.
-  std::tuple<size_t, unsigned> HandleFirstEvent(float* values,
+  std::tuple<size_t, unsigned> HandleFirstEvent(base::span<float>values,
                                                 float default_value,
                                                 unsigned number_of_values,
                                                 size_t start_frame,
@@ -375,7 +376,7 @@ class AudioParamTimeline {
                                 double sample_rate,
                                 float& default_value,
                                 unsigned number_of_values,
-                                float* values,
+                                base::span<float>values,
                                 unsigned render_quantum_frames)
       EXCLUSIVE_LOCKS_REQUIRED(events_lock_);
 
@@ -407,7 +408,7 @@ class AudioParamTimeline {
   // computed `value`, and the updated `write_index`.
   std::tuple<size_t, float, unsigned> ProcessLinearRamp(
       const AutomationState& current_state,
-      float* values,
+      base::span<float>values,
       size_t current_frame,
       float value,
       unsigned write_index);
@@ -417,7 +418,7 @@ class AudioParamTimeline {
   // computed `value`, and the updated `write_index`.
   std::tuple<size_t, float, unsigned> ProcessExponentialRamp(
       const AutomationState& current_state,
-      float* values,
+      base::span<float>values,
       size_t current_frame,
       float value,
       unsigned write_index);
@@ -427,7 +428,7 @@ class AudioParamTimeline {
   // computed `value`, and the updated `write_index`.
   std::tuple<size_t, float, unsigned> ProcessSetTarget(
       const AutomationState& current_state,
-      float* values,
+      base::span<float>values,
       size_t current_frame,
       float value,
       unsigned write_index);
@@ -437,7 +438,7 @@ class AudioParamTimeline {
   // computed `value`, and the updated `write_index`.
   std::tuple<size_t, float, unsigned> ProcessSetValueCurve(
       const AutomationState& current_state,
-      float* values,
+      base::span<float>values,
       size_t current_frame,
       float value,
       unsigned write_index);
@@ -447,7 +448,7 @@ class AudioParamTimeline {
   // computed `value`, and the updated `write_index`.
   std::tuple<size_t, float, unsigned> ProcessCancelValues(
       const AutomationState& current_state,
-      float* values,
+      base::span<float>values,
       size_t current_frame,
       float value,
       unsigned write_index) EXCLUSIVE_LOCKS_REQUIRED(events_lock_);
@@ -455,7 +456,7 @@ class AudioParamTimeline {
   // Fill the output vector `values` with the value `default_value`,
   // starting at `write_index` and continuing up to `end_frame`
   // (exclusive).  `write_index` is updated with the new index.
-  uint32_t FillWithDefault(float* values,
+  uint32_t FillWithDefault(base::span<float>values,
                            float default_value,
                            uint32_t end_frame,
                            uint32_t write_index);
diff --git a/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
index 8a4039031f7e6..2350b9487573d 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_scheduled_source_handler.cc
@@ -119,7 +119,7 @@ AudioScheduledSourceHandler::UpdateSchedulingInfo(size_t quantum_frame_size,
   // start time in the middle of the quantum.
   if (quantum_frame_offset) {
     for (unsigned i = 0; i < output_bus->NumberOfChannels(); ++i) {
-      UNSAFE_TODO(memset(output_bus->Channel(i)->MutableData(), 0,
+      UNSAFE_TODO(memset(output_bus->Channel(i)->MutableData().data(), 0,
                          sizeof(float) * quantum_frame_offset));
     }
   }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
index 3a72a57975126..1c3edd26a9015 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_global_scope_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -337,8 +339,8 @@ class AudioWorkletGlobalScopeTest : public PageTestBase, public ModuleTestBase {
     output_buses.push_back(output_bus.get());
 
     // Fill `input_channel` with 1 and zero out `output_bus`.
-    std::fill(input_channel->MutableData(),
-              input_channel->MutableData() + input_channel->length(), 1);
+    std::fill(input_channel->MutableData().data(),
+              input_channel->MutableData() .subspan( input_channel->length()).data(), 1);
     output_bus->Zero();
 
     // Then invoke the process() method to perform JS buffer manipulation. The
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
index 22689fc28ec1c..7fe2f3baccf42 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
@@ -159,7 +159,7 @@ void AudioWorkletHandler::ProcessInternal(uint32_t frames_to_process) {
       param_handler->CalculateSampleAccurateValues(
           param_values->as_span().first(frames_to_process));
     } else {
-      std::fill(param_values->Data(),
+      std::fill(param_values->Data().data(),
                 UNSAFE_TODO(param_values->Data() + frames_to_process),
                 param_handler->FinalValue());
     }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
index 0eb24402ce31b..2ba0f55cb4411 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_processor.cc
@@ -381,7 +381,7 @@ void AudioWorkletProcessor::CopyPortToArrayBuffers(
                                .Get(isolate)
                                ->GetBackingStore();
       UNSAFE_TODO(memcpy(backing_store->Data(),
-                         audio_bus->Channel(channel_index)->Data(),
+                         audio_bus->Channel(channel_index)->Data().data(),
                          bus_length * sizeof(float)));
     }
   }
@@ -405,10 +405,10 @@ void AudioWorkletProcessor::CopyArrayBuffersToPort(
       // An ArrayBuffer might be transferred. So we need to check the byte
       // length and silence the output buffer if needed.
       if (backing_store->ByteLength() == bus_length) {
-        UNSAFE_TODO(memcpy(audio_bus->Channel(channel_index)->MutableData(),
+        UNSAFE_TODO(memcpy(audio_bus->Channel(channel_index)->MutableData().data(),
                            backing_store->Data(), bus_length));
       } else {
-        UNSAFE_TODO(memset(audio_bus->Channel(channel_index)->MutableData(), 0,
+        UNSAFE_TODO(memset(audio_bus->Channel(channel_index)->MutableData().data(), 0,
                            bus_length));
       }
     }
@@ -565,7 +565,7 @@ bool AudioWorkletProcessor::CopyParamValueMapToObject(
     }
 
     UNSAFE_TODO(memcpy(float32_array->Buffer()->GetBackingStore()->Data(),
-                       param_array->Data(), array_length * sizeof(float)));
+                       param_array->Data().data(), array_length * sizeof(float)));
   }
 
   return true;
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
index 0969be50850c8..634e02de608d1 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -229,11 +231,11 @@ void BiquadDSPKernel::UpdateTailTime(int coef_index) {
   tail_time_ = ClampTo(tail, 0.0, kMaxTailTime);
 }
 
-void BiquadDSPKernel::Process(const float* source,
-                              float* destination,
+void BiquadDSPKernel::Process(base::span<const float>source,
+                              base::span<float>destination,
                               uint32_t frames_to_process) {
-  DCHECK(source);
-  DCHECK(destination);
+  DCHECK(!source.empty());
+  DCHECK(!destination.empty());
   DCHECK(GetBiquadProcessor());
 
   // Recompute filter coefficients if any of the parameters have changed.
@@ -256,17 +258,17 @@ void BiquadDSPKernel::Process(const float* source,
 
 void BiquadDSPKernel::GetFrequencyResponse(BiquadDSPKernel& kernel,
                                            int n_frequencies,
-                                           const float* frequency_hz,
-                                           float* mag_response,
-                                           float* phase_response) {
+                                           base::span<const float>frequency_hz,
+                                           base::span<float>mag_response,
+                                           base::span<float>phase_response) {
   // Only allow on the main thread because we don't want the audio thread to be
   // updating `kernel` while we're computing the response.
   DCHECK(IsMainThread());
 
   DCHECK_GE(n_frequencies, 0);
-  DCHECK(frequency_hz);
-  DCHECK(mag_response);
-  DCHECK(phase_response);
+  DCHECK(!frequency_hz.empty());
+  DCHECK(!mag_response.empty());
+  DCHECK(!phase_response.empty());
 
   Vector<float> frequency(n_frequencies);
   double nyquist = kernel.Nyquist();
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
index 92a413be11701..a7c11dcd8f592 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
+++ b/third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_BIQUAD_DSP_KERNEL_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_BIQUAD_DSP_KERNEL_H_
 
+#include "base/containers/span.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/renderer/modules/webaudio/biquad_processor.h"
 #include "third_party/blink/renderer/platform/audio/audio_dsp_kernel.h"
@@ -46,8 +47,8 @@ class BiquadDSPKernel final : public AudioDSPKernel {
         tail_time_(std::numeric_limits<double>::infinity()) {}
 
   // AudioDSPKernel
-  void Process(const float* source,
-               float* dest,
+  void Process(base::span<const float>source,
+               base::span<float>dest,
                uint32_t frames_to_process) override;
   void Reset() override { biquad_.Reset(); }
 
@@ -56,9 +57,9 @@ class BiquadDSPKernel final : public AudioDSPKernel {
   // must be called from the main thread.
   static void GetFrequencyResponse(BiquadDSPKernel& kernel,
                                    int n_frequencies,
-                                   const float* frequency_hz,
-                                   float* mag_response,
-                                   float* phase_response);
+                                   base::span<const float>frequency_hz,
+                                   base::span<float>mag_response,
+                                   base::span<float>phase_response);
 
   bool RequiresTailProcessing() const final;
   double TailTime() const override;
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_processor.cc b/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
index 0e2adc105ae5f..cf4a0007eb962 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_processor.cc
@@ -27,6 +27,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/renderer/modules/webaudio/biquad_dsp_kernel.h"
 #include "third_party/blink/renderer/platform/audio/audio_utilities.h"
@@ -172,9 +173,9 @@ void BiquadProcessor::SetType(FilterType type) {
 }
 
 void BiquadProcessor::GetFrequencyResponse(int n_frequencies,
-                                           const float* frequency_hz,
-                                           float* mag_response,
-                                           float* phase_response) {
+                                           base::span<const float>frequency_hz,
+                                           base::span<float>mag_response,
+                                           base::span<float>phase_response) {
   DCHECK(IsMainThread());
 
   // Compute the frequency response on a separate temporary kernel
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_processor.h b/third_party/blink/renderer/modules/webaudio/biquad_processor.h
index 428ab00e6b667..e51541801b8ce 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_processor.h
+++ b/third_party/blink/renderer/modules/webaudio/biquad_processor.h
@@ -28,6 +28,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_param.h"
@@ -77,9 +78,9 @@ class BiquadProcessor final : public AudioDSPKernelProcessor {
   // Get the magnitude and phase response of the filter at the given
   // set of frequencies (in Hz). The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
-                            const float* frequency_hz,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<const float>frequency_hz,
+                            base::span<float>mag_response,
+                            base::span<float>phase_response);
 
   void CheckForDirtyCoefficients();
 
diff --git a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
index a428860ba8c2a..3f4ef05ef7535 100644
--- a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
@@ -6,6 +6,7 @@
 
 #include <tuple>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_output.h"
 
@@ -78,7 +79,7 @@ void ConstantSourceHandler::Process(uint32_t frames_to_process) {
 
   if (is_sample_accurate && offset_->IsAudioRate()) {
     DCHECK_LE(frames_to_process, sample_accurate_values_.size());
-    float* offsets = sample_accurate_values_.Data();
+    base::span<float>offsets = sample_accurate_values_.Data();
     offset_->CalculateSampleAccurateValues(
         sample_accurate_values_.as_span().first(frames_to_process));
     if (non_silent_frames_to_process > 0) {
diff --git a/third_party/blink/renderer/modules/webaudio/cpu/x86/oscillator_kernel_sse2.cc b/third_party/blink/renderer/modules/webaudio/cpu/x86/oscillator_kernel_sse2.cc
index 91619130c4402..683ca1f268aa6 100644
--- a/third_party/blink/renderer/modules/webaudio/cpu/x86/oscillator_kernel_sse2.cc
+++ b/third_party/blink/renderer/modules/webaudio/cpu/x86/oscillator_kernel_sse2.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -87,7 +89,7 @@ __m128d WrapVirtualIndexVectorPd(__m128d x,
 
 std::tuple<int, double> OscillatorHandler::ProcessKRateVector(
     int n,
-    float* dest_p,
+    base::span<float>dest_p,
     double virtual_read_index,
     float frequency,
     float rate_scale) const {
@@ -181,7 +183,7 @@ std::tuple<int, double> OscillatorHandler::ProcessKRateVector(
         _mm_mul_ps(v_table_factor, _mm_sub_ps(sample_lower, sample_higher)));
 
     // WARNING: dest_p may not be aligned!
-    _mm_storeu_ps(dest_p + k, sample);
+    _mm_storeu_ps(dest_p .subspan( k).data(), sample);
 
     // Increment virtual read index and wrap virtualReadIndex into the range
     // 0 -> periodicWaveSize.
@@ -202,7 +204,7 @@ std::tuple<int, double> OscillatorHandler::ProcessKRateVector(
 double OscillatorHandler::ProcessARateVectorKernel(
     float* dest_p,
     double virtual_read_index,
-    const float* phase_increments,
+    base::span<const float>phase_increments,
     unsigned periodic_wave_size,
     const float* const lower_wave_data[4],
     const float* const higher_wave_data[4],
diff --git a/third_party/blink/renderer/modules/webaudio/gain_handler.cc b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
index 5ae07797e7ec7..d75e28609c49b 100644
--- a/third_party/blink/renderer/modules/webaudio/gain_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/gain_handler.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_input.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node_output.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
@@ -54,7 +55,7 @@ void GainHandler::Process(uint32_t frames_to_process) {
       // Apply sample-accurate gain scaling for precise envelopes, grain
       // windows, etc.
       DCHECK_LE(frames_to_process, sample_accurate_gain_values_.size());
-      float* gain_values = sample_accurate_gain_values_.Data();
+      base::span<float>gain_values = sample_accurate_gain_values_.Data();
       gain_->CalculateSampleAccurateValues(
           sample_accurate_gain_values_.as_span().first(frames_to_process));
       output_bus->CopyWithSampleAccurateGainValuesFrom(*input_bus, gain_values,
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
index d2205c3bb703a..3991b21d24204 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
@@ -6,6 +6,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
 #include "third_party/blink/renderer/core/inspector/console_message.h"
@@ -44,13 +45,13 @@ IIRFilterHandler::~IIRFilterHandler() {
 // Get the magnitude and phase response of the filter at the given set of
 // frequencies (in Hz). The phase response is in radians.
 void IIRFilterHandler::GetFrequencyResponse(int n_frequencies,
-                                            const float* frequency_hz,
-                                            float* mag_response,
-                                            float* phase_response) const {
+                                            base::span<const float>frequency_hz,
+                                            base::span<float>mag_response,
+                                            base::span<float>phase_response) const {
   DCHECK_GE(n_frequencies, 0);
-  DCHECK(frequency_hz);
-  DCHECK(mag_response);
-  DCHECK(phase_response);
+  DCHECK(!frequency_hz.empty());
+  DCHECK(!mag_response.empty());
+  DCHECK(!phase_response.empty());
 
   Vector<float> frequency(n_frequencies);
 
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
index 6199836057826..f237c0c002ffe 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_IIR_FILTER_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_IIR_FILTER_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/task/single_thread_task_runner.h"
@@ -29,9 +30,9 @@ class IIRFilterHandler final : public AudioHandler {
   // Get the magnitude and phase response of the filter at the given
   // set of frequencies (in Hz). The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
-                            const float* frequency_hz,
-                            float* mag_response,
-                            float* phase_response) const;
+                            base::span<const float>frequency_hz,
+                            base::span<float>mag_response,
+                            base::span<float>phase_response) const;
 
  private:
   IIRFilterHandler(AudioNode&,
diff --git a/third_party/blink/renderer/modules/webaudio/offline_audio_destination_handler.cc b/third_party/blink/renderer/modules/webaudio/offline_audio_destination_handler.cc
index 934b79f362c08..978cb9f18a9ab 100644
--- a/third_party/blink/renderer/modules/webaudio/offline_audio_destination_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/offline_audio_destination_handler.cc
@@ -194,7 +194,7 @@ void OfflineAudioDestinationHandler::DoOfflineRendering() {
 
     for (unsigned channel_index = 0; channel_index < number_of_channels;
          ++channel_index) {
-      const float* source = render_bus_->Channel(channel_index)->Data();
+      const float* source = render_bus_->Channel(channel_index)->Data().data();
       UNSAFE_TODO(memcpy(destinations[channel_index] + frames_processed_,
                          source, sizeof(float) * frames_available_to_copy));
     }
diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
index 66badc9cebef3..9e885c02546b6 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -324,7 +326,7 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
 
     // Convert from cents to rate scalar.
     float k = 1.0 / 1200;
-    vector_math::Vsmul(detune_values.data(), 1, &k, detune_values.data(), 1,
+    vector_math::Vsmul(detune_values, 1, &k, detune_values, 1,
                        frames_to_process);
     for (unsigned i = 0; i < frames_to_process; ++i) {
       detune_values[i] = std::exp2(detune_values[i]);
@@ -332,8 +334,8 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
 
     if (has_frequency_changes) {
       // Multiply frequencies by detune scalings.
-      vector_math::Vmul(detune_values.data(), 1, phase_increments.data(), 1,
-                        phase_increments.data(), 1, frames_to_process);
+      vector_math::Vmul(detune_values, 1, phase_increments, 1,
+                        phase_increments, 1, frames_to_process);
     }
   } else {
     // Handle ordinary parameter changes if there are no scheduled
@@ -347,8 +349,8 @@ bool OscillatorHandler::CalculateSampleAccuratePhaseIncrements(
     ClampFrequency(phase_increments.data(), frames_to_process,
                    Context()->sampleRate() / 2);
     // Convert from frequency to wavetable increment.
-    vector_math::Vsmul(phase_increments.data(), 1, &final_scale,
-                       phase_increments.data(), 1, frames_to_process);
+    vector_math::Vsmul(phase_increments, 1, &final_scale,
+                       phase_increments, 1, frames_to_process);
   }
 
   return has_sample_accurate_values;
@@ -429,7 +431,7 @@ double OscillatorHandler::ProcessARateVectorKernel(
 
 double OscillatorHandler::ProcessKRateScalar(int start,
                                              int n,
-                                             float* dest_p,
+                                             base::span<float>dest_p,
                                              double virtual_read_index,
                                              float frequency,
                                              float rate_scale) const {
@@ -485,7 +487,7 @@ double OscillatorHandler::ProcessKRateScalar(int start,
 }
 
 double OscillatorHandler::ProcessKRate(int n,
-                                       float* dest_p,
+                                       base::span<float>dest_p,
                                        double virtual_read_index) const {
   const unsigned periodic_wave_size = periodic_wave_->PeriodicWaveSize();
   const double inv_periodic_wave_size = 1.0 / periodic_wave_size;
@@ -530,7 +532,7 @@ double OscillatorHandler::ProcessKRate(int n,
           virtual_read_index, fabs(incr), read_index_mask,
           table_interpolation_factor, lower_wave_data, higher_wave_data);
 
-      *dest_p++ = sample;
+      (dest_p++)[0] = sample;
 
       // Increment virtual read index and wrap virtualReadIndex into the range
       // 0 -> periodicWaveSize.
@@ -545,9 +547,9 @@ double OscillatorHandler::ProcessKRate(int n,
 
 std::tuple<int, double> OscillatorHandler::ProcessARateVector(
     int n,
-    float* destination,
+    base::span<float>destination,
     double virtual_read_index,
-    const float* phase_increments) const {
+    base::span<const float>phase_increments) const {
   float rate_scale = periodic_wave_->RateScale();
   float inv_rate_scale = 1 / rate_scale;
   unsigned periodic_wave_size = periodic_wave_->PeriodicWaveSize();
@@ -581,7 +583,7 @@ std::tuple<int, double> OscillatorHandler::ProcessARateVector(
     // to call DoInterpolation to handle it correctly.
     if (is_big_increment) {
       virtual_read_index = ProcessARateVectorKernel(
-          destination + k, virtual_read_index, phase_increments + k,
+          destination .subspan( k).data(), virtual_read_index, phase_increments .subspan( k),
           periodic_wave_size, lower_wave_data.data(), higher_wave_data.data(),
           table_interpolation_factor.data());
     } else {
@@ -609,9 +611,9 @@ std::tuple<int, double> OscillatorHandler::ProcessARateVector(
 double OscillatorHandler::ProcessARateScalar(
     int k,
     int n,
-    float* destination,
+    base::span<float>destination,
     double virtual_read_index,
-    const float* phase_increments) const {
+    base::span<const float>phase_increments) const {
   float rate_scale = periodic_wave_->RateScale();
   float inv_rate_scale = 1 / rate_scale;
   unsigned periodic_wave_size = periodic_wave_->PeriodicWaveSize();
@@ -647,9 +649,9 @@ double OscillatorHandler::ProcessARateScalar(
 }
 
 double OscillatorHandler::ProcessARate(int n,
-                                       float* destination,
+                                       base::span<float>destination,
                                        double virtual_read_index,
-                                       float* phase_increments) const {
+                                       base::span<float>phase_increments) const {
   int frames_processed = 0;
 
   std::tie(frames_processed, virtual_read_index) =
@@ -705,7 +707,7 @@ void OscillatorHandler::Process(uint32_t frames_to_process) {
 
   unsigned periodic_wave_size = periodic_wave_->PeriodicWaveSize();
 
-  float* dest_p = output_bus->Channel(0)->MutableData();
+  base::span<float>dest_p = output_bus->Channel(0)->MutableData();
 
   DCHECK_LE(quantum_frame_offset, frames_to_process);
 
@@ -732,10 +734,10 @@ void OscillatorHandler::Process(uint32_t frames_to_process) {
                                                     table_interpolation_factor);
   }
 
-  float* phase_increments = phase_increments_.Data();
+  base::span<float>phase_increments = phase_increments_.Data();
 
   // Start rendering at the correct offset.
-  dest_p += quantum_frame_offset;
+  dest_p=dest_p.subspan(quantum_frame_offset);
   int n = non_silent_frames_to_process;
 
   // If startFrameOffset is not 0, that means the oscillator doesn't actually
diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_handler.h b/third_party/blink/renderer/modules/webaudio/oscillator_handler.h
index df6c5e2cde2fa..3a186af2f275d 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_OSCILLATOR_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_OSCILLATOR_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_oscillator_options.h"
@@ -76,13 +77,13 @@ class OscillatorHandler final : public AudioScheduledSourceHandler {
   base::WeakPtr<AudioScheduledSourceHandler> AsWeakPtr() override;
 
   // Compute the output for k-rate AudioParams
-  double ProcessKRate(int n, float* dest_p, double virtual_read_index) const;
+  double ProcessKRate(int n, base::span<float>dest_p, double virtual_read_index) const;
 
   // Scalar version for the main loop in ProcessKRate().  Returns the updated
   // virtual_read_index.
   double ProcessKRateScalar(int start_index,
                             int n,
-                            float* dest_p,
+                            base::span<float>dest_p,
                             double virtual_read_index,
                             float frequency,
                             float rate_scale) const;
@@ -91,16 +92,16 @@ class OscillatorHandler final : public AudioScheduledSourceHandler {
   // Returns the number of elements processed and the updated
   // virtual_read_index.
   std::tuple<int, double> ProcessKRateVector(int n,
-                                             float* dest_p,
+                                             base::span<float>dest_p,
                                              double virtual_read_index,
                                              float frequency,
                                              float rate_scale) const;
 
   // Compute the output for a-rate AudioParams
   double ProcessARate(int n,
-                      float* dest_p,
+                      base::span<float>dest_p,
                       double virtual_read_index,
-                      float* phase_increments) const;
+                      base::span<float>phase_increments) const;
 
   // Scalar version of ProcessARate().  Also handles any values not handled by
   // the vector version.
@@ -119,17 +120,17 @@ class OscillatorHandler final : public AudioScheduledSourceHandler {
   // Returns the updated virtual_read_index.
   double ProcessARateScalar(int k,
                             int n,
-                            float* destination,
+                            base::span<float>destination,
                             double virtual_read_index,
-                            const float* phase_increments) const;
+                            base::span<const float>phase_increments) const;
 
   // Vector version of ProcessARate().  Returns the number of frames processed
   // and the update virtual_read_index.
   std::tuple<int, double> ProcessARateVector(
       int n,
-      float* destination,
+      base::span<float>destination,
       double virtual_read_index,
-      const float* phase_increments) const;
+      base::span<const float>phase_increments) const;
 
   // Handles the linear interpolation in ProcessARateVector().
   //
@@ -153,7 +154,7 @@ class OscillatorHandler final : public AudioScheduledSourceHandler {
   double ProcessARateVectorKernel(
       float* destination,
       double virtual_read_index,
-      const float* phase_increments,
+      base::span<const float>phase_increments,
       unsigned periodic_wave_size,
       const float* const lower_wave_data[4],
       const float* const higher_wave_data[4],
diff --git a/third_party/blink/renderer/modules/webaudio/panner_handler.cc b/third_party/blink/renderer/modules/webaudio/panner_handler.cc
index ece412ac9a571..a2a994536a677 100644
--- a/third_party/blink/renderer/modules/webaudio/panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/panner_handler.cc
@@ -6,6 +6,7 @@
 
 #include <array>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/synchronization/lock.h"
@@ -234,7 +235,7 @@ void PannerHandler::ProcessSampleAccurateValues(AudioBus* destination,
   float orientation_z[render_quantum_frames_expected];
   std::array<double, render_quantum_frames_expected> azimuth;
   std::array<double, render_quantum_frames_expected> elevation;
-  float total_gain[render_quantum_frames_expected];
+  std::array<float, render_quantum_frames_expected> total_gain;
 
   position_x_->CalculateSampleAccurateValues(
       base::span(panner_x).first(frames_to_process));
@@ -249,23 +250,23 @@ void PannerHandler::ProcessSampleAccurateValues(AudioBus* destination,
   orientation_z_->CalculateSampleAccurateValues(
       base::span(orientation_z).first(frames_to_process));
 
-  const float* listener_x = listener_handler_->GetPositionXValues(
+  base::span<const float>listener_x = listener_handler_->GetPositionXValues(
       render_quantum_frames);
-  const float* listener_y = listener_handler_->GetPositionYValues(
+  base::span<const float>listener_y = listener_handler_->GetPositionYValues(
       render_quantum_frames);
-  const float* listener_z = listener_handler_->GetPositionZValues(
+  base::span<const float>listener_z = listener_handler_->GetPositionZValues(
       render_quantum_frames);
-  const float* forward_x = listener_handler_->GetForwardXValues(
+  base::span<const float>forward_x = listener_handler_->GetForwardXValues(
       render_quantum_frames);
-  const float* forward_y = listener_handler_->GetForwardYValues(
+  base::span<const float>forward_y = listener_handler_->GetForwardYValues(
       render_quantum_frames);
-  const float* forward_z = listener_handler_->GetForwardZValues(
+  base::span<const float>forward_z = listener_handler_->GetForwardZValues(
       render_quantum_frames);
-  const float* up_x = listener_handler_->GetUpXValues(
+  base::span<const float>up_x = listener_handler_->GetUpXValues(
       render_quantum_frames);
-  const float* up_y = listener_handler_->GetUpYValues(
+  base::span<const float>up_y = listener_handler_->GetUpYValues(
       render_quantum_frames);
-  const float* up_z = listener_handler_->GetUpZValues(
+  base::span<const float>up_z = listener_handler_->GetUpZValues(
       render_quantum_frames);
 
   UNSAFE_TODO({
diff --git a/third_party/blink/renderer/modules/webaudio/periodic_wave.cc b/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
index e3ecefcf5d431..25145df80f374 100644
--- a/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
+++ b/third_party/blink/renderer/modules/webaudio/periodic_wave.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -105,7 +107,7 @@ PeriodicWave* PeriodicWave::Create(BaseAudioContext& context,
   PeriodicWave* periodic_wave =
       MakeGarbageCollected<PeriodicWave>(context.sampleRate());
   periodic_wave->impl()->CreateBandLimitedTables(
-      real.data(), imag.data(), real.size(), disable_normalization);
+      real, imag, real.size(), disable_normalization);
   return periodic_wave;
 }
 
@@ -405,8 +407,8 @@ unsigned PeriodicWaveImpl::NumberOfPartialsForRange(
 // Convert into time-domain wave buffers.  One table is created for each range
 // for non-aliasing playback at different playback rates.  Thus, higher ranges
 // have more high-frequency partials culled out.
-void PeriodicWaveImpl::CreateBandLimitedTables(const float* real_data,
-                                               const float* imag_data,
+void PeriodicWaveImpl::CreateBandLimitedTables(base::span<const float>real_data,
+                                               base::span<const float>imag_data,
                                                unsigned number_of_components,
                                                bool disable_normalization) {
   // The default scale factor for when normalization is disabled.
@@ -466,7 +468,7 @@ void PeriodicWaveImpl::CreateBandLimitedTables(const float* real_data,
     band_limited_tables_.push_back(std::move(table));
 
     // Apply an inverse FFT to generate the time-domain table data.
-    float* data = band_limited_tables_[range_index]->Data();
+    base::span<float>data = band_limited_tables_[range_index]->Data();
     frame.DoInverseFFT(data);
 
     // For the first range (which has the highest power), calculate its peak
@@ -493,8 +495,8 @@ void PeriodicWaveImpl::GenerateBasicWaveform(int shape) {
 
   AudioFloatArray real(half_size);
   AudioFloatArray imag(half_size);
-  float* real_p = real.Data();
-  float* imag_p = imag.Data();
+  base::span<float>real_p = real.Data();
+  base::span<float>imag_p = imag.Data();
 
   // Clear DC and Nyquist.
   real_p[0] = 0;
diff --git a/third_party/blink/renderer/modules/webaudio/periodic_wave.h b/third_party/blink/renderer/modules/webaudio/periodic_wave.h
index 7c890db569851..2f297ffe18ce4 100644
--- a/third_party/blink/renderer/modules/webaudio/periodic_wave.h
+++ b/third_party/blink/renderer/modules/webaudio/periodic_wave.h
@@ -31,6 +31,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer_view_helpers.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
@@ -142,8 +143,8 @@ class PeriodicWaveImpl final : public GarbageCollected<PeriodicWaveImpl> {
   unsigned NumberOfPartialsForRange(unsigned range_index) const;
 
   // Creates tables based on numberOfComponents Fourier coefficients.
-  void CreateBandLimitedTables(const float* real,
-                               const float* imag,
+  void CreateBandLimitedTables(base::span<const float>real,
+                               base::span<const float>imag,
                                unsigned number_of_components,
                                bool disable_normalization);
   Vector<std::unique_ptr<AudioFloatArray>> band_limited_tables_;
diff --git a/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc b/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
index 7172964ca8363..95a38b0180b5b 100644
--- a/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
+++ b/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,7 +47,7 @@ namespace blink {
 
 namespace {
 
-void ApplyWindow(float* p, size_t n) {
+void ApplyWindow(base::span<float>p, size_t n) {
   DCHECK(IsMainThread());
 
   // Blackman window
@@ -149,8 +151,8 @@ void RealtimeAnalyser::GetFloatTimeDomainData(
     DCHECK_EQ(input_buffer_.size(), kInputBufferSize);
     DCHECK_GT(input_buffer_.size(), fft_size);
 
-    float* input_buffer = input_buffer_.Data();
-    float* destination = destination_array->Data();
+    base::span<float>input_buffer = input_buffer_.Data();
+    base::span<float>destination = destination_array->Data();
 
     unsigned write_index = GetWriteIndex();
 
@@ -176,8 +178,8 @@ void RealtimeAnalyser::GetByteTimeDomainData(DOMUint8Array* destination_array) {
     DCHECK_EQ(input_buffer_.size(), kInputBufferSize);
     DCHECK_GT(input_buffer_.size(), fft_size);
 
-    float* input_buffer = input_buffer_.Data();
-    unsigned char* destination = destination_array->Data();
+    base::span<float>input_buffer = input_buffer_.Data();
+    base::span<unsigned char>destination = destination_array->Data();
 
     unsigned write_index = GetWriteIndex();
 
@@ -208,13 +210,13 @@ void RealtimeAnalyser::WriteInput(AudioBus* bus, uint32_t frames_to_process) {
   DCHECK_LE(write_index + frames_to_process, input_buffer_.size());
 
   // Perform real-time analysis
-  float* dest = input_buffer_.Data() + write_index;
+  float* dest = input_buffer_.Data() .subspan( write_index).data();
 
   // Clear the bus and downmix the input according to the down mixing rules.
   // Then save the result in the m_inputBuffer at the appropriate place.
   down_mix_bus_->Zero();
   down_mix_bus_->SumFrom(*bus);
-  memcpy(dest, down_mix_bus_->Channel(0)->Data(),
+  memcpy(dest, down_mix_bus_->Channel(0)->Data().data(),
          frames_to_process * sizeof(*dest));
 
   write_index += frames_to_process;
@@ -232,27 +234,27 @@ void RealtimeAnalyser::DoFFTAnalysis() {
   uint32_t fft_size = FftSize();
 
   AudioFloatArray temporary_buffer(fft_size);
-  float* input_buffer = input_buffer_.Data();
-  float* temp_p = temporary_buffer.Data();
+  base::span<float>input_buffer = input_buffer_.Data();
+  base::span<float>temp_p = temporary_buffer.Data();
 
   // Take the previous fftSize values from the input buffer and copy into the
   // temporary buffer.
   unsigned write_index = GetWriteIndex();
   if (write_index < fft_size) {
-    memcpy(temp_p, input_buffer + write_index - fft_size + kInputBufferSize,
-           sizeof(*temp_p) * (fft_size - write_index));
-    memcpy(temp_p + fft_size - write_index, input_buffer,
-           sizeof(*temp_p) * write_index);
+    memcpy(temp_p.data(), input_buffer .subspan( write_index - fft_size + kInputBufferSize).data(),
+           sizeof( temp_p[0]) * (fft_size - write_index));
+    memcpy(temp_p .subspan( fft_size - write_index).data(), input_buffer.data(),
+           sizeof( temp_p[0]) * write_index);
   } else {
-    memcpy(temp_p, input_buffer + write_index - fft_size,
-           sizeof(*temp_p) * fft_size);
+    memcpy(temp_p.data(), input_buffer .subspan( write_index - fft_size).data(),
+           sizeof( temp_p[0]) * fft_size);
   }
 
   // Window the input samples.
   ApplyWindow(temp_p, fft_size);
 
   // Do the analysis.
-  analysis_frame_->DoFFT(temp_p);
+  analysis_frame_->DoFFT(temp_p.data());
 
   const AudioFloatArray& real = analysis_frame_->RealData();
   AudioFloatArray& imag = analysis_frame_->ImagData();
@@ -270,12 +272,12 @@ void RealtimeAnalyser::DoFFTAnalysis() {
 
   // Convert the analysis data from complex to magnitude and average with the
   // previous result.
-  float* destination = MagnitudeBuffer().Data();
+  base::span<float>destination = MagnitudeBuffer().Data();
   size_t n = MagnitudeBuffer().size();
   DCHECK_GE(real.size(), n);
-  const float* real_p_data = real.Data();
+  base::span<const float>real_p_data = real.Data();
   DCHECK_GE(imag.size(), n);
-  const float* imag_p_data = imag.Data();
+  base::span<const float>imag_p_data = imag.Data();
   for (size_t i = 0; i < n; ++i) {
     std::complex<double> c(real_p_data[i], imag_p_data[i]);
     double scalar_magnitude = abs(c) * magnitude_scale;
@@ -294,8 +296,8 @@ void RealtimeAnalyser::ConvertToByteData(DOMUint8Array* destination_array) {
                                           : 1 / (max_decibels_ - min_decibels_);
     const double min_decibels = min_decibels_;
 
-    const float* source = MagnitudeBuffer().Data();
-    unsigned char* destination = destination_array->Data();
+    base::span<const float>source = MagnitudeBuffer().Data();
+    base::span<unsigned char>destination = destination_array->Data();
 
     for (unsigned i = 0; i < len; ++i) {
       float linear_value = source[i];
@@ -318,8 +320,8 @@ void RealtimeAnalyser::ConvertFloatToDb(DOMFloat32Array* destination_array) {
   size_t source_length = MagnitudeBuffer().size();
   size_t len = std::min(source_length, destination_array->length());
   if (len > 0) {
-    const float* source = MagnitudeBuffer().Data();
-    float* destination = destination_array->Data();
+    base::span<const float>source = MagnitudeBuffer().Data();
+    base::span<float>destination = destination_array->Data();
 
     for (unsigned i = 0; i < len; ++i) {
       float linear_value = source[i];
diff --git a/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc b/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
index 1f22a92b8303c..8c86871f36e39 100644
--- a/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/script_processor_handler.cc
@@ -188,7 +188,7 @@ void ScriptProcessorHandler::Process(uint32_t frames_to_process) {
     }
 
     for (uint32_t i = 0; i < number_of_output_channels; ++i) {
-      float* destination = output_bus->Channel(i)->MutableData();
+      float* destination = output_bus->Channel(i)->MutableData().data();
       const float* source = UNSAFE_TODO(
           static_cast<float*>(shared_output_buffer->channels()[i].Data()) +
           buffer_read_write_index_);
diff --git a/third_party/blink/renderer/modules/webaudio/script_processor_node.cc b/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
index 57609cae54252..8b52afbd256f1 100644
--- a/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/script_processor_node.cc
@@ -287,9 +287,9 @@ void ScriptProcessorNode::DispatchEvent(double playback_time,
       for (unsigned channel = 0;
           channel < backing_input_buffer->numberOfChannels(); ++channel) {
         const float* source = static_cast<float*>(
-            backing_input_buffer->getChannelData(channel)->buffer()->Data());
+            backing_input_buffer->getChannelData(channel)->buffer()->Data().data());
         float* destination = static_cast<float*>(
-            external_input_buffer_->getChannelData(channel)->buffer()->Data());
+            external_input_buffer_->getChannelData(channel)->buffer()->Data().data());
         UNSAFE_TODO(memcpy(destination, source,
                            backing_input_buffer->length() * sizeof(float)));
       }
@@ -327,9 +327,9 @@ void ScriptProcessorNode::DispatchEvent(double playback_time,
       for (unsigned channel = 0;
           channel < backing_output_buffer->numberOfChannels(); ++channel) {
         const float* source = static_cast<float*>(
-            external_output_buffer_->getChannelData(channel)->buffer()->Data());
+            external_output_buffer_->getChannelData(channel)->buffer()->Data().data());
         float* destination = static_cast<float*>(
-            backing_output_buffer->getChannelData(channel)->buffer()->Data());
+            backing_output_buffer->getChannelData(channel)->buffer()->Data().data());
         UNSAFE_TODO(memcpy(destination, source,
                            backing_output_buffer->length() * sizeof(float)));
       }
diff --git a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
index 775dceb62dcb7..2e41e4d44daa8 100644
--- a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/stereo_panner_handler.h"
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_stereo_panner_options.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_graph_tracer.h"
@@ -74,7 +75,7 @@ void StereoPannerHandler::Process(uint32_t frames_to_process) {
   if (is_sample_accurate && pan_->IsAudioRate()) {
     // Apply sample-accurate panning specified by AudioParam automation.
     DCHECK_LE(frames_to_process, sample_accurate_pan_values_.size());
-    float* pan_values = sample_accurate_pan_values_.Data();
+    base::span<float>pan_values = sample_accurate_pan_values_.Data();
     pan_->CalculateSampleAccurateValues(
         sample_accurate_pan_values_.as_span().first(frames_to_process));
     stereo_panner_->PanWithSampleAccurateValues(input_bus.get(), output_bus,
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
index d1d192fb5fdf6..d0a8c2a4c248a 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -44,7 +46,7 @@ constexpr unsigned kDefaultNumberOfOutputChannels = 1;
 
 // Computes value of the WaveShaper
 double WaveShaperCurveValue(float input,
-                            const float* curve_data,
+                            base::span<const float>curve_data,
                             int curve_length) {
   // Calculate a virtual index based on input -1 -> +1 with -1 being
   // curve[0], +1 being curve[curveLength - 1], and 0 being at the center of
@@ -117,14 +119,14 @@ WaveShaperHandler::~WaveShaperHandler() {
   }
 }
 
-void WaveShaperHandler::SetCurve(const float* curve_data,
+void WaveShaperHandler::SetCurve(base::span<const float>curve_data,
                                  unsigned curve_length) {
   DCHECK(IsMainThread());
 
   // This synchronizes with process().
   base::AutoLock process_locker(process_lock_);
 
-  if (curve_length == 0 || !curve_data) {
+  if (curve_length == 0 || curve_data.empty()) {
     curve_ = nullptr;
     tail_time_ = 0;
     return;
@@ -132,7 +134,7 @@ void WaveShaperHandler::SetCurve(const float* curve_data,
 
   // Copy the curve data, if any, to our internal buffer.
   curve_ = std::make_unique<Vector<float>>(curve_length);
-  memcpy(curve_->data(), curve_data, sizeof(float) * curve_length);
+  memcpy(curve_->data(), curve_data.data(), sizeof(float) * curve_length);
 
   // Compute the curve output for a zero input, and set the tail time.
   const double output = WaveShaperCurveValue(0.0, curve_data, curve_length);
@@ -265,8 +267,8 @@ void WaveShaperHandler::Process(uint32_t frames_to_process) {
       for (unsigned i = 0; i < kernels_.size(); ++i) {
         if (!curve_data || !curve_length) {
           // Act as "straight wire" pass-through if no curve is set.
-          memcpy(destination_bus->Channel(i)->MutableData(),
-                 source_bus->Channel(i)->Data(),
+          memcpy(destination_bus->Channel(i)->MutableData().data(),
+                 source_bus->Channel(i)->Data().data(),
                  sizeof(float) * frames_to_process);
         } else {
           switch (oversample_) {
@@ -278,8 +280,8 @@ void WaveShaperHandler::Process(uint32_t frames_to_process) {
               break;
 
             case V8OverSampleType::Enum::k2X: {
-              float* temp_p = kernels_[i]->temp_buffer_->Data();
-              kernels_[i]->up_sampler_->Process(source_bus->Channel(i)->Data(),
+              base::span<float>temp_p = kernels_[i]->temp_buffer_->Data();
+              kernels_[i]->up_sampler_->Process(source_bus->Channel(i)->Data().data(),
                                                 temp_p, frames_to_process);
 
               // Process at 2x up-sampled rate.
@@ -287,27 +289,27 @@ void WaveShaperHandler::Process(uint32_t frames_to_process) {
                                     curve_data, curve_length);
 
               kernels_[i]->down_sampler_->Process(
-                  temp_p, destination_bus->Channel(i)->MutableData(),
+                  temp_p.data(), destination_bus->Channel(i)->MutableData(),
                   frames_to_process * 2);
             } break;
 
             case V8OverSampleType::Enum::k4X: {
-              float* temp_p = kernels_[i]->temp_buffer_->Data();
-              float* temp_p2 = kernels_[i]->temp_buffer2_->Data();
+              base::span<float>temp_p = kernels_[i]->temp_buffer_->Data();
+              base::span<float>temp_p2 = kernels_[i]->temp_buffer2_->Data();
 
-              kernels_[i]->up_sampler_->Process(source_bus->Channel(i)->Data(),
+              kernels_[i]->up_sampler_->Process(source_bus->Channel(i)->Data().data(),
                                                 temp_p, frames_to_process);
-              kernels_[i]->up_sampler2_->Process(temp_p, temp_p2,
+              kernels_[i]->up_sampler2_->Process(temp_p.data(), temp_p2,
                                                  frames_to_process * 2);
 
               // Process at 4x up-sampled rate.
               WaveShaperCurveValues(temp_p2, temp_p2, frames_to_process * 4,
                                     curve_data, curve_length);
 
-              kernels_[i]->down_sampler2_->Process(temp_p2, temp_p,
+              kernels_[i]->down_sampler2_->Process(temp_p2.data(), temp_p,
                                                    frames_to_process * 4);
               kernels_[i]->down_sampler_->Process(
-                  temp_p, destination_bus->Channel(i)->MutableData(),
+                  temp_p.data(), destination_bus->Channel(i)->MutableData(),
                   frames_to_process * 2);
             } break;
           }
@@ -416,14 +418,14 @@ void WaveShaperHandler::PullInputs(uint32_t frames_to_process) {
 
 // Like WaveShaperCurveValue, but computes the values for a vector of
 // inputs.
-void WaveShaperHandler::WaveShaperCurveValues(float* destination,
-                                              const float* source,
+void WaveShaperHandler::WaveShaperCurveValues(base::span<float>destination,
+                                              base::span<const float>source,
                                               uint32_t frames_to_process,
                                               const float* curve_data,
                                               int curve_length) {
   DCHECK_LE(frames_to_process, virtual_index_.size());
   // Index into the array computed from the source value.
-  float* virtual_index = virtual_index_.Data();
+  base::span<float>virtual_index = virtual_index_.Data();
 
   // virtual_index[k] =
   //   ClampTo(0.5 * (source[k] + 1) * (curve_length - 1),
@@ -443,19 +445,19 @@ void WaveShaperHandler::WaveShaperCurveValues(float* destination,
 
   // index = floor(virtual_index)
   DCHECK_LE(frames_to_process, index_.size());
-  float* index = index_.Data();
+  base::span<float>index = index_.Data();
 
   // v1 and v2 hold the curve_data corresponding to the closest curve
   // values to the source sample.  To save memory, v1 will use the
   // destination array.
   DCHECK_LE(frames_to_process, v1_.size());
   DCHECK_LE(frames_to_process, v2_.size());
-  float* v1 = v1_.Data();
-  float* v2 = v2_.Data();
+  base::span<float>v1 = v1_.Data();
+  base::span<float>v2 = v2_.Data();
 
   // Interpolation factor: virtual_index - index.
   DCHECK_LE(frames_to_process, f_.size());
-  float* f = f_.Data();
+  base::span<float>f = f_.Data();
 
   int max_index = curve_length - 1;
   unsigned k = 0;
@@ -469,7 +471,7 @@ void WaveShaperHandler::WaveShaperCurveValues(float* destination,
     // Do 4 eleemnts at a time
     for (int loop = 0; loop < loop_limit; ++loop, k += 4) {
       // v = virtual_index[k]
-      __m128 v = _mm_loadu_ps(virtual_index + k);
+      __m128 v = _mm_loadu_ps(virtual_index .subspan( k).data());
 
       // index1 = static_cast<int>(v);
       __m128i index1 = _mm_cvttps_epi32(v);
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
index c6d591ca89b5d..b1651c83623d1 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_HANDLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_HANDLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/scoped_refptr.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_over_sample_type.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_handler.h"
@@ -21,7 +22,7 @@ class WaveShaperHandler final : public AudioHandler {
   static scoped_refptr<WaveShaperHandler> Create(AudioNode&, float sample_rate);
   ~WaveShaperHandler() override;
 
-  void SetCurve(const float* curve_data, unsigned curve_length);
+  void SetCurve(base::span<const float>curve_data, unsigned curve_length);
   const Vector<float>* Curve() const;
   void SetOversample(V8OverSampleType::Enum oversample);
   V8OverSampleType::Enum Oversample() const;
@@ -40,8 +41,8 @@ class WaveShaperHandler final : public AudioHandler {
   double LatencyTime() const override;
   void PullInputs(uint32_t frames_to_process) override;
 
-  void WaveShaperCurveValues(float* destination,
-                             const float* source,
+  void WaveShaperCurveValues(base::span<float>destination,
+                             base::span<const float>source,
                              uint32_t frames_to_process,
                              const float* curve_data,
                              int curve_length);
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
index dace09c748fa3..1be9bfc155ef3 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.cc
@@ -25,6 +25,7 @@
 
 #include "third_party/blink/renderer/modules/webaudio/wave_shaper_node.h"
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_wave_shaper_options.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_graph_tracer.h"
@@ -68,14 +69,14 @@ WaveShaperHandler& WaveShaperNode::GetWaveShaperHandler() const {
   return static_cast<WaveShaperHandler&>(Handler());
 }
 
-void WaveShaperNode::SetCurveImpl(const float* curve_data,
+void WaveShaperNode::SetCurveImpl(base::span<const float>curve_data,
                                   size_t curve_length,
                                   ExceptionState& exception_state) {
   DCHECK(IsMainThread());
 
   unsigned length = static_cast<unsigned>(curve_length);
 
-  if (curve_data) {
+  if (!curve_data.empty()) {
     if (!base::CheckedNumeric<unsigned>(curve_length).AssignIfValid(&length)) {
       exception_state.ThrowDOMException(
           DOMExceptionCode::kNotSupportedError,
@@ -106,7 +107,7 @@ void WaveShaperNode::setCurve(NotShared<DOMFloat32Array> curve,
   if (curve) {
     SetCurveImpl(curve->Data(), curve->length(), exception_state);
   } else {
-    SetCurveImpl(nullptr, 0, exception_state);
+    SetCurveImpl({}, 0, exception_state);
   }
 }
 
@@ -114,7 +115,7 @@ void WaveShaperNode::setCurve(const Vector<float>& curve,
                               ExceptionState& exception_state) {
   DCHECK(IsMainThread());
 
-  SetCurveImpl(curve.data(), curve.size(), exception_state);
+  SetCurveImpl(curve, curve.size(), exception_state);
 }
 
 NotShared<DOMFloat32Array> WaveShaperNode::curve() const {
@@ -126,7 +127,7 @@ NotShared<DOMFloat32Array> WaveShaperNode::curve() const {
   unsigned size = curve->size();
 
   NotShared<DOMFloat32Array> result(DOMFloat32Array::Create(size));
-  UNSAFE_TODO(memcpy(result->Data(), curve->data(), sizeof(float) * size));
+  UNSAFE_TODO(memcpy(result->Data().data(), curve->data(), sizeof(float) * size));
 
   return result;
 }
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
index 0759311d38ae7..cbd062b6394ba 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_node.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_NODE_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_WEBAUDIO_WAVE_SHAPER_NODE_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer_view_helpers.h"
 #include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
 #include "third_party/blink/renderer/modules/webaudio/audio_node.h"
@@ -64,7 +65,7 @@ class WaveShaperNode final : public AudioNode {
   void ReportWillBeDestroyed() final;
 
  private:
-  void SetCurveImpl(const float* curve_data,
+  void SetCurveImpl(base::span<const float>curve_data,
                     size_t curve_length,
                     ExceptionState&);
   WaveShaperHandler& GetWaveShaperHandler() const;
diff --git a/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h b/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
index 67bd34d8cd70a..d0aea5b2711f7 100644
--- a/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
+++ b/third_party/blink/renderer/modules/webcodecs/array_buffer_util.h
@@ -69,7 +69,7 @@ class ArrayBufferContentsExternalMemory
                                              base::span<const uint8_t> span)
       : contents_(std::move(contents)), span_(span) {
     // Check that `span` refers to the memory inside `contents`.
-    auto* contents_data = static_cast<const uint8_t*>(contents_.Data());
+    base::span<const uint8_t>contents_data = static_cast<const uint8_t*>(contents_.Data());
     CHECK_GE(base::to_address(span.begin()), contents_data);
     CHECK_LE(base::to_address(span.end()),
              UNSAFE_TODO(contents_data + contents_.DataLength()));
diff --git a/third_party/blink/renderer/modules/webcodecs/audio_data.cc b/third_party/blink/renderer/modules/webcodecs/audio_data.cc
index 7462b37a3094e..b3bcfcde2e675 100644
--- a/third_party/blink/renderer/modules/webcodecs/audio_data.cc
+++ b/third_party/blink/renderer/modules/webcodecs/audio_data.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webcodecs/audio_data.h"
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/notreached.h"
 #include "base/numerics/checked_math.h"
@@ -191,7 +192,7 @@ class ArrayBufferContentsAsAudioExternalMemory
       : media::AudioBuffer::ExternalMemory(span),
         contents_(std::move(contents)) {
     // Check that `span` refers to the memory inside `contents`.
-    auto* contents_data = static_cast<uint8_t*>(contents_.Data());
+    base::span<uint8_t>contents_data = static_cast<uint8_t*>(contents_.Data());
     CHECK_GE(base::to_address(span.begin()), contents_data);
     CHECK_LE(base::to_address(span.end()),
              UNSAFE_TODO(contents_data + contents_.DataLength()));
@@ -636,7 +637,7 @@ void AudioData::CopyConvert(base::span<uint8_t> dest,
   const int channel = copy_to_options->planeIndex();
 
   CHECK_LT(channel, data_as_f32_bus_->channels());
-  float* src_data = data_as_f32_bus_->channel(channel);
+  base::span<float>src_data = data_as_f32_bus_->channel(channel);
   float* offset_src_data = UNSAFE_TODO(src_data + offset);
   CHECK_LE(UNSAFE_TODO(offset_src_data + frame_count),
            UNSAFE_TODO(src_data + data_as_f32_bus_->frames()));
diff --git a/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc b/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
index 97420b7888f41..2e14a25c2d27d 100644
--- a/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
+++ b/third_party/blink/renderer/modules/webcodecs/audio_data_test.cc
@@ -48,7 +48,7 @@ constexpr float kEpsilon = kIncrement / 100;
 
 class AudioDataTest : public testing::Test {
  protected:
-  void VerifyPlanarData(float* data, float start_value, int count) {
+  void VerifyPlanarData(base::span<float>data, float start_value, int count) {
     for (int i = 0; i < count; ++i)
       ASSERT_NEAR(data[i], start_value + i * kIncrement, kEpsilon) << "i=" << i;
   }
@@ -60,8 +60,8 @@ class AudioDataTest : public testing::Test {
   AllowSharedBufferSource* CreateCustomData(int channels, int frames) {
     auto* buffer = DOMArrayBuffer::Create(channels * frames, sizeof(float));
     for (int ch = 0; ch < channels; ++ch) {
-      float* plane_start =
-          reinterpret_cast<float*>(buffer->Data()) + ch * frames;
+      base::span<float>plane_start =
+          reinterpret_cast<float*>(buffer->Data()) .subspan( ch * frames);
       for (int i = 0; i < frames; ++i) {
         plane_start[i] = static_cast<float>((i + ch * frames) * kIncrement);
       }
@@ -491,7 +491,7 @@ TEST_F(AudioDataTest, Interleaved) {
   EXPECT_FALSE(scope.GetExceptionState().HadException());
 
   // Verify we retrieved the right samples.
-  int16_t* copy = static_cast<int16_t*>(data_copy->Data());
+  base::span<int16_t>copy = static_cast<int16_t*>(data_copy->Data());
   for (int i = 0; i < kPartialFrameCount; ++i) {
     int block_index = i * kInterleavedChannels;
     int16_t base_value = kOffset + i;
@@ -603,7 +603,7 @@ class AudioDataConversionTest : public testing::Test {
     auto* buffer =
         DOMArrayBuffer::Create(kChannels * kFrames, sizeof(ValueType));
 
-    ValueType* plane_start = reinterpret_cast<ValueType*>(buffer->Data());
+    base::span<ValueType>plane_start = reinterpret_cast<ValueType*>(buffer->Data());
     for (int i = 0; i < kFrames; ++i) {
       plane_start[i] = SourceTraits::kMinValue;
     }
@@ -615,7 +615,7 @@ class AudioDataConversionTest : public testing::Test {
       plane_start[kFrames - 1] = SourceTraits::kZeroPointValue;
     }
 
-    plane_start += kFrames;
+    plane_start=plane_start.subspan(kFrames);
 
     for (int i = 0; i < kFrames; ++i) {
       plane_start[i] = SourceTraits::kMaxValue;
@@ -644,7 +644,7 @@ class AudioDataConversionTest : public testing::Test {
     constexpr int kTotalSamples = kChannels * kFrames;
     auto* buffer = DOMArrayBuffer::Create(kTotalSamples, sizeof(ValueType));
 
-    ValueType* plane_start = reinterpret_cast<ValueType*>(buffer->Data());
+    base::span<ValueType>plane_start = reinterpret_cast<ValueType*>(buffer->Data());
     for (int i = 0; i < kTotalSamples; i += 2) {
       plane_start[i] = SourceTraits::kMinValue;
       plane_start[i + 1] = SourceTraits::kMaxValue;
@@ -709,7 +709,7 @@ class AudioDataConversionTest : public testing::Test {
     EXPECT_FALSE(scope.GetExceptionState().HadException())
         << scope.GetExceptionState().Message();
 
-    TargetType* copied_data = static_cast<TargetType*>(data_copy->Data());
+    base::span<TargetType>copied_data = static_cast<TargetType*>(data_copy->Data());
 
     // `kChannelToCopy` should only contain kMaxValue
     for (int i = 0; i < frames_to_copy; ++i) {
@@ -752,7 +752,7 @@ class AudioDataConversionTest : public testing::Test {
     EXPECT_FALSE(scope.GetExceptionState().HadException())
         << scope.GetExceptionState().Message();
 
-    TargetType* copied_data = static_cast<TargetType*>(data_copy->Data());
+    base::span<TargetType>copied_data = static_cast<TargetType*>(data_copy->Data());
 
     // The interleaved data should have kMinValue in
     // channel 0 and kMaxValue in channel 1.
diff --git a/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc b/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
index 40e6e215e2c5a..791c1bcc2cebb 100644
--- a/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
+++ b/third_party/blink/renderer/modules/webcodecs/image_decoder_external.cc
@@ -80,7 +80,7 @@ class ArrayBufferContentsSegmentReader : public SegmentReader {
   explicit ArrayBufferContentsSegmentReader(ArrayBufferContents contents)
       : contents_(std::move(contents)),
         segment_reader_(SegmentReader::CreateFromSkData(
-            SkData::MakeWithoutCopy(contents_.Data(),
+            SkData::MakeWithoutCopy(contents_.Data().data(),
                                     contents_.DataLength()))) {}
 
   size_t size() const override { return segment_reader_->size(); }
diff --git a/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc b/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
index dafe174232e16..f6410b075952a 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_frame_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -134,10 +136,10 @@ TEST_F(VideoFrameTest, CopyToRGB) {
   uint32_t buffer_size =
       blink_frame->allocationSize(options, scope.GetExceptionState());
   auto* buffer = DOMArrayBuffer::Create(buffer_size, 1);
-  uint8_t* data = static_cast<uint8_t*>(buffer->Data());
+  base::span<uint8_t>data = static_cast<uint8_t*>(buffer->Data());
 
   // Set buffer to white pixels.
-  memset(data, 0xff, buffer_size);
+  memset(data.data(), 0xff, buffer_size);
   AllowSharedBufferSource* destination =
       MakeGarbageCollected<AllowSharedBufferSource>(buffer);
 
diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 2939586ca1596..15998baadecf6 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -5033,7 +5033,7 @@ void WebGLRenderingContextBase::ReadPixelsHelper(GLint x,
   }
   ClearIfComposited(kClearCallerOther);
 
-  uint8_t* data = static_cast<uint8_t*>(pixels->BaseAddressMaybeShared()) +
+  uint8_t* data = static_cast<uint8_t*>(pixels->BaseAddressMaybeShared().data()) +
                   offset_in_bytes.ValueOrDie();
 
   // We add special handling here if the 'ArrayBufferView' is size '0' and the
diff --git a/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc b/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
index d7f5c10b6f82d..e25e4c1a88c59 100644
--- a/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
+++ b/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
@@ -461,7 +461,7 @@ WebSocketChannel::SendResult WebSocketChannelImpl::Send(
     size_t byte_offset,
     size_t byte_length,
     base::OnceClosure completion_callback) {
-  DVLOG(1) << this << " Send(" << buffer.Data() << ", " << byte_offset << ", "
+  DVLOG(1) << this << " Send(" << buffer.Data().data() << ", " << byte_offset << ", "
            << byte_length << ") "
            << "(DOMArrayBuffer argument)";
   probe::DidSendWebSocketMessage(
diff --git a/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc b/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
index 18b34e36929d5..1ddd238e366c6 100644
--- a/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
+++ b/third_party/blink/renderer/modules/webtransport/bidirectional_stream_test.cc
@@ -255,7 +255,7 @@ void TestWrite(const V8TestingScope& scope,
   auto* writer = bidirectional_stream->writable()->getWriter(
       script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+   chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
diff --git a/third_party/blink/renderer/modules/webtransport/web_transport_test.cc b/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
index 6be7e6902e9ff..633511a1b89e5 100644
--- a/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
+++ b/third_party/blink/renderer/modules/webtransport/web_transport_test.cc
@@ -790,7 +790,7 @@ TEST_F(WebTransportTest, SendDatagram) {
   auto* script_state = scope.GetScriptState();
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+   chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
@@ -826,28 +826,28 @@ TEST_F(WebTransportTest, BackpressureForOutgoingDatagrams) {
 
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'A';
+     chunk->Data()[0] = 'A';
     promise1 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'B';
+     chunk->Data()[0] = 'B';
     promise2 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'C';
+     chunk->Data()[0] = 'C';
     promise3 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
   }
   {
     auto* chunk = DOMUint8Array::Create(1);
-    *chunk->Data() = 'D';
+     chunk->Data()[0] = 'D';
     promise4 =
         writer->write(script_state, ScriptValue::From(script_state, chunk),
                       ASSERT_NO_EXCEPTION);
@@ -875,7 +875,7 @@ TEST_F(WebTransportTest, SendDatagramBeforeConnect) {
   auto* script_state = scope.GetScriptState();
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+   chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
@@ -895,7 +895,7 @@ TEST_F(WebTransportTest, SendDatagramBeforeConnect) {
       }));
 
   test::RunPendingTasks();
-  *chunk->Data() = 'N';
+   chunk->Data()[0] = 'N';
   result = writer->write(script_state, ScriptValue::From(script_state, chunk),
                          ASSERT_NO_EXCEPTION);
 
@@ -919,7 +919,7 @@ TEST_F(WebTransportTest, SendDatagramAfterClose) {
   auto* writer = writable->getWriter(script_state, ASSERT_NO_EXCEPTION);
 
   auto* chunk = DOMUint8Array::Create(1);
-  *chunk->Data() = 'A';
+   chunk->Data()[0] = 'A';
   auto result =
       writer->write(script_state, ScriptValue::From(script_state, chunk),
                     ASSERT_NO_EXCEPTION);
diff --git a/third_party/blink/renderer/modules/xr/xr_ray.cc b/third_party/blink/renderer/modules/xr/xr_ray.cc
index c3c6220fcc8ef..65fcd2bacab1e 100644
--- a/third_party/blink/renderer/modules/xr/xr_ray.cc
+++ b/third_party/blink/renderer/modules/xr/xr_ray.cc
@@ -129,7 +129,7 @@ NotShared<DOMFloat32Array> XRRay::matrix() {
   // steps:
   //    Step 1. If the operation IsDetachedBuffer on internal matrix is false,
   //    return transforms internal matrix.
-  if (!matrix_ || !matrix_->Data()) {
+  if (!matrix_ || ).empty()) {
     // Returned matrix should represent transformation from ray originating at
     // (0,0,0) with direction (0,0,-1) into ray originating at |origin_| with
     // direction |direction_|.
diff --git a/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc b/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
index 3bd0098cd1796..d999eb050ea61 100644
--- a/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
+++ b/third_party/blink/renderer/modules/xr/xr_rigid_transform.cc
@@ -114,7 +114,7 @@ NotShared<DOMFloat32Array> XRRigidTransform::matrix() {
     matrix_array_ = transformationMatrixToDOMFloat32Array(*matrix_);
   }
 
-  if (!matrix_array_ || !matrix_array_->Data()) {
+  if (!matrix_array_ || ).empty()) {
     // A page may take the matrix_array_ value and detach it so matrix_array_ is
     // a detached array buffer.  This breaks the inspector, so return an empty
     // array instead.
diff --git a/third_party/blink/renderer/modules/xr/xr_utils.cc b/third_party/blink/renderer/modules/xr/xr_utils.cc
index bb1b7afd15418..b80dfc56d03e6 100644
--- a/third_party/blink/renderer/modules/xr/xr_utils.cc
+++ b/third_party/blink/renderer/modules/xr/xr_utils.cc
@@ -29,7 +29,7 @@ gfx::Transform DOMFloat32ArrayToTransform(NotShared<DOMFloat32Array> m) {
 
 gfx::Transform WTFFloatVectorToTransform(const Vector<float>& m) {
   DCHECK_EQ(m.size(), 16u);
-  return gfx::Transform::ColMajorF(m.data());
+  return gfx::Transform::ColMajorF(m);
 }
 
 // Normalize to have length = 1.0
diff --git a/third_party/blink/renderer/modules/xr/xr_view.cc b/third_party/blink/renderer/modules/xr/xr_view.cc
index 36ca2ad8a0ec1..126a60d27aef4 100644
--- a/third_party/blink/renderer/modules/xr/xr_view.cc
+++ b/third_party/blink/renderer/modules/xr/xr_view.cc
@@ -77,7 +77,7 @@ XRSession* XRView::session() const {
 }
 
 NotShared<DOMFloat32Array> XRView::projectionMatrix() const {
-  if (!projection_matrix_ || !projection_matrix_->Data()) {
+  if (!projection_matrix_ || ).empty()) {
     // A page may take the projection matrix value and detach it so
     // projection_matrix_ is a detached array buffer.  This breaks the
     // inspector, so return an empty array instead.
diff --git a/third_party/blink/renderer/platform/audio/audio_array.h b/third_party/blink/renderer/platform/audio/audio_array.h
index e7d13b3f5bd92..c6df45fbde224 100644
--- a/third_party/blink/renderer/platform/audio/audio_array.h
+++ b/third_party/blink/renderer/platform/audio/audio_array.h
@@ -92,8 +92,8 @@ class AudioArray final {
     size_ = static_cast<uint32_t>(n);
   }
 
-  T* Data() { return aligned_data_; }
-  const T* Data() const { return aligned_data_; }
+  base::span<T> Data() { return aligned_data_; }
+  const base::span<T> Data() const { return aligned_data_; }
   uint32_t size() const { return size_; }
   base::span<T> as_span() {
     // SAFETY: Allocate() ensures `aligned_data_` and `size_` are safe.
diff --git a/third_party/blink/renderer/platform/audio/audio_bus.cc b/third_party/blink/renderer/platform/audio/audio_bus.cc
index 5a251af33aeb0..409bc6a985268 100644
--- a/third_party/blink/renderer/platform/audio/audio_bus.cc
+++ b/third_party/blink/renderer/platform/audio/audio_bus.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -82,7 +84,7 @@ AudioBus::AudioBus(unsigned number_of_channels, uint32_t length, bool allocate)
 }
 
 void AudioBus::SetChannelMemory(unsigned channel_index,
-                                float* storage,
+                                base::span<float>storage,
                                 uint32_t length) {
   if (channel_index < channels_.size()) {
     Channel(channel_index)->Set(storage, length);
@@ -385,10 +387,10 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
   if (number_of_source_channels == 2 && number_of_destination_channels == 1) {
     // Down-mixing: 2 -> 1
     //   output = 0.5 * (input.L + input.R)
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination = ChannelByType(kChannelLeft)->MutableData();
     float scale = 0.5;
 
     Vsma(source_l, 1, &scale, destination, 1, length());
@@ -397,14 +399,14 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
              number_of_destination_channels == 1) {
     // Down-mixing: 4 -> 1
     //   output = 0.25 * (input.L + input.R + input.SL + input.SR)
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
-    const float* source_sl =
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_sl =
         source_bus.ChannelByType(kChannelSurroundLeft)->Data();
-    const float* source_sr =
+    base::span<const float>source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination = ChannelByType(kChannelLeft)->MutableData();
     float scale = 0.25;
 
     Vsma(source_l, 1, &scale, destination, 1, length());
@@ -416,15 +418,15 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     // Down-mixing: 5.1 -> 1
     //   output = sqrt(1/2) * (input.L + input.R) + input.C
     //            + 0.5 * (input.SL + input.SR)
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
-    const float* source_c = source_bus.ChannelByType(kChannelCenter)->Data();
-    const float* source_sl =
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_c = source_bus.ChannelByType(kChannelCenter)->Data();
+    base::span<const float>source_sl =
         source_bus.ChannelByType(kChannelSurroundLeft)->Data();
-    const float* source_sr =
+    base::span<const float>source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination = ChannelByType(kChannelLeft)->MutableData();
     float scale_sqrt_half = sqrtf(0.5);
     float scale_half = 0.5;
 
@@ -438,15 +440,15 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     // Down-mixing: 4 -> 2
     //   output.L = 0.5 * (input.L + input.SL)
     //   output.R = 0.5 * (input.R + input.SR)
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
-    const float* source_sl =
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_sl =
         source_bus.ChannelByType(kChannelSurroundLeft)->Data();
-    const float* source_sr =
+    base::span<const float>source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    base::span<float>destination_l = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination_r = ChannelByType(kChannelRight)->MutableData();
     float scale_half = 0.5;
 
     Vsma(source_l, 1, &scale_half, destination_l, 1, length());
@@ -458,16 +460,16 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     // Down-mixing: 5.1 -> 2
     //   output.L = input.L + sqrt(1/2) * (input.C + input.SL)
     //   output.R = input.R + sqrt(1/2) * (input.C + input.SR)
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
-    const float* source_c = source_bus.ChannelByType(kChannelCenter)->Data();
-    const float* source_sl =
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_c = source_bus.ChannelByType(kChannelCenter)->Data();
+    base::span<const float>source_sl =
         source_bus.ChannelByType(kChannelSurroundLeft)->Data();
-    const float* source_sr =
+    base::span<const float>source_sr =
         source_bus.ChannelByType(kChannelSurroundRight)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    base::span<float>destination_l = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination_r = ChannelByType(kChannelRight)->MutableData();
     float scale_sqrt_half = sqrtf(0.5);
 
     Vadd(source_l, 1, destination_l, 1, destination_l, 1, length());
@@ -483,12 +485,12 @@ void AudioBus::SumFromByDownMixing(const AudioBus& source_bus) {
     //   output.R = input.R + sqrt(1/2) * input.C
     //   output.SL = input.SL
     //   output.SR = input.SR
-    const float* source_l = source_bus.ChannelByType(kChannelLeft)->Data();
-    const float* source_r = source_bus.ChannelByType(kChannelRight)->Data();
-    const float* source_c = source_bus.ChannelByType(kChannelCenter)->Data();
+    base::span<const float>source_l = source_bus.ChannelByType(kChannelLeft)->Data();
+    base::span<const float>source_r = source_bus.ChannelByType(kChannelRight)->Data();
+    base::span<const float>source_c = source_bus.ChannelByType(kChannelCenter)->Data();
 
-    float* destination_l = ChannelByType(kChannelLeft)->MutableData();
-    float* destination_r = ChannelByType(kChannelRight)->MutableData();
+    base::span<float>destination_l = ChannelByType(kChannelLeft)->MutableData();
+    base::span<float>destination_r = ChannelByType(kChannelRight)->MutableData();
     float scale_sqrt_half = sqrtf(0.5);
 
     Vadd(source_l, 1, destination_l, 1, destination_l, 1, length());
@@ -559,7 +561,7 @@ void AudioBus::CopyWithGainFrom(const AudioBus& source_bus, float gain) {
 
 void AudioBus::CopyWithSampleAccurateGainValuesFrom(
     const AudioBus& source_bus,
-    float* gain_values,
+    base::span<float>gain_values,
     unsigned number_of_gain_values) {
   // Make sure we're processing from the same type of bus.
   // We *are* able to process from mono -> stereo
@@ -567,7 +569,7 @@ void AudioBus::CopyWithSampleAccurateGainValuesFrom(
     NOTREACHED();
   }
 
-  if (!gain_values || number_of_gain_values > source_bus.length()) {
+  if (gain_values.empty() || number_of_gain_values > source_bus.length()) {
     NOTREACHED();
   }
 
@@ -578,13 +580,13 @@ void AudioBus::CopyWithSampleAccurateGainValuesFrom(
   }
 
   // We handle both the 1 -> N and N -> N case here.
-  const float* source = source_bus.Channel(0)->Data();
+  base::span<const float>source = source_bus.Channel(0)->Data();
   for (unsigned channel_index = 0; channel_index < NumberOfChannels();
        ++channel_index) {
     if (source_bus.NumberOfChannels() == NumberOfChannels()) {
       source = source_bus.Channel(channel_index)->Data();
     }
-    float* destination = Channel(channel_index)->MutableData();
+    base::span<float>destination = Channel(channel_index)->MutableData();
     vector_math::Vmul(source, 1, gain_values, 1, destination, 1,
                       number_of_gain_values);
   }
@@ -650,8 +652,8 @@ scoped_refptr<AudioBus> AudioBus::CreateBySampleRateConverting(
 
   // Sample-rate convert each channel.
   for (unsigned i = 0; i < number_of_destination_channels; ++i) {
-    const float* source = resampler_source_bus->Channel(i)->Data();
-    float* destination = destination_bus->Channel(i)->MutableData();
+    base::span<const float>source = resampler_source_bus->Channel(i)->Data();
+    base::span<float>destination = destination_bus->Channel(i)->MutableData();
 
     SincResampler resampler(sample_rate_ratio);
     resampler.Process(source, destination, source_length);
@@ -677,9 +679,9 @@ scoped_refptr<AudioBus> AudioBus::CreateByMixingToMono(
       unsigned n = source_bus->length();
       scoped_refptr<AudioBus> destination_bus = Create(1, n);
 
-      const float* source_l = source_bus->Channel(0)->Data();
-      const float* source_r = source_bus->Channel(1)->Data();
-      float* destination = destination_bus->Channel(0)->MutableData();
+      base::span<const float>source_l = source_bus->Channel(0)->Data();
+      base::span<const float>source_r = source_bus->Channel(1)->Data();
+      base::span<float>destination = destination_bus->Channel(0)->MutableData();
 
       // Do the mono mixdown.
       for (unsigned i = 0; i < n; ++i) {
diff --git a/third_party/blink/renderer/platform/audio/audio_bus.h b/third_party/blink/renderer/platform/audio/audio_bus.h
index d749e61c9776a..525bce5b08579 100644
--- a/third_party/blink/renderer/platform/audio/audio_bus.h
+++ b/third_party/blink/renderer/platform/audio/audio_bus.h
@@ -85,7 +85,7 @@ class PLATFORM_EXPORT AudioBus final : public ThreadSafeRefCounted<AudioBus> {
 
   // Tells the given channel to use an externally allocated buffer.
   void SetChannelMemory(unsigned channel_index,
-                        float* storage,
+                        base::span<float>storage,
                         uint32_t length);
 
   // Channels
@@ -163,7 +163,7 @@ class PLATFORM_EXPORT AudioBus final : public ThreadSafeRefCounted<AudioBus> {
 
   // Copies the sourceBus by scaling with sample-accurate gain values.
   void CopyWithSampleAccurateGainValuesFrom(const AudioBus& source_bus,
-                                            float* gain_values,
+                                            base::span<float>gain_values,
                                             unsigned number_of_gain_values);
 
   // Returns maximum absolute value across all channels (useful for
diff --git a/third_party/blink/renderer/platform/audio/audio_channel.cc b/third_party/blink/renderer/platform/audio/audio_channel.cc
index 472686d58d399..1713fb24782a1 100644
--- a/third_party/blink/renderer/platform/audio/audio_channel.cc
+++ b/third_party/blink/renderer/platform/audio/audio_channel.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -61,7 +63,7 @@ void AudioChannel::CopyFrom(const AudioChannel* source_channel) {
     Zero();
     return;
   }
-  memcpy(MutableData(), source_channel->Data(),
+  memcpy(MutableData().data(), source_channel->Data().data(),
          base::CheckMul(sizeof(float), length()).ValueOrDie());
 }
 
@@ -81,8 +83,8 @@ void AudioChannel::CopyFromRange(const AudioChannel* source_channel,
   size_t range_length = end_frame - start_frame;
   DCHECK_LE(range_length, length());
 
-  const float* source = source_channel->Data();
-  float* destination = MutableData();
+  base::span<const float>source = source_channel->Data();
+  float* destination = MutableData().data();
 
   const size_t safe_length =
       base::CheckMul(sizeof(float), range_length).ValueOrDie();
@@ -93,7 +95,7 @@ void AudioChannel::CopyFromRange(const AudioChannel* source_channel,
       memset(destination, 0, safe_length);
     }
   } else {
-    memcpy(destination, source + start_frame, safe_length);
+    memcpy(destination, source .subspan( start_frame).data(), safe_length);
   }
 }
 
diff --git a/third_party/blink/renderer/platform/audio/audio_channel.h b/third_party/blink/renderer/platform/audio/audio_channel.h
index 226550d6caa29..df2c2de9eebfb 100644
--- a/third_party/blink/renderer/platform/audio/audio_channel.h
+++ b/third_party/blink/renderer/platform/audio/audio_channel.h
@@ -31,6 +31,8 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/checked_math.h"
@@ -48,21 +50,21 @@ class PLATFORM_EXPORT AudioChannel final {
   // AudioFloatArray.
 
   // Reference an external buffer.
-  AudioChannel(float* storage, uint32_t length)
+  AudioChannel(base::span<float>storage, uint32_t length)
       : length_(length), raw_pointer_(storage), silent_(false) {}
 
   // Manage storage for us.
   explicit AudioChannel(uint32_t length)
-      : length_(length), raw_pointer_(nullptr), silent_(true) {
+      : length_(length), raw_pointer_({}), silent_(true) {
     mem_buffer_ = std::make_unique<AudioFloatArray>(length);
   }
 
   // A "blank" audio channel -- must call Set() before it's useful...
-  AudioChannel() : length_(0), raw_pointer_(nullptr), silent_(true) {}
+  AudioChannel() : length_(0), raw_pointer_({}), silent_(true) {}
 
   // Redefine the memory for this channel. |storage| represents external memory
   // not managed by this object.
-  void Set(float* storage, uint32_t length) {
+  void Set(base::span<float>storage, uint32_t length) {
     mem_buffer_.reset();  // cleanup managed storage
     raw_pointer_ = storage;
     length_ = length;
@@ -77,13 +79,13 @@ class PLATFORM_EXPORT AudioChannel final {
   void ResizeSmaller(uint32_t new_length);
 
   // Direct access to PCM sample data. Non-const accessor clears silent flag.
-  float* MutableData() {
+  base::span<float> MutableData() {
     ClearSilentFlag();
-    return raw_pointer_ ? raw_pointer_.get() : mem_buffer_->Data();
+    return !raw_pointer_.empty() ? raw_pointer_ : mem_buffer_->Data();
   }
 
-  const float* Data() const {
-    return raw_pointer_ ? raw_pointer_.get() : mem_buffer_->Data();
+  const base::span<float> Data() const {
+    return !raw_pointer_.empty() ? raw_pointer_ : mem_buffer_->Data();
   }
 
   // Zeroes out all sample values in buffer.
@@ -97,7 +99,7 @@ class PLATFORM_EXPORT AudioChannel final {
     if (mem_buffer_.get()) {
       mem_buffer_->Zero();
     } else {
-      UNSAFE_TODO(memset(raw_pointer_, 0,
+      UNSAFE_TODO(memset(raw_pointer_.data(), 0,
                          base::CheckMul(sizeof(float), length_).ValueOrDie()));
     }
   }
@@ -127,7 +129,7 @@ class PLATFORM_EXPORT AudioChannel final {
  private:
   uint32_t length_;
 
-  raw_ptr<float, DanglingUntriaged> raw_pointer_;
+  base::raw_span<float, DanglingUntriaged> raw_pointer_;
   std::unique_ptr<AudioFloatArray> mem_buffer_;
   bool silent_;
 };
diff --git a/third_party/blink/renderer/platform/audio/audio_destination.cc b/third_party/blink/renderer/platform/audio/audio_destination.cc
index 6843b9dcec030..adec87457d49d 100644
--- a/third_party/blink/renderer/platform/audio/audio_destination.cc
+++ b/third_party/blink/renderer/platform/audio/audio_destination.cc
@@ -500,7 +500,7 @@ AudioDestination::AudioDestination(
       // TODO(crbug.com/375449662): Spanify `AudioChannel::MuteableData`.
       resampler_bus_->SetChannelData(
           i, UNSAFE_TODO(base::span(
-                 render_bus_->Channel(i)->MutableData(),
+                 render_bus_->Channel(i)->MutableData().data(),
                  base::checked_cast<size_t>(render_bus_->length()))));
     }
   } else {
diff --git a/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h b/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
index 4cea7bb96671e..89d8ed09939e3 100644
--- a/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
+++ b/third_party/blink/renderer/platform/audio/audio_dsp_kernel.h
@@ -31,6 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_DSP_KERNEL_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_AUDIO_DSP_KERNEL_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_dsp_kernel_processor.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -59,8 +60,8 @@ class PLATFORM_EXPORT AudioDSPKernel {
 
   // Subclasses must override process() to do the processing and reset() to
   // reset DSP state.
-  virtual void Process(const float* source,
-                       float* destination,
+  virtual void Process(base::span<const float>source,
+                       base::span<float>destination,
                        uint32_t frames_to_process) = 0;
   // Subclasses that have AudioParams must override this to process the
   // AudioParams.
diff --git a/third_party/blink/renderer/platform/audio/biquad.cc b/third_party/blink/renderer/platform/audio/biquad.cc
index f14f24e8f2e55..ce6d3d5075bb2 100644
--- a/third_party/blink/renderer/platform/audio/biquad.cc
+++ b/third_party/blink/renderer/platform/audio/biquad.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -81,8 +83,8 @@ Biquad::Biquad(unsigned render_quantum_frames)
 
 Biquad::~Biquad() = default;
 
-void Biquad::Process(const float* source_p,
-                     float* dest_p,
+void Biquad::Process(base::span<const float>source_p,
+                     base::span<float>dest_p,
                      uint32_t frames_to_process) {
   // WARNING: sourceP and destP may be pointing to the same area of memory!
   // Be sure to read from sourceP before writing to destP!
@@ -95,18 +97,18 @@ void Biquad::Process(const float* source_p,
     double y1 = y1_;
     double y2 = y2_;
 
-    const double* b0 = b0_.Data();
-    const double* b1 = b1_.Data();
-    const double* b2 = b2_.Data();
-    const double* a1 = a1_.Data();
-    const double* a2 = a2_.Data();
+    base::span<const double>b0 = b0_.Data();
+    base::span<const double>b1 = b1_.Data();
+    base::span<const double>b2 = b2_.Data();
+    base::span<const double>a1 = a1_.Data();
+    base::span<const double>a2 = a2_.Data();
 
     for (int k = 0; k < n; ++k) {
       // FIXME: this can be optimized by pipelining the multiply adds...
-      float x = *source_p++;
+      float x = (source_p++)[0];
       float y = b0[k] * x + b1[k] * x1 + b2[k] * x2 - a1[k] * y1 - a2[k] * y2;
 
-      *dest_p++ = y;
+      (dest_p++)[0] = y;
 
       // Update state variables
       x2 = x1;
@@ -174,10 +176,10 @@ void Biquad::Process(const float* source_p,
 
     while (n--) {
       // FIXME: this can be optimized by pipelining the multiply adds...
-      float x = *source_p++;
+      float x = (source_p++)[0];
       float y = b0 * x + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
 
-      *dest_p++ = y;
+      (dest_p++)[0] = y;
 
       // Update state variables
       x2 = x1;
@@ -561,8 +563,8 @@ void Biquad::SetBandpassParams(int index, double frequency, double q) {
 
 void Biquad::GetFrequencyResponse(int n_frequencies,
                                   const float* frequency,
-                                  float* mag_response,
-                                  float* phase_response) {
+                                  base::span<float>mag_response,
+                                  base::span<float>phase_response) {
   // Evaluate the Z-transform of the filter at given normalized
   // frequency from 0 to 1.  (1 corresponds to the Nyquist
   // frequency.)
diff --git a/third_party/blink/renderer/platform/audio/biquad.h b/third_party/blink/renderer/platform/audio/biquad.h
index e2aee02dab501..36fc70c229da9 100644
--- a/third_party/blink/renderer/platform/audio/biquad.h
+++ b/third_party/blink/renderer/platform/audio/biquad.h
@@ -31,6 +31,7 @@
 
 #include <sys/types.h>
 #include <complex>
+#include "base/containers/span.h"
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -50,8 +51,8 @@ class PLATFORM_EXPORT Biquad final {
   explicit Biquad(unsigned render_quantum_frames);
   ~Biquad();
 
-  void Process(const float* source_p,
-               float* dest_p,
+  void Process(base::span<const float>source_p,
+               base::span<float>dest_p,
                uint32_t frames_to_process);
 
   bool HasSampleAccurateValues() const { return has_sample_accurate_values_; }
@@ -85,8 +86,8 @@ class PLATFORM_EXPORT Biquad final {
   // The phase response is in radians.
   void GetFrequencyResponse(int n_frequencies,
                             const float* frequency,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<float>mag_response,
+                            base::span<float>phase_response);
 
  private:
   void SetNormalizedCoefficients(int,
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
index 4538261588731..6b51f069d61f8 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -56,13 +58,13 @@ ALWAYS_INLINE static __m128 WrapPositionVector(__m128 v_position,
 }
 
 std::tuple<unsigned, int> Delay::ProcessARateVector(
-    float* destination,
+    base::span<float>destination,
     uint32_t frames_to_process) const {
   const int buffer_length = buffer_.size();
-  const float* buffer = buffer_.Data();
+  base::span<const float>buffer = buffer_.Data();
 
   const float sample_rate = sample_rate_;
-  const float* delay_times = delay_times_.Data();
+  base::span<const float>delay_times = delay_times_.Data();
   int w_index = write_index_;
 
   const __m128 v_sample_rate = _mm_set1_ps(sample_rate);
@@ -91,7 +93,7 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
   for (int n = 0; n < number_of_loops; ++n, k += 4) {
     // It's possible that `delay_time` contains negative values. Make sure
     // they are greater than zero.
-    const __m128 v_delay_time = _mm_max_ps(_mm_loadu_ps(delay_times + k),
+    const __m128 v_delay_time = _mm_max_ps(_mm_loadu_ps(delay_times .subspan( k).data()),
                                            v_all_zeros);
     const __m128 v_desired_delay_frames =
         _mm_mul_ps(v_delay_time, v_sample_rate);
@@ -132,7 +134,7 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
     const __m128 sample = _mm_add_ps(
         v_sample1,
         _mm_mul_ps(interpolation_factor, _mm_sub_ps(v_sample2, v_sample1)));
-    _mm_store_ps(destination + k, sample);
+    _mm_store_ps(destination .subspan( k).data(), sample);
   }
 
   // Update |w_index|_ based on how many frames we processed here, wrapping
@@ -145,7 +147,7 @@ std::tuple<unsigned, int> Delay::ProcessARateVector(
   return std::make_tuple(k, w_index);
 }
 
-void Delay::HandleNaN(float* delay_times,
+void Delay::HandleNaN(base::span<float>delay_times,
                       uint32_t frames_to_process,
                       float max_time) {
   unsigned k = 0;
@@ -155,7 +157,7 @@ void Delay::HandleNaN(float* delay_times,
 
   // This is approximately 4 times faster than the scalar version.
   for (unsigned loop = 0; loop < number_of_loops; ++loop, k += 4) {
-    __m128 x = _mm_loadu_ps(delay_times + k);
+    __m128 x = _mm_loadu_ps(delay_times .subspan( k).data());
     // 0xffffffff if x is NaN. Otherwise 0
     __m128 cmp = _mm_cmpunord_ps(x, x);
 
@@ -169,7 +171,7 @@ void Delay::HandleNaN(float* delay_times,
     // Merge i (bitwise or) x and cmp.  This makes x = max_time if x was NaN and
     // preserves x if not.
     x = _mm_or_ps(x, cmp);
-    _mm_storeu_ps(delay_times + k, x);
+    _mm_storeu_ps(delay_times .subspan( k).data(), x);
   }
 
   // Handle any frames not done in the loop above.
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_avx.h b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_avx.h
index 53393c8066e62..84d19b8742473 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_avx.h
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_avx.h
@@ -7,6 +7,7 @@
 
 #include <cstddef>
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 
 namespace blink {
@@ -23,9 +24,9 @@ bool IsAligned(const float*);
 // dest[k] = sum(source[k+m]*filter[m*filter_stride]) for all m
 // provided that |prepared_filter_p| is |prepared_filter->Data()| and that
 // |prepared_filter| is prepared with |PrepareFilterForConv|.
-void Conv(const float* source_p,
-          const float* prepared_filter_p,
-          float* dest_p,
+void Conv(base::span<const float>source_p,
+          base::span<const float>prepared_filter_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process,
           size_t filter_size);
 
@@ -35,51 +36,51 @@ void PrepareFilterForConv(const float* filter_p,
                           AudioFloatArray* prepared_filter);
 
 // dest[k] = source1[k] + source2[k]
-void Vadd(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vadd(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = source1[k] - source2[k]
-void Vsub(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vsub(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = clip(source[k], low_threshold, high_threshold)
 //         = max(low_threshold, min(high_threshold, source[k]))
-void Vclip(const float* source_p,
+void Vclip(base::span<const float>source_p,
            const float* low_threshold_p,
            const float* high_threshold_p,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 // *max_p = max(*max_p, source_max) where
 // source_max = max(abs(source[k])) for all k
-void Vmaxmgv(const float* source_p, float* max_p, uint32_t frames_to_process);
+void Vmaxmgv(base::span<const float>source_p, float* max_p, uint32_t frames_to_process);
 
 // dest[k] = source1[k] * source2[k]
-void Vmul(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vmul(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] += scale * source[k]
-void Vsma(const float* source_p,
+void Vsma(base::span<const float>source_p,
           const float* scale,
-          float* dest_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = scale * source[k]
-void Vsmul(const float* source_p,
+void Vsmul(base::span<const float>source_p,
            const float* scale,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 // dest[k] = addend + source[k]
-void Vsadd(const float* source_p,
+void Vsadd(base::span<const float>source_p,
            const float* addend,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 void Vsadd(const float* source_p,
@@ -88,16 +89,16 @@ void Vsadd(const float* source_p,
            uint32_t frames_to_process);
 
 // sum += sum(source[k]^2) for all k
-void Vsvesq(const float* source_p, float* sum_p, uint32_t frames_to_process);
+void Vsvesq(base::span<const float>source_p, float* sum_p, uint32_t frames_to_process);
 
 // real_dest[k] = real1[k] * real2[k] - imag1[k] * imag2[k]
 // imag_dest[k] = real1[k] * imag2[k] + imag1[k] * real2[k]
-void Zvmul(const float* real1p,
-           const float* imag1p,
-           const float* real2p,
-           const float* imag2p,
-           float* real_dest_p,
-           float* imag_dest_p,
+void Zvmul(base::span<const float>real1p,
+           base::span<const float>imag1p,
+           base::span<const float>real2p,
+           base::span<const float>imag2p,
+           base::span<float>real_dest_p,
+           base::span<float>imag_dest_p,
            uint32_t frames_to_process);
 
 }  // namespace avx
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
index d948e1d480b2b..41fc284a121aa 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_impl.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -52,7 +54,7 @@ void PrepareFilterForConv(const float* filter_p,
   // Reverse the filter and repeat each value across a vector
   prepared_filter->Allocate(kReversedFilterStride * kPackedFloatsPerRegister *
                             filter_size);
-  MType* reversed_filter = reinterpret_cast<MType*>(prepared_filter->Data());
+  base::span<MType>reversed_filter = reinterpret_cast<MType*>(prepared_filter->Data());
   for (size_t i = 0; i < filter_size; ++i) {
     reversed_filter[kReversedFilterStride * i] = MM_PS(set1)(*(filter_p - i));
   }
@@ -62,17 +64,17 @@ void PrepareFilterForConv(const float* filter_p,
 // dest[k] = sum(source[k+m]*filter[m*filter_stride]) for all m
 // provided that |prepared_filter_p| is |prepared_filter->Data()| and that
 // |prepared_filter| is prepared with |PrepareFilterForConv|.
-void Conv(const float* source_p,
-          const float* prepared_filter_p,
-          float* dest_p,
+void Conv(base::span<const float>source_p,
+          base::span<const float>prepared_filter_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process,
           size_t filter_size) {
-  const float* const dest_end_p = dest_p + frames_to_process;
+  const float* const dest_end_p = dest_p .subspan( frames_to_process).data();
 
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
   DCHECK_EQ(0u, filter_size % kPackedFloatsPerRegister);
 
-  const MType* reversed_filter =
+  base::span<const MType>reversed_filter =
       reinterpret_cast<const MType*>(prepared_filter_p);
 
   // Do convolution with kPackedFloatsPerRegister inputs at a time.
@@ -87,48 +89,48 @@ void Conv(const float* source_p,
         MType m_product;
         MType m_source;
 
-        m_source = MM_PS(loadu)(source_p + k);
+        m_source = MM_PS(loadu)(source_p .subspan( k).data());
         m_product =
             MM_PS(mul)(reversed_filter[kReversedFilterStride * k], m_source);
         m_convolution_sum = MM_PS(add)(m_convolution_sum, m_product);
       }
     }
-    MM_PS(storeu)(dest_p, m_convolution_sum);
+    MM_PS(storeu)(dest_p.data(), m_convolution_sum);
 
-    source_p += kPackedFloatsPerRegister;
-    dest_p += kPackedFloatsPerRegister;
+    source_p=source_p.subspan(kPackedFloatsPerRegister);
+    dest_p=dest_p.subspan(kPackedFloatsPerRegister);
   }
 }
 
 // dest[k] = source1[k] + source2[k]
-void Vadd(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vadd(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process) {
-  const float* const source1_end_p = source1p + frames_to_process;
+  const float* const source1_end_p = source1p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source1p));
+  DCHECK(IsAligned(source1p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
 #define ADD_ALL(loadSource2, storeDest)              \
   while (source1p < source1_end_p) {                 \
-    MType m_source1 = MM_PS(load)(source1p);         \
-    MType m_source2 = MM_PS(loadSource2)(source2p);  \
+    MType m_source1 = MM_PS(load)(source1p.data());         \
+    MType m_source2 = MM_PS(loadSource2)(source2p.data());  \
     MType m_dest = MM_PS(add)(m_source1, m_source2); \
-    MM_PS(storeDest)(dest_p, m_dest);                \
-    source1p += kPackedFloatsPerRegister;            \
-    source2p += kPackedFloatsPerRegister;            \
-    dest_p += kPackedFloatsPerRegister;              \
+    MM_PS(storeDest)(dest_p.data(), m_dest);                \
+    source1p=.subspan();            \
+    source2p=.subspan();            \
+    dest_p=.subspan();              \
   }
 
-  if (IsAligned(source2p)) {
-    if (IsAligned(dest_p)) {
+  if (IsAligned(source2p.data())) {
+    if (IsAligned(dest_p.data())) {
       ADD_ALL(load, store);
     } else {
       ADD_ALL(load, storeu);
     }
   } else {
-    if (IsAligned(dest_p)) {
+    if (IsAligned(dest_p.data())) {
       ADD_ALL(loadu, store);
     } else {
       ADD_ALL(loadu, storeu);
@@ -139,34 +141,34 @@ void Vadd(const float* source1p,
 }
 
 // dest[k] = source1[k] - source2[k]
-void Vsub(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vsub(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process) {
-  const float* const source1_end_p = source1p + frames_to_process;
+  const float* const source1_end_p = source1p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source1p));
+  DCHECK(IsAligned(source1p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
 #define SUB_ALL(loadSource2, storeDest)              \
   while (source1p < source1_end_p) {                 \
-    MType m_source1 = MM_PS(load)(source1p);         \
-    MType m_source2 = MM_PS(loadSource2)(source2p);  \
+    MType m_source1 = MM_PS(load)(source1p.data());         \
+    MType m_source2 = MM_PS(loadSource2)(source2p.data());  \
     MType m_dest = MM_PS(sub)(m_source1, m_source2); \
-    MM_PS(storeDest)(dest_p, m_dest);                \
-    source1p += kPackedFloatsPerRegister;            \
-    source2p += kPackedFloatsPerRegister;            \
-    dest_p += kPackedFloatsPerRegister;              \
+    MM_PS(storeDest)(dest_p.data(), m_dest);                \
+    source1p=.subspan();            \
+    source2p=.subspan();            \
+    dest_p=.subspan();              \
   }
 
-  if (IsAligned(source2p)) {
-    if (IsAligned(dest_p)) {
+  if (IsAligned(source2p.data())) {
+    if (IsAligned(dest_p.data())) {
       SUB_ALL(load, store);
     } else {
       SUB_ALL(load, storeu);
     }
   } else {
-    if (IsAligned(dest_p)) {
+    if (IsAligned(dest_p.data())) {
       SUB_ALL(loadu, store);
     } else {
       SUB_ALL(loadu, storeu);
@@ -178,14 +180,14 @@ void Vsub(const float* source1p,
 
 // dest[k] = clip(source[k], low_threshold, high_threshold)
 //         = max(low_threshold, min(high_threshold, source[k]))
-void Vclip(const float* source_p,
+void Vclip(base::span<const float>source_p,
            const float* low_threshold_p,
            const float* high_threshold_p,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process) {
-  const float* const source_end_p = source_p + frames_to_process;
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   MType m_low_threshold = MM_PS(set1)(*low_threshold_p);
@@ -193,15 +195,15 @@ void Vclip(const float* source_p,
 
 #define CLIP_ALL(storeDest)                                                  \
   while (source_p < source_end_p) {                                          \
-    MType m_source = MM_PS(load)(source_p);                                  \
+    MType m_source = MM_PS(load)(source_p.data());                                  \
     MType m_dest =                                                           \
         MM_PS(max)(m_low_threshold, MM_PS(min)(m_high_threshold, m_source)); \
-    MM_PS(storeDest)(dest_p, m_dest);                                        \
-    source_p += kPackedFloatsPerRegister;                                    \
-    dest_p += kPackedFloatsPerRegister;                                      \
+    MM_PS(storeDest)(dest_p.data(), m_dest);                                        \
+    source_p=.subspan();                                    \
+    dest_p=.subspan();                                      \
   }
 
-  if (IsAligned(dest_p)) {
+  if (IsAligned(dest_p.data())) {
     CLIP_ALL(store);
   } else {
     CLIP_ALL(storeu);
@@ -212,25 +214,25 @@ void Vclip(const float* source_p,
 
 // *max_p = max(*max_p, source_max) where
 // source_max = max(abs(source[k])) for all k
-void Vmaxmgv(const float* source_p, float* max_p, uint32_t frames_to_process) {
+void Vmaxmgv(base::span<const float>source_p, float* max_p, uint32_t frames_to_process) {
   constexpr uint32_t kMask = 0x7FFFFFFFu;
   float kMask_float;
   std::memcpy(&kMask_float, &kMask, 4);
-  const float* const source_end_p = source_p + frames_to_process;
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   MType m_mask = MM_PS(set1)(kMask_float);
   MType m_max = MM_PS(setzero)();
 
   while (source_p < source_end_p) {
-    MType m_source = MM_PS(load)(source_p);
+    MType m_source = MM_PS(load)(source_p.data());
     // Calculate the absolute value by ANDing the source with the mask,
     // which will set the sign bit to 0.
     m_source = MM_PS(and)(m_source, m_mask);
     m_max = MM_PS(max)(m_source, m_max);
-    source_p += kPackedFloatsPerRegister;
+    source_p=source_p.subspan(kPackedFloatsPerRegister);
   }
 
   // Combine the packed floats.
@@ -240,34 +242,34 @@ void Vmaxmgv(const float* source_p, float* max_p, uint32_t frames_to_process) {
 }
 
 // dest[k] = source1[k] * source2[k]
-void Vmul(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vmul(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process) {
-  const float* const source1_end_p = source1p + frames_to_process;
+  const float* const source1_end_p = source1p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source1p));
+  DCHECK(IsAligned(source1p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
 #define MULTIPLY_ALL(loadSource2, storeDest)         \
   while (source1p < source1_end_p) {                 \
-    MType m_source1 = MM_PS(load)(source1p);         \
-    MType m_source2 = MM_PS(loadSource2)(source2p);  \
+    MType m_source1 = MM_PS(load)(source1p.data());         \
+    MType m_source2 = MM_PS(loadSource2)(source2p.data());  \
     MType m_dest = MM_PS(mul)(m_source1, m_source2); \
-    MM_PS(storeDest)(dest_p, m_dest);                \
-    source1p += kPackedFloatsPerRegister;            \
-    source2p += kPackedFloatsPerRegister;            \
-    dest_p += kPackedFloatsPerRegister;              \
+    MM_PS(storeDest)(dest_p.data(), m_dest);                \
+    source1p=.subspan();            \
+    source2p=.subspan();            \
+    dest_p=.subspan();              \
   }
 
-  if (IsAligned(source2p)) {
-    if (IsAligned(dest_p)) {
+  if (IsAligned(source2p.data())) {
+    if (IsAligned(dest_p.data())) {
       MULTIPLY_ALL(load, store);
     } else {
       MULTIPLY_ALL(load, storeu);
     }
   } else {
-    if (IsAligned(dest_p)) {
+    if (IsAligned(dest_p.data())) {
       MULTIPLY_ALL(loadu, store);
     } else {
       MULTIPLY_ALL(loadu, storeu);
@@ -278,28 +280,28 @@ void Vmul(const float* source1p,
 }
 
 // dest[k] += scale * source[k]
-void Vsma(const float* source_p,
+void Vsma(base::span<const float>source_p,
           const float* scale,
-          float* dest_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process) {
-  const float* const source_end_p = source_p + frames_to_process;
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   const MType m_scale = MM_PS(set1)(*scale);
 
 #define SCALAR_MULTIPLY_AND_ADD_ALL(loadDest, storeDest)        \
   while (source_p < source_end_p) {                             \
-    MType m_source = MM_PS(load)(source_p);                     \
-    MType m_dest = MM_PS(loadDest)(dest_p);                     \
+    MType m_source = MM_PS(load)(source_p.data());                     \
+    MType m_dest = MM_PS(loadDest)(dest_p.data());                     \
     m_dest = MM_PS(add)(m_dest, MM_PS(mul)(m_scale, m_source)); \
-    MM_PS(storeDest)(dest_p, m_dest);                           \
-    source_p += kPackedFloatsPerRegister;                       \
-    dest_p += kPackedFloatsPerRegister;                         \
+    MM_PS(storeDest)(dest_p.data(), m_dest);                           \
+    source_p=.subspan();                       \
+    dest_p=.subspan();                         \
   }
 
-  if (IsAligned(dest_p)) {
+  if (IsAligned(dest_p.data())) {
     SCALAR_MULTIPLY_AND_ADD_ALL(load, store);
   } else {
     SCALAR_MULTIPLY_AND_ADD_ALL(loadu, storeu);
@@ -309,27 +311,27 @@ void Vsma(const float* source_p,
 }
 
 // dest[k] = scale * source[k]
-void Vsmul(const float* source_p,
+void Vsmul(base::span<const float>source_p,
            const float* scale,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process) {
-  const float* const source_end_p = source_p + frames_to_process;
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   const MType m_scale = MM_PS(set1)(*scale);
 
 #define SCALAR_MULTIPLY_ALL(storeDest)            \
   while (source_p < source_end_p) {               \
-    MType m_source = MM_PS(load)(source_p);       \
+    MType m_source = MM_PS(load)(source_p.data());       \
     MType m_dest = MM_PS(mul)(m_scale, m_source); \
-    MM_PS(storeDest)(dest_p, m_dest);             \
-    source_p += kPackedFloatsPerRegister;         \
-    dest_p += kPackedFloatsPerRegister;           \
+    MM_PS(storeDest)(dest_p.data(), m_dest);             \
+    source_p=.subspan();         \
+    dest_p=.subspan();           \
   }
 
-  if (IsAligned(dest_p)) {
+  if (IsAligned(dest_p.data())) {
     SCALAR_MULTIPLY_ALL(store);
   } else {
     SCALAR_MULTIPLY_ALL(storeu);
@@ -339,27 +341,27 @@ void Vsmul(const float* source_p,
 }
 
 // dest[k] = addend + source[k]
-void Vsadd(const float* source_p,
+void Vsadd(base::span<const float>source_p,
            const float* addend,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process) {
-  const float* const source_end_p = source_p + frames_to_process;
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   const MType m_addend = MM_PS(set1)(*addend);
 
 #define SCALAR_ADD_ALL(storeDest)                  \
   while (source_p < source_end_p) {                \
-    MType m_source = MM_PS(load)(source_p);        \
+    MType m_source = MM_PS(load)(source_p.data());        \
     MType m_dest = MM_PS(add)(m_addend, m_source); \
-    MM_PS(storeDest)(dest_p, m_dest);              \
-    source_p += kPackedFloatsPerRegister;          \
-    dest_p += kPackedFloatsPerRegister;            \
+    MM_PS(storeDest)(dest_p.data(), m_dest);              \
+    source_p=.subspan();          \
+    dest_p=.subspan();            \
   }
 
-  if (IsAligned(dest_p)) {
+  if (IsAligned(dest_p.data())) {
     SCALAR_ADD_ALL(store);
   } else {
     SCALAR_ADD_ALL(storeu);
@@ -369,18 +371,18 @@ void Vsadd(const float* source_p,
 }
 
 // sum += sum(source[k]^2) for all k
-void Vsvesq(const float* source_p, float* sum_p, uint32_t frames_to_process) {
-  const float* const source_end_p = source_p + frames_to_process;
+void Vsvesq(base::span<const float>source_p, float* sum_p, uint32_t frames_to_process) {
+  const float* const source_end_p = source_p .subspan( frames_to_process).data();
 
-  DCHECK(IsAligned(source_p));
+  DCHECK(IsAligned(source_p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
   MType m_sum = MM_PS(setzero)();
 
   while (source_p < source_end_p) {
-    MType m_source = MM_PS(load)(source_p);
+    MType m_source = MM_PS(load)(source_p.data());
     m_sum = MM_PS(add)(m_sum, MM_PS(mul)(m_source, m_source));
-    source_p += kPackedFloatsPerRegister;
+    source_p=source_p.subspan(kPackedFloatsPerRegister);
   }
 
   // Combine the packed floats.
@@ -391,14 +393,14 @@ void Vsvesq(const float* source_p, float* sum_p, uint32_t frames_to_process) {
 
 // real_dest[k] = real1[k] * real2[k] - imag1[k] * imag2[k]
 // imag_dest[k] = real1[k] * imag2[k] + imag1[k] * real2[k]
-void Zvmul(const float* real1p,
-           const float* imag1p,
-           const float* real2p,
-           const float* imag2p,
-           float* real_dest_p,
-           float* imag_dest_p,
+void Zvmul(base::span<const float>real1p,
+           base::span<const float>imag1p,
+           base::span<const float>real2p,
+           base::span<const float>imag2p,
+           base::span<float>real_dest_p,
+           base::span<float>imag_dest_p,
            uint32_t frames_to_process) {
-  DCHECK(IsAligned(real1p));
+  DCHECK(IsAligned(real1p.data()));
   DCHECK_EQ(0u, frames_to_process % kPackedFloatsPerRegister);
 
 #define MULTIPLY_ALL(loadOtherThanReal1, storeDest)                           \
@@ -415,8 +417,8 @@ void Zvmul(const float* real1p,
     MM_PS(storeDest)(imag_dest_p + i, imag);                                  \
   }
 
-  if (IsAligned(imag1p) && IsAligned(real2p) && IsAligned(imag2p) &&
-      IsAligned(real_dest_p) && IsAligned(imag_dest_p)) {
+  if (IsAligned(imag1p.data()) && IsAligned(real2p.data()) && IsAligned(imag2p.data()) &&
+      IsAligned(real_dest_p.data()) && IsAligned(imag_dest_p.data())) {
     MULTIPLY_ALL(load, store);
   } else {
     MULTIPLY_ALL(loadu, storeu);
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_sse.h b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_sse.h
index fe57f3ad4fe50..323bde1330331 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_sse.h
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_sse.h
@@ -7,6 +7,7 @@
 
 #include <cstddef>
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 
 namespace blink {
@@ -23,9 +24,9 @@ bool IsAligned(const float*);
 // dest[k] = sum(source[k+m]*filter[m*filter_stride]) for all m
 // provided that |prepared_filter_p| is |prepared_filter->Data()| and that
 // |prepared_filter| is prepared with |PrepareFilterForConv|.
-void Conv(const float* source_p,
-          const float* prepared_filter_p,
-          float* dest_p,
+void Conv(base::span<const float>source_p,
+          base::span<const float>prepared_filter_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process,
           size_t filter_size);
 
@@ -35,51 +36,51 @@ void PrepareFilterForConv(const float* filter_p,
                           AudioFloatArray* prepared_filter);
 
 // dest[k] = source1[k] + source2[k]
-void Vadd(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vadd(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = source1[k] - source2[k]
-void Vsub(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vsub(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = clip(source[k], low_threshold, high_threshold)
 //         = max(low_threshold, min(high_threshold, source[k]))
-void Vclip(const float* source_p,
+void Vclip(base::span<const float>source_p,
            const float* low_threshold_p,
            const float* high_threshold_p,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 // *max_p = max(*max_p, source_max) where
 // source_max = max(abs(source[k])) for all k
-void Vmaxmgv(const float* source_p, float* max_p, uint32_t frames_to_process);
+void Vmaxmgv(base::span<const float>source_p, float* max_p, uint32_t frames_to_process);
 
 // dest[k] = source1[k] * source2[k]
-void Vmul(const float* source1p,
-          const float* source2p,
-          float* dest_p,
+void Vmul(base::span<const float>source1p,
+          base::span<const float>source2p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] += scale * source[k]
-void Vsma(const float* source_p,
+void Vsma(base::span<const float>source_p,
           const float* scale,
-          float* dest_p,
+          base::span<float>dest_p,
           uint32_t frames_to_process);
 
 // dest[k] = scale * source[k]
-void Vsmul(const float* source_p,
+void Vsmul(base::span<const float>source_p,
            const float* scale,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 // dest[k] = addend + source[k]
-void Vsadd(const float* source_p,
+void Vsadd(base::span<const float>source_p,
            const float* addend,
-           float* dest_p,
+           base::span<float>dest_p,
            uint32_t frames_to_process);
 
 void Vsadd(const float* source_p,
@@ -88,16 +89,16 @@ void Vsadd(const float* source_p,
            uint32_t frames_to_process);
 
 // sum += sum(source[k]^2) for all k
-void Vsvesq(const float* source_p, float* sum_p, uint32_t frames_to_process);
+void Vsvesq(base::span<const float>source_p, float* sum_p, uint32_t frames_to_process);
 
 // real_dest[k] = real1[k] * real2[k] - imag1[k] * imag2[k]
 // imag_dest[k] = real1[k] * imag2[k] + imag1[k] * real2[k]
-void Zvmul(const float* real1p,
-           const float* imag1p,
-           const float* real2p,
-           const float* imag2p,
-           float* real_dest_p,
-           float* imag_dest_p,
+void Zvmul(base::span<const float>real1p,
+           base::span<const float>imag1p,
+           base::span<const float>real2p,
+           base::span<const float>imag2p,
+           base::span<float>real_dest_p,
+           base::span<float>imag_dest_p,
            uint32_t frames_to_process);
 
 }  // namespace sse
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_x86.h b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_x86.h
index 94567b6db9c61..ce217ef602efd 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_x86.h
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/vector_math_x86.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -43,12 +45,12 @@ static uint32_t GetAVXAlignmentOffsetInNumberOfFloats(const float* source_p) {
 }
 
 ALWAYS_INLINE static FrameCounts SplitFramesToProcess(
-    const float* source_p,
+    base::span<const float>source_p,
     uint32_t frames_to_process) {
   FrameCounts counts = {0u, 0u, 0u, 0u, 0u};
 
   const uint32_t avx_alignment_offset =
-      GetAVXAlignmentOffsetInNumberOfFloats(source_p);
+      GetAVXAlignmentOffsetInNumberOfFloats(source_p.data());
 
   // If the first frame is not AVX aligned, the first several frames (at most
   // seven) must be processed separately for proper alignment.
@@ -112,18 +114,18 @@ ALWAYS_INLINE static void PrepareFilterForConv(
   }
 }
 
-ALWAYS_INLINE static void Conv(const float* source_p,
+ALWAYS_INLINE static void Conv(base::span<const float>source_p,
                                int source_stride,
                                const float* filter_p,
                                int filter_stride,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process,
                                size_t filter_size,
                                const AudioFloatArray* prepared_filter) {
-  const float* prepared_filter_p =
-      prepared_filter ? prepared_filter->Data() : nullptr;
-  if (source_stride == 1 && dest_stride == 1 && prepared_filter_p) {
+  base::span<const float>prepared_filter_p =
+      prepared_filter ? prepared_filter->Data() : {};
+  if (source_stride == 1 && dest_stride == 1 && !prepared_filter_p.empty()) {
     if (CPUSupportsAVX() && (filter_size & ~avx::kFramesToProcessMask) == 0u) {
       // |frames_to_process| is always a multiply of render quantum and
       // therefore the frames can always be processed using AVX.
@@ -145,11 +147,11 @@ ALWAYS_INLINE static void Conv(const float* source_p,
                dest_stride, frames_to_process, filter_size, nullptr);
 }
 
-ALWAYS_INLINE static void Vadd(const float* source1p,
+ALWAYS_INLINE static void Vadd(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   if (source_stride1 == 1 && source_stride2 == 1 && dest_stride == 1) {
@@ -160,19 +162,19 @@ ALWAYS_INLINE static void Vadd(const float* source1p,
                  frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vadd(source1p + i, source2p + i, dest_p + i,
+      sse::Vadd(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i),
                 frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vadd(source1p + i, source2p + i, dest_p + i, frame_counts.avx);
+      avx::Vadd(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vadd(source1p + i, source2p + i, dest_p + i, frame_counts.sse);
+      sse::Vadd(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vadd(source1p + i, 1, source2p + i, 1, dest_p + i, 1,
+    scalar::Vadd(source1p .subspan( i), 1, source2p .subspan( i), 1, dest_p .subspan( i), 1,
                  frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
@@ -181,11 +183,11 @@ ALWAYS_INLINE static void Vadd(const float* source1p,
   }
 }
 
-ALWAYS_INLINE static void Vsub(const float* source1p,
+ALWAYS_INLINE static void Vsub(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   if (source_stride1 == 1 && source_stride2 == 1 && dest_stride == 1) {
@@ -196,19 +198,19 @@ ALWAYS_INLINE static void Vsub(const float* source1p,
                  frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vsub(source1p + i, source2p + i, dest_p + i,
+      sse::Vsub(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i),
                 frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vsub(source1p + i, source2p + i, dest_p + i, frame_counts.avx);
+      avx::Vsub(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vsub(source1p + i, source2p + i, dest_p + i, frame_counts.sse);
+      sse::Vsub(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vsub(source1p + i, 1, source2p + i, 1, dest_p + i, 1,
+    scalar::Vsub(source1p .subspan( i), 1, source2p .subspan( i), 1, dest_p .subspan( i), 1,
                  frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
@@ -217,11 +219,11 @@ ALWAYS_INLINE static void Vsub(const float* source1p,
   }
 }
 
-ALWAYS_INLINE static void Vclip(const float* source_p,
+ALWAYS_INLINE static void Vclip(base::span<const float>source_p,
                                 int source_stride,
                                 const float* low_threshold_p,
                                 const float* high_threshold_p,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   if (source_stride == 1 && dest_stride == 1) {
@@ -232,22 +234,22 @@ ALWAYS_INLINE static void Vclip(const float* source_p,
                   frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vclip(source_p + i, low_threshold_p, high_threshold_p, dest_p + i,
+      sse::Vclip(source_p .subspan( i), low_threshold_p, high_threshold_p, dest_p .subspan( i),
                  frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vclip(source_p + i, low_threshold_p, high_threshold_p, dest_p + i,
+      avx::Vclip(source_p .subspan( i), low_threshold_p, high_threshold_p, dest_p .subspan( i),
                  frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vclip(source_p + i, low_threshold_p, high_threshold_p, dest_p + i,
+      sse::Vclip(source_p .subspan( i), low_threshold_p, high_threshold_p, dest_p .subspan( i),
                  frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vclip(source_p + i, 1, low_threshold_p, high_threshold_p,
-                  dest_p + i, 1, frame_counts.scalar);
+    scalar::Vclip(source_p .subspan( i), 1, low_threshold_p, high_threshold_p,
+                  dest_p .subspan( i), 1, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vclip(source_p, source_stride, low_threshold_p, high_threshold_p,
@@ -255,7 +257,7 @@ ALWAYS_INLINE static void Vclip(const float* source_p,
   }
 }
 
-ALWAYS_INLINE static void Vmaxmgv(const float* source_p,
+ALWAYS_INLINE static void Vmaxmgv(base::span<const float>source_p,
                                   int source_stride,
                                   float* max_p,
                                   uint32_t frames_to_process) {
@@ -266,29 +268,29 @@ ALWAYS_INLINE static void Vmaxmgv(const float* source_p,
     scalar::Vmaxmgv(source_p, 1, max_p, frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vmaxmgv(source_p + i, max_p, frame_counts.sse_for_alignment);
+      sse::Vmaxmgv(source_p .subspan( i), max_p, frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vmaxmgv(source_p + i, max_p, frame_counts.avx);
+      avx::Vmaxmgv(source_p .subspan( i), max_p, frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vmaxmgv(source_p + i, max_p, frame_counts.sse);
+      sse::Vmaxmgv(source_p .subspan( i), max_p, frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vmaxmgv(source_p + i, 1, max_p, frame_counts.scalar);
+    scalar::Vmaxmgv(source_p .subspan( i), 1, max_p, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vmaxmgv(source_p, source_stride, max_p, frames_to_process);
   }
 }
 
-ALWAYS_INLINE static void Vmul(const float* source1p,
+ALWAYS_INLINE static void Vmul(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   if (source_stride1 == 1 && source_stride2 == 1 && dest_stride == 1) {
@@ -299,19 +301,19 @@ ALWAYS_INLINE static void Vmul(const float* source1p,
                  frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vmul(source1p + i, source2p + i, dest_p + i,
+      sse::Vmul(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i),
                 frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vmul(source1p + i, source2p + i, dest_p + i, frame_counts.avx);
+      avx::Vmul(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vmul(source1p + i, source2p + i, dest_p + i, frame_counts.sse);
+      sse::Vmul(source1p .subspan( i), source2p .subspan( i), dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vmul(source1p + i, 1, source2p + i, 1, dest_p + i, 1,
+    scalar::Vmul(source1p .subspan( i), 1, source2p .subspan( i), 1, dest_p .subspan( i), 1,
                  frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
@@ -320,10 +322,10 @@ ALWAYS_INLINE static void Vmul(const float* source1p,
   }
 }
 
-ALWAYS_INLINE static void Vsma(const float* source_p,
+ALWAYS_INLINE static void Vsma(base::span<const float>source_p,
                                int source_stride,
                                const float* scale,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   if (source_stride == 1 && dest_stride == 1) {
@@ -334,19 +336,19 @@ ALWAYS_INLINE static void Vsma(const float* source_p,
                  frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vsma(source_p + i, scale, dest_p + i,
+      sse::Vsma(source_p .subspan( i), scale, dest_p .subspan( i),
                 frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vsma(source_p + i, scale, dest_p + i, frame_counts.avx);
+      avx::Vsma(source_p .subspan( i), scale, dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vsma(source_p + i, scale, dest_p + i, frame_counts.sse);
+      sse::Vsma(source_p .subspan( i), scale, dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vsma(source_p + i, 1, scale, dest_p + i, 1, frame_counts.scalar);
+    scalar::Vsma(source_p .subspan( i), 1, scale, dest_p .subspan( i), 1, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vsma(source_p, source_stride, scale, dest_p, dest_stride,
@@ -354,10 +356,10 @@ ALWAYS_INLINE static void Vsma(const float* source_p,
   }
 }
 
-ALWAYS_INLINE static void Vsmul(const float* source_p,
+ALWAYS_INLINE static void Vsmul(base::span<const float>source_p,
                                 int source_stride,
                                 const float* scale,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   if (source_stride == 1 && dest_stride == 1) {
@@ -368,19 +370,19 @@ ALWAYS_INLINE static void Vsmul(const float* source_p,
                   frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vsmul(source_p + i, scale, dest_p + i,
+      sse::Vsmul(source_p .subspan( i), scale, dest_p .subspan( i),
                  frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vsmul(source_p + i, scale, dest_p + i, frame_counts.avx);
+      avx::Vsmul(source_p .subspan( i), scale, dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vsmul(source_p + i, scale, dest_p + i, frame_counts.sse);
+      sse::Vsmul(source_p .subspan( i), scale, dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vsmul(source_p + i, 1, scale, dest_p + i, 1, frame_counts.scalar);
+    scalar::Vsmul(source_p .subspan( i), 1, scale, dest_p .subspan( i), 1, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vsmul(source_p, source_stride, scale, dest_p, dest_stride,
@@ -388,10 +390,10 @@ ALWAYS_INLINE static void Vsmul(const float* source_p,
   }
 }
 
-ALWAYS_INLINE static void Vsadd(const float* source_p,
+ALWAYS_INLINE static void Vsadd(base::span<const float>source_p,
                                 int source_stride,
                                 const float* addend,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   if (source_stride == 1 && dest_stride == 1) {
@@ -402,19 +404,19 @@ ALWAYS_INLINE static void Vsadd(const float* source_p,
                   frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vsadd(source_p + i, addend, dest_p + i,
+      sse::Vsadd(source_p .subspan( i), addend, dest_p .subspan( i),
                  frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vsadd(source_p + i, addend, dest_p + i, frame_counts.avx);
+      avx::Vsadd(source_p .subspan( i), addend, dest_p .subspan( i), frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vsadd(source_p + i, addend, dest_p + i, frame_counts.sse);
+      sse::Vsadd(source_p .subspan( i), addend, dest_p .subspan( i), frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vsadd(source_p + i, 1, addend, dest_p + i, 1, frame_counts.scalar);
+    scalar::Vsadd(source_p .subspan( i), 1, addend, dest_p .subspan( i), 1, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vsadd(source_p, source_stride, addend, dest_p, dest_stride,
@@ -422,7 +424,7 @@ ALWAYS_INLINE static void Vsadd(const float* source_p,
   }
 }
 
-ALWAYS_INLINE static void Vsvesq(const float* source_p,
+ALWAYS_INLINE static void Vsvesq(base::span<const float>source_p,
                                  int source_stride,
                                  float* sum_p,
                                  uint32_t frames_to_process) {
@@ -433,30 +435,30 @@ ALWAYS_INLINE static void Vsvesq(const float* source_p,
     scalar::Vsvesq(source_p, 1, sum_p, frame_counts.scalar_for_alignment);
     size_t i = frame_counts.scalar_for_alignment;
     if (frame_counts.sse_for_alignment > 0u) {
-      sse::Vsvesq(source_p + i, sum_p, frame_counts.sse_for_alignment);
+      sse::Vsvesq(source_p .subspan( i), sum_p, frame_counts.sse_for_alignment);
       i += frame_counts.sse_for_alignment;
     }
     if (frame_counts.avx > 0u) {
-      avx::Vsvesq(source_p + i, sum_p, frame_counts.avx);
+      avx::Vsvesq(source_p .subspan( i), sum_p, frame_counts.avx);
       i += frame_counts.avx;
     }
     if (frame_counts.sse > 0u) {
-      sse::Vsvesq(source_p + i, sum_p, frame_counts.sse);
+      sse::Vsvesq(source_p .subspan( i), sum_p, frame_counts.sse);
       i += frame_counts.sse;
     }
-    scalar::Vsvesq(source_p + i, 1, sum_p, frame_counts.scalar);
+    scalar::Vsvesq(source_p .subspan( i), 1, sum_p, frame_counts.scalar);
     DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
   } else {
     scalar::Vsvesq(source_p, source_stride, sum_p, frames_to_process);
   }
 }
 
-ALWAYS_INLINE static void Zvmul(const float* real1p,
-                                const float* imag1p,
-                                const float* real2p,
-                                const float* imag2p,
-                                float* real_dest_p,
-                                float* imag_dest_p,
+ALWAYS_INLINE static void Zvmul(base::span<const float>real1p,
+                                base::span<const float>imag1p,
+                                base::span<const float>real2p,
+                                base::span<const float>imag2p,
+                                base::span<float>real_dest_p,
+                                base::span<float>imag_dest_p,
                                 uint32_t frames_to_process) {
   FrameCounts frame_counts = SplitFramesToProcess(real1p, frames_to_process);
 
@@ -464,22 +466,22 @@ ALWAYS_INLINE static void Zvmul(const float* real1p,
                 frame_counts.scalar_for_alignment);
   size_t i = frame_counts.scalar_for_alignment;
   if (frame_counts.sse_for_alignment > 0u) {
-    sse::Zvmul(real1p + i, imag1p + i, real2p + i, imag2p + i, real_dest_p + i,
-               imag_dest_p + i, frame_counts.sse_for_alignment);
+    sse::Zvmul(real1p .subspan( i), imag1p .subspan( i), real2p .subspan( i), imag2p .subspan( i), real_dest_p .subspan( i),
+               imag_dest_p .subspan( i), frame_counts.sse_for_alignment);
     i += frame_counts.sse_for_alignment;
   }
   if (frame_counts.avx > 0u) {
-    avx::Zvmul(real1p + i, imag1p + i, real2p + i, imag2p + i, real_dest_p + i,
-               imag_dest_p + i, frame_counts.avx);
+    avx::Zvmul(real1p .subspan( i), imag1p .subspan( i), real2p .subspan( i), imag2p .subspan( i), real_dest_p .subspan( i),
+               imag_dest_p .subspan( i), frame_counts.avx);
     i += frame_counts.avx;
   }
   if (frame_counts.sse > 0u) {
-    sse::Zvmul(real1p + i, imag1p + i, real2p + i, imag2p + i, real_dest_p + i,
-               imag_dest_p + i, frame_counts.sse);
+    sse::Zvmul(real1p .subspan( i), imag1p .subspan( i), real2p .subspan( i), imag2p .subspan( i), real_dest_p .subspan( i),
+               imag_dest_p .subspan( i), frame_counts.sse);
     i += frame_counts.sse;
   }
-  scalar::Zvmul(real1p + i, imag1p + i, real2p + i, imag2p + i, real_dest_p + i,
-                imag_dest_p + i, frame_counts.scalar);
+  scalar::Zvmul(real1p .subspan( i), imag1p .subspan( i), real2p .subspan( i), imag2p .subspan( i), real_dest_p .subspan( i),
+                imag_dest_p .subspan( i), frame_counts.scalar);
   DCHECK_EQ(frames_to_process, i + frame_counts.scalar);
 }
 
diff --git a/third_party/blink/renderer/platform/audio/delay.cc b/third_party/blink/renderer/platform/audio/delay.cc
index 2e5662e923c45..6ed12d3decf92 100644
--- a/third_party/blink/renderer/platform/audio/delay.cc
+++ b/third_party/blink/renderer/platform/audio/delay.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -42,10 +44,10 @@ namespace blink {
 
 namespace {
 
-void CopyToCircularBuffer(float* buffer,
+void CopyToCircularBuffer(base::span<float>buffer,
                           int write_index,
                           int buffer_length,
-                          const float* source,
+                          base::span<const float>source,
                           uint32_t frames_to_process) {
   // The algorithm below depends on this being true because we don't expect to
   // have to fill the entire buffer more than once.
@@ -59,10 +61,10 @@ void CopyToCircularBuffer(float* buffer,
 
   // Copy the sames over, carefully handling the case where we need to wrap
   // around to the beginning of the buffer.
-  memcpy(write_pointer, source,
+  memcpy(write_pointer, source.data(),
          sizeof(*write_pointer) *
              std::min(static_cast<int>(frames_to_process), remainder));
-  memcpy(buffer, source + remainder,
+  memcpy(buffer.data(), source .subspan( remainder).data(),
          sizeof(*write_pointer) *
              std::max(0, static_cast<int>(frames_to_process) - remainder));
 }
@@ -126,18 +128,18 @@ void Delay::HandleNaN(float* delay_times,
 
 int Delay::ProcessARateScalar(unsigned start,
                               int w_index,
-                              float* destination,
+                              base::span<float>destination,
                               uint32_t frames_to_process) const {
   const int buffer_length = buffer_.size();
-  const float* buffer = buffer_.Data();
+  base::span<const float>buffer = buffer_.Data();
 
   DCHECK(buffer_length);
-  DCHECK(destination);
+  DCHECK(!destination.empty());
   DCHECK_GE(write_index_, 0);
   DCHECK_LT(write_index_, buffer_length);
 
   float sample_rate = sample_rate_;
-  const float* delay_times = delay_times_.Data();
+  base::span<const float>delay_times = delay_times_.Data();
 
   for (unsigned i = start; i < frames_to_process; ++i) {
     double delay_time = std::fmax(delay_times[i], 0);
@@ -175,19 +177,19 @@ int Delay::ProcessARateScalar(unsigned start,
   return w_index;
 }
 
-void Delay::ProcessARate(const float* source,
-                         float* destination,
+void Delay::ProcessARate(base::span<const float>source,
+                         base::span<float>destination,
                          uint32_t frames_to_process) {
   int buffer_length = buffer_.size();
-  float* buffer = buffer_.Data();
+  base::span<float>buffer = buffer_.Data();
 
   DCHECK(buffer_length);
-  DCHECK(source);
-  DCHECK(destination);
+  DCHECK(!source.empty());
+  DCHECK(!destination.empty());
   DCHECK_GE(write_index_, 0);
   DCHECK_LT(write_index_, buffer_length);
 
-  float* delay_times = delay_times_.Data();
+  base::span<float>delay_times = delay_times_.Data();
 
   // Any NaN's get converted to max time
   // TODO(crbug.com/1013345): Don't need this if that bug is fixed
@@ -207,15 +209,15 @@ void Delay::ProcessARate(const float* source,
   }
 }
 
-void Delay::ProcessKRate(const float* source,
-                         float* destination,
+void Delay::ProcessKRate(base::span<const float>source,
+                         base::span<float>destination,
                          uint32_t frames_to_process) {
   int buffer_length = buffer_.size();
-  float* buffer = buffer_.Data();
+  base::span<float>buffer = buffer_.Data();
 
   DCHECK(buffer_length);
-  DCHECK(source);
-  DCHECK(destination);
+  DCHECK(!source.empty());
+  DCHECK(!destination.empty());
   DCHECK_GE(write_index_, 0);
   DCHECK_LT(write_index_, buffer_length);
 
@@ -247,7 +249,7 @@ void Delay::ProcessKRate(const float* source,
   // sample1 and sample2 hold the current and next samples in the buffer.
   // These are used for interoplating the delay value.  To reduce memory
   // usage and an extra memcpy, sample1 can be the same as destination.
-  float* sample1 = destination;
+  base::span<float>sample1 = destination;
 
   // Copy data from the source into the buffer, starting at the write index.
   // The buffer is circular, so carefully handle the wrapping of the write
@@ -265,11 +267,11 @@ void Delay::ProcessKRate(const float* source,
   float* read_pointer = &buffer[read_index1];
 
   uint32_t remainder = static_cast<uint32_t>(buffer_end - read_pointer);
-  memcpy(sample1, read_pointer,
-         sizeof(*sample1) * std::min(frames_to_process, remainder));
+  memcpy(sample1.data(), read_pointer,
+         sizeof( sample1[0]) * std::min(frames_to_process, remainder));
   if (frames_to_process > remainder) {
-    memcpy(sample1 + remainder, buffer,
-           sizeof(*sample1) * (frames_to_process - remainder));
+    memcpy(sample1 .subspan( remainder).data(), buffer.data(),
+           sizeof( sample1[0]) * (frames_to_process - remainder));
   }
 
   // If interpolation_factor = 0, we don't need to do any interpolation and
@@ -278,15 +280,15 @@ void Delay::ProcessKRate(const float* source,
     DCHECK_LE(frames_to_process, temp_buffer_.size());
 
     int read_index2 = (read_index1 + 1) % buffer_length;
-    float* sample2 = temp_buffer_.Data();
+    base::span<float>sample2 = temp_buffer_.Data();
 
     read_pointer = &buffer[read_index2];
     remainder = static_cast<uint32_t>(buffer_end - read_pointer);
-    memcpy(sample2, read_pointer,
-           sizeof(*sample1) * std::min(frames_to_process, remainder));
+    memcpy(sample2.data(), read_pointer,
+           sizeof( sample1[0]) * std::min(frames_to_process, remainder));
     if (frames_to_process > remainder) {
-      memcpy(sample2 + remainder, buffer,
-             sizeof(*sample1) * (frames_to_process - remainder));
+      memcpy(sample2 .subspan( remainder).data(), buffer.data(),
+             sizeof( sample1[0]) * (frames_to_process - remainder));
     }
 
     // Interpolate samples, where f = interpolation_factor
diff --git a/third_party/blink/renderer/platform/audio/delay.h b/third_party/blink/renderer/platform/audio/delay.h
index 6501df73a79e8..0a0e9ee165716 100644
--- a/third_party/blink/renderer/platform/audio/delay.h
+++ b/third_party/blink/renderer/platform/audio/delay.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DELAY_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DELAY_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 
@@ -41,14 +42,14 @@ class PLATFORM_EXPORT Delay final {
 
   // Handles k-rate processing.  Call `SetDelayFrames()` or `SetDelayTime()` to
   // set the delay before calling this function.
-  void ProcessKRate(const float* source,
-                    float* destination,
+  void ProcessKRate(base::span<const float>source,
+                    base::span<float>destination,
                     uint32_t frames_to_process);
 
   // Handles a-rate processing.  Fill the return value of `DelayTimes()` with
   // the delay value for each frame before calling this function.
-  void ProcessARate(const float* source,
-                    float* destination,
+  void ProcessARate(base::span<const float>source,
+                    base::span<float>destination,
                     uint32_t frames_to_process);
 
   void Reset();
@@ -73,17 +74,17 @@ class PLATFORM_EXPORT Delay final {
   // new write_index.
   int ProcessARateScalar(unsigned start,
                          int w_index,
-                         float* destination,
+                         base::span<float>destination,
                          uint32_t frames_to_process) const;
 
   // Vector version of ProcessARateScalar.  Returns the number of samples
   // process by this function and the updated wirte_index_.
   std::tuple<unsigned, int> ProcessARateVector(
-      float* destination,
+      base::span<float>destination,
       uint32_t frames_to_process) const;
 
   // Handle NaN values in `delay_times`.  Replace NaN with `max_time`.
-  void HandleNaN(float* delay_times,
+  void HandleNaN(base::span<float>delay_times,
                  uint32_t frames_to_process,
                  float max_time);
 
diff --git a/third_party/blink/renderer/platform/audio/direct_convolver.cc b/third_party/blink/renderer/platform/audio/direct_convolver.cc
index 811ede286ba2a..b1daa04e3b427 100644
--- a/third_party/blink/renderer/platform/audio/direct_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/direct_convolver.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -60,35 +62,35 @@ DirectConvolver::DirectConvolver(
       buffer_(input_block_size * 2),
       convolution_kernel_(std::move(convolution_kernel)) {
   size_t kernel_size = ConvolutionKernelSize();
-  PrepareFilterForConv(convolution_kernel_->Data() + kernel_size - 1, -1,
+  PrepareFilterForConv(convolution_kernel_->Data() .subspan( kernel_size - 1).data(), -1,
                        kernel_size, &prepared_convolution_kernel_);
 }
 
 void DirectConvolver::Process(const float* source_p,
-                              float* dest_p,
+                              base::span<float>dest_p,
                               uint32_t frames_to_process) {
   DCHECK_EQ(frames_to_process, input_block_size_);
 
   size_t kernel_size = ConvolutionKernelSize();
   DCHECK_LE(kernel_size, input_block_size_);
 
-  float* kernel_p = convolution_kernel_->Data();
+  base::span<float>kernel_p = convolution_kernel_->Data();
 
-  DCHECK(kernel_p);
+  DCHECK(!kernel_p.empty());
   DCHECK(source_p);
-  DCHECK(dest_p);
-  DCHECK(buffer_.Data());
+  DCHECK(!dest_p.empty());
+  DCHECK(!buffer_.Data().empty());
 
-  float* input_p = buffer_.Data() + input_block_size_;
+  float* input_p = buffer_.Data() .subspan( input_block_size_).data();
 
   // Copy samples to 2nd half of input buffer.
   memcpy(input_p, source_p, sizeof(float) * frames_to_process);
 
-  Conv(input_p - kernel_size + 1, 1, kernel_p + kernel_size - 1, -1, dest_p, 1,
+  Conv(input_p - kernel_size + 1, 1, kernel_p .subspan( kernel_size - 1).data(), -1, dest_p, 1,
        frames_to_process, kernel_size, &prepared_convolution_kernel_);
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(buffer_.Data(), input_p, sizeof(float) * frames_to_process);
+  memcpy(buffer_.Data().data(), input_p, sizeof(float) * frames_to_process);
 }
 
 void DirectConvolver::Reset() {
diff --git a/third_party/blink/renderer/platform/audio/direct_convolver.h b/third_party/blink/renderer/platform/audio/direct_convolver.h
index b300595d2ce24..bd8506ed5359f 100644
--- a/third_party/blink/renderer/platform/audio/direct_convolver.h
+++ b/third_party/blink/renderer/platform/audio/direct_convolver.h
@@ -30,6 +30,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DIRECT_CONVOLVER_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
@@ -45,7 +46,7 @@ class DirectConvolver final {
   DirectConvolver& operator=(const DirectConvolver&) = delete;
 
   void Process(const float* source_p,
-               float* dest_p,
+               base::span<float>dest_p,
                uint32_t frames_to_process);
 
   void Reset();
diff --git a/third_party/blink/renderer/platform/audio/down_sampler.cc b/third_party/blink/renderer/platform/audio/down_sampler.cc
index 7db5739545d5d..67f8823753b00 100644
--- a/third_party/blink/renderer/platform/audio/down_sampler.cc
+++ b/third_party/blink/renderer/platform/audio/down_sampler.cc
@@ -28,6 +28,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -95,7 +97,7 @@ DownSampler::DownSampler(unsigned input_block_size)
       input_buffer_(input_block_size * 2) {}
 
 void DownSampler::Process(const float* source_p,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           uint32_t source_frames_to_process) {
   DCHECK_EQ(source_frames_to_process, input_block_size_);
 
@@ -111,13 +113,13 @@ void DownSampler::Process(const float* source_p,
   DCHECK_EQ(input_buffer_.size(), source_frames_to_process * 2);
   DCHECK_LE(half_size, source_frames_to_process);
 
-  float* input_p = input_buffer_.Data() + source_frames_to_process;
+  float* input_p = input_buffer_.Data() .subspan( source_frames_to_process).data();
   memcpy(input_p, source_p, sizeof(float) * source_frames_to_process);
 
   // Copy the odd sample-frames from sourceP, delayed by one sample-frame
   // (destination sample-rate) to match shifting forward in time in
   // m_reducedKernel.
-  float* odd_samples_p = temp_buffer_.Data();
+  base::span<float>odd_samples_p = temp_buffer_.Data();
   for (unsigned i = 0; i < dest_frames_to_process; ++i) {
     odd_samples_p[i] = *((input_p - 1) + i * 2);
   }
@@ -125,7 +127,7 @@ void DownSampler::Process(const float* source_p,
   // Actually process oddSamplesP with m_reducedKernel for efficiency.
   // The theoretical kernel is double this size with 0 values for even terms
   // (except center).
-  convolver_.Process(odd_samples_p, dest_p, dest_frames_to_process);
+  convolver_.Process(odd_samples_p.data(), dest_p, dest_frames_to_process);
 
   // Now, account for the 0.5 term right in the middle of the kernel.
   // This amounts to a delay-line of length halfSize (at the source
@@ -137,7 +139,7 @@ void DownSampler::Process(const float* source_p,
   }
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(input_buffer_.Data(), input_p,
+  memcpy(input_buffer_.Data().data(), input_p,
          sizeof(float) * source_frames_to_process);
 }
 
diff --git a/third_party/blink/renderer/platform/audio/down_sampler.h b/third_party/blink/renderer/platform/audio/down_sampler.h
index a6f51e41d6e4e..ae8e4583b742d 100644
--- a/third_party/blink/renderer/platform/audio/down_sampler.h
+++ b/third_party/blink/renderer/platform/audio/down_sampler.h
@@ -31,6 +31,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DOWN_SAMPLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_DOWN_SAMPLER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/simple_fft_convolver.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -50,7 +51,7 @@ class PLATFORM_EXPORT DownSampler final {
 
   // The destination buffer |destP| is of size sourceFramesToProcess / 2.
   void Process(const float* source_p,
-               float* dest_p,
+               base::span<float>dest_p,
                uint32_t source_frames_to_process);
 
   void Reset();
diff --git a/third_party/blink/renderer/platform/audio/dynamics_compressor.cc b/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
index 992c4d4736229..c724af854ce3d 100644
--- a/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
+++ b/third_party/blink/renderer/platform/audio/dynamics_compressor.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -293,7 +295,7 @@ void DynamicsCompressor::Process(const AudioBus* source_bus,
       // Predelay signal, computing compression amount from un-delayed
       // version.
       for (unsigned j = 0; j < number_of_channels; ++j) {
-        float* const delay_buffer = pre_delay_buffers_[j]->Data();
+        const base::span<float>delay_buffer = pre_delay_buffers_[j]->Data();
         const float undelayed_source = source_channels[j][frame_index];
         delay_buffer[pre_delay_write_index] = undelayed_source;
 
@@ -366,7 +368,7 @@ void DynamicsCompressor::Process(const AudioBus* source_bus,
 
       // Apply final gain.
       for (unsigned j = 0; j < number_of_channels; ++j) {
-        const float* const delay_buffer = pre_delay_buffers_[j]->Data();
+        const base::span<const float>delay_buffer = pre_delay_buffers_[j]->Data();
         destination_channels[j][frame_index] =
             delay_buffer[pre_delay_read_index] * total_gain;
       }
diff --git a/third_party/blink/renderer/platform/audio/equal_power_panner.cc b/third_party/blink/renderer/platform/audio/equal_power_panner.cc
index b7ff7d2fc5e54..b23c47eb353ac 100644
--- a/third_party/blink/renderer/platform/audio/equal_power_panner.cc
+++ b/third_party/blink/renderer/platform/audio/equal_power_panner.cc
@@ -60,15 +60,15 @@ void EqualPowerPanner::Pan(double azimuth,
   DCHECK_EQ(output_bus->NumberOfChannels(), 2u);
   DCHECK_LE(frames_to_process, output_bus->length());
 
-  const float* source_l = input_bus->Channel(0)->Data();
-  const float* source_r =
+  base::span<const float>source_l = input_bus->Channel(0)->Data();
+  base::span<const float>source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
-  float* destination_l =
+  base::span<float>destination_l =
       output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
-  float* destination_r =
+  base::span<float>destination_r =
       output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
 
-  if (!source_l || !source_r || !destination_l || !destination_r) {
+  if (source_l.empty() || source_r.empty() || destination_l.empty() || destination_r.empty()) {
     return;
   }
 
@@ -112,28 +112,28 @@ void EqualPowerPanner::Pan(double azimuth,
 
   if (number_of_input_channels == 1) {  // For mono source case.
     while (n--) {
-      const float input_l = *source_l++;
+      const float input_l = (source_l++)[0];
 
-      *destination_l++ = static_cast<float>(input_l * desired_gain_l);
-      *destination_r++ = static_cast<float>(input_l * desired_gain_r);
+      (destination_l++)[0] = static_cast<float>(input_l * desired_gain_l);
+      (destination_r++)[0] = static_cast<float>(input_l * desired_gain_r);
     }
   } else {               // For stereo source case.
     if (azimuth <= 0) {  // from -90 -> 0
       while (n--) {
-        const float input_l = *source_l++;
-        const float input_r = *source_r++;
+        const float input_l = (source_l++)[0];
+        const float input_r = (source_r++)[0];
 
-        *destination_l++ =
+        (destination_l++)[0] =
             static_cast<float>(input_l + input_r * desired_gain_l);
-        *destination_r++ = static_cast<float>(input_r * desired_gain_r);
+        (destination_r++)[0] = static_cast<float>(input_r * desired_gain_r);
       }
     } else {  // from 0 -> +90
       while (n--) {
-        const float input_l = *source_l++;
-        const float input_r = *source_r++;
+        const float input_l = (source_l++)[0];
+        const float input_r = (source_r++)[0];
 
-        *destination_l++ = static_cast<float>(input_l * desired_gain_l);
-        *destination_r++ =
+        (destination_l++)[0] = static_cast<float>(input_l * desired_gain_l);
+        (destination_r++)[0] =
             static_cast<float>(input_r + input_l * desired_gain_r);
       }
     }
@@ -158,18 +158,18 @@ void EqualPowerPanner::PanWithSampleAccurateValues(
   DCHECK_EQ(output_bus->NumberOfChannels(), 2u);
   DCHECK_LE(frames_to_process, output_bus->length());
 
-  const float* source_l = input_bus->Channel(0)->Data();
-  const float* source_r =
+  base::span<const float>source_l = input_bus->Channel(0)->Data();
+  base::span<const float>source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
-  float* destination_l =
+  base::span<float>destination_l =
       output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
-  float* destination_r =
+  base::span<float>destination_r =
       output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
 
-  DCHECK(source_l);
-  DCHECK(source_r);
-  DCHECK(destination_l);
-  DCHECK(destination_r);
+  DCHECK(!source_l.empty());
+  DCHECK(!source_r.empty());
+  DCHECK(!destination_l.empty());
+  DCHECK(!destination_r.empty());
 
   int n = frames_to_process;
 
@@ -177,12 +177,12 @@ void EqualPowerPanner::PanWithSampleAccurateValues(
     for (int k = 0; k < n; ++k) {
       double desired_gain_l;
       double desired_gain_r;
-      const float input_l = *source_l++;
+      const float input_l = (source_l++)[0];
 
       CalculateDesiredGain(desired_gain_l, desired_gain_r, azimuth[k],
                            number_of_input_channels);
-      *destination_l++ = static_cast<float>(input_l * desired_gain_l);
-      *destination_r++ = static_cast<float>(input_l * desired_gain_r);
+      (destination_l++)[0] = static_cast<float>(input_l * desired_gain_l);
+      (destination_r++)[0] = static_cast<float>(input_l * desired_gain_r);
     }
   } else {  // For stereo source case.
     for (int k = 0; k < n; ++k) {
@@ -192,16 +192,16 @@ void EqualPowerPanner::PanWithSampleAccurateValues(
       CalculateDesiredGain(desired_gain_l, desired_gain_r, azimuth[k],
                            number_of_input_channels);
       if (azimuth[k] <= 0) {  // from -90 -> 0
-        const float input_l = *source_l++;
-        const float input_r = *source_r++;
-        *destination_l++ =
+        const float input_l = (source_l++)[0];
+        const float input_r = (source_r++)[0];
+        (destination_l++)[0] =
             static_cast<float>(input_l + input_r * desired_gain_l);
-        *destination_r++ = static_cast<float>(input_r * desired_gain_r);
+        (destination_r++)[0] = static_cast<float>(input_r * desired_gain_r);
       } else {  // from 0 -> +90
-        const float input_l = *source_l++;
-        const float input_r = *source_r++;
-        *destination_l++ = static_cast<float>(input_l * desired_gain_l);
-        *destination_r++ =
+        const float input_l = (source_l++)[0];
+        const float input_r = (source_r++)[0];
+        (destination_l++)[0] = static_cast<float>(input_l * desired_gain_l);
+        (destination_r++)[0] =
             static_cast<float>(input_r + input_l * desired_gain_r);
       }
     }
diff --git a/third_party/blink/renderer/platform/audio/fft_convolver.cc b/third_party/blink/renderer/platform/audio/fft_convolver.cc
index 3ba18b2dfe6ee..1f6149bc4c9e3 100644
--- a/third_party/blink/renderer/platform/audio/fft_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/fft_convolver.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,8 +47,8 @@ FFTConvolver::FFTConvolver(unsigned fft_size)
       last_overlap_buffer_(fft_size / 2) {}
 
 void FFTConvolver::Process(const FFTFrame* fft_kernel,
-                           const float* source_p,
-                           float* dest_p,
+                           base::span<const float>source_p,
+                           base::span<float>dest_p,
                            uint32_t frames_to_process) {
   unsigned half_size = FftSize() / 2;
 
@@ -63,31 +65,31 @@ void FFTConvolver::Process(const FFTFrame* fft_kernel,
       number_of_divisions == 1 ? frames_to_process : half_size;
 
   for (size_t i = 0; i < number_of_divisions;
-       ++i, source_p += division_size, dest_p += division_size) {
+       ++i, source_p=source_p.subspan(division_size), dest_p=dest_p.subspan(division_size)) {
     // Copy samples to input buffer (note contraint above!)
-    float* input_p = input_buffer_.Data();
+    base::span<float>input_p = input_buffer_.Data();
 
-    DCHECK(source_p);
-    DCHECK(input_p);
+    DCHECK(!source_p.empty());
+    DCHECK(!input_p.empty());
     DCHECK_LE(read_write_index_ + division_size, input_buffer_.size());
 
-    memcpy(input_p + read_write_index_, source_p,
+    memcpy(input_p .subspan( read_write_index_).data(), source_p.data(),
            sizeof(float) * division_size);
 
     // Copy samples from output buffer
-    float* output_p = output_buffer_.Data();
+    base::span<float>output_p = output_buffer_.Data();
 
-    DCHECK(dest_p);
-    DCHECK(output_p);
+    DCHECK(!dest_p.empty());
+    DCHECK(!output_p.empty());
     DCHECK_LE(read_write_index_ + division_size, output_buffer_.size());
 
-    memcpy(dest_p, output_p + read_write_index_, sizeof(float) * division_size);
+    memcpy(dest_p.data(), output_p .subspan( read_write_index_).data(), sizeof(float) * division_size);
     read_write_index_ += division_size;
 
     // Check if it's time to perform the next FFT
     if (read_write_index_ == half_size) {
       // The input buffer is now filled (get frequency-domain version)
-      frame_.DoFFT(input_buffer_.Data());
+      frame_.DoFFT(input_buffer_.Data().data());
       frame_.Multiply(*fft_kernel);
       frame_.DoInverseFFT(output_buffer_.Data());
 
@@ -99,7 +101,7 @@ void FFTConvolver::Process(const FFTFrame* fft_kernel,
       DCHECK_EQ(output_buffer_.size(), 2 * half_size);
       DCHECK_EQ(last_overlap_buffer_.size(), half_size);
 
-      memcpy(last_overlap_buffer_.Data(), output_buffer_.Data() + half_size,
+      memcpy(last_overlap_buffer_.Data().data(), output_buffer_.Data() .subspan( half_size).data(),
              sizeof(float) * half_size);
 
       // Reset index back to start for next time
diff --git a/third_party/blink/renderer/platform/audio/fft_convolver.h b/third_party/blink/renderer/platform/audio/fft_convolver.h
index 5567ee732ae34..71dfc749911d0 100644
--- a/third_party/blink/renderer/platform/audio/fft_convolver.h
+++ b/third_party/blink/renderer/platform/audio/fft_convolver.h
@@ -29,6 +29,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_FFT_CONVOLVER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_FFT_CONVOLVER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/fft_frame.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
@@ -54,8 +55,8 @@ class FFTConvolver final {
   //
   // Processing in-place is allowed...
   void Process(const FFTFrame* fft_kernel,
-               const float* source_p,
-               float* dest_p,
+               base::span<const float>source_p,
+               base::span<float>dest_p,
                uint32_t frames_to_process);
 
   void Reset();
diff --git a/third_party/blink/renderer/platform/audio/fft_frame.cc b/third_party/blink/renderer/platform/audio/fft_frame.cc
index d584d590e31f8..1e332c19c3425 100644
--- a/third_party/blink/renderer/platform/audio/fft_frame.cc
+++ b/third_party/blink/renderer/platform/audio/fft_frame.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -51,7 +53,7 @@ void FFTFrame::DoPaddedFFT(const float* data, unsigned data_size) {
   padded_response.CopyToRange(data, 0, data_size);
 
   // Get the frequency-domain version of padded response
-  DoFFT(padded_response.Data());
+  DoFFT(padded_response.Data().data());
 }
 
 std::unique_ptr<FFTFrame> FFTFrame::CreateInterpolatedFrame(
@@ -71,7 +73,7 @@ std::unique_ptr<FFTFrame> FFTFrame::CreateInterpolatedFrame(
   buffer.ZeroRange(fft_size / 2, fft_size);
 
   // Put back into frequency domain.
-  new_frame->DoFFT(buffer.Data());
+  new_frame->DoFFT(buffer.Data().data());
 
   return new_frame;
 }
@@ -106,10 +108,10 @@ void FFTFrame::InterpolateFrequencyComponents(const FFTFrame& frame1,
   double last_phase1 = 0.0;
   double last_phase2 = 0.0;
 
-  const float* real_p1_data = real1.Data();
-  const float* real_p2_data = real2.Data();
-  const float* imag_p1_data = imag1.Data();
-  const float* imag_p2_data = imag2.Data();
+  base::span<const float>real_p1_data = real1.Data();
+  base::span<const float>real_p2_data = real2.Data();
+  base::span<const float>imag_p1_data = imag1.Data();
+  base::span<const float>imag_p2_data = imag2.Data();
 
   real[0] = static_cast<float>(s1base * real_p1_data[0] +
                                          s2base * real_p2_data[0]);
diff --git a/third_party/blink/renderer/platform/audio/fft_frame.h b/third_party/blink/renderer/platform/audio/fft_frame.h
index c1faadc503801..314b22cf0a230 100644
--- a/third_party/blink/renderer/platform/audio/fft_frame.h
+++ b/third_party/blink/renderer/platform/audio/fft_frame.h
@@ -30,6 +30,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_FFT_FRAME_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "build/build_config.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
@@ -79,7 +80,7 @@ class PLATFORM_EXPORT FFTFrame final {
   // Compute the inverse FFT using the FFT data in |real_data_| and
   // |imag_data_|.  The inverse is saved in |data|.  |data| MUST have size at
   // least |fft_size_| elements.
-  void DoInverseFFT(float* data);
+  void DoInverseFFT(base::span<float>data);
 
   AudioFloatArray& RealData() { return real_data_; }
   const AudioFloatArray& RealData() const { return real_data_; }
diff --git a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
index 11aee4cc28c3a..8dde76ab05dae 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
@@ -222,8 +222,8 @@ bool HRTFElevation::CalculateKernelsForAzimuthElevation(
         AudioBus::Create(response->NumberOfChannels(), fft_size / 2));
     for (unsigned channel = 0; channel < response->NumberOfChannels();
          ++channel) {
-      memcpy(padded_response->Channel(channel)->MutableData(),
-             response->Channel(channel)->Data(),
+      memcpy(padded_response->Channel(channel)->MutableData().data(),
+             response->Channel(channel)->Data().data(),
              response->length() * sizeof(float));
     }
     response = padded_response;
diff --git a/third_party/blink/renderer/platform/audio/hrtf_kernel.cc b/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
index 7f3b85879148e..69cd55960b5e8 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_kernel.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -53,7 +55,7 @@ float ExtractAverageGroupDelay(AudioChannel* channel,
                                unsigned analysis_fft_size) {
   DCHECK(channel);
 
-  float* impulse_p = channel->MutableData();
+  base::span<float>impulse_p = channel->MutableData();
 
   DCHECK_GE(channel->length(), analysis_fft_size);
 
@@ -62,7 +64,7 @@ float ExtractAverageGroupDelay(AudioChannel* channel,
             analysis_fft_size);
 
   FFTFrame estimation_frame(analysis_fft_size);
-  estimation_frame.DoFFT(impulse_p);
+  estimation_frame.DoFFT(impulse_p.data());
 
   const float frame_delay =
       ClampTo<float>(estimation_frame.ExtractAverageGroupDelay());
@@ -82,7 +84,7 @@ HRTFKernel::HRTFKernel(AudioChannel* channel,
   // Determine the leading delay (average group delay) for the response.
   frame_delay_ = ExtractAverageGroupDelay(channel, fft_size / 2);
 
-  float* impulse_response = channel->MutableData();
+  base::span<float>impulse_response = channel->MutableData();
   const uint32_t response_length = channel->length();
 
   // We need to truncate to fit into 1/2 the FFT size (with zero padding) in
@@ -104,7 +106,7 @@ HRTFKernel::HRTFKernel(AudioChannel* channel,
   }
 
   fft_frame_ = std::make_unique<FFTFrame>(fft_size);
-  fft_frame_->DoPaddedFFT(impulse_response, truncated_response_length);
+  fft_frame_->DoPaddedFFT(impulse_response.data(), truncated_response_length);
 }
 
 // Interpolates two kernels with x: 0 -> 1 and returns the result.
diff --git a/third_party/blink/renderer/platform/audio/hrtf_panner.cc b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
index 9e73bb0c0887b..e5ac27084c029 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_panner.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
@@ -184,12 +184,12 @@ void HRTFPanner::Pan(double desired_azimuth,
                              : nullptr;
 
   // Get source and destination pointers.
-  const float* source_l = input_channel_l->Data();
-  const float* source_r =
+  base::span<const float>source_l = input_channel_l->Data();
+  base::span<const float>source_r =
       num_input_channels > 1 ? input_channel_r->Data() : source_l;
-  float* destination_l =
+  base::span<float>destination_l =
       output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
-  float* destination_r =
+  base::span<float>destination_r =
       output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
 
   double azimuth_blend;
@@ -272,10 +272,10 @@ void HRTFPanner::Pan(double desired_azimuth,
 
     // Calculate the source and destination pointers for the current segment.
     const unsigned offset = segment * kFramesPerSegment;
-    const float* segment_source_l = source_l + offset;
-    const float* segment_source_r = source_r + offset;
-    float* segment_destination_l = destination_l + offset;
-    float* segment_destination_r = destination_r + offset;
+    base::span<const float>segment_source_l = source_l .subspan( offset);
+    base::span<const float>segment_source_r = source_r .subspan( offset);
+    base::span<float>segment_destination_l = destination_l .subspan( offset);
+    base::span<float>segment_destination_r = destination_r .subspan( offset);
 
     // First run through delay lines for inter-aural time difference.
     delay_line_l_.SetDelayFrames(frame_delay_l);
@@ -289,13 +289,13 @@ void HRTFPanner::Pan(double desired_azimuth,
 
     // Have the convolvers render directly to the final destination if we're not
     // cross-fading.
-    float* convolution_destination_l1 =
+    base::span<float>convolution_destination_l1 =
         needs_crossfading ? temp_l1_.Data() : segment_destination_l;
-    float* convolution_destination_r1 =
+    base::span<float>convolution_destination_r1 =
         needs_crossfading ? temp_r1_.Data() : segment_destination_r;
-    float* convolution_destination_l2 =
+    base::span<float>convolution_destination_l2 =
         needs_crossfading ? temp_l2_.Data() : segment_destination_l;
-    float* convolution_destination_r2 =
+    base::span<float>convolution_destination_r2 =
         needs_crossfading ? temp_r2_.Data() : segment_destination_r;
 
     // Now do the convolutions.
diff --git a/third_party/blink/renderer/platform/audio/iir_filter.cc b/third_party/blink/renderer/platform/audio/iir_filter.cc
index 0cc719de76abf..8ac5bda968b40 100644
--- a/third_party/blink/renderer/platform/audio/iir_filter.cc
+++ b/third_party/blink/renderer/platform/audio/iir_filter.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -42,7 +44,7 @@ void IIRFilter::Reset() {
   buffer_index_ = 0;
 }
 
-static std::complex<double> EvaluatePolynomial(const double* coef,
+static std::complex<double> EvaluatePolynomial(base::span<const double>coef,
                                                std::complex<double> z,
                                                int order) {
   // Use Horner's method to evaluate the polynomial P(z) = sum(coef[k]*z^k, k,
@@ -56,8 +58,8 @@ static std::complex<double> EvaluatePolynomial(const double* coef,
   return result;
 }
 
-void IIRFilter::Process(const float* source_p,
-                        float* dest_p,
+void IIRFilter::Process(base::span<const float>source_p,
+                        base::span<float>dest_p,
                         uint32_t frames_to_process) {
   // Compute
   //
@@ -69,11 +71,11 @@ void IIRFilter::Process(const float* source_p,
   // This is a Direct Form I implementation of an IIR Filter.  Should we
   // consider doing a different implementation such as Transposed Direct Form
   // II?
-  const double* feedback = feedback_->Data();
-  const double* feedforward = feedforward_->Data();
+  base::span<const double>feedback = feedback_->Data();
+  base::span<const double>feedforward = feedforward_->Data();
 
-  DCHECK(feedback);
-  DCHECK(feedforward);
+  DCHECK(!feedback.empty());
+  DCHECK(!feedforward.empty());
 
   // Sanity check to see if the feedback coefficients have been scaled
   // appropriately. It must be EXACTLY 1!
@@ -83,8 +85,8 @@ void IIRFilter::Process(const float* source_p,
   int feedforward_length = feedforward_->size();
   int min_length = std::min(feedback_length, feedforward_length);
 
-  double* x_buffer = x_buffer_.Data();
-  double* y_buffer = y_buffer_.Data();
+  base::span<double>x_buffer = x_buffer_.Data();
+  base::span<double>y_buffer = y_buffer_.Data();
 
   for (size_t n = 0; n < frames_to_process; ++n) {
     // To help minimize roundoff, we compute using double's, even though the
@@ -121,8 +123,8 @@ void IIRFilter::Process(const float* source_p,
 
 void IIRFilter::GetFrequencyResponse(int n_frequencies,
                                      const float* frequency,
-                                     float* mag_response,
-                                     float* phase_response) {
+                                     base::span<float>mag_response,
+                                     base::span<float>phase_response) {
   // Evaluate the z-transform of the filter at the given normalized frequencies
   // from 0 to 1. (One corresponds to the Nyquist frequency.)
   //
diff --git a/third_party/blink/renderer/platform/audio/iir_filter.h b/third_party/blink/renderer/platform/audio/iir_filter.h
index 8938ec66a720c..5b90016863d37 100644
--- a/third_party/blink/renderer/platform/audio/iir_filter.h
+++ b/third_party/blink/renderer/platform/audio/iir_filter.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_IIR_FILTER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_IIR_FILTER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
@@ -21,16 +22,16 @@ class PLATFORM_EXPORT IIRFilter final {
             const AudioDoubleArray* feedback_coef);
   ~IIRFilter();
 
-  void Process(const float* source_p,
-               float* dest_p,
+  void Process(base::span<const float>source_p,
+               base::span<float>dest_p,
                uint32_t frames_to_process);
 
   void Reset();
 
   void GetFrequencyResponse(int n_frequencies,
                             const float* frequency,
-                            float* mag_response,
-                            float* phase_response);
+                            base::span<float>mag_response,
+                            base::span<float>phase_response);
 
   // Compute the tail time of the IIR filter
   double TailTime(double sample_rate,
diff --git a/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc b/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
index 3b60efc3281f7..f961260503664 100644
--- a/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
+++ b/third_party/blink/renderer/platform/audio/media_multi_channel_resampler.cc
@@ -39,7 +39,7 @@ void MediaMultiChannelResampler::Resample(
     // TODO(crbug.com/375449662): Spanify `AudioChannel::MuteableData`.
     resampler_input_bus_wrapper_->SetChannelData(
         i, UNSAFE_TODO(base::span(
-               resampler_input_bus->Channel(i)->MutableData(),
+               resampler_input_bus->Channel(i)->MutableData().data(),
                base::checked_cast<size_t>(resampler_input_bus->length()))));
   }
   ResampleInternal(frames, resampler_input_bus_wrapper_.get());
diff --git a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
index 891f425a0561b..d174322d97486 100644
--- a/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
+++ b/third_party/blink/renderer/platform/audio/pffft/fft_frame_pffft.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -151,8 +153,8 @@ FFTFrame::FFTFrame(const FFTFrame& frame)
 
   // Copy/setup frame data.
   unsigned nbytes = sizeof(float) * (fft_size_ / 2);
-  memcpy(RealData().Data(), frame.RealData().Data(), nbytes);
-  memcpy(ImagData().Data(), frame.ImagData().Data(), nbytes);
+  memcpy(RealData().Data().data(), frame.RealData().Data().data(), nbytes);
+  memcpy(ImagData().Data().data(), frame.ImagData().Data().data(), nbytes);
 }
 
 unsigned FFTFrame::MinFFTSize() {
@@ -199,7 +201,7 @@ void FFTFrame::DoFFT(const float* data) {
   PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
-  pffft_transform_ordered(setup, data, complex_data_.Data(), pffft_work_.Data(),
+  pffft_transform_ordered(setup, data, complex_data_.Data().data(), pffft_work_.Data().data(),
                           PFFFT_FORWARD);
 
   unsigned len = fft_size_ / 2;
@@ -207,9 +209,9 @@ void FFTFrame::DoFFT(const float* data) {
   // Split FFT data into real and imaginary arrays.  PFFFT transform already
   // uses the desired format; we just need to split out the real and imaginary
   // parts.
-  const float* c = complex_data_.Data();
-  float* real = real_data_.Data();
-  float* imag = imag_data_.Data();
+  base::span<const float>c = complex_data_.Data();
+  base::span<float>real = real_data_.Data();
+  base::span<float>imag = imag_data_.Data();
   for (unsigned k = 0; k < len; ++k) {
     int index = 2 * k;
     real[k] = c[index];
@@ -217,16 +219,16 @@ void FFTFrame::DoFFT(const float* data) {
   }
 }
 
-void FFTFrame::DoInverseFFT(float* data) {
+void FFTFrame::DoInverseFFT(base::span<float>data) {
   DCHECK_EQ(complex_data_.size(), fft_size_);
 
   unsigned len = fft_size_ / 2;
 
   // Pack the real and imaginary data into the complex array format.  PFFFT
   // already uses the desired format; we just need to pack the parts together.
-  float* fft_data = complex_data_.Data();
-  const float* real = real_data_.Data();
-  const float* imag = imag_data_.Data();
+  base::span<float>fft_data = complex_data_.Data();
+  base::span<const float>real = real_data_.Data();
+  base::span<const float>imag = imag_data_.Data();
   for (unsigned k = 0; k < len; ++k) {
     int index = 2 * k;
     fft_data[index] = real[k];
@@ -236,7 +238,7 @@ void FFTFrame::DoInverseFFT(float* data) {
   PFFFT_Setup* setup = FFTSetupForSize(fft_size_);
   DCHECK(setup);
 
-  pffft_transform_ordered(setup, fft_data, data, pffft_work_.Data(),
+  pffft_transform_ordered(setup, fft_data.data(), data.data(), pffft_work_.Data().data(),
                           PFFFT_BACKWARD);
 
   // The inverse transform needs to be scaled because PFFFT doesn't.
diff --git a/third_party/blink/renderer/platform/audio/push_pull_fifo.cc b/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
index cd0e1723a7799..e1c04386d7a11 100644
--- a/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
+++ b/third_party/blink/renderer/platform/audio/push_pull_fifo.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -77,18 +79,18 @@ void PushPullFIFO::Push(const AudioBus* input_bus) {
   const size_t remainder = fifo_length_ - index_write_;
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-    float* fifo_bus_channel = fifo_bus_->Channel(i)->MutableData();
-    const float* input_bus_channel = input_bus->Channel(i)->Data();
+    base::span<float>fifo_bus_channel = fifo_bus_->Channel(i)->MutableData();
+    base::span<const float>input_bus_channel = input_bus->Channel(i)->Data();
     if (remainder >= input_bus_length) {
       // The remainder is big enough for the input data.
-      memcpy(fifo_bus_channel + index_write_, input_bus_channel,
-             input_bus_length * sizeof(*fifo_bus_channel));
+      memcpy(fifo_bus_channel .subspan( index_write_).data(), input_bus_channel.data(),
+             input_bus_length * sizeof( fifo_bus_channel[0]));
     } else {
       // The input data overflows the remainder size. Wrap around the index.
-      memcpy(fifo_bus_channel + index_write_, input_bus_channel,
-             remainder * sizeof(*fifo_bus_channel));
-      memcpy(fifo_bus_channel, input_bus_channel + remainder,
-             (input_bus_length - remainder) * sizeof(*fifo_bus_channel));
+      memcpy(fifo_bus_channel .subspan( index_write_).data(), input_bus_channel.data(),
+             remainder * sizeof( fifo_bus_channel[0]));
+      memcpy(fifo_bus_channel.data(), input_bus_channel .subspan( remainder).data(),
+             (input_bus_length - remainder) * sizeof( fifo_bus_channel[0]));
     }
   }
 
@@ -165,28 +167,28 @@ size_t PushPullFIFO::Pull(AudioBus* output_bus, uint32_t frames_requested) {
   const size_t frames_to_fill = std::min(frames_available_, frames_requested);
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-    const float* fifo_bus_channel = fifo_bus_->Channel(i)->Data();
-    float* output_bus_channel = output_bus->Channel(i)->MutableData();
+    base::span<const float>fifo_bus_channel = fifo_bus_->Channel(i)->Data();
+    base::span<float>output_bus_channel = output_bus->Channel(i)->MutableData();
 
     // Fill up the output bus with the available frames first.
     if (remainder >= frames_to_fill) {
       // The remainder is big enough for the frames to pull.
-      memcpy(output_bus_channel, fifo_bus_channel + index_read_,
-             frames_to_fill * sizeof(*fifo_bus_channel));
+      memcpy(output_bus_channel.data(), fifo_bus_channel .subspan( index_read_).data(),
+             frames_to_fill * sizeof( fifo_bus_channel[0]));
     } else {
       // The frames to pull is bigger than the remainder size.
       // Wrap around the index.
-      memcpy(output_bus_channel, fifo_bus_channel + index_read_,
-             remainder * sizeof(*fifo_bus_channel));
-      memcpy(output_bus_channel + remainder, fifo_bus_channel,
-             (frames_to_fill - remainder) * sizeof(*fifo_bus_channel));
+      memcpy(output_bus_channel.data(), fifo_bus_channel .subspan( index_read_).data(),
+             remainder * sizeof( fifo_bus_channel[0]));
+      memcpy(output_bus_channel .subspan( remainder).data(), fifo_bus_channel.data(),
+             (frames_to_fill - remainder) * sizeof( fifo_bus_channel[0]));
     }
 
     // The frames available was not enough to fulfill the requested frames. Fill
     // the rest of the channel with silence.
     if (frames_requested > frames_to_fill) {
-      memset(output_bus_channel + frames_to_fill, 0,
-             (frames_requested - frames_to_fill) * sizeof(*output_bus_channel));
+      memset(output_bus_channel .subspan( frames_to_fill).data(), 0,
+             (frames_requested - frames_to_fill) * sizeof( output_bus_channel[0]));
     }
   }
 
@@ -271,7 +273,7 @@ PushPullFIFO::PullResult PushPullFIFO::PullAndUpdateEarmark(
     // Note that it silences when underrun happens now, and ship the remaining
     // frames in subsequent callbacks without silence in between.
     for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-      float* output_bus_channel = output_bus->Channel(i)->MutableData();
+      float* output_bus_channel = output_bus->Channel(i)->MutableData().data();
       memset(output_bus_channel, 0,
              frames_requested * sizeof(*output_bus_channel));
     }
@@ -286,21 +288,21 @@ PushPullFIFO::PullResult PushPullFIFO::PullAndUpdateEarmark(
   const uint32_t frames_to_fill = std::min(frames_available_, frames_requested);
 
   for (unsigned i = 0; i < fifo_bus_->NumberOfChannels(); ++i) {
-    const float* fifo_bus_channel = fifo_bus_->Channel(i)->Data();
-    float* output_bus_channel = output_bus->Channel(i)->MutableData();
+    base::span<const float>fifo_bus_channel = fifo_bus_->Channel(i)->Data();
+    base::span<float>output_bus_channel = output_bus->Channel(i)->MutableData();
 
     // Fill up the output bus with the available frames first.
     if (remainder >= frames_to_fill) {
       // The remainder is big enough for the frames to pull.
-      memcpy(output_bus_channel, fifo_bus_channel + index_read_,
-            frames_to_fill * sizeof(*fifo_bus_channel));
+      memcpy(output_bus_channel.data(), fifo_bus_channel .subspan( index_read_).data(),
+            frames_to_fill * sizeof( fifo_bus_channel[0]));
     } else {
       // The frames to pull is bigger than the remainder size.
       // Wrap around the index.
-      memcpy(output_bus_channel, fifo_bus_channel + index_read_,
-            remainder * sizeof(*fifo_bus_channel));
-      memcpy(output_bus_channel + remainder, fifo_bus_channel,
-            (frames_to_fill - remainder) * sizeof(*fifo_bus_channel));
+      memcpy(output_bus_channel.data(), fifo_bus_channel .subspan( index_read_).data(),
+            remainder * sizeof( fifo_bus_channel[0]));
+      memcpy(output_bus_channel .subspan( remainder).data(), fifo_bus_channel.data(),
+            (frames_to_fill - remainder) * sizeof( fifo_bus_channel[0]));
     }
   }
 
diff --git a/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc b/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
index c980b58d90b0f..38b1d4b485791 100644
--- a/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
+++ b/third_party/blink/renderer/platform/audio/push_pull_fifo_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -64,7 +66,7 @@ TEST(PushPullFIFOBasicTest, BasicTests) {
 // value will be |starting_value| + |bus_length|.
 size_t FillBusWithLinearRamp(AudioBus* target_bus, size_t starting_value) {
   for (unsigned c = 0; c < target_bus->NumberOfChannels(); ++c) {
-    float* bus_channel = target_bus->Channel(c)->MutableData();
+    base::span<float>bus_channel = target_bus->Channel(c)->MutableData();
     for (size_t i = 0; i < target_bus->Channel(c)->length(); ++i) {
       bus_channel[i] = static_cast<float>(starting_value + i);
     }
@@ -78,7 +80,7 @@ bool VerifyBusValueAtIndex(AudioBus* target_bus,
                            int index,
                            float expected_value) {
   for (unsigned c = 0; c < target_bus->NumberOfChannels(); ++c) {
-    float* bus_channel = target_bus->Channel(c)->MutableData();
+    base::span<float>bus_channel = target_bus->Channel(c)->MutableData();
     if (bus_channel[index] != expected_value) {
       LOG(ERROR) << ">> [FAIL] expected " << expected_value << " at index "
                  << index << " but got " << bus_channel[index] << ".";
diff --git a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
index 5f38586a29f02..19c8eb2efa4ca 100644
--- a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -42,7 +44,7 @@ namespace blink {
 ReverbAccumulationBuffer::ReverbAccumulationBuffer(uint32_t length)
     : buffer_(length), read_index_(0), read_time_frame_(0) {}
 
-void ReverbAccumulationBuffer::ReadAndClear(float* destination,
+void ReverbAccumulationBuffer::ReadAndClear(base::span<float>destination,
                                             uint32_t number_of_frames) {
   uint32_t buffer_length = buffer_.size();
 
@@ -53,15 +55,15 @@ void ReverbAccumulationBuffer::ReadAndClear(float* destination,
   uint32_t number_of_frames1 = std::min(number_of_frames, frames_available);
   uint32_t number_of_frames2 = number_of_frames - number_of_frames1;
 
-  float* source = buffer_.Data();
-  memcpy(destination, source + read_index_, sizeof(float) * number_of_frames1);
-  memset(source + read_index_, 0, sizeof(float) * number_of_frames1);
+  base::span<float>source = buffer_.Data();
+  memcpy(destination.data(), source .subspan( read_index_).data(), sizeof(float) * number_of_frames1);
+  memset(source .subspan( read_index_).data(), 0, sizeof(float) * number_of_frames1);
 
   // Handle wrap-around if necessary
   if (number_of_frames2 > 0) {
-    memcpy(destination + number_of_frames1, source,
+    memcpy(destination .subspan( number_of_frames1).data(), source.data(),
            sizeof(float) * number_of_frames2);
-    memset(source, 0, sizeof(float) * number_of_frames2);
+    memset(source.data(), 0, sizeof(float) * number_of_frames2);
   }
 
   read_index_ = (read_index_ + number_of_frames) % buffer_length;
@@ -75,7 +77,7 @@ void ReverbAccumulationBuffer::UpdateReadIndex(
   *read_index = (*read_index + number_of_frames) % buffer_.size();
 }
 
-uint32_t ReverbAccumulationBuffer::Accumulate(float* source,
+uint32_t ReverbAccumulationBuffer::Accumulate(base::span<float>source,
                                               uint32_t number_of_frames,
                                               uint32_t* read_index,
                                               size_t delay_frames) {
@@ -90,18 +92,18 @@ uint32_t ReverbAccumulationBuffer::Accumulate(float* source,
   uint32_t number_of_frames1 = std::min(number_of_frames, frames_available);
   uint32_t number_of_frames2 = number_of_frames - number_of_frames1;
 
-  float* destination = buffer_.Data();
+  base::span<float>destination = buffer_.Data();
 
   DCHECK_LE(write_index, buffer_length);
   DCHECK_LE(number_of_frames1 + write_index, buffer_length);
   DCHECK_LE(number_of_frames2, buffer_length);
 
-  vector_math::Vadd(source, 1, destination + write_index, 1,
-                    destination + write_index, 1, number_of_frames1);
+  vector_math::Vadd(source, 1, destination .subspan( write_index), 1,
+                    destination .subspan( write_index), 1, number_of_frames1);
 
   // Handle wrap-around if necessary
   if (number_of_frames2 > 0) {
-    vector_math::Vadd(source + number_of_frames1, 1, destination, 1,
+    vector_math::Vadd(source .subspan( number_of_frames1), 1, destination, 1,
                       destination, 1, number_of_frames2);
   }
 
diff --git a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.h b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.h
index fcff4daf1664a..0da3ed2c7c4bf 100644
--- a/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.h
+++ b/third_party/blink/renderer/platform/audio/reverb_accumulation_buffer.h
@@ -29,6 +29,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_REVERB_ACCUMULATION_BUFFER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_REVERB_ACCUMULATION_BUFFER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
@@ -48,7 +49,7 @@ class ReverbAccumulationBuffer final {
   ReverbAccumulationBuffer& operator=(const ReverbAccumulationBuffer&) = delete;
 
   // This will read from, then clear-out numberOfFrames
-  void ReadAndClear(float* destination, uint32_t number_of_frames);
+  void ReadAndClear(base::span<float>destination, uint32_t number_of_frames);
 
   // Each ReverbConvolverStage will accumulate its output at the appropriate
   // delay from the read position.  We need to pass in and update readIndex
@@ -56,7 +57,7 @@ class ReverbAccumulationBuffer final {
   // than the realtime thread calling ReadAndClear() and maintaining
   // m_readIndex
   // Returns the writeIndex where the accumulation took place
-  uint32_t Accumulate(float* source,
+  uint32_t Accumulate(base::span<float>source,
                       uint32_t number_of_frames,
                       uint32_t* read_index,
                       size_t delay_frames);
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver.cc b/third_party/blink/renderer/platform/audio/reverb_convolver.cc
index 3c22ec815b540..39d2a2643e52b 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver.cc
@@ -31,6 +31,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/location.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
 #include "third_party/blink/renderer/platform/audio/vector_math.h"
@@ -77,7 +78,7 @@ ReverbConvolver::ReverbConvolver(AudioChannel* impulse_response,
   // processing slices.
   max_realtime_fft_size_ = kMaxRealtimeFFTSize;
 
-  const float* response = impulse_response->Data();
+  const float* response = impulse_response->Data().data();
   uint32_t total_response_length = impulse_response->length();
 
   // The total latency is zero because the direct-convolution is used in the
@@ -178,13 +179,13 @@ void ReverbConvolver::Process(const AudioChannel* source_channel,
   DCHECK_GE(source_channel->length(), frames_to_process);
   DCHECK_GE(destination_channel->length(), frames_to_process);
 
-  const float* source = source_channel->Data();
-  float* destination = destination_channel->MutableData();
-  DCHECK(source);
-  DCHECK(destination);
+  base::span<const float>source = source_channel->Data();
+  base::span<float>destination = destination_channel->MutableData();
+  DCHECK(!source.empty());
+  DCHECK(!destination.empty());
 
   // Feed input buffer (read by all threads)
-  input_buffer_.Write(source, frames_to_process);
+  input_buffer_.Write(source.data(), frames_to_process);
 
   // Accumulate contributions from each stage
   for (auto& stage : stages_) {
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
index 94fab48f0a9f8..7b46b5d4fa4cb 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,7 +47,7 @@
 namespace blink {
 
 ReverbConvolverStage::ReverbConvolverStage(
-    const float* impulse_response,
+    base::span<const float>impulse_response,
     size_t,
     size_t reverb_total_latency,
     size_t stage_offset,
@@ -60,12 +62,12 @@ ReverbConvolverStage::ReverbConvolverStage(
       accumulation_read_index_(0),
       input_read_index_(0),
       direct_mode_(direct_mode) {
-  DCHECK(impulse_response);
+  DCHECK(!impulse_response.empty());
   DCHECK(accumulation_buffer);
 
   if (!direct_mode_) {
     fft_kernel_ = std::make_unique<FFTFrame>(fft_size);
-    fft_kernel_->DoPaddedFFT(impulse_response + stage_offset, stage_length);
+    fft_kernel_->DoPaddedFFT(impulse_response .subspan( stage_offset).data(), stage_length);
     // Account for the normalization (if any) of the convolver.  By linearity,
     // we can scale the FFT by the factor instead of the input.  We do it this
     // way so we don't need to create a temporary for the scaled result before
@@ -79,7 +81,7 @@ ReverbConvolverStage::ReverbConvolverStage(
     DCHECK_LE(stage_length, fft_size / 2);
 
     auto direct_kernel = std::make_unique<AudioFloatArray>(fft_size / 2);
-    direct_kernel->CopyToRange(impulse_response, 0, stage_length);
+    direct_kernel->CopyToRange(impulse_response.data(), 0, stage_length);
     // Account for the normalization (if any) of the convolver node.
     if (scale != 1) {
       vector_math::Vsmul(direct_kernel->Data(), 1, &scale,
@@ -128,23 +130,23 @@ ReverbConvolverStage::ReverbConvolverStage(
 void ReverbConvolverStage::ProcessInBackground(ReverbConvolver* convolver,
                                                uint32_t frames_to_process) {
   ReverbInputBuffer* input_buffer = convolver->InputBuffer();
-  float* source =
+  base::span<float>source =
       input_buffer->DirectReadFrom(&input_read_index_, frames_to_process);
   Process(source, frames_to_process);
 }
 
-void ReverbConvolverStage::Process(const float* source,
+void ReverbConvolverStage::Process(base::span<const float>source,
                                    uint32_t frames_to_process) {
-  DCHECK(source);
-  if (!source) {
+  DCHECK(!source.empty());
+  if (source.empty()) {
     return;
   }
 
   // Deal with pre-delay stream : note special handling of zero delay.
 
-  const float* pre_delayed_source;
-  float* pre_delayed_destination;
-  float* temporary_buffer;
+  base::span<const float>pre_delayed_source;
+  base::span<float>pre_delayed_destination;
+  base::span<float>temporary_buffer;
   bool is_temporary_buffer_safe = false;
   if (pre_delay_length_ > 0) {
     // Handles both the read case (call to process() ) and the write case
@@ -158,12 +160,12 @@ void ReverbConvolverStage::Process(const float* source,
 
     is_temporary_buffer_safe = frames_to_process <= temporary_buffer_.size();
 
-    pre_delayed_destination = pre_delay_buffer_.Data() + pre_read_write_index_;
+    pre_delayed_destination = pre_delay_buffer_.Data() .subspan( pre_read_write_index_);
     pre_delayed_source = pre_delayed_destination;
     temporary_buffer = temporary_buffer_.Data();
   } else {
     // Zero delay
-    pre_delayed_destination = nullptr;
+    pre_delayed_destination = {};
     pre_delayed_source = source;
     temporary_buffer = pre_delay_buffer_.Data();
 
@@ -189,7 +191,7 @@ void ReverbConvolverStage::Process(const float* source,
       fft_convolver_->Process(fft_kernel_.get(), pre_delayed_source,
                               temporary_buffer, frames_to_process);
     } else {
-      direct_convolver_->Process(pre_delayed_source, temporary_buffer,
+      direct_convolver_->Process(pre_delayed_source.data(), temporary_buffer,
                                  frames_to_process);
     }
 
@@ -201,7 +203,7 @@ void ReverbConvolverStage::Process(const float* source,
 
   // Finally copy input to pre-delay.
   if (pre_delay_length_ > 0) {
-    memcpy(pre_delayed_destination, source, sizeof(float) * frames_to_process);
+    memcpy(pre_delayed_destination.data(), source.data(), sizeof(float) * frames_to_process);
     pre_read_write_index_ += frames_to_process;
 
     DCHECK_LE(pre_read_write_index_, pre_delay_length_);
diff --git a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
index bdccb18cbd2f9..db380d7259205 100644
--- a/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
+++ b/third_party/blink/renderer/platform/audio/reverb_convolver_stage.h
@@ -30,6 +30,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_REVERB_CONVOLVER_STAGE_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/fft_frame.h"
@@ -53,7 +54,7 @@ class ReverbConvolverStage final {
   // renderPhase is useful to know so that we can manipulate the pre versus post
   // delay so that stages will perform their heavy work (FFT processing) on
   // different slices to balance the load in a real-time thread.
-  ReverbConvolverStage(const float* impulse_response,
+  ReverbConvolverStage(base::span<const float>impulse_response,
                        size_t response_length,
                        size_t reverb_total_latency,
                        size_t stage_offset,
@@ -69,7 +70,7 @@ class ReverbConvolverStage final {
 
   // WARNING: framesToProcess must be such that it evenly divides the delay
   // buffer size (stage_offset).
-  void Process(const float* source, uint32_t frames_to_process);
+  void Process(base::span<const float>source, uint32_t frames_to_process);
 
   void ProcessInBackground(ReverbConvolver* convolver,
                            uint32_t frames_to_process);
diff --git a/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc b/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
index b1b40d58a8c83..2ec9c5a38d1de 100644
--- a/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
+++ b/third_party/blink/renderer/platform/audio/reverb_input_buffer.cc
@@ -26,6 +26,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,7 +47,7 @@ void ReverbInputBuffer::Write(const float* source_p, size_t number_of_frames) {
 
   CHECK_LE(new_index, buffer_length);
 
-  memcpy(buffer_.Data() + index, source_p, sizeof(float) * number_of_frames);
+  memcpy(buffer_.Data() .subspan( index).data(), source_p, sizeof(float) * number_of_frames);
 
   if (new_index >= buffer_length) {
     new_index = 0;
@@ -54,14 +56,14 @@ void ReverbInputBuffer::Write(const float* source_p, size_t number_of_frames) {
   SetWriteIndex(new_index);
 }
 
-float* ReverbInputBuffer::DirectReadFrom(size_t* read_index,
+base::span<float> ReverbInputBuffer::DirectReadFrom(size_t* read_index,
                                          size_t number_of_frames) {
   uint32_t buffer_length = buffer_.size();
   DCHECK(read_index);
   DCHECK_LE(*read_index + number_of_frames, buffer_length);
 
-  float* source_p = buffer_.Data();
-  float* p = source_p + *read_index;
+  base::span<float>source_p = buffer_.Data();
+  base::span<float>p = source_p .subspan( *)read_index;
 
   // Update readIndex
   *read_index = (*read_index + number_of_frames) % buffer_length;
diff --git a/third_party/blink/renderer/platform/audio/reverb_input_buffer.h b/third_party/blink/renderer/platform/audio/reverb_input_buffer.h
index a70b1df9847ab..927b924b5e234 100644
--- a/third_party/blink/renderer/platform/audio/reverb_input_buffer.h
+++ b/third_party/blink/renderer/platform/audio/reverb_input_buffer.h
@@ -30,6 +30,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_REVERB_INPUT_BUFFER_H_
 
 #include <atomic>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
@@ -62,7 +63,7 @@ class ReverbInputBuffer final {
   // The assumption is that the buffer's length is evenly divisible by
   // numberOfFrames.
   // FIXME: remove numberOfFrames restriction...
-  float* DirectReadFrom(size_t* read_index, size_t number_of_frames);
+  base::span<float> DirectReadFrom(size_t* read_index, size_t number_of_frames);
 
   void Reset();
 
diff --git a/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc b/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
index ddc1f6b7805af..19b54476c0e78 100644
--- a/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
+++ b/third_party/blink/renderer/platform/audio/simple_fft_convolver.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -27,24 +29,24 @@ SimpleFFTConvolver::SimpleFFTConvolver(
   // Do padded FFT to get frequency-domain version of the convolution kernel.
   // This FFT and caching is done once in here so that it does not have to be
   // done repeatedly in |Process|.
-  fft_kernel_.DoPaddedFFT(convolution_kernel->Data(), convolution_kernel_size_);
+  fft_kernel_.DoPaddedFFT(convolution_kernel->Data().data(), convolution_kernel_size_);
 }
 
 void SimpleFFTConvolver::Process(const float* source_p,
-                                 float* dest_p,
+                                 base::span<float>dest_p,
                                  uint32_t frames_to_process) {
   unsigned half_size = FftSize() / 2;
 
   // frames_to_process must be exactly half_size.
   DCHECK(source_p);
-  DCHECK(dest_p);
+  DCHECK(!dest_p.empty());
   DCHECK_EQ(frames_to_process, half_size);
 
   // Do padded FFT (get frequency-domain version) by copying samples to the 1st
   // half of the input buffer (the second half is always zero), multiply in
   // frequency-domain and do inverse FFT to get output samples.
   input_buffer_.CopyToRange(source_p, 0, half_size);
-  frame_.DoFFT(input_buffer_.Data());
+  frame_.DoFFT(input_buffer_.Data().data());
   frame_.Multiply(fft_kernel_);
   frame_.DoInverseFFT(output_buffer_.Data());
 
@@ -54,7 +56,7 @@ void SimpleFFTConvolver::Process(const float* source_p,
                     dest_p, 1, half_size);
 
   // Finally, save 2nd half for the next time.
-  last_overlap_buffer_.CopyToRange(output_buffer_.Data() + half_size, 0,
+  last_overlap_buffer_.CopyToRange(output_buffer_.Data() .subspan( half_size).data(), 0,
                                    half_size);
 }
 
diff --git a/third_party/blink/renderer/platform/audio/simple_fft_convolver.h b/third_party/blink/renderer/platform/audio/simple_fft_convolver.h
index 4d6bbf394ff3d..7e95ed06671cb 100644
--- a/third_party/blink/renderer/platform/audio/simple_fft_convolver.h
+++ b/third_party/blink/renderer/platform/audio/simple_fft_convolver.h
@@ -6,6 +6,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_SIMPLE_FFT_CONVOLVER_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/fft_frame.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
@@ -29,7 +30,7 @@ class SimpleFFTConvolver final {
   SimpleFFTConvolver& operator=(const SimpleFFTConvolver&) = delete;
 
   void Process(const float* source_p,
-               float* dest_p,
+               base::span<float>dest_p,
                uint32_t frames_to_process);
 
   void Reset();
diff --git a/third_party/blink/renderer/platform/audio/sinc_resampler.cc b/third_party/blink/renderer/platform/audio/sinc_resampler.cc
index 63418db6c27af..47c967bf5551d 100644
--- a/third_party/blink/renderer/platform/audio/sinc_resampler.cc
+++ b/third_party/blink/renderer/platform/audio/sinc_resampler.cc
@@ -26,6 +26,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -139,7 +142,7 @@ void SincResampler::InitializeKernel() {
   }
 }
 
-void SincResampler::ConsumeSource(float* buffer,
+void SincResampler::ConsumeSource(base::span<float>buffer,
                                   unsigned number_of_source_frames) {
   DCHECK(source_provider_);
 
@@ -160,44 +163,44 @@ namespace {
 
 class BufferSourceProvider final : public AudioSourceProvider {
  public:
-  BufferSourceProvider(const float* source, int number_of_source_frames)
+  BufferSourceProvider(base::span<const float>source, int number_of_source_frames)
       : source_(source), source_frames_available_(number_of_source_frames) {}
 
   // Consumes samples from the in-memory buffer.
   void ProvideInput(AudioBus* bus, int frames_to_process) override {
-    DCHECK(source_);
+    DCHECK(!source_.empty());
     DCHECK(bus);
-    if (!source_ || !bus) {
+    if (!!source_.empty() || !bus) {
       return;
     }
 
-    float* buffer = bus->Channel(0)->MutableData();
+    base::span<float>buffer = bus->Channel(0)->MutableData();
 
     // Clamp to number of frames available and zero-pad.
     int frames_to_copy = std::min(source_frames_available_, frames_to_process);
-    memcpy(buffer, source_, sizeof(float) * frames_to_copy);
+    memcpy(buffer.data(), source_.data(), sizeof(float) * frames_to_copy);
 
     // Zero-pad if necessary.
     if (frames_to_copy < frames_to_process) {
-      memset(buffer + frames_to_copy, 0,
+      memset(buffer .subspan( frames_to_copy).data(), 0,
              sizeof(float) * (frames_to_process - frames_to_copy));
     }
 
     source_frames_available_ -= frames_to_copy;
-    source_ += frames_to_copy;
+    source_=source_.subspan(frames_to_copy);
   }
 
   void SetClient(AudioSourceProviderClient*) override {}
 
  private:
-  raw_ptr<const float, AllowPtrArithmetic> source_;
+  base::raw_span<const float, AllowPtrArithmetic> source_;
   int source_frames_available_;
 };
 
 }  // namespace
 
-void SincResampler::Process(const float* source,
-                            float* destination,
+void SincResampler::Process(base::span<const float>source,
+                            base::span<float>destination,
                             int number_of_source_frames) {
   // Resample an in-memory buffer using an AudioSourceProvider.
   BufferSourceProvider source_provider(source, number_of_source_frames);
@@ -210,13 +213,13 @@ void SincResampler::Process(const float* source,
     unsigned frames_this_time = std::min(remaining, block_size_);
     Process(&source_provider, destination, frames_this_time);
 
-    destination += frames_this_time;
+    destination=destination.subspan(frames_this_time);
     remaining -= frames_this_time;
   }
 }
 
 void SincResampler::Process(AudioSourceProvider* source_provider,
-                            float* destination,
+                            base::span<float>destination,
                             uint32_t frames_to_process) {
   DCHECK(source_provider);
   DCHECK_GT(block_size_, kernel_size_);
@@ -228,12 +231,12 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
   unsigned number_of_destination_frames = frames_to_process;
 
   // Setup various region pointers in the buffer (see diagram above).
-  float* r0 = input_buffer_.Data() + kernel_size_ / 2;
-  float* r1 = input_buffer_.Data();
-  float* r2 = r0;
-  float* r3 = r0 + block_size_ - kernel_size_ / 2;
-  float* r4 = r0 + block_size_;
-  float* r5 = r0 + kernel_size_ / 2;
+  base::span<float>r0 = input_buffer_.Data() .subspan( kernel_size_ / 2);
+  base::span<float>r1 = input_buffer_.Data();
+  float* r2 = r0.data();
+  float* r3 = r0 .subspan( block_size_ - kernel_size_ / 2).data();
+  float* r4 = r0 .subspan( block_size_).data();
+  base::span<float>r5 = r0 .subspan( kernel_size_ / 2);
 
   // Step (1)
   // Prime the input buffer at the start of the input stream.
@@ -255,11 +258,11 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
           subsample_remainder * number_of_kernel_offsets_;
       int offset_index = static_cast<int>(virtual_offset_index);
 
-      float* k1 = kernel_storage_.Data() + offset_index * kernel_size_;
-      float* k2 = k1 + kernel_size_;
+      base::span<float>k1 = kernel_storage_.Data() .subspan( offset_index * kernel_size_);
+      base::span<float>k2 = k1 .subspan( kernel_size_);
 
       // Initialize input pointer based on quantized m_virtualSourceIndex.
-      float* input_p = r1 + source_index_i;
+      base::span<float>input_p = r1 .subspan( source_index_i);
 
       // We'll compute "convolutions" for the two kernels which straddle
       // m_virtualSourceIndex
@@ -293,7 +296,7 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
         }
 
         // Now the inputP is aligned and start to apply SSE.
-        float* end_p = input_p + n - n % 4;
+        float* end_p = input_p .subspan( n - n % 4).data();
         __m128 m_input;
         __m128 m_k1;
         __m128 m_k2;
@@ -307,9 +310,9 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
 
 #define LOAD_DATA(l1, l2)           \
   do {                              \
-    m_input = _mm_load_ps(input_p); \
-    m_k1 = _mm_##l1##_ps(k1);       \
-    m_k2 = _mm_##l2##_ps(k2);       \
+    m_input = _mm_load_ps(input_p.data()); \
+    m_k1 = _mm_##l1##_ps(k1.data());       \
+    m_k2 = _mm_##l2##_ps(k2.data());       \
   } while (0)
 
 #define CONVOLVE_4_SAMPLES()          \
@@ -478,7 +481,7 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
       double result = (1.0 - kernel_interpolation_factor) * sum1 +
                       kernel_interpolation_factor * sum2;
 
-      *destination++ = result;
+      (destination++)[0] = result;
 
       // Advance the virtual index.
       virtual_source_index_ += scale_factor_;
@@ -494,7 +497,7 @@ void SincResampler::Process(AudioSourceProvider* source_provider,
 
     // Step (3) Copy r3 to r1 and r4 to r2.
     // This wraps the last input frames back to the start of the buffer.
-    memcpy(r1, r3, sizeof(float) * (kernel_size_ / 2));
+    memcpy(r1.data(), r3, sizeof(float) * (kernel_size_ / 2));
     memcpy(r2, r4, sizeof(float) * (kernel_size_ / 2));
 
     // Step (4)
diff --git a/third_party/blink/renderer/platform/audio/sinc_resampler.h b/third_party/blink/renderer/platform/audio/sinc_resampler.h
index 0360ea8907c6a..b6a5d25f89511 100644
--- a/third_party/blink/renderer/platform/audio/sinc_resampler.h
+++ b/third_party/blink/renderer/platform/audio/sinc_resampler.h
@@ -29,6 +29,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_SINC_RESAMPLER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_SINC_RESAMPLER_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/audio_source_provider.h"
@@ -55,18 +56,18 @@ class SincResampler final {
 
   // Processes numberOfSourceFrames from source to produce numberOfSourceFrames
   // / scaleFactor frames in destination.
-  void Process(const float* source,
-               float* destination,
+  void Process(base::span<const float>source,
+               base::span<float>destination,
                int number_of_source_frames);
 
   // Process with input source callback function for streaming applications.
   void Process(AudioSourceProvider*,
-               float* destination,
+               base::span<float>destination,
                uint32_t frames_to_process);
 
  protected:
   void InitializeKernel();
-  void ConsumeSource(float* buffer, unsigned number_of_source_frames);
+  void ConsumeSource(base::span<float>buffer, unsigned number_of_source_frames);
 
   double scale_factor_;
   unsigned kernel_size_;
diff --git a/third_party/blink/renderer/platform/audio/stereo_panner.cc b/third_party/blink/renderer/platform/audio/stereo_panner.cc
index 6cb6630d202bd..bc38a7d19ad9e 100644
--- a/third_party/blink/renderer/platform/audio/stereo_panner.cc
+++ b/third_party/blink/renderer/platform/audio/stereo_panner.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -27,7 +29,7 @@ StereoPanner::StereoPanner(float sample_rate) {}
 
 void StereoPanner::PanWithSampleAccurateValues(const AudioBus* input_bus,
                                                AudioBus* output_bus,
-                                               const float* pan_values,
+                                               base::span<const float>pan_values,
                                                uint32_t frames_to_process) {
   DCHECK(input_bus);
   DCHECK_LE(frames_to_process, input_bus->length());
@@ -40,15 +42,15 @@ void StereoPanner::PanWithSampleAccurateValues(const AudioBus* input_bus,
   DCHECK_EQ(output_bus->NumberOfChannels(), 2u);
   DCHECK_LE(frames_to_process, output_bus->length());
 
-  const float* source_l = input_bus->Channel(0)->Data();
-  const float* source_r =
+  base::span<const float>source_l = input_bus->Channel(0)->Data();
+  base::span<const float>source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
-  float* destination_l =
+  base::span<float>destination_l =
       output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
-  float* destination_r =
+  base::span<float>destination_r =
       output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
 
-  if (!source_l || !source_r || !destination_l || !destination_r) {
+  if (source_l.empty() || source_r.empty() || destination_l.empty() || destination_r.empty()) {
     return;
   }
 
@@ -58,30 +60,30 @@ void StereoPanner::PanWithSampleAccurateValues(const AudioBus* input_bus,
 
   if (number_of_input_channels == 1) {  // For mono source case.
     while (n--) {
-      float input_l = *source_l++;
-      double pan = ClampTo(*pan_values++, -1.0, 1.0);
+      float input_l = (source_l++)[0];
+      double pan = ClampTo((pan_values++)[0], -1.0, 1.0);
       // Pan from left to right [-1; 1] will be normalized as [0; 1].
       pan_radian = (pan * 0.5 + 0.5) * kPiOverTwoDouble;
       gain_l = fdlibm::cos(pan_radian);
       gain_r = fdlibm::sin(pan_radian);
-      *destination_l++ = static_cast<float>(input_l * gain_l);
-      *destination_r++ = static_cast<float>(input_l * gain_r);
+      (destination_l++)[0] = static_cast<float>(input_l * gain_l);
+      (destination_r++)[0] = static_cast<float>(input_l * gain_r);
     }
   } else {  // For stereo source case.
     while (n--) {
-      float input_l = *source_l++;
-      float input_r = *source_r++;
-      double pan = ClampTo(*pan_values++, -1.0, 1.0);
+      float input_l = (source_l++)[0];
+      float input_r = (source_r++)[0];
+      double pan = ClampTo((pan_values++)[0], -1.0, 1.0);
       // Normalize [-1; 0] to [0; 1]. Do nothing when [0; 1].
       pan_radian = (pan <= 0 ? pan + 1 : pan) * kPiOverTwoDouble;
       gain_l = fdlibm::cos(pan_radian);
       gain_r = fdlibm::sin(pan_radian);
       if (pan <= 0) {
-        *destination_l++ = static_cast<float>(input_l + input_r * gain_l);
-        *destination_r++ = static_cast<float>(input_r * gain_r);
+        (destination_l++)[0] = static_cast<float>(input_l + input_r * gain_l);
+        (destination_r++)[0] = static_cast<float>(input_r * gain_r);
       } else {
-        *destination_l++ = static_cast<float>(input_l * gain_l);
-        *destination_r++ = static_cast<float>(input_r + input_l * gain_r);
+        (destination_l++)[0] = static_cast<float>(input_l * gain_l);
+        (destination_r++)[0] = static_cast<float>(input_r + input_l * gain_r);
       }
     }
   }
@@ -102,15 +104,15 @@ void StereoPanner::PanToTargetValue(const AudioBus* input_bus,
   DCHECK_EQ(output_bus->NumberOfChannels(), 2u);
   DCHECK_LE(frames_to_process, output_bus->length());
 
-  const float* source_l = input_bus->Channel(0)->Data();
-  const float* source_r =
+  base::span<const float>source_l = input_bus->Channel(0)->Data();
+  base::span<const float>source_r =
       number_of_input_channels > 1 ? input_bus->Channel(1)->Data() : source_l;
-  float* destination_l =
+  base::span<float>destination_l =
       output_bus->ChannelByType(AudioBus::kChannelLeft)->MutableData();
-  float* destination_r =
+  base::span<float>destination_r =
       output_bus->ChannelByType(AudioBus::kChannelRight)->MutableData();
 
-  if (!source_l || !source_r || !destination_l || !destination_r) {
+  if (source_l.empty() || source_r.empty() || destination_l.empty() || destination_r.empty()) {
     return;
   }
 
@@ -127,9 +129,9 @@ void StereoPanner::PanToTargetValue(const AudioBus* input_bus,
 
     // TODO(rtoy): This can be vectorized using vector_math::Vsmul
     while (n--) {
-      float input_l = *source_l++;
-      *destination_l++ = static_cast<float>(input_l * gain_l);
-      *destination_r++ = static_cast<float>(input_l * gain_r);
+      float input_l = (source_l++)[0];
+      (destination_l++)[0] = static_cast<float>(input_l * gain_l);
+      (destination_r++)[0] = static_cast<float>(input_l * gain_r);
     }
   } else {  // For stereo source case.
     // Normalize [-1; 0] to [0; 1] for the left pan position (<= 0), and
@@ -143,18 +145,18 @@ void StereoPanner::PanToTargetValue(const AudioBus* input_bus,
     // TODO(rtoy): Consider moving the if statement outside the loop
     // since |target_pan| is constant inside the loop.
     while (n--) {
-      float input_l = *source_l++;
-      float input_r = *source_r++;
+      float input_l = (source_l++)[0];
+      float input_r = (source_r++)[0];
       if (target_pan <= 0) {
         // When [-1; 0], keep left channel intact and equal-power pan the
         // right channel only.
-        *destination_l++ = static_cast<float>(input_l + input_r * gain_l);
-        *destination_r++ = static_cast<float>(input_r * gain_r);
+        (destination_l++)[0] = static_cast<float>(input_l + input_r * gain_l);
+        (destination_r++)[0] = static_cast<float>(input_r * gain_r);
       } else {
         // When [0; 1], keep right channel intact and equal-power pan the
         // left channel only.
-        *destination_l++ = static_cast<float>(input_l * gain_l);
-        *destination_r++ = static_cast<float>(input_r + input_l * gain_r);
+        (destination_l++)[0] = static_cast<float>(input_l * gain_l);
+        (destination_r++)[0] = static_cast<float>(input_r + input_l * gain_r);
       }
     }
   }
diff --git a/third_party/blink/renderer/platform/audio/stereo_panner.h b/third_party/blink/renderer/platform/audio/stereo_panner.h
index 0d738505fbeb2..1fdc313c11067 100644
--- a/third_party/blink/renderer/platform/audio/stereo_panner.h
+++ b/third_party/blink/renderer/platform/audio/stereo_panner.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_STEREO_PANNER_H_
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_STEREO_PANNER_H_
 
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 
@@ -26,7 +27,7 @@ class PLATFORM_EXPORT StereoPanner final {
 
   void PanWithSampleAccurateValues(const AudioBus* input_bus,
                                    AudioBus* output_bus,
-                                   const float* pan_values,
+                                   base::span<const float>pan_values,
                                    uint32_t frames_to_process);
   void PanToTargetValue(const AudioBus* input_bus,
                         AudioBus* output_bus,
diff --git a/third_party/blink/renderer/platform/audio/up_sampler.cc b/third_party/blink/renderer/platform/audio/up_sampler.cc
index e24c025bf234a..30aee1ca67923 100644
--- a/third_party/blink/renderer/platform/audio/up_sampler.cc
+++ b/third_party/blink/renderer/platform/audio/up_sampler.cc
@@ -28,6 +28,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -100,7 +102,7 @@ UpSampler::UpSampler(unsigned input_block_size)
 }
 
 void UpSampler::Process(const float* source_p,
-                        float* dest_p,
+                        base::span<float>dest_p,
                         uint32_t source_frames_to_process) {
   const size_t convolution_kernel_size =
       direct_convolver_ ? direct_convolver_->ConvolutionKernelSize()
@@ -116,7 +118,7 @@ void UpSampler::Process(const float* source_p,
   DCHECK_LE(half_size, source_frames_to_process);
 
   // Copy source samples to 2nd half of input buffer.
-  float* input_p = input_buffer_.Data() + source_frames_to_process;
+  float* input_p = input_buffer_.Data() .subspan( source_frames_to_process).data();
   memcpy(input_p, source_p, sizeof(float) * source_frames_to_process);
 
   // Copy even sample-frames 0,2,4,6... (delayed by the linear phase delay)
@@ -126,7 +128,7 @@ void UpSampler::Process(const float* source_p,
   }
 
   // Compute odd sample-frames 1,3,5,7...
-  float* odd_samples_p = temp_buffer_.Data();
+  base::span<float>odd_samples_p = temp_buffer_.Data();
   if (direct_convolver_) {
     direct_convolver_->Process(source_p, odd_samples_p,
                                source_frames_to_process);
@@ -140,7 +142,7 @@ void UpSampler::Process(const float* source_p,
   }
 
   // Copy 2nd half of input buffer to 1st half.
-  memcpy(input_buffer_.Data(), input_p,
+  memcpy(input_buffer_.Data().data(), input_p,
          sizeof(float) * source_frames_to_process);
 }
 
diff --git a/third_party/blink/renderer/platform/audio/up_sampler.h b/third_party/blink/renderer/platform/audio/up_sampler.h
index 5238d91cae486..2204e8e4b6e13 100644
--- a/third_party/blink/renderer/platform/audio/up_sampler.h
+++ b/third_party/blink/renderer/platform/audio/up_sampler.h
@@ -32,6 +32,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_UP_SAMPLER_H_
 
 #include <memory>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/audio/direct_convolver.h"
 #include "third_party/blink/renderer/platform/audio/simple_fft_convolver.h"
@@ -52,7 +53,7 @@ class PLATFORM_EXPORT UpSampler final {
 
   // The destination buffer |destP| is of size sourceFramesToProcess * 2.
   void Process(const float* source_p,
-               float* dest_p,
+               base::span<float>dest_p,
                uint32_t source_frames_to_process);
 
   void Reset();
diff --git a/third_party/blink/renderer/platform/audio/vector_math.cc b/third_party/blink/renderer/platform/audio/vector_math.cc
index c16a05b950812..7f0ba1dcb5637 100644
--- a/third_party/blink/renderer/platform/audio/vector_math.cc
+++ b/third_party/blink/renderer/platform/audio/vector_math.cc
@@ -23,6 +23,8 @@
  * DAMAGE.
  */
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -78,11 +80,11 @@ void PrepareFilterForConv(const float* filter_p,
 #endif
 }
 
-void Conv(const float* source_p,
+void Conv(base::span<const float>source_p,
           int source_stride,
           const float* filter_p,
           int filter_stride,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process,
           size_t filter_size,
@@ -97,33 +99,33 @@ void Conv(const float* source_p,
              dest_stride, frames_to_process, filter_size, prepared_filter);
 }
 
-void Vadd(const float* source1p,
+void Vadd(base::span<const float>source1p,
           int source_stride1,
-          const float* source2p,
+          base::span<const float>source2p,
           int source_stride2,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process) {
   impl::Vadd(source1p, source_stride1, source2p, source_stride2, dest_p,
              dest_stride, frames_to_process);
 }
 
-void Vsub(const float* source1p,
+void Vsub(base::span<const float>source1p,
           int source_stride1,
-          const float* source2p,
+          base::span<const float>source2p,
           int source_stride2,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process) {
   impl::Vsub(source1p, source_stride1, source2p, source_stride2, dest_p,
              dest_stride, frames_to_process);
 }
 
-void Vclip(const float* source_p,
+void Vclip(base::span<const float>source_p,
            int source_stride,
            const float* low_threshold_p,
            const float* high_threshold_p,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   float low_threshold = *low_threshold_p;
@@ -143,11 +145,11 @@ void Vclip(const float* source_p,
               dest_stride, frames_to_process);
 }
 
-void Vclip(const float* source_p,
+void Vclip(base::span<const float>source_p,
            int source_stride,
            float low_threshold_p,
            float high_threshold_p,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   float low_threshold = low_threshold_p;
@@ -167,7 +169,7 @@ void Vclip(const float* source_p,
               dest_stride, frames_to_process);
 }
 
-void Vmaxmgv(const float* source_p,
+void Vmaxmgv(base::span<const float>source_p,
              int source_stride,
              float* max_p,
              uint32_t frames_to_process) {
@@ -179,21 +181,21 @@ void Vmaxmgv(const float* source_p,
   *max_p = max;
 }
 
-void Vmul(const float* source1p,
+void Vmul(base::span<const float>source1p,
           int source_stride1,
-          const float* source2p,
+          base::span<const float>source2p,
           int source_stride2,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process) {
   impl::Vmul(source1p, source_stride1, source2p, source_stride2, dest_p,
              dest_stride, frames_to_process);
 }
 
-void Vsma(const float* source_p,
+void Vsma(base::span<const float>source_p,
           int source_stride,
           const float* scale,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process) {
   const float k = *scale;
@@ -202,10 +204,10 @@ void Vsma(const float* source_p,
              frames_to_process);
 }
 
-void Vsma(const float* source_p,
+void Vsma(base::span<const float>source_p,
           int source_stride,
           float scale,
-          float* dest_p,
+          base::span<float>dest_p,
           int dest_stride,
           uint32_t frames_to_process) {
   const float k = scale;
@@ -214,10 +216,10 @@ void Vsma(const float* source_p,
              frames_to_process);
 }
 
-void Vsmul(const float* source_p,
+void Vsmul(base::span<const float>source_p,
            int source_stride,
            const float* scale,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   const float k = *scale;
@@ -226,10 +228,10 @@ void Vsmul(const float* source_p,
               frames_to_process);
 }
 
-void Vsmul(const float* source_p,
+void Vsmul(base::span<const float>source_p,
            int source_stride,
            float scale,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   const float k = scale;
@@ -238,10 +240,10 @@ void Vsmul(const float* source_p,
               frames_to_process);
 }
 
-void Vsadd(const float* source_p,
+void Vsadd(base::span<const float>source_p,
            int source_stride,
            const float* addend,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   const float k = *addend;
@@ -250,10 +252,10 @@ void Vsadd(const float* source_p,
               frames_to_process);
 }
 
-void Vsadd(const float* source_p,
+void Vsadd(base::span<const float>source_p,
            int source_stride,
            float addend,
-           float* dest_p,
+           base::span<float>dest_p,
            int dest_stride,
            uint32_t frames_to_process) {
   const float k = addend;
@@ -262,7 +264,7 @@ void Vsadd(const float* source_p,
               frames_to_process);
 }
 
-void Vsvesq(const float* source_p,
+void Vsvesq(base::span<const float>source_p,
             int source_stride,
             float* sum_p,
             uint32_t frames_to_process) {
@@ -274,12 +276,12 @@ void Vsvesq(const float* source_p,
   *sum_p = sum;
 }
 
-void Zvmul(const float* real1p,
-           const float* imag1p,
-           const float* real2p,
-           const float* imag2p,
-           float* real_dest_p,
-           float* imag_dest_p,
+void Zvmul(base::span<const float>real1p,
+           base::span<const float>imag1p,
+           base::span<const float>real2p,
+           base::span<const float>imag2p,
+           base::span<float>real_dest_p,
+           base::span<float>imag_dest_p,
            uint32_t frames_to_process) {
   impl::Zvmul(real1p, imag1p, real2p, imag2p, real_dest_p, imag_dest_p,
               frames_to_process);
diff --git a/third_party/blink/renderer/platform/audio/vector_math.h b/third_party/blink/renderer/platform/audio/vector_math.h
index e7657ed2155bc..b2b0663a628de 100644
--- a/third_party/blink/renderer/platform/audio/vector_math.h
+++ b/third_party/blink/renderer/platform/audio/vector_math.h
@@ -27,6 +27,7 @@
 #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_AUDIO_VECTOR_MATH_H_
 
 #include <cstddef>
+#include "base/containers/span.h"
 #include "third_party/blink/renderer/platform/audio/audio_array.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 
@@ -39,11 +40,11 @@ namespace blink::vector_math {
 //
 // dest[k*dest_stride] =
 //     sum(source[(k+m)*source_stride]*filter[m*filter_stride]) for all m
-PLATFORM_EXPORT void Conv(const float* source_p,
+PLATFORM_EXPORT void Conv(base::span<const float>source_p,
                           int source_stride,
                           const float* filter_p,
                           int filter_stride,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process,
                           size_t filter_size,
@@ -61,76 +62,76 @@ PLATFORM_EXPORT void PrepareFilterForConv(const float* filter_p,
 //
 // Note: Mac has a different implementation, and it may produce slightly
 // different results from what linux and windows would do.
-PLATFORM_EXPORT void Vsma(const float* source_p,
+PLATFORM_EXPORT void Vsma(base::span<const float>source_p,
                           int source_stride,
                           const float* scale,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process);
 
-PLATFORM_EXPORT void Vsma(const float* source_p,
+PLATFORM_EXPORT void Vsma(base::span<const float>source_p,
                           int source_stride,
                           float scale,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process);
 
 // Vector scalar multiply:
 //
 // dest[k*dest_stride] = scale * source[k*source_stride]
-PLATFORM_EXPORT void Vsmul(const float* source_p,
+PLATFORM_EXPORT void Vsmul(base::span<const float>source_p,
                            int source_stride,
                            const float* scale,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 
-PLATFORM_EXPORT void Vsmul(const float* source_p,
+PLATFORM_EXPORT void Vsmul(base::span<const float>source_p,
                            int source_stride,
                            float scale,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 
-PLATFORM_EXPORT void Vsadd(const float* source_p,
+PLATFORM_EXPORT void Vsadd(base::span<const float>source_p,
                            int source_stride,
                            const float* addend,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 
-PLATFORM_EXPORT void Vsadd(const float* source_p,
+PLATFORM_EXPORT void Vsadd(base::span<const float>source_p,
                            int source_stride,
                            float addend,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 // Vector add:
 //
 // dest[k*dest_stride] = source1[k*source_stride1] + source2[k*source_stride2]
-PLATFORM_EXPORT void Vadd(const float* source1p,
+PLATFORM_EXPORT void Vadd(base::span<const float>source1p,
                           int source_stride1,
-                          const float* source2p,
+                          base::span<const float>source2p,
                           int source_stride2,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process);
 
 // Vector subtract:
 //
 // dest[k*dest_stride] = source1[k*source_stride1] - source2[k*source_stride2]
-PLATFORM_EXPORT void Vsub(const float* source1p,
+PLATFORM_EXPORT void Vsub(base::span<const float>source1p,
                           int source_stride1,
-                          const float* source2p,
+                          base::span<const float>source2p,
                           int source_stride2,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process);
 
 // Finds the maximum magnitude of a float vector:
 //
 // max = max(abs(source[k*source_stride])) for all k.
-PLATFORM_EXPORT void Vmaxmgv(const float* source_p,
+PLATFORM_EXPORT void Vmaxmgv(base::span<const float>source_p,
                              int source_stride,
                              float* max_p,
                              uint32_t frames_to_process);
@@ -138,7 +139,7 @@ PLATFORM_EXPORT void Vmaxmgv(const float* source_p,
 // Sums the squares of a float vector's elements:
 //
 // sum = sum(source[k*source_stride]^2, k = 0, frames_to_process);
-PLATFORM_EXPORT void Vsvesq(const float* source_p,
+PLATFORM_EXPORT void Vsvesq(base::span<const float>source_p,
                             int source_stride,
                             float* sum_p,
                             uint32_t frames_to_process);
@@ -146,11 +147,11 @@ PLATFORM_EXPORT void Vsvesq(const float* source_p,
 // For an element-by-element multiply of two float vectors:
 //
 // dest[k*dest_stride] = source1[k*source_stride1] * source2[k*source_stride2]
-PLATFORM_EXPORT void Vmul(const float* source1p,
+PLATFORM_EXPORT void Vmul(base::span<const float>source1p,
                           int source_stride1,
-                          const float* source2p,
+                          base::span<const float>source2p,
                           int source_stride2,
-                          float* dest_p,
+                          base::span<float>dest_p,
                           int dest_stride,
                           uint32_t frames_to_process);
 
@@ -158,12 +159,12 @@ PLATFORM_EXPORT void Vmul(const float* source1p,
 // |imag1p| forms the real and complex components of source1; |real2p| and
 // |imag2p| the components of source2, and |real_dest_p| and |imag_dest_p|, the
 // components of the destination.
-PLATFORM_EXPORT void Zvmul(const float* real1p,
-                           const float* imag1p,
-                           const float* real2p,
-                           const float* imag2p,
-                           float* real_dest_p,
-                           float* imag_dest_p,
+PLATFORM_EXPORT void Zvmul(base::span<const float>real1p,
+                           base::span<const float>imag1p,
+                           base::span<const float>real2p,
+                           base::span<const float>imag2p,
+                           base::span<float>real_dest_p,
+                           base::span<float>imag_dest_p,
                            uint32_t frames_to_process);
 
 // Copies elements while clipping values to the threshold inputs.
@@ -172,19 +173,19 @@ PLATFORM_EXPORT void Zvmul(const float* real1p,
 //
 // where y = clip(x, low, high) = max(low, min(x, high)), effectively making
 // low <= y <= high.
-PLATFORM_EXPORT void Vclip(const float* source_p,
+PLATFORM_EXPORT void Vclip(base::span<const float>source_p,
                            int source_stride,
                            const float* low_threshold_p,
                            const float* high_threshold_p,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 
-PLATFORM_EXPORT void Vclip(const float* source_p,
+PLATFORM_EXPORT void Vclip(base::span<const float>source_p,
                            int source_stride,
                            float low_threshold_p,
                            float high_threshold_p,
-                           float* dest_p,
+                           base::span<float>dest_p,
                            int dest_stride,
                            uint32_t frames_to_process);
 
diff --git a/third_party/blink/renderer/platform/audio/vector_math_scalar.h b/third_party/blink/renderer/platform/audio/vector_math_scalar.h
index 4733ccad19321..18843225121ff 100644
--- a/third_party/blink/renderer/platform/audio/vector_math_scalar.h
+++ b/third_party/blink/renderer/platform/audio/vector_math_scalar.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -21,11 +23,11 @@ namespace blink {
 namespace vector_math {
 namespace scalar {
 
-ALWAYS_INLINE static void Conv(const float* source_p,
+ALWAYS_INLINE static void Conv(base::span<const float>source_p,
                                int source_stride,
                                const float* filter_p,
                                int filter_stride,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process,
                                size_t filter_size,
@@ -313,143 +315,143 @@ ALWAYS_INLINE static void Conv(const float* source_p,
 #undef CONVOLVE_ONE_SAMPLE
 }
 
-ALWAYS_INLINE static void Vadd(const float* source1p,
+ALWAYS_INLINE static void Vadd(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    *dest_p = *source1p + *source2p;
-    source1p += source_stride1;
-    source2p += source_stride2;
-    dest_p += dest_stride;
+     dest_p[0] =  source1p[0] +  source2p[0];
+    source1p=source1p.subspan(source_stride1);
+    source2p=source2p.subspan(source_stride2);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vsub(const float* source1p,
+ALWAYS_INLINE static void Vsub(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    *dest_p = *source1p - *source2p;
-    source1p += source_stride1;
-    source2p += source_stride2;
-    dest_p += dest_stride;
+     dest_p[0] =  source1p[0] -  source2p[0];
+    source1p=source1p.subspan(source_stride1);
+    source2p=source2p.subspan(source_stride2);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vclip(const float* source_p,
+ALWAYS_INLINE static void Vclip(base::span<const float>source_p,
                                 int source_stride,
                                 const float* low_threshold_p,
                                 const float* high_threshold_p,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    *dest_p = ClampTo(*source_p, *low_threshold_p, *high_threshold_p);
-    source_p += source_stride;
-    dest_p += dest_stride;
+     dest_p[0] = ClampTo( source_p[0], *low_threshold_p, *high_threshold_p);
+    source_p=source_p.subspan(source_stride);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vmaxmgv(const float* source_p,
+ALWAYS_INLINE static void Vmaxmgv(base::span<const float>source_p,
                                   int source_stride,
                                   float* max_p,
                                   uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    *max_p = std::max(*max_p, std::abs(*source_p));
-    source_p += source_stride;
+    *max_p = std::max(*max_p, std::abs( source_p[0]));
+    source_p=source_p.subspan(source_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vmul(const float* source1p,
+ALWAYS_INLINE static void Vmul(base::span<const float>source1p,
                                int source_stride1,
-                               const float* source2p,
+                               base::span<const float>source2p,
                                int source_stride2,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    *dest_p = *source1p * *source2p;
-    source1p += source_stride1;
-    source2p += source_stride2;
-    dest_p += dest_stride;
+     dest_p[0] =  source1p[0] *  source2p[0];
+    source1p=source1p.subspan(source_stride1);
+    source2p=source2p.subspan(source_stride2);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vsma(const float* source_p,
+ALWAYS_INLINE static void Vsma(base::span<const float>source_p,
                                int source_stride,
                                const float* scale,
-                               float* dest_p,
+                               base::span<float>dest_p,
                                int dest_stride,
                                uint32_t frames_to_process) {
   const float k = *scale;
   while (frames_to_process > 0u) {
-    *dest_p += k * *source_p;
-    source_p += source_stride;
-    dest_p += dest_stride;
+     dest_p[0] += k *  source_p[0];
+    source_p=source_p.subspan(source_stride);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vsmul(const float* source_p,
+ALWAYS_INLINE static void Vsmul(base::span<const float>source_p,
                                 int source_stride,
                                 const float* scale,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   const float k = *scale;
   while (frames_to_process > 0u) {
-    *dest_p = k * *source_p;
-    source_p += source_stride;
-    dest_p += dest_stride;
+     dest_p[0] = k *  source_p[0];
+    source_p=source_p.subspan(source_stride);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vsadd(const float* source_p,
+ALWAYS_INLINE static void Vsadd(base::span<const float>source_p,
                                 int source_stride,
                                 const float* addend,
-                                float* dest_p,
+                                base::span<float>dest_p,
                                 int dest_stride,
                                 uint32_t frames_to_process) {
   const float k = *addend;
   while (frames_to_process > 0u) {
-    *dest_p = *source_p + k;
-    source_p += source_stride;
-    dest_p += dest_stride;
+     dest_p[0] =  source_p[0] + k;
+    source_p=source_p.subspan(source_stride);
+    dest_p=dest_p.subspan(dest_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Vsvesq(const float* source_p,
+ALWAYS_INLINE static void Vsvesq(base::span<const float>source_p,
                                  int source_stride,
                                  float* sum_p,
                                  uint32_t frames_to_process) {
   while (frames_to_process > 0u) {
-    const float sample = *source_p;
+    const float sample =  source_p[0];
     *sum_p += sample * sample;
-    source_p += source_stride;
+    source_p=source_p.subspan(source_stride);
     --frames_to_process;
   }
 }
 
-ALWAYS_INLINE static void Zvmul(const float* real1p,
-                                const float* imag1p,
-                                const float* real2p,
-                                const float* imag2p,
-                                float* real_dest_p,
-                                float* imag_dest_p,
+ALWAYS_INLINE static void Zvmul(base::span<const float>real1p,
+                                base::span<const float>imag1p,
+                                base::span<const float>real2p,
+                                base::span<const float>imag2p,
+                                base::span<float>real_dest_p,
+                                base::span<float>imag_dest_p,
                                 uint32_t frames_to_process) {
   for (size_t i = 0u; i < frames_to_process; ++i) {
     // Read and compute result before storing them, in case the
diff --git a/third_party/blink/renderer/platform/audio/vector_math_test.cc b/third_party/blink/renderer/platform/audio/vector_math_test.cc
index b372fd1a0afea..b6d4d136065df 100644
--- a/third_party/blink/renderer/platform/audio/vector_math_test.cc
+++ b/third_party/blink/renderer/platform/audio/vector_math_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -148,7 +150,7 @@ class TestVector {
   ReverseIterator rbegin() const { return ReverseIterator(end()); }
   ReverseIterator rend() const { return ReverseIterator(begin()); }
   const MemoryLayout* memory_layout() const { return memory_layout_; }
-  T* p() const { return p_; }
+  base::span<T> p() const { return p_; }
   size_t size() const { return size_; }
   int stride() const { return static_cast<int>(memory_layout()->stride); }
 
diff --git a/third_party/blink/renderer/platform/exported/web_audio_bus.cc b/third_party/blink/renderer/platform/exported/web_audio_bus.cc
index c62ef4c5511d9..804f3079e5815 100644
--- a/third_party/blink/renderer/platform/exported/web_audio_bus.cc
+++ b/third_party/blink/renderer/platform/exported/web_audio_bus.cc
@@ -80,7 +80,7 @@ float* WebAudioBus::ChannelData(unsigned channel_index) {
   if (!private_)
     return nullptr;
   DCHECK_LT(channel_index, NumberOfChannels());
-  return private_->Channel(channel_index)->MutableData();
+  return private_->Channel(channel_index)->MutableData().data();
 }
 
 scoped_refptr<AudioBus> WebAudioBus::Release() {
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
index 3acbfc966fc11..f8f3bc3586bda 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -105,13 +107,13 @@ WebContentDecryptionModuleImpl::CreateSession(
 }
 
 void WebContentDecryptionModuleImpl::SetServerCertificate(
-    const uint8_t* server_certificate,
+    base::span<const uint8_t>server_certificate,
     size_t server_certificate_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(server_certificate);
+  DCHECK(!server_certificate.empty());
   adapter_->SetServerCertificate(
-      std::vector<uint8_t>(server_certificate,
-                           server_certificate + server_certificate_length),
+      std::vector<uint8_t>(server_certificate.data(),
+                           server_certificate .subspan( server_certificate_length).data()),
       std::make_unique<CdmResultPromise<>>(result,
                                            adapter_->GetKeySystemUMAPrefix(),
                                            kSetServerCertificateUMAName));
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
index 1e2e6f1409cf6..0957f6e5a175e 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_impl.h
@@ -11,6 +11,7 @@
 #include <memory>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/functional/callback_forward.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/types/pass_key.h"
@@ -57,7 +58,7 @@ class PLATFORM_EXPORT WebContentDecryptionModuleImpl
   // WebContentDecryptionModule implementation.
   std::unique_ptr<WebContentDecryptionModuleSession> CreateSession(
       WebEncryptedMediaSessionType session_type) override;
-  void SetServerCertificate(const uint8_t* server_certificate,
+  void SetServerCertificate(base::span<const uint8_t>server_certificate,
                             size_t server_certificate_length,
                             WebContentDecryptionModuleResult result) override;
   void GetStatusForPolicy(const WebString& min_hdcp_version_string,
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
index 25daf6d0f5b9f..0087af01a1fa3 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -63,7 +65,7 @@ media::CdmSessionType ConvertSessionType(
 }
 
 bool SanitizeInitData(media::EmeInitDataType init_data_type,
-                      const unsigned char* init_data,
+                      base::span<const unsigned char>init_data,
                       size_t init_data_length,
                       std::vector<uint8_t>* sanitized_init_data,
                       std::string* error_message) {
@@ -80,11 +82,11 @@ bool SanitizeInitData(media::EmeInitDataType init_data_type,
         error_message->assign("Initialization data for WebM is too long.");
         return false;
       }
-      sanitized_init_data->assign(init_data, init_data + init_data_length);
+      sanitized_init_data->assign(init_data.data(), init_data .subspan( init_data_length).data());
       return true;
 
     case media::EmeInitDataType::CENC:
-      sanitized_init_data->assign(init_data, init_data + init_data_length);
+      sanitized_init_data->assign(init_data.data(), init_data .subspan( init_data_length).data());
       if (!media::ValidatePsshInput(*sanitized_init_data)) {
         error_message->assign("Initialization data for CENC is incorrect.");
         return false;
@@ -94,7 +96,7 @@ bool SanitizeInitData(media::EmeInitDataType init_data_type,
     case media::EmeInitDataType::KEYIDS: {
       // Extract the keys and then rebuild the message. This ensures that any
       // extra data in the provided JSON is dropped.
-      std::string init_data_string(init_data, init_data + init_data_length);
+      std::string init_data_string(init_data.data(), init_data .subspan( init_data_length).data());
       media::KeyIdList key_ids;
       if (!media::ExtractKeyIdsFromKeyIdsInitData(init_data_string, &key_ids,
                                                   error_message))
@@ -144,7 +146,7 @@ bool SanitizeSessionId(const WebString& session_id,
 }
 
 bool SanitizeResponse(const std::string& key_system,
-                      const uint8_t* response,
+                      base::span<const uint8_t>response,
                       size_t response_length,
                       std::vector<uint8_t>* sanitized_response) {
   // The user agent should thoroughly validate the response before passing it
@@ -157,7 +159,7 @@ bool SanitizeResponse(const std::string& key_system,
     return false;
 
   if (media::IsClearKey(key_system) || media::IsExternalClearKey(key_system)) {
-    std::string key_string(response, response + response_length);
+    std::string key_string(response.data(), response .subspan( response_length).data());
     media::KeyIdAndKeyPairs keys;
     auto session_type = media::CdmSessionType::kTemporary;
     if (!ExtractKeysFromJWKSet(key_string, &keys, &session_type))
@@ -180,7 +182,7 @@ bool SanitizeResponse(const std::string& key_system,
   }
 
   // TODO(jrummell): Verify responses for Widevine.
-  sanitized_response->assign(response, response + response_length);
+  sanitized_response->assign(response.data(), response .subspan( response_length).data());
   return true;
 }
 
@@ -292,10 +294,10 @@ WebString WebContentDecryptionModuleSessionImpl::SessionId() const {
 
 void WebContentDecryptionModuleSessionImpl::InitializeNewSession(
     media::EmeInitDataType eme_init_data_type,
-    const unsigned char* init_data,
+    base::span<const unsigned char>init_data,
     size_t init_data_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(init_data);
+  DCHECK(!init_data.empty());
   DCHECK(session_id_.empty());
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
@@ -402,10 +404,10 @@ void WebContentDecryptionModuleSessionImpl::Load(
 }
 
 void WebContentDecryptionModuleSessionImpl::Update(
-    const uint8_t* response,
+    base::span<const uint8_t>response,
     size_t response_length,
     WebContentDecryptionModuleResult result) {
-  DCHECK(response);
+  DCHECK(!response.empty());
   DCHECK(!session_id_.empty());
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
diff --git a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
index eac2f48cdb98b..5ae145474648e 100644
--- a/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
+++ b/third_party/blink/renderer/platform/media/web_content_decryption_module_session_impl.h
@@ -11,6 +11,7 @@
 #include <string>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
@@ -44,12 +45,12 @@ class PLATFORM_EXPORT WebContentDecryptionModuleSessionImpl
   WebString SessionId() const override;
 
   void InitializeNewSession(media::EmeInitDataType init_data_type,
-                            const unsigned char* initData,
+                            base::span<const unsigned char>initData,
                             size_t initDataLength,
                             WebContentDecryptionModuleResult result) override;
   void Load(const WebString& session_id,
             WebContentDecryptionModuleResult result) override;
-  void Update(const uint8_t* response,
+  void Update(base::span<const uint8_t>response,
               size_t response_length,
               WebContentDecryptionModuleResult result) override;
   void Close(WebContentDecryptionModuleResult result) override;
diff --git a/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc b/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
index a6e197801df3f..2a5f4c2bd6ed5 100644
--- a/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
+++ b/third_party/blink/renderer/platform/mediastream/media_stream_audio_test.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -115,7 +117,7 @@ class FakeMediaStreamAudioSource final : public MediaStreamAudioSource,
 
       // Deliver the next chunk of audio data. Each sample value is its offset
       // from the very first sample.
-      float* const data = audio_bus_->channel(0);
+      const base::span<float>data = audio_bus_->channel(0);
       for (int i = 0; i < buffer_size; ++i)
         data[i] = ++sample_count_;
       CHECK_LT(sample_count_, kMaxValueSafelyConvertableToFloat);
diff --git a/third_party/blink/renderer/platform/mojo/string16_mojom_traits.cc b/third_party/blink/renderer/platform/mojo/string16_mojom_traits.cc
index 4cbdaf7336bc8..1044ee3c3d4b2 100644
--- a/third_party/blink/renderer/platform/mojo/string16_mojom_traits.cc
+++ b/third_party/blink/renderer/platform/mojo/string16_mojom_traits.cc
@@ -48,7 +48,7 @@ bool StructTraits<mojo_base::mojom::String16DataView, WTF::String>::Read(
   if (view.size() > std::numeric_limits<uint32_t>::max())
     return false;
   *out = WTF::String(
-      base::span(reinterpret_cast<const UChar*>(view.data()), view.size()));
+      base::span(reinterpret_cast<const UChar*>(view.data().data()), view.size()));
   return true;
 }
 
diff --git a/ui/gfx/geometry/skia_conversions_unittest.cc b/ui/gfx/geometry/skia_conversions_unittest.cc
index cd350eb7f67af..6fe889e3b4e2b 100644
--- a/ui/gfx/geometry/skia_conversions_unittest.cc
+++ b/ui/gfx/geometry/skia_conversions_unittest.cc
@@ -65,7 +65,7 @@ TEST(SkiaConversionsTest, SkIRectToRectClamping) {
 TEST(SkiaConversionsTest, TransformSkM44Conversions) {
   std::vector<float> v = {1, 2,  3,  4,  5,  6,  7,  8,
                           9, 10, 11, 12, 13, 14, 15, 16};
-  Transform t = Transform::ColMajorF(v.data());
+  Transform t = Transform::ColMajorF(v);
 
   SkM44 m = TransformToSkM44(t);
   std::vector<float> v1(16);
@@ -76,7 +76,7 @@ TEST(SkiaConversionsTest, TransformSkM44Conversions) {
 
 TEST(SkiaConversionsTest, TransformSkMatrixConversions) {
   std::vector<float> v = {1, 2, 0, 4, 5, 6, 0, 8, 0, 0, 1, 0, 13, 14, 0, 16};
-  Transform t = Transform::ColMajorF(v.data());
+  Transform t = Transform::ColMajorF(v);
 
   std::vector<float> v1(16);
   SkMatrix m = TransformToFlattenedSkMatrix(t);
diff --git a/ui/gfx/geometry/transform.cc b/ui/gfx/geometry/transform.cc
index 3ed805c2697cb..75797bb617c2c 100644
--- a/ui/gfx/geometry/transform.cc
+++ b/ui/gfx/geometry/transform.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -112,7 +114,7 @@ Transform Transform::ColMajor(const double a[16]) {
 }
 
 // static
-Transform Transform::ColMajorF(const float a[16]) {
+Transform Transform::ColMajorF(base::span<const float, 16> a) {
   if (AllTrue(Float4{a[1], a[2], a[3], a[4]} == Float4{0, 0, 0, 0} &
               Float4{a[6], a[7], a[8], a[9]} == Float4{0, 0, 0, 0} &
               Float4{a[10], a[11], a[14], a[15]} == Float4{1, 0, 0, 1})) {
diff --git a/ui/gfx/geometry/transform.h b/ui/gfx/geometry/transform.h
index 95fc5b4519e0a..a45d87dc78faf 100644
--- a/ui/gfx/geometry/transform.h
+++ b/ui/gfx/geometry/transform.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -169,7 +171,7 @@ class COMPONENT_EXPORT(GEOMETRY_SKIA) Transform {
   // Constructs Transform from a float col-major array. Creates an
   // AxisTransform2d or a Matrix44 depending on the values. GetColMajorF() and
   // ColMajorF() are used when passing a Transform through mojo.
-  static Transform ColMajorF(const float a[16]);
+  static Transform ColMajorF(base::span<const float, 16> a);
 
   // Gets col-major data.
   void GetColMajor(double a[16]) const;
diff --git a/ui/gfx/geometry/transform_unittest.cc b/ui/gfx/geometry/transform_unittest.cc
index d8896353a34f7..b170df9bb000f 100644
--- a/ui/gfx/geometry/transform_unittest.cc
+++ b/ui/gfx/geometry/transform_unittest.cc
@@ -1634,10 +1634,10 @@ double ComputeDecompRecompError(const Transform& transform) {
   DecomposedTransform decomp = *transform.Decompose();
   Transform composed = Transform::Compose(decomp);
 
-  float expected[16];
-  float actual[16];
-  transform.GetColMajorF(expected);
-  composed.GetColMajorF(actual);
+  std::array<float, 16> expected;
+  std::array<float, 16> actual;
+  transform.GetColMajorF(expected.data());
+  composed.GetColMajorF(actual.data());
   double sse = 0;
   for (int i = 0; i < 16; i++) {
     double diff = expected[i] - actual[i];
@@ -2024,7 +2024,7 @@ TEST(XFormTest, MakeRotation) {
 }
 
 TEST(XFormTest, ColMajorF) {
-  float data[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
+  auto data = std::to_array<float>({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,});
   auto transform = Transform::ColMajorF(data);
 
   EXPECT_ROW0_EQ(2.0, 6.0, 10.0, 14.0, transform);
@@ -2032,8 +2032,8 @@ TEST(XFormTest, ColMajorF) {
   EXPECT_ROW2_EQ(4.0, 8.0, 12.0, 16.0, transform);
   EXPECT_ROW3_EQ(5.0, 9.0, 13.0, 17.0, transform);
 
-  float data1[16];
-  transform.GetColMajorF(data1);
+  std::array<float, 16> data1;
+  transform.GetColMajorF(data1.data());
   for (int i = 0; i < 16; i++)
     EXPECT_EQ(data1[i], data[i]);
   EXPECT_EQ(transform, Transform::ColMajorF(data1));
diff --git a/ui/gfx/mojom/hdr_metadata_mojom_traits.cc b/ui/gfx/mojom/hdr_metadata_mojom_traits.cc
index 0aad0b25ceeea..91b60a5eb3db5 100644
--- a/ui/gfx/mojom/hdr_metadata_mojom_traits.cc
+++ b/ui/gfx/mojom/hdr_metadata_mojom_traits.cc
@@ -48,7 +48,7 @@ bool StructTraits<gfx::mojom::HdrMetadataAgtmDataView, gfx::HdrMetadataAgtm>::
   ArrayDataView<uint8_t> payload;
   data.GetPayloadDataView(&payload);
   if (!payload.is_null()) {
-    output->payload = SkData::MakeWithCopy(payload.data(), payload.size());
+    output->payload = SkData::MakeWithCopy(payload.data().data(), payload.size());
   }
   return true;
 }
```

## Build Failure Log

```
Overlapping replacements: ./third_party/blink/renderer/platform/audio/sinc_resampler.cc at offset 11906, length 4294967295: "=.subspan()" and offset 17706, length 1: "("
Overlapping replacements: ./third_party/blink/renderer/platform/audio/sinc_resampler.cc at offset 11866, length 4294967295: "=.subspan()" and offset 17706, length 1: "("
Overlapping replacements: ./third_party/blink/renderer/platform/audio/sinc_resampler.cc at offset 11831, length 4294967295: "=.subspan()" and offset 17706, length 1: "("
Applied 5 edits (0 errors) to 1 files [0.59%]
Applied 34 edits (0 errors) to 2 files [1.18%]
Applied 157 edits (0 errors) to 3 files [1.78%]
Applied 158 edits (0 errors) to 4 files [2.37%]
Applied 187 edits (0 errors) to 5 files [2.96%]
Applied 221 edits (0 errors) to 6 files [3.55%]
Applied 290 edits (0 errors) to 7 files [4.14%]
Applied 326 edits (0 errors) to 8 files [4.73%]
Applied 460 edits (0 errors) to 9 files [5.33%]
Applied 526 edits (0 errors) to 10 files [5.92%]
Applied 549 edits (0 errors) to 11 files [6.51%]
Applied 575 edits (0 errors) to 12 files [7.10%]
Applied 596 edits (0 errors) to 13 files [7.69%]
Applied 605 edits (0 errors) to 14 files [8.28%]
Applied 610 edits (0 errors) to 15 files [8.88%]
Applied 695 edits (0 errors) to 16 files [9.47%]
Applied 703 edits (0 errors) to 17 files [10.06%]
Applied 719 edits (0 errors) to 18 files [10.65%]
Applied 776 edits (0 errors) to 19 files [11.24%]
Applied 786 edits (0 errors) to 20 files [11.83%]
Applied 787 edits (0 errors) to 21 files [12.43%]
Applied 788 edits (0 errors) to 22 files [13.02%]
Applied 806 edits (0 errors) to 23 files [13.61%]
Applied 849 edits (3 errors) to 24 files [14.20%]
Applied 853 edits (3 errors) to 25 files [14.79%]
Applied 857 edits (3 errors) to 26 files [15.38%]
Applied 871 edits (3 errors) to 27 files [15.98%]
Applied 895 edits (3 errors) to 28 files [16.57%]
Applied 905 edits (3 errors) to 29 files [17.16%]
Applied 906 edits (3 errors) to 30 files [17.75%]
Applied 923 edits (3 errors) to 31 files [18.34%]
Applied 932 edits (3 errors) to 32 files [18.93%]
Applied 944 edits (3 errors) to 33 files [19.53%]
Applied 951 edits (3 errors) to 34 files [20.12%]
Applied 976 edits (3 errors) to 35 files [20.71%]
Applied 978 edits (3 errors) to 36 files [21.30%]
Applied 984 edits (3 errors) to 37 files [21.89%]
Applied 1028 edits (3 errors) to 38 files [22.49%]
Applied 1038 edits (3 errors) to 39 files [23.08%]
Applied 1074 edits (3 errors) to 40 files [23.67%]
Applied 1078 edits (3 errors) to 41 files [24.26%]
Applied 1091 edits (3 errors) to 42 files [24.85%]
Applied 1115 edits (3 errors) to 43 files [25.44%]
Applied 1116 edits (3 errors) to 44 files [26.04%]
Applied 1122 edits (3 errors) to 45 files [26.63%]
Applied 1167 edits (3 errors) to 46 files [27.22%]
Applied 1171 edits (3 errors) to 47 files [27.81%]
Applied 1178 edits (3 errors) to 48 files [28.40%]
Applied 1180 edits (3 errors) to 49 files [28.99%]
Applied 1197 edits (3 errors) to 50 files [29.59%]
Applied 1202 edits (3 errors) to 51 files [30.18%]
Applied 1203 edits (3 errors) to 52 files [30.77%]
Applied 1212 edits (3 errors) to 53 files [31.36%]
Applied 1214 edits (3 errors) to 54 files [31.95%]
Applied 1230 edits (3 errors) to 55 files [32.54%]
Applied 1232 edits (3 errors) to 56 files [33.14%]
Applied 1248 edits (3 errors) to 57 files [33.73%]
Applied 1255 edits (3 errors) to 58 files [34.32%]
Applied 1257 edits (3 errors) to 59 files [34.91%]
Applied 1262 edits (3 errors) to 60 files [35.50%]
Applied 1266 edits (3 errors) to 61 files [36.09%]
Applied 1273 edits (3 errors) to 62 files [36.69%]
Applied 1275 edits (3 errors) to 63 files [37.28%]
Applied 1282 edits (3 errors) to 64 files [37.87%]
Applied 1288 edits (3 errors) to 65 files [38.46%]
Applied 1290 edits (3 errors) to 66 files [39.05%]
Applied 1295 edits (3 errors) to 67 files [39.64%]
Applied 1308 edits (3 errors) to 68 files [40.24%]
Applied 1316 edits (3 errors) to 69 files [40.83%]
Applied 1324 edits (3 errors) to 70 files [41.42%]
Applied 1334 edits (3 errors) to 71 files [42.01%]
Applied 1337 edits (3 errors) to 72 files [42.60%]
Applied 1354 edits (3 errors) to 73 files [43.20%]
Applied 1356 edits (3 errors) to 74 files [43.79%]
Applied 1357 edits (3 errors) to 75 files [44.38%]
Applied 1361 edits (3 errors) to 76 files [44.97%]
Applied 1364 edits (3 errors) to 77 files [45.56%]
Applied 1367 edits (3 errors) to 78 files [46.15%]
Applied 1370 edits (3 errors) to 79 files [46.75%]
Applied 1373 edits (3 errors) to 80 files [47.34%]
Applied 1376 edits (3 errors) to 81 files [47.93%]
Applied 1379 edits (3 errors) to 82 files [48.52%]
Applied 1381 edits (3 errors) to 83 files [49.11%]
Applied 1386 edits (3 errors) to 84 files [49.70%]
Applied 1388 edits (3 errors) to 85 files [50.30%]
Applied 1391 edits (3 errors) to 86 files [50.89%]
Applied 1399 edits (3 errors) to 87 files [51.48%]
Applied 1400 edits (3 errors) to 88 files [52.07%]
Applied 1411 edits (3 errors) to 89 files [52.66%]
Applied 1413 edits (3 errors) to 90 files [53.25%]
Applied 1420 edits (3 errors) to 91 files [53.85%]
Applied 1421 edits (3 errors) to 92 files [54.44%]
Applied 1427 edits (3 errors) to 93 files [55.03%]
Applied 1429 edits (3 errors) to 94 files [55.62%]
Applied 1435 edits (3 errors) to 95 files [56.21%]
Applied 1451 edits (3 errors) to 96 files [56.80%]
Applied 1453 edits (3 errors) to 97 files [57.40%]
Applied 1455 edits (3 errors) to 98 files [57.99%]
Applied 1458 edits (3 errors) to 99 files [58.58%]
Applied 1459 edits (3 errors) to 100 files [59.17%]
Applied 1470 edits (3 errors) to 101 files [59.76%]
Applied 1473 edits (3 errors) to 102 files [60.36%]
Applied 1476 edits (3 errors) to 103 files [60.95%]
Applied 1478 edits (3 errors) to 104 files [61.54%]
Applied 1480 edits (3 errors) to 105 files [62.13%]
Applied 1487 edits (3 errors) to 106 files [62.72%]
Applied 1489 edits (3 errors) to 107 files [63.31%]
Applied 1491 edits (3 errors) to 108 files [63.91%]
Applied 1493 edits (3 errors) to 109 files [64.50%]
Applied 1494 edits (3 errors) to 110 files [65.09%]
Applied 1495 edits (3 errors) to 111 files [65.68%]
Applied 1498 edits (3 errors) to 112 files [66.27%]
Applied 1501 edits (3 errors) to 113 files [66.86%]
Applied 1503 edits (3 errors) to 114 files [67.46%]
Applied 1507 edits (3 errors) to 115 files [68.05%]
Applied 1508 edits (3 errors) to 116 files [68.64%]
Applied 1509 edits (3 errors) to 117 files [69.23%]
Applied 1512 edits (3 errors) to 118 files [69.82%]
Applied 1515 edits (3 errors) to 119 files [70.41%]
Applied 1519 edits (3 errors) to 120 files [71.01%]
Applied 1522 edits (3 errors) to 121 files [71.60%]
Applied 1523 edits (3 errors) to 122 files [72.19%]
Applied 1525 edits (3 errors) to 123 files [72.78%]
Applied 1526 edits (3 errors) to 124 files [73.37%]
Applied 1529 edits (3 errors) to 125 files [73.96%]
Applied 1531 edits (3 errors) to 126 files [74.56%]
Applied 1532 edits (3 errors) to 127 files [75.15%]
Applied 1535 edits (3 errors) to 128 files [75.74%]
Applied 1537 edits (3 errors) to 129 files [76.33%]
Applied 1540 edits (3 errors) to 130 files [76.92%]
Applied 1542 edits (3 errors) to 131 files [77.51%]
Applied 1546 edits (3 errors) to 132 files [78.11%]
Applied 1547 edits (3 errors) to 133 files [78.70%]
Applied 1549 edits (3 errors) to 134 files [79.29%]
Applied 1550 edits (3 errors) to 135 files [79.88%]
Applied 1552 edits (3 errors) to 136 files [80.47%]
Applied 1553 edits (3 errors) to 137 files [81.07%]
Applied 1554 edits (3 errors) to 138 files [81.66%]
Applied 1556 edits (3 errors) to 139 files [82.25%]
Applied 1558 edits (3 errors) to 140 files [82.84%]
Applied 1560 edits (3 errors) to 141 files [83.43%]
Applied 1562 edits (3 errors) to 142 files [84.02%]
Applied 1563 edits (3 errors) to 143 files [84.62%]
Applied 1567 edits (3 errors) to 144 files [85.21%]
Applied 1569 edits (3 errors) to 145 files [85.80%]
Applied 1570 edits (3 errors) to 146 files [86.39%]
Applied 1572 edits (3 errors) to 147 files [86.98%]
Applied 1575 edits (3 errors) to 148 files [87.57%]
Applied 1577 edits (3 errors) to 149 files [88.17%]
Applied 1578 edits (3 errors) to 150 files [88.76%]
Applied 1580 edits (3 errors) to 151 files [89.35%]
Applied 1582 edits (3 errors) to 152 files [89.94%]
Applied 1583 edits (3 errors) to 153 files [90.53%]
Applied 1584 edits (3 errors) to 154 files [91.12%]
Applied 1585 edits (3 errors) to 155 files [91.72%]
Applied 1586 edits (3 errors) to 156 files [92.31%]
Applied 1587 edits (3 errors) to 157 files [92.90%]
Applied 1588 edits (3 errors) to 158 files [93.49%]
Applied 1589 edits (3 errors) to 159 files [94.08%]
Applied 1590 edits (3 errors) to 160 files [94.67%]
Applied 1591 edits (3 errors) to 161 files [95.27%]
Applied 1592 edits (3 errors) to 162 files [95.86%]
Applied 1594 edits (3 errors) to 163 files [96.45%]
Applied 1595 edits (3 errors) to 164 files [97.04%]
Applied 1596 edits (3 errors) to 165 files [97.63%]
Applied 1597 edits (3 errors) to 166 files [98.22%]
Applied 1598 edits (3 errors) to 167 files [98.82%]
Applied 1599 edits (3 errors) to 168 files [99.41%]
Applied 1600 edits (3 errors) to 169 files [100.00%]
```

# Build Failure: 2025_05_02_patch_1070

## Chromium Revision

`a3ffac36a0fd4cbdc95cd5ec879816b9634a1d56`

## Code Changes (Diff)

```diff
diff --git a/base/bits.h b/base/bits.h
index 5f93183d034b7..98e0f4e6397ff 100644
--- a/base/bits.h
+++ b/base/bits.h
@@ -14,6 +14,7 @@
 #include <concepts>
 #include <type_traits>
 
+#include "base/containers/span.h"
 #include "base/check.h"
 
 namespace base::bits {
@@ -91,7 +92,7 @@ inline constexpr T AlignUpDeprecatedDoNotUse(T size, T alignment) {
 // two. Defined for types where sizeof(T) is one byte.
 template <typename T>
   requires(sizeof(T) == 1)
-inline T* AlignUp(T* ptr, uintptr_t alignment) {
+inline base::span<T> AlignUp(T* ptr, uintptr_t alignment) {
   return reinterpret_cast<T*>(
       AlignUp(reinterpret_cast<uintptr_t>(ptr), alignment));
 }
diff --git a/base/bits_unittest.cc b/base/bits_unittest.cc
index 6464844af0598..9364342817b5d 100644
--- a/base/bits_unittest.cc
+++ b/base/bits_unittest.cc
@@ -64,21 +64,21 @@ TEST(BitsTest, AlignUpPointer) {
   static constexpr uintptr_t kUintPtrTMax =
       std::numeric_limits<uintptr_t>::max();
   EXPECT_EQ(reinterpret_cast<uint8_t*>(0),
-            AlignUp(reinterpret_cast<uint8_t*>(0), 4));
+            AlignUp(reinterpret_cast<uint8_t*>(0), 4).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4),
-            AlignUp(reinterpret_cast<uint8_t*>(1), 4));
+            AlignUp(reinterpret_cast<uint8_t*>(1), 4).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(1), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(1), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(4096), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4096), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(4096),
-            AlignUp(reinterpret_cast<uint8_t*>(4095), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4095), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(8192),
-            AlignUp(reinterpret_cast<uint8_t*>(4097), 4096));
+            AlignUp(reinterpret_cast<uint8_t*>(4097), 4096).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(kUintPtrTMax - 31),
-            AlignUp(reinterpret_cast<uint8_t*>(kUintPtrTMax - 62), 32));
+            AlignUp(reinterpret_cast<uint8_t*>(kUintPtrTMax - 62), 32).data());
   EXPECT_EQ(reinterpret_cast<uint8_t*>(kUintPtrTMax / 2 + 1),
-            AlignUp(reinterpret_cast<uint8_t*>(1), kUintPtrTMax / 2 + 1));
+            AlignUp(reinterpret_cast<uint8_t*>(1), kUintPtrTMax / 2 + 1).data());
 }
 
 TEST(BitsTest, AlignDown) {
diff --git a/base/debug/test_elf_image_builder.cc b/base/debug/test_elf_image_builder.cc
index f9b8a93bdccbe..a06aa4024a79e 100644
--- a/base/debug/test_elf_image_builder.cc
+++ b/base/debug/test_elf_image_builder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -74,19 +76,19 @@ TestElfImageBuilder& TestElfImageBuilder::AddNoteSegment(
       sizeof(Nhdr) + bits::AlignUp(name_with_null_size, size_t{4}) +
           bits::AlignUp(desc.size(), size_t{4}),
       '\0');
-  uint8_t* loc = &buffer.front();
+  base::span<uint8_t>loc = &buffer.front();
   Nhdr nhdr;
   nhdr.n_namesz = name_with_null_size;
   nhdr.n_descsz = desc.size();
   nhdr.n_type = type;
   loc = AppendHdr(nhdr, loc);
 
-  memcpy(loc, name.data(), name.size());
-  *(loc + name.size()) = '\0';
-  loc += bits::AlignUp(name_with_null_size, size_t{4});
+  memcpy(loc.data(), name.data(), name.size());
+   (loc .subspan( name.size())[0]) = '\0';
+  loc=loc.subspan(bits::AlignUp(name_with_null_size, size_t{4}));
 
-  memcpy(loc, &desc.front(), desc.size());
-  loc += bits::AlignUp(desc.size(), size_t{4});
+  memcpy(loc.data(), &desc.front(), desc.size());
+  loc=loc.subspan(bits::AlignUp(desc.size(), size_t{4}));
 
   DCHECK_EQ(&buffer.front() + buffer.size(), loc);
 
@@ -113,7 +115,7 @@ struct TestElfImageBuilder::ImageMeasures {
 
 Addr TestElfImageBuilder::GetVirtualAddressForOffset(
     Off offset,
-    const uint8_t* elf_start) const {
+    base::span<const uint8_t>elf_start) const {
   switch (mapping_type_) {
     case RELOCATABLE:
       return static_cast<Addr>(offset);
@@ -122,7 +124,7 @@ Addr TestElfImageBuilder::GetVirtualAddressForOffset(
       return static_cast<Addr>(offset + kLoadBias);
 
     case NON_RELOCATABLE:
-      return reinterpret_cast<Addr>(elf_start + offset);
+      return reinterpret_cast<Addr>(elf_start .subspan( offset));
   }
 }
 
@@ -195,15 +197,15 @@ TestElfImage TestElfImageBuilder::Build() {
       mapping_type_ == RELOCATABLE_WITH_BIAS ? kLoadBias : 0;
   std::vector<uint8_t> buffer(load_bias + (kPageSize - 1) + measures.total_size,
                               '\0');
-  uint8_t* const elf_start =
+  const base::span<uint8_t>elf_start =
       bits::AlignUp(&buffer.front() + load_bias, kPageSize);
-  uint8_t* loc = elf_start;
+  base::span<uint8_t>loc = elf_start;
 
   // Add the ELF header.
   loc = AppendHdr(CreateEhdr(measures.phdrs_required), loc);
 
   // Add the program header table.
-  loc = bits::AlignUp(loc, kPhdrAlign);
+  loc = bits::AlignUp(loc.data(), kPhdrAlign);
   loc = AppendHdr(
       CreatePhdr(PT_PHDR, PF_R, kPhdrAlign, loc - elf_start,
                  GetVirtualAddressForOffset(loc - elf_start, elf_start),
@@ -241,22 +243,22 @@ TestElfImage TestElfImageBuilder::Build() {
   }
 
   // Add the notes.
-  loc = bits::AlignUp(loc, kNoteAlign);
+  loc = bits::AlignUp(loc.data(), kNoteAlign);
   for (const std::vector<uint8_t>& contents : note_contents_) {
-    memcpy(loc, &contents.front(), contents.size());
-    loc += contents.size();
+    memcpy(loc.data(), &contents.front(), contents.size());
+    loc=loc.subspan(contents.size());
   }
 
   // Add the load segments.
   for (auto it = load_segments_.begin(); it != load_segments_.end(); ++it) {
     if (it != load_segments_.begin()) {
-      loc = bits::AlignUp(loc, kLoadAlign);
+      loc = bits::AlignUp(loc.data(), kLoadAlign);
     }
-    memset(loc, 0, it->size);
-    loc += it->size;
+    memset(loc.data(), 0, it->size);
+    loc=loc.subspan(size);
   }
 
-  loc = bits::AlignUp(loc, kDynamicAlign);
+  loc = bits::AlignUp(loc.data(), kDynamicAlign);
 
   // Add the soname state.
   if (soname_) {
@@ -278,16 +280,16 @@ TestElfImage TestElfImageBuilder::Build() {
   // Linux relocates this value on ELF load, so produce the pointer value after
   // relocation. That value will always be equal to the actual memory address.
   strtab_dyn.d_un.d_ptr =
-      reinterpret_cast<uintptr_t>(elf_start + measures.strtab_start);
+      reinterpret_cast<uintptr_t>(elf_start .subspan( measures.strtab_start));
 #endif
   loc = AppendHdr(strtab_dyn, loc);
 
   // Add a string table with one entry for the soname, if necessary.
-  *loc++ = '\0';  // The first byte holds a null character.
+  (loc++)[0] = '\0';  // The first byte holds a null character.
   if (soname_) {
-    memcpy(loc, soname_->data(), soname_->size());
-    *(loc + soname_->size()) = '\0';
-    loc += soname_->size() + 1;
+    memcpy(loc.data(), soname_->data(), soname_->size());
+     (loc .subspan( soname_->size())[0]) = '\0';
+    loc=loc.subspan(soname_->size() + 1);
   }
 
   // The offset past the end of the contents should be consistent with the size
@@ -299,10 +301,10 @@ TestElfImage TestElfImageBuilder::Build() {
 
 // static
 template <typename T>
-uint8_t* TestElfImageBuilder::AppendHdr(const T& hdr, uint8_t* loc) {
+base::span<uint8_t> TestElfImageBuilder::AppendHdr(const T& hdr, base::span<uint8_t>loc) {
   static_assert(std::is_trivially_copyable_v<T>, "T should be a plain struct");
   memcpy(loc, &hdr, sizeof(T));
-  return loc + sizeof(T);
+  return loc .subspan( sizeof)(T);
 }
 
 Ehdr TestElfImageBuilder::CreateEhdr(Half phnum) {
diff --git a/base/debug/test_elf_image_builder.h b/base/debug/test_elf_image_builder.h
index 7dfee81fab428..23f9bffb9bb3d 100644
--- a/base/debug/test_elf_image_builder.h
+++ b/base/debug/test_elf_image_builder.h
@@ -100,7 +100,7 @@ class TestElfImageBuilder {
   // addresses equal to the offset with a possible constant load bias.
   // Non-relocatable ELF images have virtual addresses equal to the actual
   // memory address.
-  Addr GetVirtualAddressForOffset(Off offset, const uint8_t* elf_start) const;
+  Addr GetVirtualAddressForOffset(Off offset, base::span<const uint8_t>elf_start) const;
 
   // Measures sizes/start offset of segments in the image.
   ImageMeasures MeasureSizesAndOffsets() const;
@@ -108,7 +108,7 @@ class TestElfImageBuilder {
   // Appends a header of type |T| at |loc|, a memory address within the ELF
   // image being constructed, and returns the address past the header.
   template <typename T>
-  static uint8_t* AppendHdr(const T& hdr, uint8_t* loc);
+  static base::span<uint8_t> AppendHdr(const T& hdr, base::span<uint8_t>loc);
 
   Ehdr CreateEhdr(Half phnum);
   Phdr CreatePhdr(Word type,
diff --git a/base/files/memory_mapped_file.h b/base/files/memory_mapped_file.h
index 420779bbb9a44..024c6b6fb55f4 100644
--- a/base/files/memory_mapped_file.h
+++ b/base/files/memory_mapped_file.h
@@ -111,7 +111,7 @@ class BASE_EXPORT MemoryMappedFile {
   }
 
   const uint8_t* data() const { return bytes_.data(); }
-  uint8_t* data() { return bytes_.data(); }
+  base::span<uint8_t> data() { return bytes_; }
   size_t length() const { return bytes_.size(); }
 
   span<const uint8_t> bytes() const { return bytes_; }
diff --git a/base/i18n/icu_util.cc b/base/i18n/icu_util.cc
index df9dd86a57e1b..b29c4cbcb2b89 100644
--- a/base/i18n/icu_util.cc
+++ b/base/i18n/icu_util.cc
@@ -232,7 +232,7 @@ int LoadIcuData(PlatformFile data_fd,
   }
 
   (*out_error_code) = U_ZERO_ERROR;
-  udata_setCommonData(const_cast<uint8_t*>((*out_mapped_data_file)->data()),
+  udata_setCommonData(const_cast<uint8_t*>((*out_mapped_data_file)->data().data()),
                       out_error_code);
   if (U_FAILURE(*out_error_code)) {
     LOG(ERROR) << "Failed to initialize ICU with data file: "
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index fe1d55df6dcc8..f9c92d00fe322 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -119,12 +119,12 @@ struct SharedState {
 const SharedState* SharedStateFromSharedMemory(
     const WritableSharedMemoryMapping& shared_memory) {
   DCHECK(shared_memory.IsValid());
-  return shared_memory.GetMemoryAs<const SharedState>();
+  return shared_memory.GetMemoryAs<const SharedState>().data();
 }
 SharedState* SharedStateFromSharedMemory(
     WritableSharedMemoryMapping& shared_memory) {
   DCHECK(shared_memory.IsValid());
-  return shared_memory.GetMemoryAs<SharedState>();
+  return shared_memory.GetMemoryAs<SharedState>().data();
 }
 
 // Round up |size| to a multiple of page size.
diff --git a/base/memory/platform_shared_memory_region_unittest.cc b/base/memory/platform_shared_memory_region_unittest.cc
index c6f5329763730..605e6a1d8f002 100644
--- a/base/memory/platform_shared_memory_region_unittest.cc
+++ b/base/memory/platform_shared_memory_region_unittest.cc
@@ -464,7 +464,7 @@ TEST_F(PlatformSharedMemoryRegionTest, MappingProtectionSetCorrectly) {
   // The `mapped_size()` is larger then `size()` but is the actual size of the
   // shared memory backing.
   auto full_map_mem =
-      UNSAFE_BUFFERS(span(ro_mapping.data(), ro_mapping.mapped_size()));
+      UNSAFE_BUFFERS(span(ro_mapping.data().data(), ro_mapping.mapped_size()));
   EXPECT_FALSE(TryToRestoreWritablePermissions(full_map_mem.data(),
                                                full_map_mem.size()));
 
diff --git a/base/memory/shared_memory_mapping.h b/base/memory/shared_memory_mapping.h
index b45619dda274e..8c27381d97561 100644
--- a/base/memory/shared_memory_mapping.h
+++ b/base/memory/shared_memory_mapping.h
@@ -118,34 +118,34 @@ class BASE_EXPORT ReadOnlySharedMemoryMapping : public SharedMemoryMapping {
   // Use `span(mapping)` to make a span of `uint8_t`, `GetMemoryAs<T>()` to
   // access the memory as a single `T` or `GetMemoryAsSpan<T>()` to access it as
   // an array of `T`.
-  const uint8_t* data() const { return mapped_memory().data(); }
+  const base::span<uint8_t> data() const { return mapped_memory(); }
 
   // Iterate memory as bytes up to the end of its logical size.
   iterator begin() const {
     // SAFETY: There is an internal invariant (enforced in the constructors)
     // that `size() <= mapped_memory().size()`, so `data()` points to at least
     // that many valid bytes.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size()));
   }
   iterator end() const {
     // SAFETY: As in `begin()` above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size(), data() + size()));
   }
 
   // TODO(crbug.com/355451178): Deprecated. Use `span(mapping)` to make a span
   // of `uint8_t`, `GetMemoryAs<T>()` to access the memory as a single `T` or
   // `GetMemoryAsSpan<T>()` to access it as an array of `T`, or `data()` for an
   // unbounded pointer.
-  const void* memory() const { return data(); }
+  const base::span<void> memory() const { return data(); }
 
   // Returns a pointer to a page-aligned const T if the mapping is valid and
   // large enough to contain a T, or nullptr otherwise.
   template <typename T>
     requires subtle::AllowedOverSharedMemory<T>
-  const T* GetMemoryAs() const {
+  const base::span<T> GetMemoryAs() const {
     return (IsValid() && sizeof(T) <= size())
-               ? reinterpret_cast<const T*>(mapped_memory().data())
-               : nullptr;
+               ? reinterpret_cast<const T*>(mapped_memory())
+               : {};
   }
 
   // Returns a span of const T. The number of elements is autodeduced from the
@@ -211,47 +211,47 @@ class BASE_EXPORT WritableSharedMemoryMapping : public SharedMemoryMapping {
   // Use `span(mapping)` to make a span of `uint8_t`, `GetMemoryAs<T>()` to
   // access the memory as a single `T` or `GetMemoryAsSpan<T>()` to access it as
   // an array of `T`.
-  uint8_t* data() { return mapped_memory().data(); }
-  const uint8_t* data() const { return mapped_memory().data(); }
+  base::span<uint8_t> data() { return mapped_memory(); }
+  const base::span<uint8_t> data() const { return mapped_memory(); }
 
   // Iterate memory as bytes up to the end of its logical size.
   iterator begin() {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size()));
   }
   const_iterator begin() const {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(const_iterator(data(), data() + size()));
+    return UNSAFE_BUFFERS(const_iterator(data().data(), data() + size()));
   }
   iterator end() {
     // SAFETY: As in the ReadOnly code above.
-    return UNSAFE_BUFFERS(iterator(data(), data() + size(), data() + size()));
+    return UNSAFE_BUFFERS(iterator(data().data(), data() + size(), data() + size()));
   }
   const_iterator end() const {
     // SAFETY: As in the ReadOnly code above.
     return UNSAFE_BUFFERS(
-        const_iterator(data(), data() + size(), data() + size()));
+        const_iterator(data().data(), data() + size(), data() + size()));
   }
 
   // TODO(crbug.com/355451178): Deprecated. Use `span(mapping)` to make a span
   // of `uint8_t`, `GetMemoryAs<T>()` to access the memory as a single `T`, or
   // `GetMemoryAsSpan<T>()` to access it as an array of `T` or `data()` for an
   // unbounded pointer.
-  void* memory() { return data(); }
-  const void* memory() const { return data(); }
+  base::span<void> memory() { return data(); }
+  const base::span<void> memory() const { return data(); }
 
   // Returns a pointer to a page-aligned T if the mapping is valid and large
   // enough to contain a T, or nullptr otherwise.
   template <typename T>
     requires subtle::AllowedOverSharedMemory<T>
-  const T* GetMemoryAs() const {
+  const base::span<T> GetMemoryAs() const {
     return (IsValid() && sizeof(T) <= size())
-               ? reinterpret_cast<T*>(mapped_memory().data())
-               : nullptr;
+               ? reinterpret_cast<T*>(mapped_memory())
+               : {};
   }
   template <typename T>
     requires(!std::is_const_v<T> && subtle::AllowedOverSharedMemory<T>)
-  T* GetMemoryAs() {
+  base::span<T> GetMemoryAs() {
     return const_cast<T*>(std::as_const(*this).GetMemoryAs<const T>());
   }
 
diff --git a/base/memory/shared_memory_mapping_unittest.cc b/base/memory/shared_memory_mapping_unittest.cc
index d8ead663827f6..a2230d1399d6e 100644
--- a/base/memory/shared_memory_mapping_unittest.cc
+++ b/base/memory/shared_memory_mapping_unittest.cc
@@ -41,8 +41,8 @@ class SharedMemoryMappingTest : public ::testing::Test {
 };
 
 TEST_F(SharedMemoryMappingTest, Invalid) {
-  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint8_t>());
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint8_t>());
+  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint8_t>().data());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint8_t>().data());
   EXPECT_TRUE(write_mapping_.GetMemoryAsSpan<uint8_t>().empty());
   EXPECT_TRUE(read_mapping_.GetMemoryAsSpan<uint8_t>().empty());
   EXPECT_TRUE(write_mapping_.GetMemoryAsSpan<uint8_t>(1).empty());
@@ -52,10 +52,10 @@ TEST_F(SharedMemoryMappingTest, Invalid) {
 TEST_F(SharedMemoryMappingTest, Scalar) {
   CreateMapping(sizeof(uint32_t));
 
-  uint32_t* write_ptr = write_mapping_.GetMemoryAs<uint32_t>();
+  uint32_t* write_ptr = write_mapping_.GetMemoryAs<uint32_t>().data();
   ASSERT_NE(nullptr, write_ptr);
 
-  const uint32_t* read_ptr = read_mapping_.GetMemoryAs<uint32_t>();
+  const uint32_t* read_ptr = read_mapping_.GetMemoryAs<uint32_t>().data();
   ASSERT_NE(nullptr, read_ptr);
 
   *write_ptr = 0u;
@@ -209,9 +209,9 @@ TEST_F(SharedMemoryMappingTest, ConstCorrectness) {
 TEST_F(SharedMemoryMappingTest, TooBigScalar) {
   CreateMapping(sizeof(uint8_t));
 
-  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint32_t>());
+  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<uint32_t>().data());
 
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint32_t>());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<uint32_t>().data());
 }
 
 TEST_F(SharedMemoryMappingTest, TooBigSpanWithAutoDeducedElementCount) {
@@ -239,13 +239,13 @@ TEST_F(SharedMemoryMappingTest, TooBigSpanWithExplicitElementCount) {
 TEST_F(SharedMemoryMappingTest, Atomic) {
   CreateMapping(sizeof(std::atomic<uint32_t>));
 
-  auto* write_ptr = write_mapping_.GetMemoryAs<std::atomic<uint32_t>>();
+  auto* write_ptr = write_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data();
   ASSERT_NE(nullptr, write_ptr);
 
   // Placement new to initialize the std::atomic in place.
   new (write_ptr) std::atomic<uint32_t>;
 
-  const auto* read_ptr = read_mapping_.GetMemoryAs<std::atomic<uint32_t>>();
+  const auto* read_ptr = read_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data();
   ASSERT_NE(nullptr, read_ptr);
 
   write_ptr->store(0u, std::memory_order_relaxed);
@@ -258,9 +258,9 @@ TEST_F(SharedMemoryMappingTest, Atomic) {
 TEST_F(SharedMemoryMappingTest, TooBigAtomic) {
   CreateMapping(sizeof(std::atomic<uint8_t>));
 
-  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<std::atomic<uint32_t>>());
+  EXPECT_EQ(nullptr, write_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data());
 
-  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<std::atomic<uint32_t>>());
+  EXPECT_EQ(nullptr, read_mapping_.GetMemoryAs<std::atomic<uint32_t>>().data());
 }
 
 // TODO(dcheng): This test is temporarily disabled on iOS. iOS devices allow
diff --git a/base/metrics/persistent_histogram_allocator.cc b/base/metrics/persistent_histogram_allocator.cc
index ce78ffd851e96..513f0e64ce2a6 100644
--- a/base/metrics/persistent_histogram_allocator.cc
+++ b/base/metrics/persistent_histogram_allocator.cc
@@ -394,10 +394,10 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::AllocateHistogram(
       ranges_ref =
           memory_allocator_->Allocate(ranges_bytes, kTypeIdRangesArray);
       if (ranges_ref) {
-        HistogramBase::Sample32* ranges_data =
+        base::span<HistogramBase::Sample32>ranges_data =
             memory_allocator_->GetAsArray<HistogramBase::Sample32>(
                 ranges_ref, kTypeIdRangesArray, ranges_count);
-        if (ranges_data) {
+        if (!ranges_data.empty()) {
           for (size_t i = 0; i < bucket_ranges->size(); ++i) {
             UNSAFE_TODO(ranges_data[i]) = bucket_ranges->range(i);
           }
@@ -587,7 +587,7 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(
   const HistogramBase::Sample32* const ranges_data =
       memory_allocator_->GetAsArray<HistogramBase::Sample32>(
           histogram_ranges_ref, kTypeIdRangesArray,
-          PersistentMemoryAllocator::kSizeAny, &allocated_bytes);
+          PersistentMemoryAllocator::kSizeAny, &allocated_bytes).data();
   const size_t ranges_size = histogram_bucket_count + 1;
   const uint32_t max_buckets =
       std::numeric_limits<uint32_t>::max() / sizeof(HistogramBase::Sample32);
@@ -629,8 +629,7 @@ std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(
 
   PersistentMemoryAllocator::Reference counts_ref =
       histogram_data_ptr->counts_ref.load(std::memory_order_acquire);
-  if (counts_ref != 0 && !memory_allocator_->GetAsArray<uint8_t>(
-                             counts_ref, kTypeIdCountsArray, counts_bytes)) {
+  if (counts_ref != 0 && ).empty()) {
     return nullptr;
   }
 
diff --git a/base/metrics/persistent_histogram_allocator_unittest.cc b/base/metrics/persistent_histogram_allocator_unittest.cc
index a04b7e610a819..c74463d8def2a 100644
--- a/base/metrics/persistent_histogram_allocator_unittest.cc
+++ b/base/metrics/persistent_histogram_allocator_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -627,9 +629,9 @@ TEST_F(PersistentHistogramAllocatorTest, RangesDeDuplication) {
   EXPECT_NE(0U, ref2);
   EXPECT_NE(ref1, ref2);
 
-  uint32_t* data1 =
+  base::span<uint32_t>data1 =
       allocator_->GetAsArray<uint32_t>(ref1, 0, kRangesRefIndex + 1);
-  uint32_t* data2 =
+  base::span<uint32_t>data2 =
       allocator_->GetAsArray<uint32_t>(ref2, 0, kRangesRefIndex + 1);
   EXPECT_EQ(ranges_ref, data1[kRangesRefIndex]);
   EXPECT_EQ(ranges_ref, data2[kRangesRefIndex]);
diff --git a/base/metrics/persistent_memory_allocator.cc b/base/metrics/persistent_memory_allocator.cc
index 67001ae1d65ec..c874753f0ecc6 100644
--- a/base/metrics/persistent_memory_allocator.cc
+++ b/base/metrics/persistent_memory_allocator.cc
@@ -11,6 +11,7 @@
 #include <optional>
 #include <string_view>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
@@ -435,7 +436,7 @@ PersistentMemoryAllocator::PersistentMemoryAllocator(Memory memory,
     if (!name.empty()) {
       const size_t name_length = name.length() + 1;
       shared_meta()->name = Allocate(name_length, 0);
-      char* name_cstr = GetAsArray<char>(shared_meta()->name, 0, name_length);
+      char* name_cstr = GetAsArray<char>(shared_meta()->name, 0, name_length).data();
       if (name_cstr) {
         UNSAFE_TODO(memcpy(name_cstr, name.data(), name.length()));
       }
@@ -538,7 +539,7 @@ PersistentMemoryAllocator::Reference PersistentMemoryAllocator::GetAsReference(
   }
 
   Reference ref = static_cast<Reference>(offset) - sizeof(BlockHeader);
-  if (!GetBlockData(ref, type_id, kSizeAny)) {
+  if ().empty()) {
     return kReferenceNull;
   }
 
@@ -998,7 +999,7 @@ uint32_t PersistentMemoryAllocator::version() const {
   return shared_meta()->version;
 }
 
-const volatile void* PersistentMemoryAllocator::GetBlockData(
+const volatile base::span<void> PersistentMemoryAllocator::GetBlockData(
     Reference ref,
     uint32_t type_id,
     size_t size,
@@ -1007,7 +1008,7 @@ const volatile void* PersistentMemoryAllocator::GetBlockData(
   const volatile BlockHeader* block = GetBlock(
       ref, type_id, size, /*queue_ok=*/false, /*free_ok=*/false, alloc_size);
   if (!block) {
-    return nullptr;
+    return {};
   }
   return UNSAFE_TODO(reinterpret_cast<const volatile char*>(block) +
                      sizeof(BlockHeader));
@@ -1334,8 +1335,8 @@ span<uint8_t> DelayedPersistentAllocation::GetUntyped() const {
   }
 
   // Find the referenced memory and return it as a span if successful.
-  uint8_t* mem = allocator_->GetAsArray<uint8_t>(ref, type_, size_);
-  if (mem) {
+  base::span<uint8_t>mem = allocator_->GetAsArray<uint8_t>(ref, type_, size_);
+  if (!mem.empty()) {
     // This is the success path.
     return UNSAFE_TODO(span(mem + offset_, size_ - offset_));
   }
diff --git a/base/metrics/persistent_memory_allocator.h b/base/metrics/persistent_memory_allocator.h
index 25b4501fc8b41..0913e2e78cfcf 100644
--- a/base/metrics/persistent_memory_allocator.h
+++ b/base/metrics/persistent_memory_allocator.h
@@ -473,7 +473,7 @@ class BASE_EXPORT PersistentMemoryAllocator {
   // compatibilty when using these accessors. Only use fixed-size types such
   // as char, float, double, or (u)intXX_t.
   template <typename T>
-  T* GetAsArray(Reference ref,
+  base::span<T> GetAsArray(Reference ref,
                 uint32_t type_id,
                 size_t count,
                 size_t* alloc_size = nullptr) {
@@ -488,7 +488,7 @@ class BASE_EXPORT PersistentMemoryAllocator {
                       size_t* alloc_size = nullptr) const {
     static_assert(std::is_fundamental_v<T>, "use GetAsObject<>()");
     return const_cast<const char*>(reinterpret_cast<const volatile T*>(
-        GetBlockData(ref, type_id, count * sizeof(T), alloc_size)));
+        GetBlockData(ref, type_id, count * sizeof(T), alloc_size).data()));
   }
 
   // Gets the corresponding reference for an object held in persistent memory.
@@ -778,11 +778,11 @@ class BASE_EXPORT PersistentMemoryAllocator {
   }
 
   // Gets the actual data within a block associated with a specific reference.
-  const volatile void* GetBlockData(Reference ref,
+  const volatile base::span<void> GetBlockData(Reference ref,
                                     uint32_t type_id,
                                     size_t size,
                                     size_t* alloc_size = nullptr) const;
-  volatile void* GetBlockData(Reference ref,
+  volatile base::span<void> GetBlockData(Reference ref,
                               uint32_t type_id,
                               size_t size,
                               size_t* alloc_size = nullptr) {
diff --git a/base/metrics/persistent_memory_allocator_unittest.cc b/base/metrics/persistent_memory_allocator_unittest.cc
index 63d045b063c39..6eca24ce77ae7 100644
--- a/base/metrics/persistent_memory_allocator_unittest.cc
+++ b/base/metrics/persistent_memory_allocator_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -152,8 +154,8 @@ TEST_F(PersistentMemoryAllocatorTest, AllocateAndIterate) {
 
   // Verify that pointers can be turned back into references and that invalid
   // addresses return null.
-  char* memory1 = allocator_->GetAsArray<char>(block1, 1, 1);
-  ASSERT_TRUE(memory1);
+  base::span<char>memory1 = allocator_->GetAsArray<char>(block1, 1, 1);
+  ASSERT_TRUE(memory1.data());
   EXPECT_EQ(block1, allocator_->GetAsReference(memory1, 0));
   EXPECT_EQ(block1, allocator_->GetAsReference(memory1, 1));
   EXPECT_EQ(0U, allocator_->GetAsReference(memory1, 2));
@@ -780,8 +782,8 @@ TEST(SharedPersistentMemoryAllocatorTest, CreationTest) {
 
   // Clear-on-change test.
   Reference data_ref = shalloc3.Allocate(sizeof(int) * 4, 911);
-  int* data = shalloc3.GetAsArray<int>(data_ref, 911, 4);
-  ASSERT_TRUE(data);
+  base::span<int>data = shalloc3.GetAsArray<int>(data_ref, 911, 4);
+  ASSERT_TRUE(data.data());
   data[0] = 0;
   data[1] = 1;
   data[2] = 2;
diff --git a/base/process/process_metrics_unittest.cc b/base/process/process_metrics_unittest.cc
index d61a242093588..ed906159ed914 100644
--- a/base/process/process_metrics_unittest.cc
+++ b/base/process/process_metrics_unittest.cc
@@ -1047,7 +1047,7 @@ TEST(ProcessMetricsTestLinux, GetPageFaultCounts) {
     WritableSharedMemoryMapping mapping = region.Map();
     ASSERT_TRUE(mapping.IsValid());
 
-    memset(mapping.memory(), 42, kMappedSize);
+    memset(mapping.memory().data(), 42, kMappedSize);
   }
 
   PageFaultCounts counts_after;
diff --git a/base/profiler/stack_copier.cc b/base/profiler/stack_copier.cc
index 85f2ae0d8a3a9..45b0f5578430f 100644
--- a/base/profiler/stack_copier.cc
+++ b/base/profiler/stack_copier.cc
@@ -94,7 +94,7 @@ const uint8_t* StackCopier::CopyStackContentsAndRewritePointers(
   // RewritePointerIfInOriginalStack(). Bytes before this cannot be a pointer
   // because they occupy less space than a pointer would.
   const uint8_t* first_aligned_address =
-      bits::AlignUp(byte_src, sizeof(uintptr_t));
+      bits::AlignUp(byte_src, sizeof(uintptr_t)).data();
 
   // The stack copy bottom, which is offset from |stack_buffer_bottom| by the
   // same alignment as in the original stack. This guarantees identical
diff --git a/base/trace_event/process_memory_dump_unittest.cc b/base/trace_event/process_memory_dump_unittest.cc
index e596dc486694e..8954b97b6ff88 100644
--- a/base/trace_event/process_memory_dump_unittest.cc
+++ b/base/trace_event/process_memory_dump_unittest.cc
@@ -72,7 +72,7 @@ std::optional<size_t> CountResidentBytesInSharedMemory(
   // mapped_size() is larger than `mem.size()` but represents the actual memory
   // segment size in the SharedMemoryMapping.
   auto mapped =
-      UNSAFE_BUFFERS(base::span(mapping.data(), mapping.mapped_size()));
+      UNSAFE_BUFFERS(base::span(mapping.data().data(), mapping.mapped_size()));
   return ProcessMemoryDump::CountResidentBytesInSharedMemory(mapped.data(),
                                                              mapped.size());
 }
diff --git a/cc/trees/layer_tree_host_impl.cc b/cc/trees/layer_tree_host_impl.cc
index bd606c1760f9b..5e2d93a86a1ed 100644
--- a/cc/trees/layer_tree_host_impl.cc
+++ b/cc/trees/layer_tree_host_impl.cc
@@ -5944,14 +5944,14 @@ void LayerTreeHostImpl::SetActiveURL(const GURL& url, ukm::SourceId source_id) {
 void LayerTreeHostImpl::SetUkmSmoothnessDestination(
     base::WritableSharedMemoryMapping ukm_smoothness_data) {
   dropped_frame_counter_.SetUkmSmoothnessDestination(
-      ukm_smoothness_data.GetMemoryAs<UkmSmoothnessDataShared>());
+      ukm_smoothness_data.GetMemoryAs<UkmSmoothnessDataShared>().data());
   ukm_smoothness_mapping_ = std::move(ukm_smoothness_data);
 }
 
 void LayerTreeHostImpl::SetUkmDroppedFramesDestination(
     base::WritableSharedMemoryMapping ukm_dropped_frames_data) {
   frame_trackers_.SetUkmDroppedFramesDestination(
-      ukm_dropped_frames_data.GetMemoryAs<UkmDroppedFramesDataShared>());
+      ukm_dropped_frames_data.GetMemoryAs<UkmDroppedFramesDataShared>().data());
   ukm_dropped_frames_mapping_ = std::move(ukm_dropped_frames_data);
 }
 
diff --git a/cc/trees/layer_tree_host_unittest.cc b/cc/trees/layer_tree_host_unittest.cc
index 0737217dc85d6..e860ff2b55e4e 100644
--- a/cc/trees/layer_tree_host_unittest.cc
+++ b/cc/trees/layer_tree_host_unittest.cc
@@ -9700,7 +9700,7 @@ class LayerTreeHostUkmSmoothnessMetric : public LayerTreeTest {
   void AfterTest() override {
     ASSERT_TRUE(shmem_region_.IsValid());
     auto mapping = shmem_region_.Map();
-    auto* smoothness = mapping.GetMemoryAs<UkmSmoothnessDataShared>();
+    auto* smoothness = mapping.GetMemoryAs<UkmSmoothnessDataShared>().data();
     ASSERT_TRUE(smoothness);
     // It is not always possible to guarantee an exact number of dropped frames.
     // So validate that there are non-zero dropped frames.
diff --git a/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc b/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
index b7448cedc7e96..72632a5e64bf9 100644
--- a/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
+++ b/chrome/browser/enterprise/connectors/analysis/page_print_analysis_request_unittest.cc
@@ -24,7 +24,7 @@ namespace enterprise_connectors {
 static base::ReadOnlySharedMemoryRegion CreateFakePage(size_t page_size) {
   base::MappedReadOnlyRegion page =
       base::ReadOnlySharedMemoryRegion::Create(page_size);
-  memset(page.mapping.memory(), 'a', page_size);
+  memset(page.mapping.memory().data(), 'a', page_size);
   return std::move(page.region);
 }
 
diff --git a/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc b/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
index 368fe5ba89ae6..ac0ee27853188 100644
--- a/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
+++ b/chrome/browser/on_device_translation/file_operation_proxy_impl_unittest.cc
@@ -151,7 +151,7 @@ class FileOperationProxyImplTest : public testing::Test {
     base::MemoryMappedFile mapped_file;
     CHECK(mapped_file.Initialize(std::move(open_result)));
     EXPECT_THAT(
-        std::string_view(reinterpret_cast<const char*>(mapped_file.data()),
+        std::string_view(reinterpret_cast<const char*>(mapped_file.data().data()),
                          mapped_file.length()),
         *expected_file_content);
   }
diff --git a/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc b/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
index 5bdb8018f641e..d605cb282ebf7 100644
--- a/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
+++ b/chrome/browser/page_load_metrics/observers/core/ukm_page_load_metrics_observer.cc
@@ -1524,7 +1524,7 @@ void UkmPageLoadMetricsObserver::RecordPageLoadTimestampMetrics(
 
 void UkmPageLoadMetricsObserver::RecordDroppedFramesMetrics() {
   auto* dropped_frames =
-      ukm_dropped_frames_data_.GetMemoryAs<cc::UkmDroppedFramesDataShared>();
+      ukm_dropped_frames_data_.GetMemoryAs<cc::UkmDroppedFramesDataShared>().data();
   if (!dropped_frames) {
     return;
   }
@@ -1543,7 +1543,7 @@ void UkmPageLoadMetricsObserver::RecordDroppedFramesMetrics() {
 
 void UkmPageLoadMetricsObserver::RecordSmoothnessMetrics() {
   auto* smoothness =
-      ukm_smoothness_data_.GetMemoryAs<cc::UkmSmoothnessDataShared>();
+      ukm_smoothness_data_.GetMemoryAs<cc::UkmSmoothnessDataShared>().data();
   if (!smoothness) {
     return;
   }
diff --git a/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc b/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
index 021e7a99fcabf..6547671d7cd29 100644
--- a/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
+++ b/chrome/browser/printing/pdf_nup_converter_client_browsertest.cc
@@ -60,7 +60,7 @@ base::MappedReadOnlyRegion GetPdfRegion(const char* file_name) {
   if (!pdf_region.IsValid())
     return pdf_region;
 
-  memcpy(pdf_region.mapping.memory(), pdf_str.data(), pdf_str.size());
+  memcpy(pdf_region.mapping.memory().data(), pdf_str.data(), pdf_str.size());
   return pdf_region;
 }
 
@@ -71,7 +71,7 @@ base::MappedReadOnlyRegion GetBadDataRegion() {
   if (!pdf_region.IsValid())
     return pdf_region;
 
-  memcpy(pdf_region.mapping.memory(), kBadData, std::size(kBadData));
+  memcpy(pdf_region.mapping.memory().data(), kBadData, std::size(kBadData));
   return pdf_region;
 }
 
diff --git a/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc b/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
index 4fc77f73f6a9e..32a3d3c7b1e22 100644
--- a/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
+++ b/chrome/browser/safe_browsing/client_side_detection_host_browsertest.cc
@@ -113,7 +113,7 @@ class FakeClientSideDetectionService : public ClientSideDetectionService {
   base::ReadOnlySharedMemoryRegion GetModelSharedMemoryRegion() override {
     base::MappedReadOnlyRegion mapped_region =
         base::ReadOnlySharedMemoryRegion::Create(client_side_model_.length());
-    memcpy(mapped_region.mapping.memory(), client_side_model_.data(),
+    memcpy(mapped_region.mapping.memory().data(), client_side_model_.data(),
            client_side_model_.length());
     return mapped_region.region.Duplicate();
   }
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
index 667838cfbd978..93eb357195e68 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/connector_data_pipe_getter_unittest.cc
@@ -71,7 +71,7 @@ class ConnectorDataPipeGetterTest : public testing::Test {
     if (!region.IsValid())
       return base::ReadOnlySharedMemoryRegion();
 
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
index f775531bfc617..ef9dc722d1a75 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/multipart_uploader_unittest.cc
@@ -69,7 +69,7 @@ class MultipartUploadRequestTest : public testing::Test {
     base::MappedReadOnlyRegion region =
         base::ReadOnlySharedMemoryRegion::Create(content.size());
     EXPECT_TRUE(region.IsValid());
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc b/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
index 459a2c09cd207..9c785a24e8cff 100644
--- a/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
+++ b/chrome/browser/safe_browsing/cloud_content_scanning/resumable_uploader_unittest.cc
@@ -106,7 +106,7 @@ class ResumableUploadRequestTest : public testing::Test {
     base::MappedReadOnlyRegion region =
         base::ReadOnlySharedMemoryRegion::Create(content.size());
     EXPECT_TRUE(region.IsValid());
-    std::memcpy(region.mapping.memory(), content.data(), content.size());
+    std::memcpy(region.mapping.memory().data(), content.data(), content.size());
     return std::move(region.region);
   }
 
diff --git a/chrome/browser/v8_compile_hints/v8_compile_hints_tab_helper.cc b/chrome/browser/v8_compile_hints/v8_compile_hints_tab_helper.cc
index 62915b909cbb6..2e5b2edd117bd 100644
--- a/chrome/browser/v8_compile_hints/v8_compile_hints_tab_helper.cc
+++ b/chrome/browser/v8_compile_hints/v8_compile_hints_tab_helper.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -139,7 +141,7 @@ void V8CompileHintsTabHelper::SendDataToRenderer(const proto::Model& model) {
     return;
   }
 
-  int64_t* memory = shared_memory_mapping.GetMemoryAs<int64_t>();
+  base::span<int64_t>memory = shared_memory_mapping.GetMemoryAs<int64_t>();
 
   for (size_t i = 0; i < kModelInt64Count; ++i) {
     memory[i] = model.bloom_filter().Get(i);
diff --git a/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc b/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
index 2c6e6e87aa29c..5176c39ce1d60 100644
--- a/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
+++ b/chrome/renderer/safe_browsing/phishing_classifier_browsertest.cc
@@ -203,7 +203,7 @@ class PhishingClassifierTest
     mapped_region_ =
         base::ReadOnlySharedMemoryRegion::Create(model_str.length());
     ASSERT_TRUE(mapped_region_.IsValid());
-    memcpy(mapped_region_.mapping.memory(), model_str.data(),
+    memcpy(mapped_region_.mapping.memory().data(), model_str.data(),
            model_str.length());
     base::File tflite_model;
     base::FilePath tflite_path;
diff --git a/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc b/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
index 31f983e13c0da..b1bfe8d18185c 100644
--- a/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
+++ b/chrome/renderer/safe_browsing/phishing_classifier_delegate_browsertest.cc
@@ -193,7 +193,7 @@ class PhishingClassifierDelegateTest : public ChromeRenderViewTest {
     std::string model_str = GetFlatBufferString(model_version);
     base::MappedReadOnlyRegion mapped_region =
         base::ReadOnlySharedMemoryRegion::Create(model_str.length());
-    memcpy(mapped_region.mapping.memory(), model_str.data(),
+    memcpy(mapped_region.mapping.memory().data(), model_str.data(),
            model_str.length());
 
     ScorerStorage::GetInstance()->SetScorer(
@@ -357,7 +357,7 @@ TEST_F(PhishingClassifierDelegateTest, HasVisualTfLiteModel) {
   std::string model_str = GetFlatBufferString(0);
   base::MappedReadOnlyRegion mapped_region =
       base::ReadOnlySharedMemoryRegion::Create(model_str.length());
-  memcpy(mapped_region.mapping.memory(), model_str.data(), model_str.length());
+  memcpy(mapped_region.mapping.memory().data(), model_str.data(), model_str.length());
   ScorerStorage::GetInstance()->SetScorer(
       Scorer::Create(mapped_region.region.Duplicate(), std::move(file)));
   ASSERT_TRUE(classifier_->is_ready());
diff --git a/components/capture_mode/camera_video_frame_handler.cc b/components/capture_mode/camera_video_frame_handler.cc
index 7caaee95909e3..c5be78d53be13 100644
--- a/components/capture_mode/camera_video_frame_handler.cc
+++ b/components/capture_mode/camera_video_frame_handler.cc
@@ -177,7 +177,7 @@ class SharedMemoryBufferHandleHolder : public BufferHandleHolder {
     auto frame = media::VideoFrame::WrapExternalData(
         frame_info->pixel_format, frame_info->coded_size,
         frame_info->visible_rect, frame_info->visible_rect.size(),
-        mapping.GetMemoryAs<uint8_t>(), mapping.size(), frame_info->timestamp);
+        mapping.GetMemoryAs<uint8_t>().data(), mapping.size(), frame_info->timestamp);
 
     if (frame) {
       frame->AddDestructionObserver(base::DoNothingWithBoundArgs(mapping_));
diff --git a/components/enterprise/watermarking/content/watermark_text_container.cc b/components/enterprise/watermarking/content/watermark_text_container.cc
index a06fbbf576b6e..f57f9e5dcf23a 100644
--- a/components/enterprise/watermarking/content/watermark_text_container.cc
+++ b/components/enterprise/watermarking/content/watermark_text_container.cc
@@ -38,7 +38,7 @@ watermark::mojom::WatermarkBlockPtr WatermarkTextContainer::Serialize() const {
   if (!region_mapping.IsValid()) {
     return nullptr;
   }
-  stream.copyTo(region_mapping.mapping.memory());
+  stream.copyTo(region_mapping.mapping.memory().data());
   return watermark::mojom::WatermarkBlockPtr(std::in_place,
                                              std::move(region_mapping.region),
                                              block_width_, block_height_);
diff --git a/components/enterprise/watermarking/watermark_test_utils.cc b/components/enterprise/watermarking/watermark_test_utils.cc
index 9959aaea6cdfd..4e682a8443dd9 100644
--- a/components/enterprise/watermarking/watermark_test_utils.cc
+++ b/components/enterprise/watermarking/watermark_test_utils.cc
@@ -47,7 +47,7 @@ watermark::mojom::WatermarkBlockPtr MakeTestWatermarkBlock(
   if (!region_mapping.IsValid()) {
     return nullptr;
   }
-  stream.copyTo(region_mapping.mapping.memory());
+  stream.copyTo(region_mapping.mapping.memory().data());
 
   // Measure string dimensions
   SkScalar text_width = font.measureText(
diff --git a/components/metrics/persistent_system_profile.cc b/components/metrics/persistent_system_profile.cc
index 5ffc5ec97f90a..7b1221b84cbcf 100644
--- a/components/metrics/persistent_system_profile.cc
+++ b/components/metrics/persistent_system_profile.cc
@@ -86,7 +86,7 @@ void PersistentSystemProfile::RecordAllocator::Reset() {
     // arrays of fundamental types are allowed.
     RecordHeader* header =
         reinterpret_cast<RecordHeader*>(allocator_->GetAsArray<char>(
-            alloc_reference_, kTypeIdSystemProfile, sizeof(RecordHeader)));
+            alloc_reference_, kTypeIdSystemProfile, sizeof(RecordHeader)).data());
     DCHECK(header);
     base::subtle::NoBarrier_Store(&header->as_atomic, 0);
   }
@@ -122,15 +122,15 @@ bool PersistentSystemProfile::RecordAllocator::HasMoreData() const {
   if (alloc_reference_ == 0 && !NextSegment())
     return false;
 
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block)
+  if (block.empty())
     return false;
 
   RecordHeader header;
   header.as_atomic = base::subtle::Acquire_Load(
-      reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_));
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()));
   return header.as_parts.type != kUnusedSpace;
 }
 
@@ -163,7 +163,7 @@ bool PersistentSystemProfile::RecordAllocator::AddSegment(size_t min_size) {
     // or by the "reset" procedure.
     DCHECK_EQ(0, base::subtle::NoBarrier_Load(
                      allocator_->GetAsArray<base::subtle::Atomic32>(
-                         alloc_reference_, kTypeIdSystemProfile, 1)));
+                         alloc_reference_, kTypeIdSystemProfile, 1).data()));
     return true;
   }
 
@@ -188,10 +188,10 @@ bool PersistentSystemProfile::RecordAllocator::AddSegment(size_t min_size) {
 bool PersistentSystemProfile::RecordAllocator::WriteData(RecordType type,
                                                          const char** data,
                                                          size_t* data_size) {
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block)
+  if (block.empty())
     return false;  // It's bad if there is no accessible block.
 
   const size_t max_write_size = std::min(
@@ -212,11 +212,11 @@ bool PersistentSystemProfile::RecordAllocator::WriteData(RecordType type,
   if (end_offset_ < alloc_size_) {
     // An empty record header has to be next before this one gets written.
     base::subtle::NoBarrier_Store(
-        reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_), 0);
+        reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()), 0);
   }
-  memcpy(block + offset + sizeof(header), *data, write_size);
+  memcpy(block .subspan( offset + sizeof).data()(header), *data, write_size);
   base::subtle::Release_Store(
-      reinterpret_cast<base::subtle::Atomic32*>(block + offset),
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( offset).data()),
       header.as_atomic);
 
   // Account for what was stored and prepare for follow-on records with any
@@ -232,10 +232,10 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
     std::string* record) const {
   DCHECK_GT(alloc_size_, end_offset_);
 
-  char* block =
+  base::span<char>block =
       allocator_->GetAsArray<char>(alloc_reference_, kTypeIdSystemProfile,
                                    base::PersistentMemoryAllocator::kSizeAny);
-  if (!block) {
+  if (block.empty()) {
     *type = kUnusedSpace;
     return true;  // No more data.
   }
@@ -243,7 +243,7 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
   // Get and validate the record header.
   RecordHeader header;
   header.as_atomic = base::subtle::Acquire_Load(
-      reinterpret_cast<base::subtle::Atomic32*>(block + end_offset_));
+      reinterpret_cast<base::subtle::Atomic32*>(block .subspan( end_offset_).data()));
   bool continued = !!header.as_parts.continued;
   if (header.as_parts.type == kUnusedSpace) {
     *type = kUnusedSpace;
@@ -275,7 +275,7 @@ bool PersistentSystemProfile::RecordAllocator::ReadData(
   }
 
   // Append the record data to the output string.
-  record->append(block + end_offset_ + sizeof(header), read_size);
+  record->append(block .subspan( end_offset_ + sizeof).data()(header), read_size);
   end_offset_ += CalculateRecordSize(read_size);
   DCHECK_GE(alloc_size_, end_offset_);
 
diff --git a/components/mirroring/service/fake_video_capture_host.cc b/components/mirroring/service/fake_video_capture_host.cc
index e998ac5d3548b..0ea240404a3dd 100644
--- a/components/mirroring/service/fake_video_capture_host.cc
+++ b/components/mirroring/service/fake_video_capture_host.cc
@@ -74,7 +74,7 @@ void FakeVideoCaptureHost::SendOneFrame(const gfx::Size& size,
   if (!shmem.IsValid()) {
     return;
   }
-  memset(shmem.mapping.memory(), 125, 5000);
+  memset(shmem.mapping.memory().data(), 125, 5000);
   observer_->OnNewBuffer(
       0, media::mojom::VideoBufferHandle::NewReadOnlyShmemRegion(
              std::move(shmem.region)));
diff --git a/components/mirroring/service/video_capture_client.cc b/components/mirroring/service/video_capture_client.cc
index a5a5d3a9047a6..508d7f239d9df 100644
--- a/components/mirroring/service/video_capture_client.cc
+++ b/components/mirroring/service/video_capture_client.cc
@@ -234,7 +234,7 @@ void VideoCaptureClient::OnBufferReady(media::mojom::ReadyBufferPtr buffer) {
       frame = media::VideoFrame::WrapExternalData(
           buffer->info->pixel_format, buffer->info->coded_size,
           buffer->info->visible_rect, buffer->info->visible_rect.size(),
-          mapping.GetMemoryAs<uint8_t>(), frame_allocation_size,
+          mapping.GetMemoryAs<uint8_t>().data(), frame_allocation_size,
           buffer->info->timestamp);
     }
     buffer_finished_callback =
@@ -253,7 +253,7 @@ void VideoCaptureClient::OnBufferReady(media::mojom::ReadyBufferPtr buffer) {
       frame = media::VideoFrame::WrapExternalData(
           buffer->info->pixel_format, buffer->info->coded_size,
           buffer->info->visible_rect, buffer->info->visible_rect.size(),
-          mapping.GetMemoryAs<uint8_t>(), frame_allocation_size,
+          mapping.GetMemoryAs<uint8_t>().data(), frame_allocation_size,
           buffer->info->timestamp);
       if (frame) {
         frame->BackWithOwnedSharedMemory(std::move(shm_region),
diff --git a/components/omnibox/browser/on_device_tail_model_executor.cc b/components/omnibox/browser/on_device_tail_model_executor.cc
index 417e608c292a4..e4b15b3927ea8 100644
--- a/components/omnibox/browser/on_device_tail_model_executor.cc
+++ b/components/omnibox/browser/on_device_tail_model_executor.cc
@@ -276,7 +276,7 @@ bool OnDeviceTailModelExecutor::InitModelInterpreter(
 
   std::unique_ptr<tflite::FlatBufferModel> model =
       tflite::FlatBufferModel::VerifyAndBuildFromBuffer(
-          reinterpret_cast<const char*>(model_fb_->data()),
+          reinterpret_cast<const char*>(model_fb_->data().data()),
           model_fb_->length());
 
   if (model == nullptr) {
diff --git a/components/printing/browser/print_to_pdf/pdf_print_job.cc b/components/printing/browser/print_to_pdf/pdf_print_job.cc
index d631aec7d767d..0cef01eb6a19c 100644
--- a/components/printing/browser/print_to_pdf/pdf_print_job.cc
+++ b/components/printing/browser/print_to_pdf/pdf_print_job.cc
@@ -131,7 +131,7 @@ void PdfPrintJob::ReportMemoryRegion(
   }
 
   std::string data =
-      std::string(static_cast<const char*>(mapping.memory()), mapping.size());
+      std::string(static_cast<const char*>(mapping.memory().data()), mapping.size());
   std::move(print_to_pdf_callback_)
       .Run(PdfPrintResult::kPrintSuccess,
            base::MakeRefCounted<base::RefCountedString>(std::move(data)));
diff --git a/components/safe_browsing/content/browser/client_side_phishing_model.cc b/components/safe_browsing/content/browser/client_side_phishing_model.cc
index 04b37b7ce6a72..295501415bcfa 100644
--- a/components/safe_browsing/content/browser/client_side_phishing_model.cc
+++ b/components/safe_browsing/content/browser/client_side_phishing_model.cc
@@ -647,7 +647,7 @@ void ClientSidePhishingModel::ClearMappedRegionForTesting() {
 
 void* ClientSidePhishingModel::GetFlatBufferMemoryAddressForTesting() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return mapped_region_.mapping.memory();
+  return mapped_region_.mapping.memory().data();
 }
 
 // This function is used for testing in client_side_phishing_model_unittest
diff --git a/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc b/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
index 6c7fb8dc400e2..e16621a7e0ff3 100644
--- a/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
+++ b/components/safe_browsing/content/browser/client_side_phishing_model_unittest.cc
@@ -192,7 +192,7 @@ void GetFlatBufferStringFromMappedMemory(
   ASSERT_TRUE(region.IsValid());
   base::ReadOnlySharedMemoryMapping mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  *output = std::string(reinterpret_cast<const char*>(mapping.memory()),
+  *output = std::string(reinterpret_cast<const char*>(mapping.memory().data()),
                         mapping.size());
 }
 
diff --git a/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc b/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
index 43b3fa9643451..02744c79caa6f 100644
--- a/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
+++ b/components/safe_browsing/content/renderer/phishing_classifier/scorer.cc
@@ -407,7 +407,7 @@ std::unique_ptr<Scorer> Scorer::Create(base::ReadOnlySharedMemoryRegion region,
   }
 
   flatbuffers::Verifier verifier(
-      reinterpret_cast<const uint8_t*>(mapping.memory()), mapping.size());
+      reinterpret_cast<const uint8_t*>(mapping.memory().data()), mapping.size());
   if (!flat::VerifyClientSideModelBuffer(verifier)) {
     RecordScorerCreationStatus(SCORER_FAIL_FLATBUFFER_FAILED_VERIFY);
     return nullptr;
diff --git a/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc b/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
index fe7db86e1a356..e59ee7456fade 100644
--- a/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
+++ b/components/safe_browsing/content/renderer/phishing_classifier/scorer_unittest.cc
@@ -98,7 +98,7 @@ base::MappedReadOnlyRegion GetMappedReadOnlyRegionWithData(std::string data) {
   base::MappedReadOnlyRegion mapped_region =
       base::ReadOnlySharedMemoryRegion::Create(data.length());
   EXPECT_TRUE(mapped_region.IsValid());
-  memcpy(mapped_region.mapping.memory(), data.data(), data.length());
+  memcpy(mapped_region.mapping.memory().data(), data.data(), data.length());
   return mapped_region;
 }
 
diff --git a/components/services/font/public/cpp/mapped_font_file.cc b/components/services/font/public/cpp/mapped_font_file.cc
index 23e48d2841166..562a2e45cc939 100644
--- a/components/services/font/public/cpp/mapped_font_file.cc
+++ b/components/services/font/public/cpp/mapped_font_file.cc
@@ -27,7 +27,7 @@ bool MappedFontFile::Initialize(base::File file) {
 SkMemoryStream* MappedFontFile::CreateMemoryStream() {
   DCHECK(mapped_font_file_.IsValid());
   sk_sp<SkData> data =
-      SkData::MakeWithProc(mapped_font_file_.data(), mapped_font_file_.length(),
+      SkData::MakeWithProc(mapped_font_file_.data().data(), mapped_font_file_.length(),
                            &MappedFontFile::ReleaseProc, this);
   if (!data)
     return nullptr;
diff --git a/components/services/on_device_translation/translate_kit_client.cc b/components/services/on_device_translation/translate_kit_client.cc
index cd4aaa316289a..31178ba81a97f 100644
--- a/components/services/on_device_translation/translate_kit_client.cc
+++ b/components/services/on_device_translation/translate_kit_client.cc
@@ -62,7 +62,7 @@ void DeleteReadOnlyMemoryRegion(std::uintptr_t memory_map_ptr,
 const void* ReadOnlyMemoryRegionData(std::uintptr_t memory_map_ptr,
                                      std::uintptr_t user_data) {
   CHECK(memory_map_ptr);
-  return reinterpret_cast<base::MemoryMappedFile*>(memory_map_ptr)->data();
+  return reinterpret_cast<base::MemoryMappedFile*>(memory_map_ptr)->data().data();
 }
 
 uint64_t ReadOnlyMemoryRegionLength(std::uintptr_t memory_map_ptr,
diff --git a/components/services/print_compositor/print_compositor_impl.cc b/components/services/print_compositor/print_compositor_impl.cc
index 0671759f8e83b..e1bd9f6b8a585 100644
--- a/components/services/print_compositor/print_compositor_impl.cc
+++ b/components/services/print_compositor/print_compositor_impl.cc
@@ -485,7 +485,7 @@ mojom::PrintCompositor::Status PrintCompositorImpl::CompositePages(
     return mojom::PrintCompositor::Status::kHandleMapError;
   }
 
-  wstream.copyToAndReset(region_mapping.mapping.memory());
+  wstream.copyToAndReset(region_mapping.mapping.memory().data());
   *region = std::move(region_mapping.region);
   return mojom::PrintCompositor::Status::kSuccess;
 }
@@ -557,7 +557,7 @@ void PrintCompositorImpl::FinishDocumentRequest(
           doc_info_->compositor_stream.bytesWritten());
   if (region_mapping.IsValid()) {
     doc_info_->compositor_stream.copyToAndReset(
-        region_mapping.mapping.memory());
+        region_mapping.mapping.memory().data());
     region = std::move(region_mapping.region);
     status = mojom::PrintCompositor::Status::kSuccess;
   } else {
diff --git a/components/services/print_compositor/print_compositor_impl_unittest.cc b/components/services/print_compositor/print_compositor_impl_unittest.cc
index 2c322a0dadb48..113fb8adfbb29 100644
--- a/components/services/print_compositor/print_compositor_impl_unittest.cc
+++ b/components/services/print_compositor/print_compositor_impl_unittest.cc
@@ -172,7 +172,7 @@ class PrintCompositorImplTest : public testing::Test {
                                                          int page_num) {
     static constexpr size_t kSize = sizeof(TestRequestData);
     auto region = base::ReadOnlySharedMemoryRegion::Create(kSize);
-    auto* data = region.mapping.GetMemoryAs<TestRequestData>();
+    auto* data = region.mapping.GetMemoryAs<TestRequestData>().data();
     data->frame_guid = frame_guid;
     data->page_num = page_num;
     return std::move(region.region);
diff --git a/components/visitedlink/browser/partitioned_visitedlink_writer.cc b/components/visitedlink/browser/partitioned_visitedlink_writer.cc
index 4f583e1671f12..56901e152c8bf 100644
--- a/components/visitedlink/browser/partitioned_visitedlink_writer.cc
+++ b/components/visitedlink/browser/partitioned_visitedlink_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -278,11 +280,11 @@ bool PartitionedVisitedLinkWriter::CreateVisitedLinkTableHelper(
     return false;
   }
 
-  memset(memory->mapping.memory(), 0, alloc_size);
+  memset(memory->mapping.memory().data(), 0, alloc_size);
 
   // Save the header for other processes to read.
   PartitionedSharedHeader* header =
-      static_cast<PartitionedSharedHeader*>(memory->mapping.memory());
+      static_cast<PartitionedSharedHeader*>(memory->mapping.memory().data());
   header->length = num_entries;
   return true;
 }
@@ -329,7 +331,7 @@ void PartitionedVisitedLinkWriter::ResizeTable(int32_t new_size) {
   }
 
   {
-    Fingerprint* old_hash_table =
+    base::span<Fingerprint>old_hash_table =
         GetHashTableFromMapping(old_hash_table_mapping);
     // Now we have two tables, our local copy which is the old one, and the new
     // one loaded into this object where we need to copy the data.
@@ -363,7 +365,7 @@ bool PartitionedVisitedLinkWriter::BuildTableFromDelegate() {
 VisitedLinkWriter::Hash PartitionedVisitedLinkWriter::AddFingerprint(
     Fingerprint fingerprint,
     bool send_notifications) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     base::UmaHistogramEnumeration("History.VisitedLinks.TryToAddFingerprint",
                                   AddFingerprint::kTableError);
     NOTREACHED();  // Not initialized.
@@ -418,7 +420,7 @@ void PartitionedVisitedLinkWriter::DeleteFingerprintsFromCurrentTable(
 }
 
 bool PartitionedVisitedLinkWriter::DeleteFingerprint(Fingerprint fingerprint) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     NOTREACHED();  // Not initialized.
   }
   if (!IsVisited(fingerprint)) {
@@ -658,7 +660,7 @@ void PartitionedVisitedLinkWriter::DeleteAllVisitedLinks() {
 
   // Clear the hash table.
   used_items_ = 0;
-  memset(hash_table_, 0, this->table_length_ * sizeof(Fingerprint));
+  memset(hash_table_.data(), 0, this->table_length_ * sizeof(Fingerprint));
 
   // Resize it if it is now too empty. Resize may write the new table out for
   // us, otherwise, schedule writing the new table to disk ourselves.
@@ -769,14 +771,14 @@ std::optional<uint64_t> PartitionedVisitedLinkWriter::GetOrAddOriginSalt(
 }
 
 // static
-VisitedLinkCommon::Fingerprint*
+base::span<VisitedLinkCommon::Fingerprint>
 PartitionedVisitedLinkWriter::GetHashTableFromMapping(
     base::WritableSharedMemoryMapping& hash_table_mapping) {
   DCHECK(hash_table_mapping.IsValid());
   // Our table pointer is just the data immediately following the header.
   return reinterpret_cast<Fingerprint*>(
-      static_cast<char*>(hash_table_mapping.memory()) +
-      sizeof(PartitionedSharedHeader));
+      static_cast<char*>(hash_table_mapping.memory()) .subspan(
+      sizeof)(PartitionedSharedHeader));
 }
 
 }  // namespace visitedlink
diff --git a/components/visitedlink/browser/partitioned_visitedlink_writer.h b/components/visitedlink/browser/partitioned_visitedlink_writer.h
index 9a7eeb5926e4a..0109394d456b9 100644
--- a/components/visitedlink/browser/partitioned_visitedlink_writer.h
+++ b/components/visitedlink/browser/partitioned_visitedlink_writer.h
@@ -8,6 +8,7 @@
 #include <map>
 #include <set>
 
+#include "base/containers/span.h"
 #include "base/memory/read_only_shared_memory_region.h"
 #include "components/visitedlink/common/visitedlink_common.h"
 #include "components/visitedlink/core/visited_link.h"
@@ -240,7 +241,7 @@ class PartitionedVisitedLinkWriter : public VisitedLinkCommon {
 
   // Returns a pointer to the start of the hash table, given the mapping
   // containing the hash table.
-  static Fingerprint* GetHashTableFromMapping(
+  static base::span<Fingerprint> GetHashTableFromMapping(
       base::WritableSharedMemoryMapping& hash_table_mapping);
 
   // Returns the default table size. It can be overridden in unit tests.
diff --git a/components/visitedlink/browser/visitedlink_writer.cc b/components/visitedlink/browser/visitedlink_writer.cc
index 269b9c5d0f559..2c99bc1c2435d 100644
--- a/components/visitedlink/browser/visitedlink_writer.cc
+++ b/components/visitedlink/browser/visitedlink_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -407,7 +409,7 @@ void VisitedLinkWriter::DeleteAllURLs() {
 
   // Clear the hash table.
   used_items_ = 0;
-  memset(hash_table_, 0, this->table_length_ * sizeof(Fingerprint));
+  memset(hash_table_.data(), 0, this->table_length_ * sizeof(Fingerprint));
 
   // Resize it if it is now too empty. Resize may write the new table out for
   // us, otherwise, schedule writing the new table to disk ourselves.
@@ -487,7 +489,7 @@ void VisitedLinkWriter::DeleteURLs(URLIterator* urls) {
 VisitedLinkWriter::Hash VisitedLinkWriter::AddFingerprint(
     Fingerprint fingerprint,
     bool send_notifications) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     UMA_HISTOGRAM_ENUMERATION("History.VisitedLinks.TryToAddFingerprint",
                               AddFingerprint::kTableError);
     NOTREACHED();  // Not initialized.
@@ -547,7 +549,7 @@ void VisitedLinkWriter::DeleteFingerprintsFromCurrentTable(
 
 bool VisitedLinkWriter::DeleteFingerprint(Fingerprint fingerprint,
                                           bool update_file) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     NOTREACHED();  // Not initialized.
   }
   if (!IsVisited(fingerprint))
@@ -922,10 +924,10 @@ bool VisitedLinkWriter::CreateApartURLTable(
   if (!memory->IsValid())
     return false;
 
-  memset(memory->mapping.memory(), 0, alloc_size);
+  memset(memory->mapping.memory().data(), 0, alloc_size);
 
   // Save the header for other processes to read.
-  SharedHeader* header = static_cast<SharedHeader*>(memory->mapping.memory());
+  SharedHeader* header = static_cast<SharedHeader*>(memory->mapping.memory().data());
   header->length = num_entries;
   memcpy(header->salt, salt, LINK_SALT_LENGTH);
 
@@ -986,7 +988,7 @@ void VisitedLinkWriter::ResizeTable(int32_t new_size) {
   shared_memory_serial_++;
 
   {
-    Fingerprint* old_hash_table =
+    base::span<Fingerprint>old_hash_table =
         GetHashTableFromMapping(old_hash_table_mapping);
     // Now we have two tables, our local copy which is the old one, and the new
     // one loaded into this object where we need to copy the data.
@@ -1204,12 +1206,12 @@ void VisitedLinkWriter::TableBuilder::OnCompleteMainThread() {
 }
 
 // static
-VisitedLinkCommon::Fingerprint* VisitedLinkWriter::GetHashTableFromMapping(
+base::span<VisitedLinkCommon::Fingerprint> VisitedLinkWriter::GetHashTableFromMapping(
     base::WritableSharedMemoryMapping& hash_table_mapping) {
   DCHECK(hash_table_mapping.IsValid());
   // Our table pointer is just the data immediately following the header.
   return reinterpret_cast<Fingerprint*>(
-      static_cast<char*>(hash_table_mapping.memory()) + sizeof(SharedHeader));
+      static_cast<char*>(hash_table_mapping.memory()) .subspan( sizeof)(SharedHeader));
 }
 
 }  // namespace visitedlink
diff --git a/components/visitedlink/browser/visitedlink_writer.h b/components/visitedlink/browser/visitedlink_writer.h
index 79de29510d397..0344b065b34f9 100644
--- a/components/visitedlink/browser/visitedlink_writer.h
+++ b/components/visitedlink/browser/visitedlink_writer.h
@@ -13,6 +13,7 @@
 #include <set>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/files/file_path.h"
 #include "base/files/scoped_file.h"
 #include "base/functional/callback.h"
@@ -402,7 +403,7 @@ class VisitedLinkWriter : public VisitedLinkCommon {
 
   // Returns a pointer to the start of the hash table, given the mapping
   // containing the hash table.
-  static Fingerprint* GetHashTableFromMapping(
+  static base::span<Fingerprint> GetHashTableFromMapping(
       base::WritableSharedMemoryMapping& hash_table_mapping);
 
   // Reference to the browser context that this object belongs to
diff --git a/components/visitedlink/common/visitedlink_common.cc b/components/visitedlink/common/visitedlink_common.cc
index f5bd0ffc685d4..6abc4f684a666 100644
--- a/components/visitedlink/common/visitedlink_common.cc
+++ b/components/visitedlink/common/visitedlink_common.cc
@@ -54,7 +54,7 @@ bool VisitedLinkCommon::IsVisited(std::string_view canonical_url) const {
   if (canonical_url.size() == 0) {
     return false;
   }
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     return false;
   }
   return IsVisited(ComputeURLFingerprint(canonical_url));
@@ -65,7 +65,7 @@ bool VisitedLinkCommon::IsVisited(const GURL& url) const {
 }
 
 bool VisitedLinkCommon::IsVisited(const VisitedLink& link, uint64_t salt) {
-  if (!hash_table_ || table_length_ == 0) {
+  if (!!hash_table_.empty() || table_length_ == 0) {
     return false;
   }
   if (!link.IsValid()) {
diff --git a/components/visitedlink/common/visitedlink_common.h b/components/visitedlink/common/visitedlink_common.h
index 5b97414065022..78256f87ff908 100644
--- a/components/visitedlink/common/visitedlink_common.h
+++ b/components/visitedlink/common/visitedlink_common.h
@@ -11,6 +11,7 @@
 #include <string_view>
 #include <vector>
 
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "components/visitedlink/core/visited_link.h"
 
@@ -142,7 +143,7 @@ class VisitedLinkCommon {
   // function should be called instead of accessing the table directly to
   // contain endian issues.
   Fingerprint FingerprintAt(int32_t table_offset) const {
-    if (!hash_table_)
+    if (!!hash_table_.empty())
       return null_fingerprint_;
     return hash_table_[table_offset];
   }
@@ -182,7 +183,7 @@ class VisitedLinkCommon {
 
   // pointer to the first item
   // May temporarily point to an old unmapped region during update.
-  raw_ptr<VisitedLinkCommon::Fingerprint,
+  base::raw_span<VisitedLinkCommon::Fingerprint,
           DisableDanglingPtrDetection | AllowPtrArithmetic>
       hash_table_ = nullptr;
 
diff --git a/components/visitedlink/renderer/visitedlink_reader.cc b/components/visitedlink/renderer/visitedlink_reader.cc
index 34e6e6d50d1f6..43093c96d755b 100644
--- a/components/visitedlink/renderer/visitedlink_reader.cc
+++ b/components/visitedlink/renderer/visitedlink_reader.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -85,7 +87,7 @@ void VisitedLinkReader::UpdateUnpartitionedVisitedLinks(
       return;
 
     const SharedHeader* header =
-        static_cast<const SharedHeader*>(header_mapping.memory());
+        static_cast<const SharedHeader*>(header_mapping.memory().data());
     table_len = header->length;
     memcpy(salt_, header->salt, sizeof(salt_));
   }
@@ -97,7 +99,7 @@ void VisitedLinkReader::UpdateUnpartitionedVisitedLinks(
 
   // Commit the data.
   hash_table_ = const_cast<Fingerprint*>(reinterpret_cast<const Fingerprint*>(
-      static_cast<const SharedHeader*>(table_mapping_.memory()) + 1));
+      static_cast<const SharedHeader*>(table_mapping_.memory()) .subspan( 1)));
   table_length_ = table_len;
   base::UmaHistogramCounts10M(
       "History.VisitedLinks.HashTableLengthOnReaderInit", table_length_);
@@ -116,7 +118,7 @@ void VisitedLinkReader::UpdatePartitionedVisitedLinks(
     }
 
     const PartitionedSharedHeader* header =
-        static_cast<const PartitionedSharedHeader*>(header_mapping.memory());
+        static_cast<const PartitionedSharedHeader*>(header_mapping.memory().data());
     table_len = header->length;
   }
 
@@ -128,8 +130,8 @@ void VisitedLinkReader::UpdatePartitionedVisitedLinks(
 
   // Commit the data.
   hash_table_ = const_cast<Fingerprint*>(reinterpret_cast<const Fingerprint*>(
-      static_cast<const PartitionedSharedHeader*>(table_mapping_.memory()) +
-      1));
+      static_cast<const PartitionedSharedHeader*>(table_mapping_.memory()) .subspan(
+      1)));
   table_length_ = table_len;
   base::UmaHistogramCounts10M(
       "History.VisitedLinks.HashTableLengthOnReaderInit", table_length_);
@@ -155,11 +157,11 @@ void VisitedLinkReader::UpdateOriginSalts(
 }
 
 void VisitedLinkReader::FreeTable() {
-  if (!hash_table_)
+  if (!!hash_table_.empty())
     return;
 
   table_mapping_ = base::ReadOnlySharedMemoryMapping();
-  hash_table_ = nullptr;
+  hash_table_ = {};
   table_length_ = 0;
 }
 
diff --git a/components/viz/common/yuv_readback_unittest.cc b/components/viz/common/yuv_readback_unittest.cc
index 31a262e025ee2..6da54197bd563 100644
--- a/components/viz/common/yuv_readback_unittest.cc
+++ b/components/viz/common/yuv_readback_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -240,7 +242,7 @@ class YUVReadbackTest : public testing::Test {
     return ret;
   }
 
-  void PrintPlane(const unsigned char* plane,
+  void PrintPlane(base::span<const unsigned char>plane,
                   int xsize,
                   int stride,
                   int ysize) {
@@ -255,9 +257,9 @@ class YUVReadbackTest : public testing::Test {
 
   // Compare two planes make sure that each component of each pixel
   // is no more than |maxdiff| apart.
-  void ComparePlane(const unsigned char* truth,
+  void ComparePlane(base::span<const unsigned char>truth,
                     int truth_stride,
-                    const unsigned char* other,
+                    base::span<const unsigned char>other,
                     int other_stride,
                     int maxdiff,
                     int xsize,
@@ -386,18 +388,18 @@ class YUVReadbackTest : public testing::Test {
       FlipSKBitmap(&input_pixels);
     }
 
-    unsigned char* Y =
+    base::span<unsigned char>Y =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY);
-    unsigned char* U =
+    base::span<unsigned char>U =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU);
-    unsigned char* V =
+    base::span<unsigned char>V =
         truth_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV);
     int32_t y_stride = truth_frame->stride(media::VideoFrame::Plane::kY);
     int32_t u_stride = truth_frame->stride(media::VideoFrame::Plane::kU);
     int32_t v_stride = truth_frame->stride(media::VideoFrame::Plane::kV);
-    memset(Y, 0x00, y_stride * output_ysize);
-    memset(U, 0x80, u_stride * output_ysize / 2);
-    memset(V, 0x80, v_stride * output_ysize / 2);
+    memset(Y.data(), 0x00, y_stride * output_ysize);
+    memset(U.data(), 0x80, u_stride * output_ysize / 2);
+    memset(V.data(), 0x80, v_stride * output_ysize / 2);
 
     const auto kRGBtoYColorWeights =
         std::to_array<float>({0.257f, 0.504f, 0.098f, 0.0625f});
diff --git a/components/viz/service/display/renderer_pixeltest.cc b/components/viz/service/display/renderer_pixeltest.cc
index d8df32c901754..2191d4d5b037c 100644
--- a/components/viz/service/display/renderer_pixeltest.cc
+++ b/components/viz/service/display/renderer_pixeltest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -485,30 +487,30 @@ void CreateTestY16TextureDrawQuad_TwoColor(
   DCHECK_EQ(video_frame->stride(0) % 2, 0ul);
 
   for (int j = 0; j < video_frame->rows(0); ++j) {
-    uint8_t* row = video_frame->writable_data(0) + j * video_frame->stride(0);
+    base::span<uint8_t>row = video_frame->writable_data(0) .subspan( j * video_frame->stride(0));
     if (j < foreground_rect.y() || j >= foreground_rect.bottom()) {
       for (size_t i = 0; i < video_frame->stride(0) / 2; ++i) {
-        *row++ = i & 0xFF;  // Fill R with anything. It is not rendered.
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;  // Fill R with anything. It is not rendered.
+        (row++)[0] = g_background;
       }
     } else {
       for (size_t i = 0; i < std::min<size_t>(video_frame->stride(0) / 2,
                                               foreground_rect.x());
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_background;
       }
       for (size_t i = foreground_rect.x();
            i < std::min<size_t>(video_frame->stride(0) / 2,
                                 foreground_rect.right());
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_foreground;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_foreground;
       }
       for (size_t i = foreground_rect.right(); i < video_frame->stride(0) / 2;
            ++i) {
-        *row++ = i & 0xFF;
-        *row++ = g_background;
+        (row++)[0] = i & 0xFF;
+        (row++)[0] = g_background;
       }
     }
   }
@@ -537,7 +539,7 @@ void CreateTestMultiplanarVideoDrawQuad(
   float draw_opacity = 1.0f;
   const bool with_alpha = (video_frame->format() == media::PIXEL_FORMAT_I420A);
   if (with_alpha) {
-    memset(video_frame->writable_data(media::VideoFrame::Plane::kA),
+    memset(video_frame->writable_data(media::VideoFrame::Plane::kA).data(),
            alpha_value,
            video_frame->stride(media::VideoFrame::Plane::kA) *
                video_frame->rows(media::VideoFrame::Plane::kA));
@@ -597,21 +599,21 @@ class TestVideoFrameBuilder {
     uint8_t u_value = 0;
     uint8_t v_value = 0;
     for (int i = 0; i < video_frame_->rows(media::VideoFrame::Plane::kY); ++i) {
-      uint8_t* y_row =
-          video_frame_->writable_data(media::VideoFrame::Plane::kY) +
-          video_frame_->stride(media::VideoFrame::Plane::kY) * i;
+      base::span<uint8_t>y_row =
+          video_frame_->writable_data(media::VideoFrame::Plane::kY) .subspan(
+          video_frame_->stride(media::VideoFrame::Plane::kY) * i);
       for (int j = 0; j < video_frame_->row_bytes(media::VideoFrame::Plane::kY);
            ++j) {
         y_row[j] = (y_value += 1);
       }
     }
     for (int i = 0; i < video_frame_->rows(media::VideoFrame::Plane::kU); ++i) {
-      uint8_t* u_row =
-          video_frame_->writable_data(media::VideoFrame::Plane::kU) +
-          video_frame_->stride(media::VideoFrame::Plane::kU) * i;
-      uint8_t* v_row =
-          video_frame_->writable_data(media::VideoFrame::Plane::kV) +
-          video_frame_->stride(media::VideoFrame::Plane::kV) * i;
+      base::span<uint8_t>u_row =
+          video_frame_->writable_data(media::VideoFrame::Plane::kU) .subspan(
+          video_frame_->stride(media::VideoFrame::Plane::kU) * i);
+      base::span<uint8_t>v_row =
+          video_frame_->writable_data(media::VideoFrame::Plane::kV) .subspan(
+          video_frame_->stride(media::VideoFrame::Plane::kV) * i);
       for (int j = 0; j < video_frame_->row_bytes(media::VideoFrame::Plane::kU);
            ++j) {
         u_row[j] = (u_value += 3);
@@ -641,7 +643,7 @@ class TestVideoFrameBuilder {
     int sample_size[] = {1, 2, 2};
 
     for (int i = 0; i < 3; ++i) {
-      memset(video_frame_->writable_data(planes[i]), yuv_background[i],
+      memset(video_frame_->writable_data(planes[i]).data(), yuv_background[i],
              video_frame_->stride(planes[i]) * video_frame_->rows(planes[i]));
     }
 
@@ -671,18 +673,18 @@ class TestVideoFrameBuilder {
   scoped_refptr<media::VideoFrame> DrawSolid(uint8_t y, uint8_t u, uint8_t v) {
     // YUV values of a solid, constant, color. Useful for testing that color
     // space/color range are being handled properly.
-    memset(video_frame_->writable_data(media::VideoFrame::Plane::kY), y,
+    memset(video_frame_->writable_data(media::VideoFrame::Plane::kY).data(), y,
            video_frame_->stride(media::VideoFrame::Plane::kY) *
                video_frame_->rows(media::VideoFrame::Plane::kY));
     if (video_frame_->format() == media::PIXEL_FORMAT_NV12) {
       const int stride_uv = video_frame_->stride(media::VideoFrame::Plane::kUV);
       const int half_height = (video_frame_->coded_size().height() + 1) / 2;
-      uint8_t* uv_plane =
+      base::span<uint8_t>uv_plane =
           video_frame_->writable_data(media::VideoFrame::Plane::kUV);
       // Set U and V.
       for (int row = 0; row < half_height; ++row) {
         for (int col = 0; col < stride_uv; col++) {
-          *uv_plane = col % 2 == 0 ? u : v;
+           uv_plane[0] = col % 2 == 0 ? u : v;
           uv_plane++;
         }
       }
@@ -690,10 +692,10 @@ class TestVideoFrameBuilder {
       // Only NV12, YV12 and I420 formats are used for testing here.
       CHECK(video_frame_->format() == media::PIXEL_FORMAT_I420 ||
             video_frame_->format() == media::PIXEL_FORMAT_YV12);
-      memset(video_frame_->writable_data(media::VideoFrame::Plane::kU), u,
+      memset(video_frame_->writable_data(media::VideoFrame::Plane::kU).data(), u,
              video_frame_->stride(media::VideoFrame::Plane::kU) *
                  video_frame_->rows(media::VideoFrame::Plane::kU));
-      memset(video_frame_->writable_data(media::VideoFrame::Plane::kV), v,
+      memset(video_frame_->writable_data(media::VideoFrame::Plane::kV).data(), v,
              video_frame_->stride(media::VideoFrame::Plane::kV) *
                  video_frame_->rows(media::VideoFrame::Plane::kV));
     }
@@ -2456,16 +2458,16 @@ scoped_refptr<media::VideoFrame> CreateHighbitVideoFrame(
   for (int plane = media::VideoFrame::Plane::kY;
        plane <= media::VideoFrame::Plane::kV; ++plane) {
     int width = video_frame->row_bytes(plane);
-    const uint8_t* src = video_frame->data(plane);
-    uint16_t* dst = reinterpret_cast<uint16_t*>(ret->writable_data(plane));
+    base::span<const uint8_t>src = video_frame->data(plane);
+    base::span<uint16_t>dst = reinterpret_cast<uint16_t*>(ret->writable_data(plane));
     for (int row = 0; row < video_frame->rows(plane); row++) {
       for (int x = 0; x < width; x++) {
         // Replicate the top bits into the lower bits, this way
         // 0xFF becomes 0x3FF.
         dst[x] = (src[x] << 2) | (src[x] >> 6);
       }
-      src += video_frame->stride(plane);
-      dst += ret->stride(plane) / 2;
+      src=src.subspan(video_frame->stride(plane));
+      dst=dst.subspan(ret->stride(plane) / 2);
     }
   }
   return ret;
diff --git a/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc b/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
index eec192c22a4d2..9ac7c1cd7d0ab 100644
--- a/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/frame_sink_video_capturer_impl_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -274,7 +276,7 @@ class MockConsumer : public mojom::FrameSinkVideoConsumer {
       ASSERT_LE(required_bytes_to_hold_planes, mapping.size());
       frame = media::VideoFrame::WrapExternalData(
           info->pixel_format, info->coded_size, info->visible_rect,
-          info->visible_rect.size(), mapping.GetMemoryAs<const uint8_t>(),
+          info->visible_rect.size(), mapping.GetMemoryAs<const uint8_t>().data(),
           mapping.size(), info->timestamp);
       ASSERT_TRUE(frame);
       frame->AddDestructionObserver(
@@ -645,7 +647,7 @@ bool IsLetterboxedI420Plane(int plane,
         content_rect_copy.width() / 2, content_rect_copy.height() / 2);
   }
   for (int row = 0; row < frame.rows(plane); ++row) {
-    const uint8_t* p = frame.visible_data(plane) + row * frame.stride(plane);
+    base::span<const uint8_t>p = frame.visible_data(plane) .subspan( row * frame.stride(plane));
     for (int col = 0; col < frame.row_bytes(plane); ++col) {
       if (content_rect_copy.Contains(gfx::Point(col, row))) {
         if (p[col] != component) {
@@ -680,7 +682,7 @@ bool IsLetterboxedRGBA(SkColor color,
                                                 frame.coded_size().height());
   bitmap.installPixels(
       bitmap_info,
-      const_cast<uint8_t*>(frame.visible_data(VideoFrame::Plane::kARGB)),
+      const_cast<uint8_t*>(frame.visible_data(VideoFrame::Plane::kARGB).data()),
       frame.stride(VideoFrame::Plane::kARGB));
 
   for (int row = 0; row < bitmap.height(); ++row) {
diff --git a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
index 5217379fd0c50..ee9344f2e7211 100644
--- a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
+++ b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool.cc
@@ -115,7 +115,7 @@ scoped_refptr<VideoFrame> SharedMemoryVideoFramePool::WrapBuffer(
   // destroyed).
   scoped_refptr<VideoFrame> frame = VideoFrame::WrapExternalData(
       format, size, gfx::Rect(size), size,
-      static_cast<uint8_t*>(pooled_buffer.mapping.memory()),
+      static_cast<uint8_t*>(pooled_buffer.mapping.memory().data()),
       pooled_buffer.mapping.size(), base::TimeDelta());
   CHECK(frame);
   // Sanity-check the assumption being made for SetMarkedBuffer():
diff --git a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
index 364672359b769..2e0b2f6c3de63 100644
--- a/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/shared_memory_video_frame_pool_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -171,7 +173,7 @@ bool PlanesAreFilledWithValues(const VideoFrame& frame, const uint8_t* values) {
        ++plane) {
     const uint8_t expected_value = values[plane - VideoFrame::Plane::kY];
     for (int y = 0; y < frame.rows(plane); ++y) {
-      const uint8_t* row = frame.visible_data(plane) + y * frame.stride(plane);
+      base::span<const uint8_t>row = frame.visible_data(plane) .subspan( y * frame.stride(plane));
       for (int x = 0; x < frame.row_bytes(plane); ++x) {
         EXPECT_EQ(expected_value, row[x])
             << "at row " << y << " in plane " << plane;
diff --git a/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc b/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
index 3f9778b53f95f..968a9aa6d1a2c 100644
--- a/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
+++ b/components/viz/service/frame_sinks/video_capture/video_capture_overlay_unittest.cc
@@ -457,11 +457,11 @@ class VideoCaptureOverlayRenderTest
     // as those of the YUV tests, and so only one set of golden files needs to
     // be used.
     if (is_argb_test()) {
-      uint8_t* dst = frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
+      base::span<uint8_t>dst = frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
       const int stride = frame->stride(VideoFrame::Plane::kARGB);
-      for (int row = 0; row < size.height(); ++row, dst += stride) {
-        uint32_t* const begin = reinterpret_cast<uint32_t*>(dst);
-        std::fill(begin, begin + size.width(), UINT32_C(0xff000000));
+      for (int row = 0; row < size.height(); ++row, dst=dst.subspan(stride)) {
+        const base::span<uint32_t>begin = reinterpret_cast<uint32_t*>(dst);
+        std::fill(begin.data(), begin .subspan( size.width()).data(), UINT32_C(0xff000000));
       }
     } else /* if (!is_argb_test()) */ {
       media::FillYUV(frame.get(), 0x00, 0x80, 0x80);
@@ -494,7 +494,7 @@ class VideoCaptureOverlayRenderTest
             kBGRA_8888_SkColorType, kUnpremul_SkAlphaType,
             frame.ColorSpace().ToSkColorSpace());
         canonical_bitmap.writePixels(
-            SkPixmap(frame_format, frame.visible_data(VideoFrame::Plane::kARGB),
+            SkPixmap(frame_format, frame.visible_data(VideoFrame::Plane::kARGB).data(),
                      frame.stride(VideoFrame::Plane::kARGB)),
             0, 0);
         break;
@@ -508,12 +508,12 @@ class VideoCaptureOverlayRenderTest
             new gfx::ColorTransform::TriStim[size.GetArea()]);
         int pos = 0;
         for (int row = 0; row < size.height(); ++row) {
-          const uint8_t* y = frame.visible_data(VideoFrame::Plane::kY) +
-                             (row * frame.stride(VideoFrame::Plane::kY));
-          const uint8_t* u = frame.visible_data(VideoFrame::Plane::kU) +
-                             ((row / 2) * frame.stride(VideoFrame::Plane::kU));
-          const uint8_t* v = frame.visible_data(VideoFrame::Plane::kV) +
-                             ((row / 2) * frame.stride(VideoFrame::Plane::kV));
+          base::span<const uint8_t>y = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                             (row * frame.stride(VideoFrame::Plane::kY)));
+          base::span<const uint8_t>u = frame.visible_data(VideoFrame::Plane::kU) .subspan(
+                             ((row / 2) * frame.stride(VideoFrame::Plane::kU)));
+          base::span<const uint8_t>v = frame.visible_data(VideoFrame::Plane::kV) .subspan(
+                             ((row / 2) * frame.stride(VideoFrame::Plane::kV)));
           for (int col = 0; col < size.width(); ++col) {
             colors[pos].SetPoint(y[col] / 255.0f, u[col / 2] / 255.0f,
                                  v[col / 2] / 255.0f);
diff --git a/components/viz/test/test_raster_interface.h b/components/viz/test/test_raster_interface.h
index 136976e2936f6..196acfc62e6dc 100644
--- a/components/viz/test/test_raster_interface.h
+++ b/components/viz/test/test_raster_interface.h
@@ -7,6 +7,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "components/viz/test/test_context_support.h"
 #include "gpu/command_buffer/client/raster_interface.h"
@@ -117,7 +118,7 @@ class TestRasterInterface : public gpu::raster::RasterInterface {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override {}
   void ReadbackYUVPixelsAsync(
       const gpu::Mailbox& source_mailbox,
@@ -126,11 +127,11 @@ class TestRasterInterface : public gpu::raster::RasterInterface {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override {}
diff --git a/components/zucchini/mapped_file.h b/components/zucchini/mapped_file.h
index 4834d78d25c21..09ec0bc73447b 100644
--- a/components/zucchini/mapped_file.h
+++ b/components/zucchini/mapped_file.h
@@ -52,7 +52,7 @@ class MappedFileWriter {
   const MappedFileWriter& operator=(const MappedFileWriter&) = delete;
   ~MappedFileWriter();
 
-  uint8_t* data() { return buffer_.data(); }
+  uint8_t* data() { return buffer_.data().data(); }
   size_t length() const { return buffer_.length(); }
   zucchini::MutableBufferView region() { return {data(), length()}; }
 
diff --git a/content/browser/font_access/font_access_manager_unittest.cc b/content/browser/font_access/font_access_manager_unittest.cc
index 185e5d76fe8e6..35ac1d2ee93ea 100644
--- a/content/browser/font_access/font_access_manager_unittest.cc
+++ b/content/browser/font_access/font_access_manager_unittest.cc
@@ -184,7 +184,7 @@ void ValidateFontEnumerationBasic(FontEnumerationStatus status,
   base::ReadOnlySharedMemoryMapping mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
   blink::FontEnumerationTable table;
-  EXPECT_TRUE(table.ParseFromArray(mapping.memory(), mapping.size()));
+  EXPECT_TRUE(table.ParseFromArray(mapping.memory().data(), mapping.size()));
 
   blink::FontEnumerationTable_FontData previous_font;
   for (const auto& font : table.fonts()) {
diff --git a/content/browser/media/capture/fake_video_capture_stack.cc b/content/browser/media/capture/fake_video_capture_stack.cc
index 0d1d113041e3c..39a76652663d3 100644
--- a/content/browser/media/capture/fake_video_capture_stack.cc
+++ b/content/browser/media/capture/fake_video_capture_stack.cc
@@ -158,7 +158,7 @@ class FakeVideoCaptureStackReceiver final : public media::VideoFrameReceiver {
     auto video_frame = media::VideoFrame::WrapExternalData(
         frame.frame_info->pixel_format, frame.frame_info->coded_size,
         frame.frame_info->visible_rect, frame.frame_info->visible_rect.size(),
-        mapping.GetMemoryAs<const uint8_t>(), mapping.size(),
+        mapping.GetMemoryAs<const uint8_t>().data(), mapping.size(),
         frame.frame_info->timestamp);
     CHECK(video_frame);
 
diff --git a/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc b/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
index 46a8e24a3ec9a..8a549d963ea10 100644
--- a/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
+++ b/content/browser/media/capture/frame_sink_video_capture_device_unittest.cc
@@ -392,7 +392,7 @@ class FrameSinkVideoCaptureDeviceTest : public testing::Test {
         base::ReadOnlySharedMemoryRegion::Create(
             media::VideoFrame::AllocationSize(kFormat, kResolution));
     CHECK(region.IsValid());
-    memset(region.mapping.memory(), GetFrameFillValue(frame_number),
+    memset(region.mapping.memory().data(), GetFrameFillValue(frame_number),
            region.mapping.size());
 
     mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>
diff --git a/content/browser/media/capture/frame_test_util.cc b/content/browser/media/capture/frame_test_util.cc
index ce30a4e0b42f7..471a26d69f6ac 100644
--- a/content/browser/media/capture/frame_test_util.cc
+++ b/content/browser/media/capture/frame_test_util.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/342213636): Remove this and spanify to fix the errors.
 #pragma allow_unsafe_buffers
@@ -36,9 +38,9 @@ using TriStim = gfx::ColorTransform::TriStim;
 
 // Copies YUV row data into an array of TriStims, mapping [0,255]⇒[0.0,1.0]. The
 // chroma planes are assumed to be half-width.
-void LoadStimsFromYUV(const uint8_t y_src[],
-                      const uint8_t u_src[],
-                      const uint8_t v_src[],
+void LoadStimsFromYUV(base::span<const uint8_t> y_src,
+                      base::span<const uint8_t> u_src,
+                      base::span<const uint8_t> v_src,
                       int width,
                       TriStim stims[]) {
   for (int i = 0; i < width; ++i) {
@@ -47,8 +49,8 @@ void LoadStimsFromYUV(const uint8_t y_src[],
   }
 }
 
-void LoadStimsFromYUV(const uint8_t y_src[],
-                      const uint16_t uv_src[],
+void LoadStimsFromYUV(base::span<const uint8_t> y_src,
+                      base::span<const uint16_t> uv_src,
                       int width,
                       TriStim stims[]) {
 // https://docs.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering#nv12
@@ -121,21 +123,21 @@ SkBitmap FrameTestUtil::ConvertToBitmap(const media::VideoFrame& frame) {
   for (int row = 0; row < bitmap.height(); ++row) {
     if (frame.format() == media::VideoPixelFormat::PIXEL_FORMAT_I420) {
       LoadStimsFromYUV(
-          frame.visible_data(media::VideoFrame::Plane::kY) +
-              row * frame.stride(media::VideoFrame::Plane::kY),
-          frame.visible_data(media::VideoFrame::Plane::kU) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kU),
-          frame.visible_data(media::VideoFrame::Plane::kV) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kV),
+          frame.visible_data(media::VideoFrame::Plane::kY) .subspan(
+              row * frame.stride(media::VideoFrame::Plane::kY)),
+          frame.visible_data(media::VideoFrame::Plane::kU) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kU)),
+          frame.visible_data(media::VideoFrame::Plane::kV) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kV)),
           bitmap.width(), stims.data());
     } else {
       CHECK_EQ(frame.format(), media::VideoPixelFormat::PIXEL_FORMAT_NV12);
       LoadStimsFromYUV(
-          frame.visible_data(media::VideoFrame::Plane::kY) +
-              row * frame.stride(media::VideoFrame::Plane::kY),
+          frame.visible_data(media::VideoFrame::Plane::kY) .subspan(
+              row * frame.stride(media::VideoFrame::Plane::kY)),
           reinterpret_cast<const uint16_t*>(
-              frame.visible_data(media::VideoFrame::Plane::kUV) +
-              (row / 2) * frame.stride(media::VideoFrame::Plane::kUV)),
+              frame.visible_data(media::VideoFrame::Plane::kUV) .subspan(
+              (row / 2) * frame.stride(media::VideoFrame::Plane::kUV))),
           bitmap.width(), stims.data());
     }
     transform->Transform(stims.data(), stims.size());
diff --git a/content/browser/renderer_host/media/video_capture_controller_unittest.cc b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
index c94bb4d3b793d..9d08c94ce1663 100644
--- a/content/browser/renderer_host/media/video_capture_controller_unittest.cc
+++ b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
@@ -217,7 +217,7 @@ class VideoCaptureControllerTest
     const int rotation = 0;
     const int frame_feedback_id = 0;
     device_client_->OnIncomingCapturedData(
-        stub_frame->data(0),
+        stub_frame->data(0).data(),
         media::VideoFrame::AllocationSize(stub_frame->format(),
                                           stub_frame->coded_size()),
         format, color_space, rotation, false /* flip_y */, base::TimeTicks(),
diff --git a/content/browser/service_host/service_process_host_browsertest.cc b/content/browser/service_host/service_process_host_browsertest.cc
index d995a1119fd56..51408718e8104 100644
--- a/content/browser/service_host/service_process_host_browsertest.cc
+++ b/content/browser/service_host/service_process_host_browsertest.cc
@@ -164,7 +164,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, AllMessagesReceived) {
   });
   auto region = base::UnsafeSharedMemoryRegion::Create(kBufferSize);
   base::WritableSharedMemoryMapping mapping = region.Map();
-  memset(mapping.memory(), 0, kBufferSize);
+  memset(mapping.memory().data(), 0, kBufferSize);
 
   // Send several messages, since it helps to verify a lack of raciness between
   // service-side message dispatch and service termination.
@@ -177,7 +177,7 @@ IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, AllMessagesReceived) {
 
   const std::string& kLastMessage = kMessages[std::size(kMessages) - 1];
   EXPECT_EQ(0,
-            memcmp(mapping.memory(), kLastMessage.data(), kLastMessage.size()));
+            memcmp(mapping.memory().data(), kLastMessage.data(), kLastMessage.size()));
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessHostBrowserTest, ObserveCrash) {
diff --git a/content/browser/service_host/utility_process_host_browsertest.cc b/content/browser/service_host/utility_process_host_browsertest.cc
index 00176ea1916bf..3b263d110d4a5 100644
--- a/content/browser/service_host/utility_process_host_browsertest.cc
+++ b/content/browser/service_host/utility_process_host_browsertest.cc
@@ -148,7 +148,7 @@ class UtilityProcessHostBrowserTest : public BrowserChildProcessObserver,
     DCHECK(mojo::core::IsMojoIpczEnabled());
     auto region = base::WritableSharedMemoryRegion::Create(kTestMessage.size());
     auto mapping = region.Map();
-    memcpy(mapping.memory(), kTestMessage.data(), kTestMessage.size());
+    memcpy(mapping.memory().data(), kTestMessage.data(), kTestMessage.size());
     service_->CloneSharedMemoryContents(
         base::WritableSharedMemoryRegion::ConvertToReadOnly(std::move(region)),
         base::BindOnce(&UtilityProcessHostBrowserTest::OnMemoryCloneReceived,
@@ -201,7 +201,7 @@ class UtilityProcessHostBrowserTest : public BrowserChildProcessObserver,
     auto mapping = region.Map();
     ASSERT_EQ(kTestMessage.size(), mapping.size());
     EXPECT_EQ(kTestMessage,
-              std::string_view(static_cast<const char*>(mapping.memory()),
+              std::string_view(static_cast<const char*>(mapping.memory().data()),
                                kTestMessage.size()));
     ResetService();
     GetUIThreadTaskRunner({})->PostTask(FROM_HERE, std::move(done_closure_));
diff --git a/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc b/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
index 39a8a8439397f..eca6437cdf641 100644
--- a/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
+++ b/content/browser/webrtc/webrtc_video_capture_service_browsertest.cc
@@ -331,7 +331,7 @@ class SharedMemoryDeviceExerciser : public VirtualDeviceExerciser,
     const uint8_t dummy_value = frame_count % 256;
 
     // Reset the whole buffer to 0
-    memset(outgoing_buffer.memory(), 0, outgoing_buffer.size());
+    memset(outgoing_buffer.memory().data(), 0, outgoing_buffer.size());
 
     // Set all bytes affecting |info->visible_rect| to |dummy_value|.
     const int kYStride = info->strides ? info->strides->stride_by_plane[0]
diff --git a/content/shell/utility/shell_content_utility_client.cc b/content/shell/utility/shell_content_utility_client.cc
index 4b7a885fa28fe..650a0c5e5e955 100644
--- a/content/shell/utility/shell_content_utility_client.cc
+++ b/content/shell/utility/shell_content_utility_client.cc
@@ -128,7 +128,7 @@ class TestUtilityServiceImpl : public mojom::TestService {
     auto mapping = region.Map();
     auto new_region = base::UnsafeSharedMemoryRegion::Create(region.GetSize());
     auto new_mapping = new_region.Map();
-    memcpy(new_mapping.memory(), mapping.memory(), region.GetSize());
+    memcpy(new_mapping.memory().data(), mapping.memory().data(), region.GetSize());
     std::move(callback).Run(std::move(new_region));
   }
 
diff --git a/device/gamepad/gamepad_provider_unittest.cc b/device/gamepad/gamepad_provider_unittest.cc
index a7e8c1ea67a84..7a003108b5773 100644
--- a/device/gamepad/gamepad_provider_unittest.cc
+++ b/device/gamepad/gamepad_provider_unittest.cc
@@ -128,7 +128,7 @@ TEST_F(GamepadProviderTest, PollingAccess) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -178,7 +178,7 @@ TEST_F(GamepadProviderTest, ConnectDisconnectMultiple) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -237,7 +237,7 @@ TEST_F(GamepadProviderTest, UserGesture) {
   EXPECT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
@@ -291,7 +291,7 @@ TEST_F(GamepadProviderTest, Sanitization) {
   ASSERT_TRUE(mapping.IsValid());
 
   const GamepadHardwareBuffer* buffer =
-      static_cast<const GamepadHardwareBuffer*>(mapping.memory());
+      static_cast<const GamepadHardwareBuffer*>(mapping.memory().data());
 
   // Wait until the shared memory buffer has been written at least once.
   WaitForData(buffer);
diff --git a/extensions/renderer/user_script_set.cc b/extensions/renderer/user_script_set.cc
index 9e2bab8055a8b..2b5edd5bc7032 100644
--- a/extensions/renderer/user_script_set.cc
+++ b/extensions/renderer/user_script_set.cc
@@ -103,7 +103,7 @@ bool UserScriptSet::UpdateUserScripts(
 
   // First get the size of the memory block.
   const base::Pickle::Header* pickle_header =
-      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>();
+      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>().data();
   if (!pickle_header)
     return false;
 
diff --git a/gpu/command_buffer/client/client_shared_image.cc b/gpu/command_buffer/client/client_shared_image.cc
index 471d2b82d21cf..d995a17ad3fae 100644
--- a/gpu/command_buffer/client/client_shared_image.cc
+++ b/gpu/command_buffer/client/client_shared_image.cc
@@ -105,7 +105,7 @@ class ScopedMappingGpuMemoryBuffer : public ClientSharedImage::ScopedMapping {
     // the start of the plane, as that region is by definition the memory
     // storing the data of the plane.
     return UNSAFE_BUFFERS(base::span<uint8_t>(
-        reinterpret_cast<uint8_t*>(buffer_->memory(plane_index)), span_length));
+        reinterpret_cast<uint8_t*>(buffer_->memory(plane_index).data()), span_length));
   }
   size_t Stride(const uint32_t plane_index) override {
     CHECK(buffer_);
diff --git a/gpu/command_buffer/client/client_transfer_cache.cc b/gpu/command_buffer/client/client_transfer_cache.cc
index e45e08d072f36..979606522832e 100644
--- a/gpu/command_buffer/client/client_transfer_cache.cc
+++ b/gpu/command_buffer/client/client_transfer_cache.cc
@@ -19,7 +19,7 @@ void* ClientTransferCache::MapEntry(MappedMemoryManager* mapped_memory,
     mapped_ptr_ = std::nullopt;
     return nullptr;
   }
-  return mapped_ptr_->address();
+  return mapped_ptr_->address().data();
 }
 
 void* ClientTransferCache::MapTransferBufferEntry(
@@ -33,7 +33,7 @@ void* ClientTransferCache::MapTransferBufferEntry(
     transfer_buffer_ptr_ = std::nullopt;
     return nullptr;
   }
-  return transfer_buffer_ptr_->address();
+  return transfer_buffer_ptr_->address().data();
 }
 
 void ClientTransferCache::UnmapAndCreateEntry(uint32_t type, uint32_t id) {
diff --git a/gpu/command_buffer/client/cmd_buffer_helper.cc b/gpu/command_buffer/client/cmd_buffer_helper.cc
index d0fc4abb385af..418389a613e9d 100644
--- a/gpu/command_buffer/client/cmd_buffer_helper.cc
+++ b/gpu/command_buffer/client/cmd_buffer_helper.cc
@@ -9,6 +9,7 @@
 #include <stdint.h>
 
 #include <algorithm>
+#include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/strings/stringprintf.h"
 #include "base/time/time.h"
@@ -104,7 +105,7 @@ bool CommandBufferHelper::AllocateRingBuffer() {
 void CommandBufferHelper::SetGetBuffer(int32_t id,
                                        scoped_refptr<Buffer> buffer) {
   command_buffer_->SetGetBuffer(id);
-  entries_ = nullptr;
+  entries_ = {};
   total_entry_count_ = 0;
   ring_buffer_ = std::move(buffer);
   ring_buffer_id_ = id;
diff --git a/gpu/command_buffer/client/cmd_buffer_helper.h b/gpu/command_buffer/client/cmd_buffer_helper.h
index 54f4365689e8d..da67f91c88161 100644
--- a/gpu/command_buffer/client/cmd_buffer_helper.h
+++ b/gpu/command_buffer/client/cmd_buffer_helper.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -337,7 +339,7 @@ class GPU_EXPORT CommandBufferHelper {
   int32_t ring_buffer_id_ = -1;
   uint32_t ring_buffer_size_ = 0;
   scoped_refptr<gpu::Buffer> ring_buffer_;
-  raw_ptr<CommandBufferEntry, AllowPtrArithmetic> entries_ = nullptr;
+  base::raw_span<CommandBufferEntry, AllowPtrArithmetic> entries_ = nullptr;
   int32_t total_entry_count_ = 0;  // the total number of entries
   int32_t immediate_entry_count_ = 0;
   int32_t token_ = 0;
diff --git a/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc b/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
index d17b92f7fdd0f..043bb50ac8b9b 100644
--- a/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
+++ b/gpu/command_buffer/client/dawn_client_memory_transfer_service.cc
@@ -144,7 +144,7 @@ void* DawnClientMemoryTransferService::AllocateHandle(
   DCHECK(mapped_memory_);
   return mapped_memory_->Alloc(
       alloc_size, &handle->shm_id, &handle->shm_offset,
-      TransferBufferAllocationOption::kReturnNullOnOOM);
+      TransferBufferAllocationOption::kReturnNullOnOOM).data();
 }
 
 void DawnClientMemoryTransferService::MarkHandleFree(void* ptr) {
diff --git a/gpu/command_buffer/client/dawn_client_serializer.cc b/gpu/command_buffer/client/dawn_client_serializer.cc
index 1fe299f663a22..599d5782946e8 100644
--- a/gpu/command_buffer/client/dawn_client_serializer.cc
+++ b/gpu/command_buffer/client/dawn_client_serializer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -60,11 +62,11 @@ void* DawnClientSerializer::GetCmdSpace(size_t size) {
   if (buffer_.valid() && !overflows_remaining_space) [[likely]] {
     // If the buffer is valid and has sufficient space, return the
     // pointer and increment the offset.
-    uint8_t* ptr = static_cast<uint8_t*>(buffer_.address());
-    ptr += put_offset_;
+    base::span<uint8_t>ptr = static_cast<uint8_t*>(buffer_.address());
+    ptr=ptr.subspan(put_offset_);
 
     put_offset_ += static_cast<uint32_t>(size);
-    return ptr;
+    return ptr.data();
   }
 
   if (!transfer_buffer_) {
@@ -89,7 +91,7 @@ void* DawnClientSerializer::GetCmdSpace(size_t size) {
   }
 
   put_offset_ = size;
-  return buffer_.address();
+  return buffer_.address().data();
 }
 
 void DawnClientSerializer::Commit() {
diff --git a/gpu/command_buffer/client/gl_helper.cc b/gpu/command_buffer/client/gl_helper.cc
index 4bdc07751b19f..9e77fcc902aae 100644
--- a/gpu/command_buffer/client/gl_helper.cc
+++ b/gpu/command_buffer/client/gl_helper.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -158,7 +161,7 @@ class GLHelper::CopyTextureToImpl final {
                             GLenum texture_target,
                             const gfx::Point& src_starting_point,
                             const gfx::Size& dst_size,
-                            unsigned char* out,
+                            base::span<unsigned char>out,
                             size_t row_stride_bytes,
                             bool flip_y,
                             GLenum format,
@@ -170,7 +173,7 @@ class GLHelper::CopyTextureToImpl final {
                      const gfx::Size& dst_size,
                      size_t bytes_per_row,     // generally dst_size.width() * 4
                      size_t row_stride_bytes,  // generally dst_size.width() * 4
-                     unsigned char* out,
+                     base::span<unsigned char>out,
                      GLenum format,
                      GLenum type,
                      size_t bytes_per_pixel,
@@ -179,7 +182,7 @@ class GLHelper::CopyTextureToImpl final {
 
   void ReadbackPlane(const gfx::Size& texture_size,
                      int row_stride_bytes,
-                     unsigned char* data,
+                     base::span<unsigned char>data,
                      int size_shift,
                      const gfx::Rect& paste_rect,
                      ReadbackSwizzle swizzle,
@@ -202,7 +205,7 @@ class GLHelper::CopyTextureToImpl final {
             size_t bytes_per_pixel_,
             size_t bytes_per_row_,
             size_t row_stride_bytes_,
-            unsigned char* pixels_,
+            base::span<unsigned char>pixels_,
             bool flip_y_,
             base::OnceCallback<void(bool)> callback_)
         : size(size_),
@@ -221,7 +224,7 @@ class GLHelper::CopyTextureToImpl final {
     size_t row_stride_bytes;
     bool flip_y;
     base::OnceCallback<void(bool)> callback;
-    raw_ptr<unsigned char> pixels;
+    base::raw_span<unsigned char> pixels;
     GLuint buffer = 0;
     GLuint query = 0;
   };
@@ -278,11 +281,11 @@ class GLHelper::CopyTextureToImpl final {
                      const gfx::Size& src_texture_size,
                      const gfx::Rect& output_rect,
                      int y_plane_row_stride_bytes,
-                     unsigned char* y_plane_data,
+                     base::span<unsigned char>y_plane_data,
                      int u_plane_row_stride_bytes,
-                     unsigned char* u_plane_data,
+                     base::span<unsigned char>u_plane_data,
                      int v_plane_row_stride_bytes,
-                     unsigned char* v_plane_data,
+                     base::span<unsigned char>v_plane_data,
                      const gfx::Point& paste_location,
                      base::OnceCallback<void(bool)> callback) override;
 
@@ -360,7 +363,7 @@ void GLHelper::CopyTextureToImpl::ReadbackAsync(
     const gfx::Size& dst_size,
     size_t bytes_per_row,
     size_t row_stride_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     GLenum format,
     GLenum type,
     size_t bytes_per_pixel,
@@ -396,7 +399,7 @@ void GLHelper::CopyTextureToImpl::ReadbackTextureAsync(
     GLenum texture_target,
     const gfx::Point& src_starting_point,
     const gfx::Size& dst_size,
-    unsigned char* out,
+    base::span<unsigned char>out,
     size_t row_stride_bytes,
     bool flip_y,
     GLenum format,
@@ -453,17 +456,17 @@ void GLHelper::CopyTextureToImpl::ReadbackDone(Request* finished_request) {
                                                    request->size.width());
         size_t bytes_to_copy =
             std::min(request->row_stride_bytes, request->bytes_per_row);
-        unsigned char* dst = request->pixels;
+        base::span<unsigned char>dst = request->pixels;
         if (request->flip_y && request->size.height() > 1) {
-          dst += dst_stride * (request->size.height() - 1);
+          dst=dst.subspan(dst_stride * ()request->size.height() - 1);
           dst_stride = -dst_stride;
         }
         // We need to use `RelaxedAtomicWriteMemcpy` because we might be writing
         // into memory observed by JS at the same time.
         for (int y = 0; y < request->size.height(); y++) {
           base::subtle::RelaxedAtomicWriteMemcpy(
-              base::span(dst, bytes_to_copy), base::span(src, bytes_to_copy));
-          dst += dst_stride;
+              base::span(dst.data(), bytes_to_copy), base::span(src, bytes_to_copy));
+          dst=dst.subspan(dst_stride);
           src += src_stride;
         }
         gl_->UnmapBufferCHROMIUM(GL_PIXEL_PACK_TRANSFER_BUFFER_CHROMIUM);
@@ -526,7 +529,7 @@ void GLHelper::ReadbackTextureAsync(GLuint texture,
                                     GLenum texture_target,
                                     const gfx::Point& src_starting_point,
                                     const gfx::Size& dst_size,
-                                    unsigned char* out,
+                                    base::span<unsigned char>out,
                                     size_t row_stride_bytes,
                                     bool flip_y,
                                     GLenum format,
@@ -570,7 +573,7 @@ GLint GLHelper::MaxDrawBuffers() {
 void GLHelper::CopyTextureToImpl::ReadbackPlane(
     const gfx::Size& texture_size,
     int row_stride_bytes,
-    unsigned char* data,
+    base::span<unsigned char>data,
     int size_shift,
     const gfx::Rect& paste_rect,
     ReadbackSwizzle swizzle,
@@ -583,7 +586,7 @@ void GLHelper::CopyTextureToImpl::ReadbackPlane(
   const bool kFlipY = false;
   size_t bytes_per_row = paste_rect.width() >> size_shift;
   ReadbackAsync(gfx::Point(), texture_size, bytes_per_row, row_stride_bytes,
-                data + offset,
+                data .subspan( offset),
                 (swizzle == kSwizzleBGRA) ? GL_BGRA_EXT : GL_RGBA,
                 GL_UNSIGNED_BYTE, 4, kFlipY, std::move(callback));
 }
@@ -773,11 +776,11 @@ void GLHelper::CopyTextureToImpl::ReadbackYUVImpl::ReadbackYUV(
     const gfx::Size& src_texture_size,
     const gfx::Rect& output_rect,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void(bool)> callback) {
   DCHECK(!(paste_location.x() & 1));
diff --git a/gpu/command_buffer/client/gl_helper.h b/gpu/command_buffer/client/gl_helper.h
index f7ed136f8f5c0..0954bf7b186a4 100644
--- a/gpu/command_buffer/client/gl_helper.h
+++ b/gpu/command_buffer/client/gl_helper.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -166,7 +167,7 @@ class GPU_EXPORT GLHelper {
                             GLenum texture_target,
                             const gfx::Point& src_starting_point,
                             const gfx::Size& dst_size,
-                            unsigned char* out,
+                            base::span<unsigned char>out,
                             size_t row_stride_bytes,
                             bool flip_y,
                             GLenum format,
@@ -458,11 +459,11 @@ class GPU_EXPORT ReadbackYUVInterface {
                            const gfx::Size& src_texture_size,
                            const gfx::Rect& output_rect,
                            int y_plane_row_stride_bytes,
-                           unsigned char* y_plane_data,
+                           base::span<unsigned char>y_plane_data,
                            int u_plane_row_stride_bytes,
-                           unsigned char* u_plane_data,
+                           base::span<unsigned char>u_plane_data,
                            int v_plane_row_stride_bytes,
-                           unsigned char* v_plane_data,
+                           base::span<unsigned char>v_plane_data,
                            const gfx::Point& paste_location,
                            base::OnceCallback<void(bool)> callback) = 0;
 };
diff --git a/gpu/command_buffer/client/gles2_implementation.cc b/gpu/command_buffer/client/gles2_implementation.cc
index c41a5020fb159..8f5a738c16f39 100644
--- a/gpu/command_buffer/client/gles2_implementation.cc
+++ b/gpu/command_buffer/client/gles2_implementation.cc
@@ -2223,7 +2223,7 @@ void GLES2Implementation::ShaderBinary(GLsizei n,
     return;
   }
   void* shader_ids = buffer.elements();
-  void* shader_data = buffer.elements() + shader_id_size;
+  void* shader_data = buffer.elements() .subspan( shader_id_size);
   memcpy(shader_ids, shaders, shader_id_size);
   memcpy(shader_data, binary, length);
   helper_->ShaderBinary(n, buffer.shm_id(), buffer.offset(), binaryformat,
@@ -2445,7 +2445,7 @@ void GLES2Implementation::BufferDataHelper(GLenum target,
   }
 
   if (buffer.size() >= static_cast<unsigned int>(size)) {
-    memcpy(buffer.address(), data, size);
+    memcpy(buffer.address().data(), data, size);
     helper_->BufferData(target, size, buffer.shm_id(), buffer.offset(), usage);
     return;
   }
@@ -3956,7 +3956,7 @@ void GLES2Implementation::TexSubImage3DImpl(GLenum target,
     }
 
     if (num_images > 0) {
-      int8_t* buffer_pointer = reinterpret_cast<int8_t*>(buffer->address());
+      base::span<int8_t>buffer_pointer = reinterpret_cast<int8_t*>(buffer->address());
       uint32_t src_height =
           unpack_image_height_ > 0 ? unpack_image_height_ : height;
       uint32_t image_size_dst = buffer_padded_row_size * height;
@@ -3964,7 +3964,7 @@ void GLES2Implementation::TexSubImage3DImpl(GLenum target,
       for (GLint ii = 0; ii < num_images; ++ii) {
         CopyRectToBuffer(source + ii * image_size_src, my_height,
                          unpadded_row_size, pixels_padded_row_size,
-                         buffer_pointer + ii * image_size_dst,
+                         buffer_pointer .subspan( ii * image_size_dst),
                          buffer_padded_row_size);
       }
     } else {
@@ -5010,13 +5010,13 @@ void GLES2Implementation::ReadPixels(GLint xoffset,
     if (remaining_rows == 0) {
       break;
     }
-    const uint8_t* src = static_cast<const uint8_t*>(buffer.address());
+    base::span<const uint8_t>src = static_cast<const uint8_t*>(buffer.address());
     if (padded_row_size == unpadded_row_size &&
         (pack_row_length_ == 0 || pack_row_length_ == width) &&
         result->row_length == width && result->num_rows == num_rows) {
       // The pixels are tightly packed.
       uint32_t copy_size = unpadded_row_size * num_rows;
-      memcpy(dest, src, copy_size);
+      memcpy(dest, src.data(), copy_size);
       dest += copy_size;
     } else if (result->row_length > 0 && result->num_rows > 0) {
       uint32_t copy_row_size = result->row_length * group_size;
@@ -5031,15 +5031,15 @@ void GLES2Implementation::ReadPixels(GLint xoffset,
       for (GLint yy = 0; yy < num_rows; ++yy) {
         if (y_index + yy >= 0 && copied_rows < result->num_rows) {
           if (yy + 1 == num_rows && remaining_rows == num_rows) {
-            memcpy(dest + skip_row_bytes, src + skip_row_bytes,
+            memcpy(dest + skip_row_bytes, src .subspan( skip_row_bytes).data(),
                    copy_last_row_size);
           } else {
-            memcpy(dest + skip_row_bytes, src + skip_row_bytes, copy_row_size);
+            memcpy(dest + skip_row_bytes, src .subspan( skip_row_bytes).data(), copy_row_size);
           }
           ++copied_rows;
         }
         dest += padded_row_size;
-        src += service_padded_row_size;
+        src=src.subspan(service_padded_row_size);
       }
       DCHECK_EQ(result->num_rows, copied_rows);
     }
@@ -7186,7 +7186,7 @@ bool GLES2Implementation::PackStringsToBucket(GLsizei count,
       if (ii > 0 && buffer.size() == size)
         --copy_size;
       if (copy_size)
-        memcpy(buffer.address(), src, copy_size);
+        memcpy(buffer.address().data(), src, copy_size);
       if (copy_size < buffer.size()) {
         // Append NULL in the end.
         DCHECK(copy_size + 1 == buffer.size());
diff --git a/gpu/command_buffer/client/gles2_implementation_unittest.cc b/gpu/command_buffer/client/gles2_implementation_unittest.cc
index 17446d4b942fd..1df8d6b6e378c 100644
--- a/gpu/command_buffer/client/gles2_implementation_unittest.cc
+++ b/gpu/command_buffer/client/gles2_implementation_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -276,8 +278,8 @@ class GLES2ImplementationTest : public testing::Test {
       Mock::VerifyAndClearExpectations(gl_.get());
 
       scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-      commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) +
-                  command_buffer()->GetServicePutOffset();
+      commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) .subspan(
+                  command_buffer()->GetServicePutOffset()).data();
       ClearCommands();
       EXPECT_TRUE(transfer_buffer_->InSync());
 
@@ -304,7 +306,7 @@ class GLES2ImplementationTest : public testing::Test {
 
     void ClearCommands() {
       scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-      memset(ring_buffer->memory(), kInitialValue, ring_buffer->size());
+      memset(ring_buffer->memory().data(), kInitialValue, ring_buffer->size());
     }
 
     std::unique_ptr<MockClientCommandBuffer> command_buffer_;
@@ -325,10 +327,10 @@ class GLES2ImplementationTest : public testing::Test {
 
   bool NoCommandsWritten() {
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    const uint8_t* cmds = static_cast<const uint8_t*>(ring_buffer->memory());
-    const uint8_t* end = cmds + ring_buffer->size();
+    base::span<const uint8_t>cmds = static_cast<const uint8_t*>(ring_buffer->memory());
+    const uint8_t* end = cmds .subspan( ring_buffer->size()).data();
     for (; cmds < end; ++cmds) {
-      if (*cmds != kInitialValue) {
+      if ( cmds[0] != kInitialValue) {
         return false;
       }
     }
@@ -407,7 +409,7 @@ class GLES2ImplementationTest : public testing::Test {
 
   void ClearCommands() {
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    memset(ring_buffer->memory(), kInitialValue, ring_buffer->size());
+    memset(ring_buffer->memory().data(), kInitialValue, ring_buffer->size());
   }
 
   size_t MaxTransferBufferSize() {
@@ -2131,7 +2133,7 @@ TEST_F(GLES2ImplementationTest, GetIntegerDisjointValue) {
   ASSERT_EQ(mem.id, GetQueryTracker()->DisjointCountSyncShmID());
   ASSERT_EQ(mem.offset, GetQueryTracker()->DisjointCountSyncShmOffset());
   DisjointValueSync* disjoint_sync =
-      reinterpret_cast<DisjointValueSync*>(mem.ptr);
+      reinterpret_cast<DisjointValueSync*>(mem.ptr.data());
 
   ClearCommands();
   GLint disjoint_value = -1;
@@ -2233,7 +2235,7 @@ static bool CheckRect(int width,
                       GLenum type,
                       int alignment,
                       const uint8_t* r1,
-                      const uint8_t* r2) {
+                      base::span<const uint8_t>r2) {
   uint32_t size = 0;
   uint32_t unpadded_row_size = 0;
   uint32_t padded_row_size = 0;
@@ -2246,11 +2248,11 @@ static bool CheckRect(int width,
   int r2_stride = static_cast<int>(padded_row_size);
 
   for (int y = 0; y < height; ++y) {
-    if (memcmp(r1, r2, unpadded_row_size) != 0) {
+    if (memcmp(r1, r2.data(), unpadded_row_size) != 0) {
       return false;
     }
     r1 += padded_row_size;
-    r2 += r2_stride;
+    r2=r2.subspan(r2_stride);
   }
   return true;
 }
@@ -2546,7 +2548,7 @@ TEST_F(GLES2ImplementationTest, SubImage2DUnpack) {
       for (int y = 0; y < kSrcSubImageHeight; ++y) {
         const uint8_t* src_row =
             src_pixels.data() + client_skip_size + y * client_padded_row_size;
-        const uint8_t* dst_row = mem.ptr + y * service_padded_row_size;
+        const uint8_t* dst_row = mem.ptr .subspan( y * service_padded_row_size).data();
         EXPECT_EQ(0, memcmp(src_row, dst_row, service_unpadded_row_size));
       }
       ClearCommands();
@@ -2704,8 +2706,8 @@ TEST_F(GLES3ImplementationTest, SubImage3DUnpack) {
           const uint8_t* src_row =
               src_pixels.data() + client_skip_size +
               (kSrcHeight * z + y) * client_padded_row_size;
-          const uint8_t* dst_row = mem.ptr +
-              (kSrcSubImageHeight * z + y) * service_padded_row_size;
+          const uint8_t* dst_row = mem.ptr .subspan(
+              (kSrcSubImageHeight * z + y) * service_padded_row_size).data();
           EXPECT_EQ(0, memcmp(src_row, dst_row, service_unpadded_row_size));
         }
       }
@@ -3829,8 +3831,8 @@ TEST_F(GLES2ImplementationTest, TraceBeginCHROMIUM) {
   ExpectedMemoryInfo mem1 = GetExpectedMemory(kPaddedString1Size);
   ExpectedMemoryInfo mem2 = GetExpectedMemory(kPaddedString2Size);
 
-  ASSERT_STREQ(category_name.c_str(), reinterpret_cast<char*>(mem1.ptr));
-  ASSERT_STREQ(trace_name.c_str(), reinterpret_cast<char*>(mem2.ptr));
+  ASSERT_STREQ(category_name.c_str(), reinterpret_cast<char*>(mem1.ptr.data()));
+  ASSERT_STREQ(trace_name.c_str(), reinterpret_cast<char*>(mem2.ptr.data()));
 
   Cmds expected;
   expected.category_size1.Init(kCategoryBucketId, category_name.size() + 1);
@@ -3867,7 +3869,7 @@ TEST_F(GLES2ImplementationTest, SetActiveURLCHROMIUM) {
 
   ExpectedMemoryInfo mem = GetExpectedMemory(kPaddedStringSize);
   EXPECT_EQ(0,
-            memcmp(url.c_str(), reinterpret_cast<char*>(mem.ptr), url.size()));
+            memcmp(url.c_str(), reinterpret_cast<char*>(mem.ptr.data()), url.size()));
 
   Cmds expected;
   expected.url_size.Init(kURLBucketId, url.size());
diff --git a/gpu/command_buffer/client/implementation_base.cc b/gpu/command_buffer/client/implementation_base.cc
index 137526c0bd93f..d42d3555d3a23 100644
--- a/gpu/command_buffer/client/implementation_base.cc
+++ b/gpu/command_buffer/client/implementation_base.cc
@@ -312,7 +312,7 @@ bool ImplementationBase::GetBucketContents(uint32_t bucket_id,
         }
       }
       uint32_t size_to_copy = std::min(size, buffer.size());
-      memcpy(&(*data)[offset], buffer.address(), size_to_copy);
+      memcpy(&(*data)[offset], buffer.address().data(), size_to_copy);
       offset += size_to_copy;
       size -= size_to_copy;
       buffer.Release();
@@ -337,7 +337,7 @@ void ImplementationBase::SetBucketContents(uint32_t bucket_id,
       if (!buffer.valid()) {
         return;
       }
-      memcpy(buffer.address(), static_cast<const int8_t*>(data) + offset,
+      memcpy(buffer.address().data(), static_cast<const int8_t*>(data) + offset,
              buffer.size());
       helper_->SetBucketData(bucket_id, offset, buffer.size(), buffer.shm_id(),
                              buffer.offset());
diff --git a/gpu/command_buffer/client/mapped_memory.cc b/gpu/command_buffer/client/mapped_memory.cc
index ab2be5f7b166a..6cdada259c363 100644
--- a/gpu/command_buffer/client/mapped_memory.cc
+++ b/gpu/command_buffer/client/mapped_memory.cc
@@ -10,6 +10,7 @@
 #include <algorithm>
 #include <functional>
 
+#include "base/containers/span.h"
 #include "base/atomic_sequence_num.h"
 #include "base/check.h"
 #include "base/memory/ptr_util.h"
@@ -59,7 +60,7 @@ MappedMemoryManager::~MappedMemoryManager() {
   }
 }
 
-void* MappedMemoryManager::Alloc(unsigned int size,
+base::span<void> MappedMemoryManager::Alloc(unsigned int size,
                                  int32_t* shm_id,
                                  unsigned int* shm_offset,
                                  TransferBufferAllocationOption option) {
@@ -100,7 +101,7 @@ void* MappedMemoryManager::Alloc(unsigned int size,
 
   if (max_allocated_bytes_ != SharedMemoryLimits::kNoLimit &&
       (allocated_memory_ + size) > max_allocated_bytes_) {
-    return nullptr;
+    return {};
   }
 
   // Make a new chunk to satisfy the request.
@@ -109,13 +110,13 @@ void* MappedMemoryManager::Alloc(unsigned int size,
   chunk_size = (size + chunk_size_multiple_ - 1) & ~(chunk_size_multiple_ - 1);
   uint32_t safe_chunk_size = 0;
   if (!chunk_size.AssignIfValid(&safe_chunk_size))
-    return nullptr;
+    return {};
 
   int32_t id = -1;
   scoped_refptr<gpu::Buffer> shm = cmd_buf->CreateTransferBuffer(
       safe_chunk_size, &id, /* alignment */ 0, option);
   if (id  < 0)
-    return nullptr;
+    return {};
   DCHECK(shm.get());
   MemoryChunk* mc = new MemoryChunk(id, shm, helper_);
   allocated_memory_ += mc->GetSize();
@@ -223,9 +224,9 @@ FencedAllocator::State MappedMemoryManager::GetPointerStatusForTest(
 }
 
 void ScopedMappedMemoryPtr::Release() {
-  if (buffer_) {
+  if (!buffer_.empty()) {
     mapped_memory_manager_->FreePendingToken(buffer_, helper_->InsertToken());
-    buffer_ = nullptr;
+    buffer_ = {};
     size_ = 0;
     shm_id_ = 0;
     shm_offset_ = 0;
@@ -240,7 +241,7 @@ void ScopedMappedMemoryPtr::Reset(uint32_t new_size) {
 
   if (new_size) {
     buffer_ = mapped_memory_manager_->Alloc(new_size, &shm_id_, &shm_offset_);
-    size_ = buffer_ ? new_size : 0;
+    size_ = !buffer_.empty() ? new_size : 0;
   }
 }
 
diff --git a/gpu/command_buffer/client/mapped_memory.h b/gpu/command_buffer/client/mapped_memory.h
index bf183fddcb012..b9f8c86e1b4c9 100644
--- a/gpu/command_buffer/client/mapped_memory.h
+++ b/gpu/command_buffer/client/mapped_memory.h
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -104,7 +107,7 @@ class GPU_EXPORT MemoryChunk {
   // Returns true if pointer is in the range of this block.
   bool IsInChunk(void* pointer) const {
     return pointer >= shm_->memory() &&
-           pointer < static_cast<const int8_t*>(shm_->memory()) + shm_->size();
+           pointer < static_cast<const int8_t*>(shm_->memory()) .subspan( shm_->size());
   }
 
   // Returns true of any memory in this chunk is in use or free pending token.
@@ -167,7 +170,7 @@ class GPU_EXPORT MappedMemoryManager {
   //           to check error conditions.
   // Returns:
   //   pointer to allocated block of memory. nullptr if failure.
-  void* Alloc(uint32_t size,
+  base::span<void> Alloc(uint32_t size,
               int32_t* shm_id,
               uint32_t* shm_offset,
               TransferBufferAllocationOption option =
@@ -238,7 +241,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
   ScopedMappedMemoryPtr(uint32_t size,
                         CommandBufferHelper* helper,
                         MappedMemoryManager* mapped_memory_manager)
-      : buffer_(nullptr),
+      : buffer_({}),
         size_(0),
         shm_id_(0),
         shm_offset_(0),
@@ -273,7 +276,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
     return shm_offset_;
   }
 
-  void* address() const {
+  base::span<void> address() const {
     return buffer_;
   }
 
@@ -282,7 +285,7 @@ class GPU_EXPORT ScopedMappedMemoryPtr {
   void Reset(uint32_t new_size);
 
  private:
-  raw_ptr<void> buffer_;
+  base::raw_span<void> buffer_;
   uint32_t size_;
   int32_t shm_id_;
   uint32_t shm_offset_;
diff --git a/gpu/command_buffer/client/mapped_memory_unittest.cc b/gpu/command_buffer/client/mapped_memory_unittest.cc
index 98dcf1682f77a..30219c67397cc 100644
--- a/gpu/command_buffer/client/mapped_memory_unittest.cc
+++ b/gpu/command_buffer/client/mapped_memory_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -91,7 +93,7 @@ class MemoryChunkTest : public MappedMemoryTestBase {
     MappedMemoryTestBase::TearDown();
   }
 
-  uint8_t* buffer_memory() { return static_cast<uint8_t*>(buffer_->memory()); }
+  base::span<uint8_t> buffer_memory() { return static_cast<uint8_t*>(buffer_->memory()); }
 
   std::unique_ptr<MemoryChunk> chunk_;
   scoped_refptr<gpu::Buffer> buffer_;
diff --git a/gpu/command_buffer/client/mock_transfer_buffer.cc b/gpu/command_buffer/client/mock_transfer_buffer.cc
index 45d6ddee5026f..632c08e34442a 100644
--- a/gpu/command_buffer/client/mock_transfer_buffer.cc
+++ b/gpu/command_buffer/client/mock_transfer_buffer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -26,7 +28,7 @@ MockTransferBuffer::MockTransferBuffer(CommandBuffer* command_buffer,
       alignment_(alignment),
       actual_buffer_index_(0),
       expected_buffer_index_(0),
-      last_alloc_(nullptr),
+      last_alloc_({}),
       expected_offset_(result_size),
       actual_offset_(result_size),
       initialize_fail_(initialize_fail) {
@@ -63,7 +65,7 @@ int MockTransferBuffer::GetShmId() {
 void* MockTransferBuffer::AcquireResultBuffer() {
   EXPECT_FALSE(outstanding_result_pointer_);
   outstanding_result_pointer_ = true;
-  return actual_buffer() + actual_buffer_index_ * alignment_;
+  return actual_buffer() .subspan( actual_buffer_index_ * alignment_).data();
 }
 
 void MockTransferBuffer::ReleaseResultBuffer() {
@@ -83,7 +85,7 @@ bool MockTransferBuffer::HaveBuffer() const {
   return true;
 }
 
-void* MockTransferBuffer::AllocUpTo(unsigned int size,
+base::span<void> MockTransferBuffer::AllocUpTo(unsigned int size,
                                     unsigned int* size_allocated) {
   EXPECT_TRUE(size_allocated != nullptr);
   EXPECT_TRUE(last_alloc_ == nullptr);
@@ -101,7 +103,7 @@ void* MockTransferBuffer::AllocUpTo(unsigned int size,
   *size_allocated = size;
 
   // Make sure each buffer has a different offset.
-  last_alloc_ = actual_buffer() + offset + actual_buffer_index_ * alignment_;
+  last_alloc_ = actual_buffer() .subspan( offset + actual_buffer_index_ * alignment_);
   return last_alloc_;
 }
 
@@ -119,13 +121,13 @@ RingBuffer::Offset MockTransferBuffer::GetOffset(void* pointer) const {
 }
 
 void MockTransferBuffer::DiscardBlock(void* p) {
-  EXPECT_EQ(last_alloc_, p);
-  last_alloc_ = nullptr;
+  EXPECT_EQ(last_alloc_.data(), p);
+  last_alloc_ = {};
 }
 
 void MockTransferBuffer::FreePendingToken(void* p, unsigned int /* token */) {
-  EXPECT_EQ(last_alloc_, p);
-  last_alloc_ = nullptr;
+  EXPECT_EQ(last_alloc_.data(), p);
+  last_alloc_ = {};
 }
 
 unsigned int MockTransferBuffer::GetSize() const {
@@ -196,11 +198,11 @@ uint32_t MockTransferBuffer::AllocateExpectedTransferBuffer(uint32_t size) {
   return offset + expected_buffer_index_ * alignment_;
 }
 
-void* MockTransferBuffer::GetExpectedTransferAddressFromOffset(uint32_t offset,
+base::span<void> MockTransferBuffer::GetExpectedTransferAddressFromOffset(uint32_t offset,
                                                                uint32_t size) {
   EXPECT_GE(offset, expected_buffer_index_ * alignment_);
   EXPECT_LE(offset + size, size_ + expected_buffer_index_ * alignment_);
-  return expected_buffer() + offset;
+  return expected_buffer() .subspan( offset);
 }
 
 int MockTransferBuffer::GetExpectedResultBufferId() {
diff --git a/gpu/command_buffer/client/mock_transfer_buffer.h b/gpu/command_buffer/client/mock_transfer_buffer.h
index 728111ace3f8b..57ddb29c9e25c 100644
--- a/gpu/command_buffer/client/mock_transfer_buffer.h
+++ b/gpu/command_buffer/client/mock_transfer_buffer.h
@@ -8,6 +8,8 @@
 
 #include <array>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/stack_allocated.h"
 #include "gpu/command_buffer/client/ring_buffer.h"
@@ -25,7 +27,7 @@ class MockTransferBuffer : public TransferBufferInterface {
    public:
     uint32_t offset;
     int32_t id;
-    uint8_t* ptr;
+    base::span<uint8_t>ptr;
   };
 
   MockTransferBuffer(CommandBuffer* command_buffer,
@@ -51,7 +53,7 @@ class MockTransferBuffer : public TransferBufferInterface {
   int GetResultOffset() override;
   void Free() override;
   bool HaveBuffer() const override;
-  void* AllocUpTo(unsigned int size, unsigned int* size_allocated) override;
+  base::span<void> AllocUpTo(unsigned int size, unsigned int* size_allocated) override;
   void* Alloc(unsigned int size) override;
   RingBuffer::Offset GetOffset(void* pointer) const override;
   void DiscardBlock(void* p) override;
@@ -71,16 +73,16 @@ class MockTransferBuffer : public TransferBufferInterface {
  private:
   static const int kNumBuffers = 2;
 
-  uint8_t* actual_buffer() const {
+  base::span<uint8_t> actual_buffer() const {
     return static_cast<uint8_t*>(buffers_[actual_buffer_index_]->memory());
   }
 
-  uint8_t* expected_buffer() const {
+  base::span<uint8_t> expected_buffer() const {
     return static_cast<uint8_t*>(buffers_[expected_buffer_index_]->memory());
   }
 
   uint32_t AllocateExpectedTransferBuffer(uint32_t size);
-  void* GetExpectedTransferAddressFromOffset(uint32_t offset, uint32_t size);
+  base::span<void> GetExpectedTransferAddressFromOffset(uint32_t offset, uint32_t size);
   int GetExpectedResultBufferId();
   uint32_t GetExpectedResultBufferOffset();
   int GetExpectedTransferBufferId();
@@ -93,7 +95,7 @@ class MockTransferBuffer : public TransferBufferInterface {
   std::array<scoped_refptr<Buffer>, kNumBuffers> buffers_;
   int actual_buffer_index_;
   int expected_buffer_index_;
-  raw_ptr<void> last_alloc_;
+  base::raw_span<void> last_alloc_;
   uint32_t expected_offset_;
   uint32_t actual_offset_;
   bool initialize_fail_;
diff --git a/gpu/command_buffer/client/raster_implementation.cc b/gpu/command_buffer/client/raster_implementation.cc
index dea4b21599f7f..90f1278f47c99 100644
--- a/gpu/command_buffer/client/raster_implementation.cc
+++ b/gpu/command_buffer/client/raster_implementation.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -164,8 +166,8 @@ class ScopedSharedMemoryPtr {
   }
 
   void* address() {
-    return scoped_transfer_ptr_ ? scoped_transfer_ptr_->address()
-                                : scoped_mapped_ptr_->address();
+    return scoped_transfer_ptr_ ? scoped_transfer_ptr_->address().data()
+                                : scoped_mapped_ptr_->address().data();
   }
 
  private:
@@ -309,7 +311,7 @@ class RasterImplementation::PaintOpSerializer {
       return 0;
     }
 
-    size_t size = op.Serialize(buffer_ + written_bytes_, free_bytes_, options,
+    size_t size = op.Serialize(buffer_ .subspan( written_bytes_), free_bytes_, options,
                                flags_to_serialize, current_ctm, original_ctm);
     size_t block_size = *max_op_size_hint_;
 
@@ -324,11 +326,11 @@ class RasterImplementation::PaintOpSerializer {
       while (true) {
         buffer_ = static_cast<char*>(
             ri_->MapRasterCHROMIUM(block_size, &free_bytes_));
-        if (!buffer_) {
+        if (buffer_.empty()) {
           return 0;
         }
 
-        size = op.Serialize(buffer_ + written_bytes_, free_bytes_, options,
+        size = op.Serialize(buffer_ .subspan( written_bytes_), free_bytes_, options,
                             flags_to_serialize, current_ctm, original_ctm);
         if (size) {
           *max_op_size_hint_ = std::max(size, *max_op_size_hint_);
@@ -398,11 +400,11 @@ class RasterImplementation::PaintOpSerializer {
     written_bytes_ = 0;
   }
 
-  bool valid() const { return !!buffer_; }
+  bool valid() const { return !buffer_.empty(); }
 
  private:
   RasterImplementation* const ri_ = nullptr;
-  char* buffer_ = nullptr;
+  base::span<char>buffer_ = nullptr;
   cc::DecodeStashingImageProvider* const stashing_image_provider_ = nullptr;
   TransferCacheSerializeHelperImpl* const transfer_cache_helper_ = nullptr;
   ClientFontManager* font_manager_ = nullptr;
@@ -1146,18 +1148,18 @@ void RasterImplementation::GetQueryObjectui64vEXT(GLuint id,
   }
 }
 
-void* RasterImplementation::MapRasterCHROMIUM(uint32_t size,
+base::span<void> RasterImplementation::MapRasterCHROMIUM(uint32_t size,
                                               uint32_t* size_allocated) {
   *size_allocated = 0u;
   if (raster_mapped_buffer_) {
     SetGLError(GL_INVALID_OPERATION, "glMapRasterCHROMIUM", "already mapped");
-    return nullptr;
+    return {};
   }
   raster_mapped_buffer_.emplace(size, helper_, transfer_buffer_);
   if (!raster_mapped_buffer_->valid()) {
     SetGLError(GL_INVALID_OPERATION, "glMapRasterCHROMIUM", "size too big");
     raster_mapped_buffer_ = std::nullopt;
-    return nullptr;
+    return {};
   }
   *size_allocated = raster_mapped_buffer_->size();
   return raster_mapped_buffer_->address();
@@ -1181,7 +1183,7 @@ void* RasterImplementation::MapFontBuffer(uint32_t size) {
     font_mapped_buffer_ = std::nullopt;
     return nullptr;
   }
-  return font_mapped_buffer_->address();
+  return font_mapped_buffer_->address().data();
 }
 
 void RasterImplementation::UnmapRasterCHROMIUM(uint32_t raster_written_size,
@@ -1607,7 +1609,7 @@ void RasterImplementation::OnAsyncARGBReadbackDone(
     // region.
     auto* result =
         static_cast<cmds::ReadbackARGBImagePixelsINTERNALImmediate::Result*>(
-            request->shared_memory->address());
+            request->shared_memory->address().data());
     if (*result) {
       // We need to use `RelaxedAtomicWriteMemcpy` because we might be writing
       // into memory observed by JS at the same time.
@@ -1615,8 +1617,8 @@ void RasterImplementation::OnAsyncARGBReadbackDone(
       auto dst = base::span<uint8_t>(
           static_cast<uint8_t*>(request->dst_pixels.get()), plane_size);
       auto src = base::span<uint8_t>(
-          static_cast<uint8_t*>(request->shared_memory->address()) +
-              request->pixels_offset,
+          static_cast<uint8_t*>(request->shared_memory->address()) .subspan(
+              request->pixels_offset).data(),
           plane_size);
       base::subtle::RelaxedAtomicWriteMemcpy(dst, src);
       request->readback_successful = true;
@@ -1657,7 +1659,7 @@ void RasterImplementation::ReadbackARGBPixelsAsync(
     const gfx::Point& source_starting_point,
     const SkImageInfo& dst_info,
     GLuint dst_row_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     base::OnceCallback<void(bool)> readback_done) {
   TRACE_EVENT0("gpu", "RasterImplementation::ReadbackARGBPixelsAsync");
   DCHECK(!!readback_done);
@@ -1699,11 +1701,11 @@ void RasterImplementation::ReadbackYUVPixelsAsync(
     const gfx::Rect& output_rect,
     bool vertically_flip_texture,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void()> release_mailbox,
     base::OnceCallback<void(bool)> readback_done) {
@@ -1783,9 +1785,9 @@ void RasterImplementation::ReadbackYUVPixelsAsync(
   EndQueryEXT(GL_COMMANDS_ISSUED_CHROMIUM);
 
   auto request = std::make_unique<AsyncYUVReadbackRequest>(
-      output_rect, query, y_plane_row_stride_bytes, y_offset, y_plane_data,
-      u_plane_row_stride_bytes, u_offset, u_plane_data,
-      v_plane_row_stride_bytes, v_offset, v_plane_data,
+      output_rect, query, y_plane_row_stride_bytes, y_offset, y_plane_data.data(),
+      u_plane_row_stride_bytes, u_offset, u_plane_data.data(),
+      v_plane_row_stride_bytes, v_offset, v_plane_data.data(),
       std::move(scoped_shared_memory), std::move(release_mailbox),
       std::move(readback_done));
   auto* request_ptr = request.get();
diff --git a/gpu/command_buffer/client/raster_implementation.h b/gpu/command_buffer/client/raster_implementation.h
index 9039dd6c87aa2..2ad4a62da1b20 100644
--- a/gpu/command_buffer/client/raster_implementation.h
+++ b/gpu/command_buffer/client/raster_implementation.h
@@ -14,6 +14,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/trace_event/memory_dump_provider.h"
 #include "cc/paint/paint_cache.h"
@@ -164,7 +165,7 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override;
 
   void ReadbackYUVPixelsAsync(
@@ -174,11 +175,11 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override;
@@ -290,7 +291,7 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
 
   // Try to map a transfer buffer of |size|.  Will return a pointer to a
   // buffer of |size_allocated|, which will be equal to or lesser than |size|.
-  void* MapRasterCHROMIUM(uint32_t size, uint32_t* size_allocated);
+  base::span<void> MapRasterCHROMIUM(uint32_t size, uint32_t* size_allocated);
 
   // |raster_written_size| is the size of buffer used by raster commands.
   // |total_written_size| is the total size of the buffer written to, including
diff --git a/gpu/command_buffer/client/raster_implementation_gles.cc b/gpu/command_buffer/client/raster_implementation_gles.cc
index 2cadedb61d3ea..bb51f7ab3b04e 100644
--- a/gpu/command_buffer/client/raster_implementation_gles.cc
+++ b/gpu/command_buffer/client/raster_implementation_gles.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -286,7 +288,7 @@ void RasterImplementationGLES::ReadbackARGBPixelsAsync(
     const gfx::Point& source_starting_point,
     const SkImageInfo& dst_info,
     GLuint dst_row_bytes,
-    unsigned char* out,
+    base::span<unsigned char>out,
     base::OnceCallback<void(bool)> readback_done) {
   DCHECK(!readback_done.is_null());
   DCHECK(dst_info.colorType() == kRGBA_8888_SkColorType ||
@@ -348,11 +350,11 @@ void RasterImplementationGLES::ReadbackYUVPixelsAsync(
     const gfx::Rect& output_rect,
     bool vertically_flip_texture,
     int y_plane_row_stride_bytes,
-    unsigned char* y_plane_data,
+    base::span<unsigned char>y_plane_data,
     int u_plane_row_stride_bytes,
-    unsigned char* u_plane_data,
+    base::span<unsigned char>u_plane_data,
     int v_plane_row_stride_bytes,
-    unsigned char* v_plane_data,
+    base::span<unsigned char>v_plane_data,
     const gfx::Point& paste_location,
     base::OnceCallback<void()> release_mailbox,
     base::OnceCallback<void(bool)> readback_done) {
diff --git a/gpu/command_buffer/client/raster_implementation_gles.h b/gpu/command_buffer/client/raster_implementation_gles.h
index f19daa9461756..d10cd097cd947 100644
--- a/gpu/command_buffer/client/raster_implementation_gles.h
+++ b/gpu/command_buffer/client/raster_implementation_gles.h
@@ -5,6 +5,7 @@
 #ifndef GPU_COMMAND_BUFFER_CLIENT_RASTER_IMPLEMENTATION_GLES_H_
 #define GPU_COMMAND_BUFFER_CLIENT_RASTER_IMPLEMENTATION_GLES_H_
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/client/client_font_manager.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
@@ -112,7 +113,7 @@ class RASTER_EXPORT RasterImplementationGLES : public RasterInterface {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) override;
 
   void ReadbackYUVPixelsAsync(
@@ -122,11 +123,11 @@ class RASTER_EXPORT RasterImplementationGLES : public RasterInterface {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) override;
diff --git a/gpu/command_buffer/client/raster_implementation_unittest.cc b/gpu/command_buffer/client/raster_implementation_unittest.cc
index 2eef962fdb268..55c51be67a83f 100644
--- a/gpu/command_buffer/client/raster_implementation_unittest.cc
+++ b/gpu/command_buffer/client/raster_implementation_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -135,8 +137,8 @@ class RasterImplementationTest : public testing::Test {
       Mock::VerifyAndClearExpectations(gl_.get());
 
       scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-      commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) +
-                  command_buffer()->GetServicePutOffset();
+      commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) .subspan(
+                  command_buffer()->GetServicePutOffset()).data();
       ClearCommands();
       EXPECT_TRUE(transfer_buffer_->InSync());
 
@@ -164,7 +166,7 @@ class RasterImplementationTest : public testing::Test {
 
     void ClearCommands() {
       scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-      memset(ring_buffer->memory(), kInitialValue, ring_buffer->size());
+      memset(ring_buffer->memory().data(), kInitialValue, ring_buffer->size());
     }
 
     std::unique_ptr<MockClientCommandBuffer> command_buffer_;
@@ -184,10 +186,10 @@ class RasterImplementationTest : public testing::Test {
 
   bool NoCommandsWritten() {
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    const uint8_t* cmds = static_cast<const uint8_t*>(ring_buffer->memory());
-    const uint8_t* end = cmds + ring_buffer->size();
+    base::span<const uint8_t>cmds = static_cast<const uint8_t*>(ring_buffer->memory());
+    const uint8_t* end = cmds .subspan( ring_buffer->size()).data();
     for (; cmds < end; ++cmds) {
-      if (*cmds != kInitialValue) {
+      if ( cmds[0] != kInitialValue) {
         return false;
       }
     }
@@ -240,7 +242,7 @@ class RasterImplementationTest : public testing::Test {
 
   void ClearCommands() {
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    memset(ring_buffer->memory(), kInitialValue, ring_buffer->size());
+    memset(ring_buffer->memory().data(), kInitialValue, ring_buffer->size());
   }
 
   uint32_t MaxTransferBufferSize() {
@@ -833,19 +835,19 @@ TEST_F(RasterImplementationTest, TransferCacheSerialization) {
   ScopedTransferBufferPtr buffer(buffer_size, helper_, transfer_buffer_);
   ASSERT_EQ(buffer.size(), buffer_size);
 
-  uint8_t* buffer_start = reinterpret_cast<uint8_t*>(buffer.address());
-  memset(buffer_start, 0, buffer_size);
+  base::span<uint8_t>buffer_start = reinterpret_cast<uint8_t*>(buffer.address());
+  memset(buffer_start.data(), 0, buffer_size);
   gl_->SetRasterMappedBufferForTesting(std::move(buffer));
   auto transfer_cache = gl_->CreateTransferCacheHelperForTesting();
 
   std::vector<uint8_t> data(buffer_size - 16u);
-  uint8_t* memory = buffer_start + 8u;
+  uint8_t* memory = buffer_start .subspan( 8u).data();
   cc::ClientRawMemoryTransferCacheEntry inlined_entry(data);
   EXPECT_EQ(transfer_cache->CreateEntry(inlined_entry, memory), data.size());
   EXPECT_EQ(memcmp(data.data(), memory, data.size()), 0);
 
   data.resize(buffer_size + 16u);
-  memory = buffer_start + 8u;
+  memory = buffer_start .subspan( 8u).data();
   cc::ClientRawMemoryTransferCacheEntry non_inlined_entry(data);
   EXPECT_EQ(transfer_cache->CreateEntry(non_inlined_entry, memory), 0u);
 }
@@ -869,7 +871,7 @@ TEST_F(RasterImplementationTest, SetActiveURLCHROMIUM) {
 
   ExpectedMemoryInfo mem = GetExpectedMemory(kPaddedStringSize);
   EXPECT_EQ(0,
-            memcmp(url.c_str(), reinterpret_cast<char*>(mem.ptr), url.size()));
+            memcmp(url.c_str(), reinterpret_cast<char*>(mem.ptr.data()), url.size()));
 
   Cmds expected;
   expected.url_size.Init(kURLBucketId, url.size());
diff --git a/gpu/command_buffer/client/raster_interface.h b/gpu/command_buffer/client/raster_interface.h
index 50c3071c974fa..8fdbb39c092e1 100644
--- a/gpu/command_buffer/client/raster_interface.h
+++ b/gpu/command_buffer/client/raster_interface.h
@@ -143,7 +143,7 @@ class RasterInterface : public InterfaceBase {
       const gfx::Point& source_starting_point,
       const SkImageInfo& dst_info,
       GLuint dst_row_bytes,
-      unsigned char* out,
+      base::span<unsigned char>out,
       base::OnceCallback<void(bool)> readback_done) = 0;
 
   // Starts an asynchronus readback and translation of RGBA |source_mailbox|
@@ -161,11 +161,11 @@ class RasterInterface : public InterfaceBase {
       const gfx::Rect& output_rect,
       bool vertically_flip_texture,
       int y_plane_row_stride_bytes,
-      unsigned char* y_plane_data,
+      base::span<unsigned char>y_plane_data,
       int u_plane_row_stride_bytes,
-      unsigned char* u_plane_data,
+      base::span<unsigned char>u_plane_data,
       int v_plane_row_stride_bytes,
-      unsigned char* v_plane_data,
+      base::span<unsigned char>v_plane_data,
       const gfx::Point& paste_location,
       base::OnceCallback<void()> release_mailbox,
       base::OnceCallback<void(bool)> readback_done) = 0;
diff --git a/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc b/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
index fc1740c53ebfb..76ba536ad8d4e 100644
--- a/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
+++ b/gpu/command_buffer/client/readback_buffer_shadow_tracker.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -32,7 +34,7 @@ uint32_t ReadbackBufferShadowTracker::Buffer::Alloc(int32_t* shm_id,
                                                     uint32_t* shm_offset,
                                                     bool* already_allocated) {
   *already_allocated = readback_shm_address_ != nullptr;
-  if (!readback_shm_address_) {
+  if (!!readback_shm_address_.empty()) {
     readback_shm_address_ =
         mapped_memory_->Alloc(size_, &shm_id_, &shm_offset_);
   }
@@ -42,11 +44,11 @@ uint32_t ReadbackBufferShadowTracker::Buffer::Alloc(int32_t* shm_id,
 }
 
 void ReadbackBufferShadowTracker::Buffer::Free() {
-  if (readback_shm_address_) {
+  if (!readback_shm_address_.empty()) {
     mapped_memory_->FreePendingToken(readback_shm_address_,
                                      helper_->InsertToken());
   }
-  readback_shm_address_ = nullptr;
+  readback_shm_address_ = {};
 }
 
 void* ReadbackBufferShadowTracker::Buffer::MapReadbackShm(uint32_t offset,
@@ -55,7 +57,7 @@ void* ReadbackBufferShadowTracker::Buffer::MapReadbackShm(uint32_t offset,
   if (serial_of_readback_data_ != serial_of_last_write_) {
     return nullptr;
   }
-  if (!readback_shm_address_) {
+  if (!!readback_shm_address_.empty()) {
     return nullptr;
   }
   if (map_size > size_) {
diff --git a/gpu/command_buffer/client/readback_buffer_shadow_tracker.h b/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
index e8ed2dfa6e853..a55887698ca35 100644
--- a/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
+++ b/gpu/command_buffer/client/readback_buffer_shadow_tracker.h
@@ -6,6 +6,7 @@
 #define GPU_COMMAND_BUFFER_CLIENT_READBACK_BUFFER_SHADOW_TRACKER_H_
 
 #include <GLES2/gl2.h>
+#include "base/memory/raw_span.h"
 #include "base/containers/flat_map.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/weak_ptr.h"
@@ -54,7 +55,7 @@ class ReadbackBufferShadowTracker {
     raw_ptr<GLES2CmdHelper> helper_;
     int32_t shm_id_ = 0;
     uint32_t shm_offset_ = 0;
-    raw_ptr<void> readback_shm_address_ = nullptr;
+    base::raw_span<void> readback_shm_address_ = nullptr;
     uint64_t serial_of_last_write_ = 1;  // will be updated right after creation
     uint64_t serial_of_readback_data_ = 0;
     uint32_t size_ = 0;
diff --git a/gpu/command_buffer/client/ring_buffer.cc b/gpu/command_buffer/client/ring_buffer.cc
index b696ebfdd6a48..7e60ca2b7c4ed 100644
--- a/gpu/command_buffer/client/ring_buffer.cc
+++ b/gpu/command_buffer/client/ring_buffer.cc
@@ -11,6 +11,7 @@
 #include <algorithm>
 #include <ostream>
 
+#include "base/containers/span.h"
 #include "base/check_op.h"
 #include "base/notreached.h"
 #include "base/numerics/safe_conversions.h"
@@ -55,7 +56,7 @@ void RingBuffer::FreeOldestBlock() {
   blocks_.pop_front();
 }
 
-void* RingBuffer::Alloc(uint32_t size) {
+base::span<void> RingBuffer::Alloc(uint32_t size) {
   DCHECK_LE(size, size_) << "attempt to allocate more than maximum memory";
   // Similarly to malloc, an allocation of 0 allocates at least 1 byte, to
   // return different pointers every time.
diff --git a/gpu/command_buffer/client/ring_buffer.h b/gpu/command_buffer/client/ring_buffer.h
index 9eca902ce6a81..4335cb845b862 100644
--- a/gpu/command_buffer/client/ring_buffer.h
+++ b/gpu/command_buffer/client/ring_buffer.h
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -59,7 +62,7 @@ class GPU_EXPORT RingBuffer {
   //
   // Returns:
   //   the pointer to the allocated memory block.
-  void* Alloc(uint32_t size);
+  base::span<void> Alloc(uint32_t size);
 
   // Frees a block of memory, pending the passage of a token. That memory won't
   // be re-allocated until the token has passed through the command stream.
@@ -99,8 +102,8 @@ class GPU_EXPORT RingBuffer {
   uint32_t NumUsedBlocks() const { return num_used_blocks_; }
 
   // Gets a pointer to a memory block given the base memory and the offset.
-  void* GetPointer(RingBuffer::Offset offset) const {
-    return static_cast<int8_t*>(base_) + offset;
+  base::span<void> GetPointer(RingBuffer::Offset offset) const {
+    return static_cast<int8_t*>(base_) .subspan( offset);
   }
 
   // Gets the offset to a memory block given the base memory and the address.
@@ -167,7 +170,7 @@ class GPU_EXPORT RingBuffer {
   uint32_t num_used_blocks_ = 0;
 
   // The physical address that corresponds to base_offset.
-  raw_ptr<void, AcrossTasksDanglingUntriaged> base_;
+  base::raw_span<void, AcrossTasksDanglingUntriaged> base_;
 };
 
 }  // namespace gpu
diff --git a/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc b/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
index 2ee21f45c3101..2fe3d99d7e376 100644
--- a/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
+++ b/gpu/command_buffer/client/test_gpu_memory_buffer_manager.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -51,11 +53,11 @@ class GpuMemoryBufferImpl : public gfx::GpuMemoryBuffer {
     mapped_ = true;
     return true;
   }
-  void* memory(size_t plane) override {
+  base::span<void> memory(size_t plane) override {
     DCHECK(mapped_);
     DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
-    return reinterpret_cast<uint8_t*>(mapping_.memory()) + offset_ +
-           gfx::BufferOffsetForBufferFormat(size_, format_, plane);
+    return reinterpret_cast<uint8_t*>(mapping_.memory()) .subspan( offset_ +
+           gfx::BufferOffsetForBufferFormat(size_, format_, plane));
   }
   void Unmap() override {
     DCHECK(mapped_);
@@ -104,7 +106,7 @@ class GpuMemoryBufferFromClient : public gfx::GpuMemoryBuffer {
   ~GpuMemoryBufferFromClient() override = default;
 
   bool Map() override { return client_buffer_->Map(); }
-  void* memory(size_t plane) override { return client_buffer_->memory(plane); }
+  base::span<void> memory(size_t plane) override { return client_buffer_->memory(plane); }
   void Unmap() override { client_buffer_->Unmap(); }
   gfx::Size GetSize() const override { return client_buffer_->GetSize(); }
   gfx::BufferFormat GetFormat() const override {
diff --git a/gpu/command_buffer/client/transfer_buffer.cc b/gpu/command_buffer/client/transfer_buffer.cc
index 5e00e23a2c11d..910dcb4e763b3 100644
--- a/gpu/command_buffer/client/transfer_buffer.cc
+++ b/gpu/command_buffer/client/transfer_buffer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -132,7 +134,7 @@ void TransferBuffer::AllocateRingBuffer(unsigned int size) {
       ring_buffer_ = std::make_unique<RingBuffer>(buffer_, alignment_,
                                                   result_size_, helper_);
       buffer_id_ = id;
-      result_buffer_ = buffer_->memory();
+      result_buffer_ = buffer_->memory().data();
       result_shm_offset_ = 0;
       bytes_since_last_shrink_ = 0;
       return;
@@ -226,14 +228,14 @@ void TransferBuffer::ShrinkOrExpandRingBufferIfNecessary(
   }
 }
 
-void* TransferBuffer::AllocUpTo(
+base::span<void> TransferBuffer::AllocUpTo(
     unsigned int size, unsigned int* size_allocated) {
   DCHECK(size_allocated);
 
   ShrinkOrExpandRingBufferIfNecessary(size);
 
   if (!HaveBuffer()) {
-    return nullptr;
+    return {};
   }
 
   unsigned int max_size = ring_buffer_->GetLargestFreeOrPendingSize();
@@ -254,7 +256,7 @@ void* TransferBuffer::Alloc(unsigned int size) {
     return nullptr;
   }
   bytes_since_last_shrink_ += size;
-  return ring_buffer_->Alloc(size);
+  return ring_buffer_->Alloc(size).data();
 }
 
 void* TransferBuffer::AcquireResultBuffer() {
@@ -296,22 +298,22 @@ ScopedTransferBufferPtr::ScopedTransferBufferPtr(
       size_(other.size_),
       helper_(other.helper_),
       transfer_buffer_(other.transfer_buffer_) {
-  other.buffer_ = nullptr;
+  other.buffer_ = {};
   other.size_ = 0u;
 }
 
 void ScopedTransferBufferPtr::Release() {
-  if (buffer_) {
+  if (!buffer_.empty()) {
     transfer_buffer_->FreePendingToken(buffer_, helper_->InsertToken());
-    buffer_ = nullptr;
+    buffer_ = {};
     size_ = 0;
   }
 }
 
 void ScopedTransferBufferPtr::Discard() {
-  if (buffer_) {
+  if (!buffer_.empty()) {
     transfer_buffer_->DiscardBlock(buffer_);
-    buffer_ = nullptr;
+    buffer_ = {};
     size_ = 0;
   }
 }
@@ -334,10 +336,10 @@ void ScopedTransferBufferPtr::Shrink(unsigned int new_size) {
 }
 
 bool ScopedTransferBufferPtr::BelongsToBuffer(uint8_t* memory) const {
-  if (!buffer_)
+  if (!!buffer_.empty())
     return false;
-  uint8_t* start = static_cast<uint8_t*>(buffer_.get());
-  uint8_t* end = start + size_;
+  base::span<uint8_t>start = static_cast<uint8_t*>(buffer_);
+  uint8_t* end = start .subspan( size_).data();
   return memory >= start && memory <= end;
 }
 
diff --git a/gpu/command_buffer/client/transfer_buffer.h b/gpu/command_buffer/client/transfer_buffer.h
index 042c8819d32a8..364d297a41793 100644
--- a/gpu/command_buffer/client/transfer_buffer.h
+++ b/gpu/command_buffer/client/transfer_buffer.h
@@ -10,6 +10,8 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/compiler_specific.h"
 #include "base/containers/circular_deque.h"
 #include "base/memory/raw_ptr.h"
@@ -47,7 +49,7 @@ class GPU_EXPORT TransferBufferInterface {
   virtual bool HaveBuffer() const = 0;
 
   // Allocates up to size bytes.
-  virtual void* AllocUpTo(unsigned int size, unsigned int* size_allocated) = 0;
+  virtual base::span<void> AllocUpTo(unsigned int size, unsigned int* size_allocated) = 0;
 
   // Allocates size bytes.
   // Note: Alloc will fail if it can not return size bytes.
@@ -100,7 +102,7 @@ class GPU_EXPORT TransferBuffer : public TransferBufferInterface {
   int GetResultOffset() override;
   void Free() override;
   bool HaveBuffer() const override;
-  void* AllocUpTo(unsigned int size, unsigned int* size_allocated) override;
+  base::span<void> AllocUpTo(unsigned int size, unsigned int* size_allocated) override;
   void* Alloc(unsigned int size) override;
   RingBuffer::Offset GetOffset(void* pointer) const override;
   void DiscardBlock(void* p) override;
@@ -184,7 +186,7 @@ class GPU_EXPORT ScopedTransferBufferPtr {
   ScopedTransferBufferPtr(unsigned int size,
                           CommandBufferHelper* helper,
                           TransferBufferInterface* transfer_buffer)
-      : buffer_(nullptr),
+      : buffer_({}),
         size_(0),
         helper_(helper),
         transfer_buffer_(transfer_buffer) {
@@ -194,7 +196,7 @@ class GPU_EXPORT ScopedTransferBufferPtr {
   // Constructs an empty and invalid allocation that should be Reset() later.
   ScopedTransferBufferPtr(CommandBufferHelper* helper,
                           TransferBufferInterface* transfer_buffer)
-      : buffer_(nullptr),
+      : buffer_({}),
         size_(0),
         helper_(helper),
         transfer_buffer_(transfer_buffer) {}
@@ -222,7 +224,7 @@ class GPU_EXPORT ScopedTransferBufferPtr {
     return transfer_buffer_->GetOffset(buffer_);
   }
 
-  void* address() const {
+  base::span<void> address() const {
     return buffer_;
   }
 
@@ -239,7 +241,7 @@ class GPU_EXPORT ScopedTransferBufferPtr {
   void Shrink(unsigned int new_size);
 
  private:
-  raw_ptr<void> buffer_;
+  base::raw_span<void> buffer_;
   unsigned int size_;
 
   // Found dangling on `linux-rel` in
@@ -260,7 +262,7 @@ class ScopedTransferBufferArray : public ScopedTransferBufferPtr {
           num_elements * sizeof(T), helper, transfer_buffer) {
   }
 
-  T* elements() {
+  base::span<T> elements() {
     return static_cast<T*>(address());
   }
 
diff --git a/gpu/command_buffer/client/webgpu_implementation_unittest.cc b/gpu/command_buffer/client/webgpu_implementation_unittest.cc
index 2c79df260f612..b432d348a7be3 100644
--- a/gpu/command_buffer/client/webgpu_implementation_unittest.cc
+++ b/gpu/command_buffer/client/webgpu_implementation_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -84,8 +86,8 @@ class WebGPUImplementationTest : public testing::Test {
     Mock::VerifyAndClearExpectations(gl_.get());
 
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) +
-                command_buffer_->GetServicePutOffset();
+    commands_ = static_cast<CommandBufferEntry*>(ring_buffer->memory()) .subspan(
+                command_buffer_->GetServicePutOffset()).data();
     ClearCommands();
     EXPECT_TRUE(transfer_buffer_->InSync());
 
@@ -95,7 +97,7 @@ class WebGPUImplementationTest : public testing::Test {
 
   void ClearCommands() {
     scoped_refptr<Buffer> ring_buffer = helper_->get_ring_buffer();
-    memset(ring_buffer->memory(), kInitialValue, ring_buffer->size());
+    memset(ring_buffer->memory().data(), kInitialValue, ring_buffer->size());
   }
 
   void SetUp() override { ASSERT_TRUE(Initialize()); }
diff --git a/gpu/command_buffer/common/buffer.cc b/gpu/command_buffer/common/buffer.cc
index 45b72b3832c75..539bd338ad10f 100644
--- a/gpu/command_buffer/common/buffer.cc
+++ b/gpu/command_buffer/common/buffer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -45,7 +47,7 @@ MemoryBufferBacking::MemoryBufferBacking(uint32_t size, uint32_t alignment)
 
 MemoryBufferBacking::~MemoryBufferBacking() = default;
 
-const void* MemoryBufferBacking::GetMemory() const {
+const base::span<void> MemoryBufferBacking::GetMemory() const {
   return alignment_ > 0 ? base::bits::AlignUp(memory_.get(), alignment_)
                         : memory_.get();
 }
@@ -74,7 +76,7 @@ base::UnguessableToken SharedMemoryBufferBacking::GetGUID() const {
   return shared_memory_region_.GetGUID();
 }
 
-const void* SharedMemoryBufferBacking::GetMemory() const {
+const base::span<void> SharedMemoryBufferBacking::GetMemory() const {
   return shared_memory_mapping_.memory();
 }
 
@@ -86,17 +88,17 @@ Buffer::Buffer(std::unique_ptr<BufferBacking> backing)
     : backing_(std::move(backing)),
       memory_(backing_->GetMemory()),
       size_(backing_->GetSize()) {
-  DCHECK(memory_) << "The memory must be mapped to create a Buffer";
+  DCHECK(!memory_.empty()) << "The memory must be mapped to create a Buffer";
 }
 
 Buffer::~Buffer() = default;
 
-void* Buffer::GetDataAddress(uint32_t data_offset, uint32_t data_size) const {
+base::span<void> Buffer::GetDataAddress(uint32_t data_offset, uint32_t data_size) const {
   base::CheckedNumeric<uint32_t> end = data_offset;
   end += data_size;
   if (!end.IsValid() || end.ValueOrDie() > static_cast<uint32_t>(size_))
-    return nullptr;
-  return static_cast<uint8_t*>(memory_) + data_offset;
+    return {};
+  return static_cast<uint8_t*>(memory_) .subspan( data_offset);
 }
 
 void* Buffer::GetDataAddressAndSize(uint32_t data_offset,
@@ -104,7 +106,7 @@ void* Buffer::GetDataAddressAndSize(uint32_t data_offset,
   if (data_offset > static_cast<uint32_t>(size_))
     return nullptr;
   *data_size = GetRemainingSize(data_offset);
-  return static_cast<uint8_t*>(memory_) + data_offset;
+  return static_cast<uint8_t*>(memory_) .subspan( data_offset).data();
 }
 
 uint32_t Buffer::GetRemainingSize(uint32_t data_offset) const {
diff --git a/gpu/command_buffer/common/buffer.h b/gpu/command_buffer/common/buffer.h
index da5bbe4d2b86b..1dad07b82471c 100644
--- a/gpu/command_buffer/common/buffer.h
+++ b/gpu/command_buffer/common/buffer.h
@@ -11,6 +11,8 @@
 #include <memory>
 #include <utility>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/unsafe_shared_memory_region.h"
@@ -24,10 +26,10 @@ class GPU_EXPORT BufferBacking {
   virtual ~BufferBacking() = default;
   virtual const base::UnsafeSharedMemoryRegion& shared_memory_region() const;
   virtual base::UnguessableToken GetGUID() const;
-  void* GetMemory() {
+  base::span<void> GetMemory() {
     return const_cast<void*>(std::as_const(*this).GetMemory());
   }
-  virtual const void* GetMemory() const = 0;
+  virtual const base::span<void> GetMemory() const = 0;
   virtual uint32_t GetSize() const = 0;
 };
 
@@ -39,7 +41,7 @@ class GPU_EXPORT MemoryBufferBacking : public BufferBacking {
   MemoryBufferBacking& operator=(const MemoryBufferBacking&) = delete;
 
   ~MemoryBufferBacking() override;
-  const void* GetMemory() const override;
+  const base::span<void> GetMemory() const override;
   uint32_t GetSize() const override;
 
  private:
@@ -62,7 +64,7 @@ class GPU_EXPORT SharedMemoryBufferBacking : public BufferBacking {
   ~SharedMemoryBufferBacking() override;
   const base::UnsafeSharedMemoryRegion& shared_memory_region() const override;
   base::UnguessableToken GetGUID() const override;
-  const void* GetMemory() const override;
+  const base::span<void> GetMemory() const override;
   uint32_t GetSize() const override;
 
  private:
@@ -79,12 +81,12 @@ class GPU_EXPORT Buffer : public base::RefCountedThreadSafe<Buffer> {
   Buffer& operator=(const Buffer&) = delete;
 
   BufferBacking* backing() const { return backing_.get(); }
-  void* memory() { return memory_; }
-  const void* memory() const { return memory_; }
+  base::span<void> memory() { return memory_; }
+  const void* memory() const { return memory_.data(); }
   uint32_t size() const { return size_; }
 
   // Returns nullptr if the address overflows the memory.
-  void* GetDataAddress(uint32_t data_offset, uint32_t data_size) const;
+  base::span<void> GetDataAddress(uint32_t data_offset, uint32_t data_size) const;
 
   // Returns nullptr if the address overflows the memory.
   void* GetDataAddressAndSize(uint32_t data_offset, uint32_t* data_size) const;
@@ -97,7 +99,7 @@ class GPU_EXPORT Buffer : public base::RefCountedThreadSafe<Buffer> {
   ~Buffer();
 
   std::unique_ptr<BufferBacking> backing_;
-  raw_ptr<void> memory_;
+  base::raw_span<void> memory_;
   uint32_t size_;
 };
 
diff --git a/gpu/command_buffer/common/discardable_handle.cc b/gpu/command_buffer/common/discardable_handle.cc
index 27665af763713..4d68b9884431b 100644
--- a/gpu/command_buffer/common/discardable_handle.cc
+++ b/gpu/command_buffer/common/discardable_handle.cc
@@ -37,7 +37,7 @@ bool DiscardableHandleBase::ValidateParameters(const Buffer* buffer,
     return false;
   if (byte_offset % sizeof(base::subtle::Atomic32))
     return false;
-  if (!buffer->GetDataAddress(byte_offset, sizeof(base::subtle::Atomic32)))
+  if ().empty())
     return false;
 
   return true;
@@ -61,7 +61,7 @@ scoped_refptr<Buffer> DiscardableHandleBase::BufferForTesting() const {
 
 volatile base::subtle::Atomic32* DiscardableHandleBase::AsAtomic() const {
   return reinterpret_cast<volatile base::subtle::Atomic32*>(
-      buffer_->GetDataAddress(byte_offset_, sizeof(base::subtle::Atomic32)));
+      buffer_->GetDataAddress(byte_offset_, sizeof(base::subtle::Atomic32)).data());
 }
 
 ClientDiscardableHandle::ClientDiscardableHandle()
diff --git a/gpu/command_buffer/common/shm_count.cc b/gpu/command_buffer/common/shm_count.cc
index e596ad61162af..63221310ba763 100644
--- a/gpu/command_buffer/common/shm_count.cc
+++ b/gpu/command_buffer/common/shm_count.cc
@@ -23,7 +23,7 @@ bool ShmCountBase::IsInitialized() const {
 }
 
 volatile ShmCountBase::AtomicType* ShmCountBase::AsAtomic() {
-  return reinterpret_cast<volatile AtomicType*>(mapping_.memory());
+  return reinterpret_cast<volatile AtomicType*>(mapping_.memory().data());
 }
 
 GpuProcessShmCount::GpuProcessShmCount() = default;
diff --git a/gpu/command_buffer/service/buffer_manager.cc b/gpu/command_buffer/service/buffer_manager.cc
index 62b578d00ba4a..6d48092cff401 100644
--- a/gpu/command_buffer/service/buffer_manager.cc
+++ b/gpu/command_buffer/service/buffer_manager.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -119,12 +121,12 @@ Buffer::MappedRange::MappedRange(
       shm(shm),
       shm_offset(shm_offset) {
   DCHECK(pointer);
-  DCHECK(shm.get() && GetShmPointer());
+  DCHECK(shm.get() && !GetShmPointer().empty());
 }
 
 Buffer::MappedRange::~MappedRange() = default;
 
-void* Buffer::MappedRange::GetShmPointer() const {
+base::span<void> Buffer::MappedRange::GetShmPointer() const {
   DCHECK(shm.get());
   return shm->GetDataAddress(shm_offset, static_cast<unsigned int>(size));
 }
diff --git a/gpu/command_buffer/service/buffer_manager.h b/gpu/command_buffer/service/buffer_manager.h
index 45a124671eb58..656c92c444a06 100644
--- a/gpu/command_buffer/service/buffer_manager.h
+++ b/gpu/command_buffer/service/buffer_manager.h
@@ -14,6 +14,7 @@
 #include <unordered_map>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/check_op.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/ref_counted.h"
@@ -47,7 +48,7 @@ class GPU_GLES2_EXPORT Buffer : public base::RefCounted<Buffer> {
     MappedRange(GLintptr offset, GLsizeiptr size, GLenum access, void* pointer,
                 scoped_refptr<gpu::Buffer> shm, unsigned int shm_offset);
     ~MappedRange();
-    void* GetShmPointer() const;
+    base::span<void> GetShmPointer() const;
   };
 
   Buffer(BufferManager* manager, GLuint service_id);
diff --git a/gpu/command_buffer/service/command_buffer_service.cc b/gpu/command_buffer/service/command_buffer_service.cc
index ef58d4826e6af..5c608c3106acf 100644
--- a/gpu/command_buffer/service/command_buffer_service.cc
+++ b/gpu/command_buffer/service/command_buffer_service.cc
@@ -324,7 +324,7 @@ void CommandBufferService::SetSharedStateBuffer(
   DCHECK(shared_state_buffer_->GetSize() >= sizeof(*shared_state_));
 
   shared_state_ =
-      static_cast<CommandBufferSharedState*>(shared_state_buffer_->GetMemory());
+      static_cast<CommandBufferSharedState*>(shared_state_buffer_->GetMemory().data());
 
   UpdateState();
 }
diff --git a/gpu/command_buffer/service/command_buffer_service_unittest.cc b/gpu/command_buffer/service/command_buffer_service_unittest.cc
index 6900d0a0cb122..c1934115ecb3a 100644
--- a/gpu/command_buffer/service/command_buffer_service_unittest.cc
+++ b/gpu/command_buffer/service/command_buffer_service_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -56,7 +58,7 @@ class CommandBufferServiceTest : public testing::Test,
   }
 
   AsyncAPIMock* api_mock() { return api_mock_.get(); }
-  CommandBufferEntry* buffer() {
+  base::span<CommandBufferEntry> buffer() {
     return static_cast<CommandBufferEntry*>(buffer_->memory());
   }
 
diff --git a/gpu/command_buffer/service/common_decoder.cc b/gpu/command_buffer/service/common_decoder.cc
index 24da63c45a588..4e643464c8b32 100644
--- a/gpu/command_buffer/service/common_decoder.cc
+++ b/gpu/command_buffer/service/common_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -166,13 +168,13 @@ CommonDecoder::CommonDecoder(DecoderClient* client,
 
 CommonDecoder::~CommonDecoder() = default;
 
-void* CommonDecoder::GetAddressAndCheckSize(unsigned int shm_id,
+base::span<void> CommonDecoder::GetAddressAndCheckSize(unsigned int shm_id,
                                             unsigned int data_offset,
                                             unsigned int data_size) {
   scoped_refptr<gpu::Buffer> buffer =
       command_buffer_service_->GetTransferBuffer(shm_id);
   if (!buffer.get())
-    return nullptr;
+    return {};
   return buffer->GetDataAddress(data_offset, data_size);
 }
 
@@ -421,13 +423,13 @@ bool CommonDecoder::ReadColorSpace(uint32_t shm_id,
     return true;
   }
 
-  const uint8_t* data = static_cast<const uint8_t*>(
+  base::span<const uint8_t>data = static_cast<const uint8_t*>(
       GetAddressAndCheckSize(shm_id, shm_offset, color_space_size));
-  if (!data) {
+  if (data.empty()) {
     return false;
   }
 
-  base::span<const uint8_t> color_space_data(data, data + color_space_size);
+  base::span<const uint8_t> color_space_data(data.data(), data .subspan( color_space_size).data());
   base::Pickle color_space_pickle =
       base::Pickle::WithUnownedBuffer(color_space_data);
   base::PickleIterator iterator(color_space_pickle);
diff --git a/gpu/command_buffer/service/common_decoder.h b/gpu/command_buffer/service/common_decoder.h
index 7d6c205e3ff90..eac970ebcfe95 100644
--- a/gpu/command_buffer/service/common_decoder.h
+++ b/gpu/command_buffer/service/common_decoder.h
@@ -13,6 +13,7 @@
 #include <string>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/common/buffer.h"
 #include "gpu/command_buffer/common/cmd_buffer_common.h"
@@ -149,7 +150,7 @@ class GPU_EXPORT CommonDecoder {
   // Returns:
   //   nullptr if shm_id isn't a valid shared memory buffer ID or if the size
   //   check fails. Return a pointer to the data otherwise.
-  void* GetAddressAndCheckSize(unsigned int shm_id,
+  base::span<void> GetAddressAndCheckSize(unsigned int shm_id,
                                unsigned int offset,
                                unsigned int size);
 
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder.cc b/gpu/command_buffer/service/gles2_cmd_decoder.cc
index 0a4d51dba9a6c..42726b07c771d 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -15267,7 +15267,7 @@ error::Error GLES2DecoderImpl::HandleBeginQueryEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
@@ -15414,7 +15414,7 @@ error::Error GLES2DecoderImpl::HandleQueryCounterEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
@@ -16904,13 +16904,13 @@ void GLES2DecoderImpl::DoFlushMappedBufferRange(
         "offset + size out of bounds");
     return;
   }
-  char* client_data = reinterpret_cast<char*>(mapped_range->GetShmPointer());
-  DCHECK(client_data);
+  base::span<char>client_data = reinterpret_cast<char*>(mapped_range->GetShmPointer());
+  DCHECK(!client_data.empty());
   char* gpu_data = reinterpret_cast<char*>(mapped_range->pointer.get());
   DCHECK(gpu_data);
-  memcpy(gpu_data + offset, client_data + offset, size);
+  memcpy(gpu_data + offset, client_data .subspan( offset).data(), size);
   if (buffer->shadowed()) {
-    buffer->SetRange(mapped_range->offset + offset, size, client_data + offset);
+    buffer->SetRange(mapped_range->offset + offset, size, client_data .subspan( offset));
   }
   api()->glFlushMappedBufferRangeFn(target, offset, size);
 }
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
index a7137c3bd951d..4162478f3b2db 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
@@ -3856,7 +3856,7 @@ error::Error GLES2DecoderPassthroughImpl::DoQueryCounterEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
@@ -3915,7 +3915,7 @@ error::Error GLES2DecoderPassthroughImpl::DoBeginQueryEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
index 5842ff4ee2fe1..1702df7c20121 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -130,7 +132,7 @@ GLES2DecoderTestBase::GLES2DecoderTestBase()
       client_sync_id_(127),
       shared_memory_id_(0),
       shared_memory_offset_(0),
-      shared_memory_address_(nullptr),
+      shared_memory_address_({}),
       shared_memory_base_(nullptr),
       service_renderbuffer_id_(0),
       service_renderbuffer_valid_(false),
@@ -464,8 +466,8 @@ ContextResult GLES2DecoderTestBase::MaybeInitDecoderWithWorkarounds(
                                                           &shared_memory_id_);
   shared_memory_offset_ = kSharedMemoryOffset;
   shared_memory_address_ =
-      static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
-  shared_memory_base_ = buffer->memory();
+      static_cast<int8_t*>(buffer->memory()) .subspan( shared_memory_offset_);
+  shared_memory_base_ = buffer->memory().data();
   ClearSharedMemory();
 
   ContextCreationAttribs attribs;
@@ -732,7 +734,7 @@ void GLES2DecoderTestBase::SetBucketData(
   cmd1.Init(bucket_id, data_size);
   EXPECT_EQ(error::kNoError, ExecuteCmd(cmd1));
   if (data) {
-    memcpy(shared_memory_address_, data, data_size);
+    memcpy(shared_memory_address_.data(), data, data_size);
     cmd::SetBucketData cmd2;
     cmd2.Init(bucket_id, 0, data_size, shared_memory_id_, kSharedMemoryOffset);
     EXPECT_EQ(error::kNoError, ExecuteCmd(cmd2));
@@ -761,16 +763,16 @@ void GLES2DecoderTestBase::SetBucketAsCStrings(uint32_t bucket_id,
   cmd::SetBucketSize cmd1;
   cmd1.Init(bucket_id, total_size);
   EXPECT_EQ(error::kNoError, ExecuteCmd(cmd1));
-  memcpy(shared_memory_address_, header.data(), header_size);
+  memcpy(shared_memory_address_.data(), header.data(), header_size);
   uint32_t offset = header_size;
   for (GLsizei ii = 0; ii < count; ++ii) {
     if (str && str[ii]) {
       size_t str_len = strlen(str[ii]);
-      memcpy(static_cast<char*>(shared_memory_address_) + offset, str[ii],
+      memcpy(static_cast<char*>(shared_memory_address_) .subspan( offset).data(), str[ii],
              str_len);
       offset += str_len;
     }
-    memcpy(static_cast<char*>(shared_memory_address_) + offset, &str_end, 1);
+    memcpy(static_cast<char*>(shared_memory_address_) .subspan( offset).data(), &str_end, 1);
     offset += 1;
   }
   cmd::SetBucketData cmd2;
@@ -1662,7 +1664,7 @@ void GLES2DecoderTestBase::DoFramebufferRenderbuffer(
 
 GLenum GLES2DecoderTestBase::DoCheckFramebufferStatus(GLenum target) {
   auto* result = static_cast<cmds::CheckFramebufferStatus::Result*>(
-      shared_memory_address_);
+      shared_memory_address_.data());
   *result = 0;
   cmds::CheckFramebufferStatus cmd;
   cmd.Init(GL_FRAMEBUFFER, shared_memory_id_, shared_memory_offset_);
@@ -2199,10 +2201,10 @@ void GLES2DecoderTestBase::DoBufferData(GLenum target, GLsizei size) {
 void GLES2DecoderTestBase::DoBufferSubData(
     GLenum target, GLint offset, GLsizei size, const void* data) {
   EXPECT_CALL(*gl_,
-              BufferSubData(target, offset, size, shared_memory_address_.get()))
+              BufferSubData(target, offset, size, shared_memory_address_))
       .Times(1)
       .RetiresOnSaturation();
-  memcpy(shared_memory_address_, data, size);
+  memcpy(shared_memory_address_.data(), data, size);
   cmds::BufferSubData cmd;
   cmd.Init(target, offset, size, shared_memory_id_, shared_memory_offset_);
   EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
@@ -2421,8 +2423,8 @@ void GLES2DecoderPassthroughTestBase::SetUp() {
                                                           &shared_memory_id_);
   shared_memory_offset_ = kSharedMemoryOffset;
   shared_memory_address_ =
-      static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
-  shared_memory_base_ = buffer->memory();
+      static_cast<int8_t*>(buffer->memory()) .subspan( shared_memory_offset_).data();
+  shared_memory_base_ = buffer->memory().data();
   shared_memory_size_ = kSharedBufferSize - shared_memory_offset_;
 
   decoder_->MakeCurrent();
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
index 0e61b36d83272..c0d24832599dd 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
+++ b/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -124,13 +126,13 @@ class GLES2DecoderTestBase : public ::testing::TestWithParam<bool>,
 
   template <typename T>
   T GetSharedMemoryAs() {
-    return reinterpret_cast<T>(shared_memory_address_.get());
+    return reinterpret_cast<T>(shared_memory_address_);
   }
 
   template <typename T>
   T GetSharedMemoryAsWithOffset(uint32_t offset) {
     void* ptr =
-        reinterpret_cast<int8_t*>(shared_memory_address_.get()) + offset;
+        reinterpret_cast<int8_t*>(shared_memory_address_) + offset;
     return reinterpret_cast<T>(ptr);
   }
 
@@ -540,7 +542,7 @@ class GLES2DecoderTestBase : public ::testing::TestWithParam<bool>,
 
   template <typename Command, typename Result>
   bool IsObjectHelper(GLuint client_id) {
-    Result* result = static_cast<Result*>(shared_memory_address_);
+    Result* result = static_cast<Result*>(shared_memory_address_.data());
     Command cmd;
     cmd.Init(client_id, shared_memory_id_, kSharedMemoryOffset);
     EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
@@ -723,7 +725,7 @@ class GLES2DecoderTestBase : public ::testing::TestWithParam<bool>,
 
   int32_t shared_memory_id_;
   uint32_t shared_memory_offset_;
-  raw_ptr<void> shared_memory_address_;
+  base::raw_span<void> shared_memory_address_;
   raw_ptr<void> shared_memory_base_;
 
   GLuint service_renderbuffer_id_;
diff --git a/gpu/command_buffer/service/query_manager_unittest.cc b/gpu/command_buffer/service/query_manager_unittest.cc
index 24860c01d3541..d8b66aa60cde2 100644
--- a/gpu/command_buffer/service/query_manager_unittest.cc
+++ b/gpu/command_buffer/service/query_manager_unittest.cc
@@ -70,10 +70,10 @@ class QueryManagerTest : public GpuServiceTest {
     scoped_refptr<gpu::Buffer> buffer =
         command_buffer_service_->CreateTransferBufferHelper(kSharedBufferSize,
                                                             &shared_memory_id_);
-    memset(buffer->memory(), kInitialMemoryValue, kSharedBufferSize);
+    memset(buffer->memory().data(), kInitialMemoryValue, kSharedBufferSize);
     buffer = command_buffer_service_->CreateTransferBufferHelper(
         kSharedBufferSize, &shared_memory2_id_);
-    memset(buffer->memory(), kInitialMemoryValue, kSharedBufferSize);
+    memset(buffer->memory().data(), kInitialMemoryValue, kSharedBufferSize);
     decoder_ = std::make_unique<MockGLES2Decoder>(
         &client_, command_buffer_service_.get(), &outputter_);
     TestHelper::SetupFeatureInfoInitExpectations(
@@ -110,7 +110,7 @@ class QueryManagerTest : public GpuServiceTest {
     if (!buffer)
       return nullptr;
     QuerySync* sync = static_cast<QuerySync*>(
-        buffer->GetDataAddress(shm_offset, sizeof(QuerySync)));
+        buffer->GetDataAddress(shm_offset, sizeof(QuerySync)).data());
     if (!sync)
       return nullptr;
     return manager->CreateQuery(target, client_id, std::move(buffer), sync);
diff --git a/gpu/command_buffer/service/raster_decoder.cc b/gpu/command_buffer/service/raster_decoder.cc
index a056326abe53b..f21f97f37d65a 100644
--- a/gpu/command_buffer/service/raster_decoder.cc
+++ b/gpu/command_buffer/service/raster_decoder.cc
@@ -1766,7 +1766,7 @@ error::Error RasterDecoderImpl::HandleBeginQueryEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
@@ -1835,7 +1835,7 @@ error::Error RasterDecoderImpl::HandleQueryCounterEXT(
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
-      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
+      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)).data());
   if (!sync)
     return error::kOutOfBounds;
 
diff --git a/gpu/command_buffer/service/raster_decoder_unittest.cc b/gpu/command_buffer/service/raster_decoder_unittest.cc
index ebad30bd52ce4..0c3358d470799 100644
--- a/gpu/command_buffer/service/raster_decoder_unittest.cc
+++ b/gpu/command_buffer/service/raster_decoder_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -229,7 +231,7 @@ class RasterDecoderOOPTest : public testing::Test, DecoderClient {
                                                             &shared_memory_id_);
     shared_memory_offset_ = kSharedMemoryOffset;
     shared_memory_address_ =
-        static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
+        static_cast<int8_t*>(buffer->memory()) .subspan( shared_memory_offset_).data();
 
     workarounds.webgl_or_caps_max_texture_size = INT_MAX - 1;
     shared_image_factory_ = std::make_unique<SharedImageFactory>(
diff --git a/gpu/command_buffer/service/raster_decoder_unittest_base.cc b/gpu/command_buffer/service/raster_decoder_unittest_base.cc
index fbcb9133c752c..03bcc478abb26 100644
--- a/gpu/command_buffer/service/raster_decoder_unittest_base.cc
+++ b/gpu/command_buffer/service/raster_decoder_unittest_base.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -193,8 +195,8 @@ void RasterDecoderTestBase::InitDecoder(const InitState& init) {
                                                           &shared_memory_id_);
   shared_memory_offset_ = kSharedMemoryOffset;
   shared_memory_address_ =
-      static_cast<int8_t*>(buffer->memory()) + shared_memory_offset_;
-  shared_memory_base_ = buffer->memory();
+      static_cast<int8_t*>(buffer->memory()) .subspan( shared_memory_offset_).data();
+  shared_memory_base_ = buffer->memory().data();
   ClearSharedMemory();
 }
 
diff --git a/gpu/command_buffer/service/shared_memory_region_wrapper.cc b/gpu/command_buffer/service/shared_memory_region_wrapper.cc
index b688ba9bcd646..76e997b7688b8 100644
--- a/gpu/command_buffer/service/shared_memory_region_wrapper.cc
+++ b/gpu/command_buffer/service/shared_memory_region_wrapper.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -124,7 +126,7 @@ bool SharedMemoryRegionWrapper::IsValid() const {
 
 const uint8_t* SharedMemoryRegionWrapper::GetMemory(int plane_index) const {
   DCHECK(IsValid());
-  return mapping_.GetMemoryAs<const uint8_t>() + planes_[plane_index].offset;
+  return mapping_.GetMemoryAs<const uint8_t>() .subspan( planes_[plane_index].offset).data();
 }
 
 size_t SharedMemoryRegionWrapper::GetStride(int plane_index) const {
@@ -135,7 +137,7 @@ size_t SharedMemoryRegionWrapper::GetStride(int plane_index) const {
 base::span<const uint8_t> SharedMemoryRegionWrapper::GetMemoryPlanes() const {
   DCHECK(IsValid());
   auto full_mapped_span =
-      base::span(mapping_.GetMemoryAs<const uint8_t>(), mapping_.mapped_size());
+      base::span(mapping_.GetMemoryAs<const uint8_t>().data(), mapping_.mapped_size());
   // It is possible that the first plane starts at a non-zero offset. So we
   // subspan at this offset.
   return full_mapped_span.subspan(planes_[0].offset);
diff --git a/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc b/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
index cb77c345d5c0c..77530a19daf4f 100644
--- a/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
+++ b/gpu/command_buffer/tests/gl_gpu_memory_buffer_unittest.cc
@@ -160,7 +160,7 @@ TEST_P(GpuMemoryBufferTest, MapUnmap) {
   ASSERT_TRUE(buffer->Map());
   ASSERT_NE(nullptr, buffer->memory(0));
   ASSERT_NE(0, buffer->stride(0));
-  const uint8_t* data = static_cast<uint8_t*>(buffer->memory(0));
+  const uint8_t* data = static_cast<uint8_t*>(buffer->memory(0).data());
   const int stride = buffer->stride(0);
   // libyuv defines the formats as word-order.
   std::array<uint8_t, kImageWidth * kImageHeight * 4> argb = {};
diff --git a/gpu/command_buffer/tests/gl_helper_unittest.cc b/gpu/command_buffer/tests/gl_helper_unittest.cc
index 44c64422cc860..3717083123a1e 100644
--- a/gpu/command_buffer/tests/gl_helper_unittest.cc
+++ b/gpu/command_buffer/tests/gl_helper_unittest.cc
@@ -18,6 +18,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/ref_counted_memory.h"
@@ -997,7 +998,7 @@ class GLHelperTest : public testing::Test {
 
   bool ReadBackTexture(GLuint src_texture,
                        const gfx::Rect& src_rect,
-                       unsigned char* pixels,
+                       base::span<unsigned char>pixels,
                        size_t pixels_stride,
                        bool flip_y,
                        SkColorType color_type) {
@@ -1043,7 +1044,7 @@ class GLHelperTest : public testing::Test {
     // Initialize the output bitmap with Green color.
     // When the readback is over output bitmap should have the red color.
     output_pixels.eraseColor(SK_ColorGREEN);
-    uint8_t* pixels = static_cast<uint8_t*>(output_pixels.getPixels());
+    base::span<uint8_t>pixels = static_cast<uint8_t*>(output_pixels.getPixels());
     if (!ReadBackTexture(src_texture, gfx::Rect(src_size), pixels,
                          output_pixels.rowBytes(), /*flip_y=*/false,
                          color_type) ||
diff --git a/gpu/command_buffer/tests/gl_manager.cc b/gpu/command_buffer/tests/gl_manager.cc
index 8bbbea88ac465..f149f4e5ced95 100644
--- a/gpu/command_buffer/tests/gl_manager.cc
+++ b/gpu/command_buffer/tests/gl_manager.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -81,7 +83,7 @@ class GpuMemoryBufferImplTest : public gfx::GpuMemoryBuffer {
     mapped_ = true;
     return true;
   }
-  void* memory(size_t plane) override {
+  base::span<void> memory(size_t plane) override {
     DCHECK(mapped_);
     DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
     return bytes_->as_vector().data() +
diff --git a/gpu/ipc/client/command_buffer_proxy_impl.cc b/gpu/ipc/client/command_buffer_proxy_impl.cc
index d438d776aa830..c8ec6a824e6a4 100644
--- a/gpu/ipc/client/command_buffer_proxy_impl.cc
+++ b/gpu/ipc/client/command_buffer_proxy_impl.cc
@@ -671,7 +671,7 @@ void CommandBufferProxyImpl::TryUpdateStateDontReportError() {
 const gpu::CommandBufferSharedState* CommandBufferProxyImpl::shared_state()
     const {
   return reinterpret_cast<const gpu::CommandBufferSharedState*>(
-      shared_state_mapping_.memory());
+      shared_state_mapping_.memory().data());
 }
 
 base::HistogramBase*
diff --git a/gpu/ipc/client/shared_image_interface_proxy.cc b/gpu/ipc/client/shared_image_interface_proxy.cc
index 3cc66e4f45f09..b58811ccc68d5 100644
--- a/gpu/ipc/client/shared_image_interface_proxy.cc
+++ b/gpu/ipc/client/shared_image_interface_proxy.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -56,7 +58,7 @@ void* GetDataAddress(base::MappedReadOnlyRegion& region,
   size_t end;
   if (!safe_end.AssignIfValid(&end) || end > region.mapping.size())
     return nullptr;
-  return region.mapping.GetMemoryAs<uint8_t>() + offset;
+  return region.mapping.GetMemoryAs<uint8_t>() .subspan( offset).data();
 }
 
 std::vector<SyncToken> GenerateDependenciesFromSyncToken(
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
index 083073ca5b1eb..fc04018209575 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/memory/ptr_util.h"
 #include "gpu/ipc/common/gpu_memory_buffer_support.h"
@@ -108,7 +109,7 @@ bool GpuMemoryBufferImplNativePixmap::Map() {
   return true;
 }
 
-void* GpuMemoryBufferImplNativePixmap::memory(size_t plane) {
+base::span<void> GpuMemoryBufferImplNativePixmap::memory(size_t plane) {
   AssertMapped();
   return pixmap_->GetMemoryAddress(plane);
 }
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
index 3ffb148887675..7211c2d3c1051 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h
@@ -10,6 +10,7 @@
 #include <memory>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "gpu/gpu_export.h"
 #include "gpu/ipc/common/gpu_memory_buffer_impl.h"
 
@@ -48,7 +49,7 @@ class GPU_EXPORT GpuMemoryBufferImplNativePixmap : public GpuMemoryBufferImpl {
 
   // Overridden from gfx::GpuMemoryBuffer:
   bool Map() override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   int stride(size_t plane) const override;
   gfx::GpuMemoryBufferType GetType() const override;
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
index b86c4f916360c..2e15e2e6d9f37 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -253,11 +255,11 @@ bool GpuMemoryBufferImplSharedMemory::Map() {
   return true;
 }
 
-void* GpuMemoryBufferImplSharedMemory::memory(size_t plane) {
+base::span<void> GpuMemoryBufferImplSharedMemory::memory(size_t plane) {
   AssertMapped();
   DCHECK_LT(plane, gfx::NumberOfPlanesForLinearBufferFormat(format_));
-  return static_cast<uint8_t*>(shared_memory_mapping_.memory()) + offset_ +
-         gfx::BufferOffsetForBufferFormat(size_, format_, plane);
+  return static_cast<uint8_t*>(shared_memory_mapping_.memory()) .subspan( offset_ +
+         gfx::BufferOffsetForBufferFormat(size_, format_, plane));
 }
 
 void GpuMemoryBufferImplSharedMemory::Unmap() {
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
index 506376f984df0..9acc11d18737b 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_shared_memory.h
@@ -9,6 +9,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "gpu/gpu_export.h"
 #include "gpu/ipc/common/gpu_memory_buffer_impl.h"
 
@@ -61,7 +62,7 @@ class GPU_EXPORT GpuMemoryBufferImplSharedMemory : public GpuMemoryBufferImpl {
 
   // Overridden from gfx::GpuMemoryBuffer:
   bool Map() override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   int stride(size_t plane) const override;
   gfx::GpuMemoryBufferType GetType() const override;
diff --git a/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h b/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
index 97c6ac742b137..011ed1fb12aeb 100644
--- a/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
+++ b/gpu/ipc/common/gpu_memory_buffer_impl_test_template.h
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -309,8 +311,8 @@ TYPED_TEST_P(GpuMemoryBufferImplTest, Map) {
       size_t height = kBufferSize.height() /
                       gfx::SubsamplingFactorForBufferFormat(format, plane);
       for (size_t y = 0; y < height; ++y) {
-        memcpy(static_cast<char*>(buffer->memory(plane)) +
-                   y * buffer->stride(plane),
+        memcpy(static_cast<char*>(buffer->memory(plane)) .subspan(
+                   y * buffer).data()->stride(plane),
                data.data(), row_size_in_bytes);
         EXPECT_EQ(0, memcmp(static_cast<char*>(buffer->memory(plane)) +
                                 y * buffer->stride(plane),
@@ -368,8 +370,8 @@ TYPED_TEST_P(GpuMemoryBufferImplTest, PersistentMap) {
       size_t height = kBufferSize.height() /
                       gfx::SubsamplingFactorForBufferFormat(format, plane);
       for (size_t y = 0; y < height; ++y) {
-        memcpy(static_cast<char*>(buffer->memory(plane)) +
-                   y * buffer->stride(plane),
+        memcpy(static_cast<char*>(buffer->memory(plane)) .subspan(
+                   y * buffer).data()->stride(plane),
                data.data(), row_size_in_bytes);
         EXPECT_EQ(0, memcmp(static_cast<char*>(buffer->memory(plane)) +
                                 y * buffer->stride(plane),
diff --git a/ipc/ipc_channel_mojo_unittest.cc b/ipc/ipc_channel_mojo_unittest.cc
index 0ad0d599a1895..322fa877da9f1 100644
--- a/ipc/ipc_channel_mojo_unittest.cc
+++ b/ipc/ipc_channel_mojo_unittest.cc
@@ -1637,7 +1637,7 @@ TYPED_TEST(IPCChannelMojoSharedMemoryRegionTypedTest, Send) {
       base::CreateMappedRegion<typename TypeParam::RegionType>(size);
 
   std::string content = HandleSendingHelper::GetSendingFileContent();
-  memcpy(mapping.memory(), content.data(), content.size());
+  memcpy(mapping.memory().data(), content.data(), content.size());
 
   // Create a success listener, and launch the child process.
   base::RunLoop run_loop;
diff --git a/media/audio/audio_input_device.cc b/media/audio/audio_input_device.cc
index 8d6e46c3fe186..6a0aa4c9900cb 100644
--- a/media/audio/audio_input_device.cc
+++ b/media/audio/audio_input_device.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -420,14 +422,14 @@ void AudioInputDevice::AudioThreadCallback::MapSharedMemory() {
   shared_memory_mapping_ = shared_memory_region_.MapAt(0, memory_length_);
 
   // Create vector of audio buses by wrapping existing blocks of memory.
-  const uint8_t* ptr =
+  base::span<const uint8_t>ptr =
       static_cast<const uint8_t*>(shared_memory_mapping_.memory());
   for (uint32_t i = 0; i < total_segments_; ++i) {
     const media::AudioInputBuffer* buffer =
-        reinterpret_cast<const media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<const media::AudioInputBuffer*>(ptr.data());
     audio_buses_.push_back(
         media::AudioBus::WrapReadOnlyMemory(audio_parameters_, buffer->audio));
-    ptr += segment_length_;
+    ptr=ptr.subspan(segment_length_);
   }
 
   // Indicate that browser side capture initialization has succeeded and IPC
@@ -442,9 +444,9 @@ void AudioInputDevice::AudioThreadCallback::Process(uint32_t pending_data) {
   // The shared memory represents parameters, size of the data buffer and the
   // actual data buffer containing audio data. Map the memory into this
   // structure and parse out parameters and the data area.
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
-  ptr += current_segment_id_ * segment_length_;
-  AudioInputBuffer* buffer = reinterpret_cast<AudioInputBuffer*>(ptr);
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  ptr=ptr.subspan(current_segment_id_ * segment_length_);
+  AudioInputBuffer* buffer = reinterpret_cast<AudioInputBuffer*>(ptr.data());
 
   // Usually this will be equal but in the case of low sample rate (e.g. 8kHz,
   // the buffer may be bigger (on mac at least)).
diff --git a/media/audio/audio_input_device_unittest.cc b/media/audio/audio_input_device_unittest.cc
index 641792819d213..f067fe31dba9f 100644
--- a/media/audio/audio_input_device_unittest.cc
+++ b/media/audio/audio_input_device_unittest.cc
@@ -120,7 +120,7 @@ class AudioInputDeviceTest
     shared_memory_ = base::UnsafeSharedMemoryRegion::Create(memory_size);
     shared_memory_mapping_ = shared_memory_.Map();
     ASSERT_TRUE(shared_memory_.IsValid());
-    memset(shared_memory_mapping_.memory(), 0xff, memory_size);
+    memset(shared_memory_mapping_.memory().data(), 0xff, memory_size);
 
     ASSERT_TRUE(
         CancelableSyncSocket::CreatePair(&browser_socket_, &renderer_socket_));
@@ -146,7 +146,7 @@ class AudioInputDeviceTest
     EXPECT_CALL(*capture_callback_, OnCaptureStarted());
     EXPECT_CALL(*input_ipc, CloseStream());
 
-    uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+    uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory().data());
     buffer_ = reinterpret_cast<AudioInputBuffer*>(ptr);
     buffer_->params.id = 0;
     buffer_->params.capture_time_us =
diff --git a/media/audio/audio_output_device_thread_callback.cc b/media/audio/audio_output_device_thread_callback.cc
index 986a80038efd0..2f8d96b86a091 100644
--- a/media/audio/audio_output_device_thread_callback.cc
+++ b/media/audio/audio_output_device_thread_callback.cc
@@ -45,7 +45,7 @@ void AudioOutputDeviceThreadCallback::MapSharedMemory() {
 
   media::AudioOutputBuffer* buffer =
       reinterpret_cast<media::AudioOutputBuffer*>(
-          shared_memory_mapping_.memory());
+          shared_memory_mapping_.memory().data());
   output_bus_ = media::AudioBus::WrapMemory(audio_parameters_, buffer->audio);
   output_bus_->set_is_bitstream_format(audio_parameters_.IsBitstreamFormat());
 }
@@ -57,7 +57,7 @@ void AudioOutputDeviceThreadCallback::Process(uint32_t control_signal) {
   // Read and reset the glitch info.
   media::AudioOutputBuffer* buffer =
       reinterpret_cast<media::AudioOutputBuffer*>(
-          shared_memory_mapping_.memory());
+          shared_memory_mapping_.memory().data());
   media::AudioGlitchInfo glitch_info{
       .duration = base::Microseconds(buffer->params.glitch_duration_us),
       .count = buffer->params.glitch_count};
diff --git a/media/audio/audio_output_device_unittest.cc b/media/audio/audio_output_device_unittest.cc
index d125537b3c54b..1b6a94346c771 100644
--- a/media/audio/audio_output_device_unittest.cc
+++ b/media/audio/audio_output_device_unittest.cc
@@ -203,7 +203,7 @@ void AudioOutputDeviceTest::CallOnStreamCreated() {
   ASSERT_TRUE(shared_memory_region_.IsValid());
   shared_memory_mapping_ = shared_memory_region_.Map();
   ASSERT_TRUE(shared_memory_mapping_.IsValid());
-  memset(shared_memory_mapping_.memory(), 0xff, kMemorySize);
+  memset(shared_memory_mapping_.memory().data(), 0xff, kMemorySize);
 
   ASSERT_TRUE(CancelableSyncSocket::CreatePair(&browser_socket_,
                                                &renderer_socket_));
diff --git a/media/base/decoder_buffer_unittest.cc b/media/base/decoder_buffer_unittest.cc
index 7c419245473bb..8e37b90a54137 100644
--- a/media/base/decoder_buffer_unittest.cc
+++ b/media/base/decoder_buffer_unittest.cc
@@ -103,7 +103,7 @@ TEST(DecoderBufferTest, FromPlatformSharedMemoryRegion) {
   auto region = base::UnsafeSharedMemoryRegion::Create(kDataSize);
   auto mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  memcpy(mapping.GetMemoryAs<uint8_t>(), kData, kDataSize);
+  memcpy(mapping.GetMemoryAs<uint8_t>().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(
       DecoderBuffer::FromSharedMemoryRegion(std::move(region), 0, kDataSize));
@@ -122,7 +122,7 @@ TEST(DecoderBufferTest, FromPlatformSharedMemoryRegion_Unaligned) {
   auto region = base::UnsafeSharedMemoryRegion::Create(kDataSize);
   auto mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  memcpy(mapping.GetMemoryAs<uint8_t>(), kData, kDataSize);
+  memcpy(mapping.GetMemoryAs<uint8_t>().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(DecoderBuffer::FromSharedMemoryRegion(
       std::move(region), kDataOffset, kDataSize - kDataOffset));
@@ -140,7 +140,7 @@ TEST(DecoderBufferTest, FromPlatformSharedMemoryRegion_ZeroSize) {
   auto region = base::UnsafeSharedMemoryRegion::Create(kDataSize);
   auto mapping = region.Map();
   ASSERT_TRUE(mapping.IsValid());
-  memcpy(mapping.memory(), kData, kDataSize);
+  memcpy(mapping.memory().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(
       DecoderBuffer::FromSharedMemoryRegion(std::move(region), 0, 0));
@@ -153,7 +153,7 @@ TEST(DecoderBufferTest, FromSharedMemoryRegion) {
 
   auto mapping_region = base::ReadOnlySharedMemoryRegion::Create(kDataSize);
   ASSERT_TRUE(mapping_region.IsValid());
-  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>(), kData, kDataSize);
+  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(DecoderBuffer::FromSharedMemoryRegion(
       std::move(mapping_region.region), 0, kDataSize));
@@ -171,7 +171,7 @@ TEST(DecoderBufferTest, FromSharedMemoryRegion_Unaligned) {
 
   auto mapping_region = base::ReadOnlySharedMemoryRegion::Create(kDataSize);
   ASSERT_TRUE(mapping_region.IsValid());
-  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>(), kData, kDataSize);
+  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(DecoderBuffer::FromSharedMemoryRegion(
       std::move(mapping_region.region), kDataOffset, kDataSize - kDataOffset));
@@ -188,7 +188,7 @@ TEST(DecoderBufferTest, FromSharedMemoryRegion_ZeroSize) {
   const size_t kDataSize = std::size(kData);
 
   auto mapping_region = base::ReadOnlySharedMemoryRegion::Create(kDataSize);
-  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>(), kData, kDataSize);
+  memcpy(mapping_region.mapping.GetMemoryAs<uint8_t>().data(), kData, kDataSize);
 
   scoped_refptr<DecoderBuffer> buffer(DecoderBuffer::FromSharedMemoryRegion(
       std::move(mapping_region.region), 0, 0));
diff --git a/media/base/test_helpers.cc b/media/base/test_helpers.cc
index 5d3a2f2d7e8c7..b90cf6d4f2318 100644
--- a/media/base/test_helpers.cc
+++ b/media/base/test_helpers.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -73,13 +75,13 @@ void I4xxxRect(VideoFrame* dest_frame,
       << VideoPixelFormatToString(dest_frame->format());
 
   // Write known full size planes first.
-  libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kY) +
-                       y * dest_frame->stride(VideoFrame::Plane::kY) + x,
+  libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kY) .subspan(
+                       y * dest_frame->stride(VideoFrame::Plane::kY) + x).data(),
                    dest_frame->stride(VideoFrame::Plane::kY), width, height,
                    value_y);
   if (num_planes == 4) {
-    libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kA) +
-                         y * dest_frame->stride(VideoFrame::Plane::kA) + x,
+    libyuv::SetPlane(dest_frame->GetWritableVisibleData(VideoFrame::Plane::kA) .subspan(
+                         y * dest_frame->stride(VideoFrame::Plane::kA) + x).data(),
                      dest_frame->stride(VideoFrame::Plane::kA), width, height,
                      value_a);
   }
@@ -92,15 +94,15 @@ void I4xxxRect(VideoFrame* dest_frame,
 
   // Write variable sized planes.
   libyuv::SetPlane(
-      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kU) +
+      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kU) .subspan(
           start_xy.height() * dest_frame->stride(VideoFrame::Plane::kU) +
-          start_xy.width(),
+          start_xy.width()).data(),
       dest_frame->stride(VideoFrame::Plane::kU), uv_size.width(),
       uv_size.height(), value_u);
   libyuv::SetPlane(
-      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kV) +
+      dest_frame->GetWritableVisibleData(VideoFrame::Plane::kV) .subspan(
           start_xy.height() * dest_frame->stride(VideoFrame::Plane::kV) +
-          start_xy.width(),
+          start_xy.width()).data(),
       dest_frame->stride(VideoFrame::Plane::kV), uv_size.width(),
       uv_size.height(), value_v);
 }
@@ -160,24 +162,24 @@ void FillFourColorsFrameYUV(VideoFrame& dest_frame,
 
   if (temp_frame) {
     ASSERT_EQ(libyuv::I420ToNV12(
-                  temp_frame->visible_data(VideoFrame::Plane::kY),
+                  temp_frame->visible_data(VideoFrame::Plane::kY).data(),
                   temp_frame->stride(VideoFrame::Plane::kY),
-                  temp_frame->visible_data(VideoFrame::Plane::kU),
+                  temp_frame->visible_data(VideoFrame::Plane::kU).data(),
                   temp_frame->stride(VideoFrame::Plane::kU),
-                  temp_frame->visible_data(VideoFrame::Plane::kV),
+                  temp_frame->visible_data(VideoFrame::Plane::kV).data(),
                   temp_frame->stride(VideoFrame::Plane::kV),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
                   dest_frame.stride(VideoFrame::Plane::kY),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
                   dest_frame.stride(VideoFrame::Plane::kUV),
                   dest_frame.visible_rect().width(),
                   dest_frame.visible_rect().height()),
               0);
     if (dest_frame.format() == PIXEL_FORMAT_NV12A) {
       libyuv::CopyPlane(
-          temp_frame->visible_data(VideoFrame::Plane::kA),
+          temp_frame->visible_data(VideoFrame::Plane::kA).data(),
           temp_frame->stride(VideoFrame::Plane::kA),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
           dest_frame.stride(VideoFrame::Plane::kATriPlanar),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height());
@@ -202,7 +204,7 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
 
   // Yellow top left.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB), 0, 0,
                 visible_size.width() / 2, visible_size.height() / 2, yellow),
             0);
@@ -210,14 +212,14 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
   // Red top right.
   ASSERT_EQ(
       libyuv::ARGBRect(
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
           dest_frame.stride(VideoFrame::Plane::kARGB), visible_size.width() / 2,
           0, visible_size.width() / 2, visible_size.height() / 2, red),
       0);
 
   // Blue bottom left.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB), 0,
                 visible_size.height() / 2, visible_size.width() / 2,
                 visible_size.height() / 2, blue),
@@ -225,7 +227,7 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
 
   // Green bottom right.
   ASSERT_EQ(libyuv::ARGBRect(
-                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                 dest_frame.stride(VideoFrame::Plane::kARGB),
                 visible_size.width() / 2, visible_size.height() / 2,
                 visible_size.width() / 2, visible_size.height() / 2, green),
@@ -234,9 +236,9 @@ void FillFourColorsFrameARGB(VideoFrame& dest_frame,
   if (dest_frame.format() == PIXEL_FORMAT_XBGR ||
       dest_frame.format() == PIXEL_FORMAT_ABGR) {
     ASSERT_EQ(libyuv::ARGBToABGR(
-                  dest_frame.visible_data(VideoFrame::Plane::kARGB),
+                  dest_frame.visible_data(VideoFrame::Plane::kARGB).data(),
                   dest_frame.stride(VideoFrame::Plane::kARGB),
-                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+                  dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
                   dest_frame.stride(VideoFrame::Plane::kARGB),
                   visible_size.width(), visible_size.height()),
               0);
diff --git a/media/base/video_frame.cc b/media/base/video_frame.cc
index 8b70bb8ae5596..ecf9ebad8ddbb 100644
--- a/media/base/video_frame.cc
+++ b/media/base/video_frame.cc
@@ -17,6 +17,7 @@
 #include <string_view>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -1560,12 +1561,12 @@ base::span<uint8_t> VideoFrame::GetWritableVisiblePlaneData(size_t plane) {
   return GetVisibleDataInternal(non_const_span, plane);
 }
 
-const uint8_t* VideoFrame::visible_data(size_t plane) const {
-  return GetVisiblePlaneData(plane).data();
+const base::span<uint8_t> VideoFrame::visible_data(size_t plane) const {
+  return GetVisiblePlaneData(plane);
 }
 
-uint8_t* VideoFrame::GetWritableVisibleData(size_t plane) {
-  return GetWritableVisiblePlaneData(plane).data();
+base::span<uint8_t> VideoFrame::GetWritableVisibleData(size_t plane) {
+  return GetWritableVisiblePlaneData(plane);
 }
 
 gpu::SyncToken VideoFrame::acquire_sync_token() const {
@@ -1993,7 +1994,7 @@ VideoFrame::ScopedMapping::~ScopedMapping() {
   }
 }
 
-uint8_t* VideoFrame::ScopedMapping::Memory(uint32_t plane_index) {
+base::span<uint8_t> VideoFrame::ScopedMapping::Memory(uint32_t plane_index) {
   return static_cast<uint8_t*>(
       gpu_memory_buffer_
           ? gpu_memory_buffer_->memory(plane_index)
diff --git a/media/base/video_frame.h b/media/base/video_frame.h
index a9c22c0aece8d..dce8e8dccb5eb 100644
--- a/media/base/video_frame.h
+++ b/media/base/video_frame.h
@@ -127,7 +127,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     ~ScopedMapping();
 
     // Returns a pointer to the beginning of the plane.
-    uint8_t* Memory(uint32_t plane_index);
+    base::span<uint8_t> Memory(uint32_t plane_index);
 
     // Returns plane stride.
     size_t Stride(uint32_t plane_index);
@@ -684,12 +684,12 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // Returns pointer to the buffer for a given plane, if this is an
   // IsMappable() frame type. The memory is owned by VideoFrame object and must
   // not be freed by the caller.
-  const uint8_t* data(size_t plane) const {
+  const base::span<uint8_t> data(size_t plane) const {
     auto span = data_span(plane);
     if (span.empty()) [[unlikely]] {
-      return nullptr;
+      return {};
     }
-    return span.data();
+    return span;
   }
 
   base::span<const uint8_t> data_span(size_t plane) const {
@@ -698,7 +698,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     return data_[plane];
   }
 
-  uint8_t* writable_data(size_t plane) {
+  base::span<uint8_t> writable_data(size_t plane) {
     // TODO(crbug.com/40265179): Also CHECK that the storage type isn't
     // STORAGE_UNOWNED_MEMORY once non-compliant usages are fixed.
     CHECK_NE(storage_type_, STORAGE_SHMEM);
@@ -715,8 +715,8 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // IsMappable() storage types. The returned pointer is offset into the
   // plane buffer specified by visible_rect().origin(). Memory is owned by
   // VideoFrame object and must not be freed by the caller.
-  const uint8_t* visible_data(size_t plane) const;
-  uint8_t* GetWritableVisibleData(size_t plane);
+  const base::span<uint8_t> visible_data(size_t plane) const;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane);
 
   // Returns spans of data in the visible region of the frame, for
   // IsMappable() storage types. The returned span is offset into the
diff --git a/media/base/video_frame_converter.cc b/media/base/video_frame_converter.cc
index f1dea1d1f55ad..3ed070ec1e17d 100644
--- a/media/base/video_frame_converter.cc
+++ b/media/base/video_frame_converter.cc
@@ -35,7 +35,7 @@ scoped_refptr<VideoFrame> WrapTempFrameForABGRToARGB(
   return VideoFrame::WrapExternalData(
       override_format, tmp_frame->coded_size(), tmp_frame->visible_rect(),
       tmp_frame->natural_size(),
-      tmp_frame->writable_data(VideoFrame::Plane::kARGB),
+      tmp_frame->writable_data(VideoFrame::Plane::kARGB).data(),
       VideoFrame::AllocationSize(override_format, tmp_frame->coded_size()),
       tmp_frame->timestamp());
 }
diff --git a/media/base/video_frame_converter_internals.cc b/media/base/video_frame_converter_internals.cc
index ab17fde3fab0e..a9718c4bde2ec 100644
--- a/media/base/video_frame_converter_internals.cc
+++ b/media/base/video_frame_converter_internals.cc
@@ -24,11 +24,11 @@ bool ARGBScale(const VideoFrame& src_frame,
                libyuv::FilterMode filter) {
   DCHECK(IsSupportedRGBFormat(src_frame.format()));
   return libyuv::ARGBScale(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
              src_frame.visible_rect().width(),
              src_frame.visible_rect().height(),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
              dest_frame.stride(VideoFrame::Plane::kARGB),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height(), filter) == 0;
@@ -58,9 +58,9 @@ bool ARGBToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
              dest_frame.stride(VideoFrame::Plane::kA),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -73,13 +73,13 @@ bool ARGBToI444x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   DCHECK(dest_frame.format() == PIXEL_FORMAT_I444 ||
          dest_frame.format() == PIXEL_FORMAT_I444A);
   if (libyuv::ARGBToI444(
-          src_frame.visible_data(VideoFrame::Plane::kARGB),
+          src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
           src_frame.stride(VideoFrame::Plane::kARGB),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
           dest_frame.stride(VideoFrame::Plane::kU),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
           dest_frame.stride(VideoFrame::Plane::kV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -89,9 +89,9 @@ bool ARGBToI444x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
              dest_frame.stride(VideoFrame::Plane::kA),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -120,9 +120,9 @@ bool ARGBToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   return libyuv::ARGBExtractAlpha(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
              dest_frame.stride(VideoFrame::Plane::kATriPlanar),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -135,9 +135,9 @@ bool ABGRToARGB(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_XRGB);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   return libyuv::ABGRToARGB(
-             src_frame.visible_data(VideoFrame::Plane::kARGB),
+             src_frame.visible_data(VideoFrame::Plane::kARGB).data(),
              src_frame.stride(VideoFrame::Plane::kARGB),
-             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB),
+             dest_frame.GetWritableVisibleData(VideoFrame::Plane::kARGB).data(),
              dest_frame.stride(VideoFrame::Plane::kARGB),
              dest_frame.visible_rect().width(),
              dest_frame.visible_rect().height()) == 0;
@@ -168,12 +168,12 @@ void I4xxxScale(const VideoFrame& src_frame, VideoFrame& dest_frame) {
 
   for (size_t i = 0; i < VideoFrame::NumPlanes(dest_frame.format()); ++i) {
     libyuv::ScalePlane(
-        src_frame.visible_data(i), src_frame.stride(i),
+        src_frame.visible_data(i).data(), src_frame.stride(i),
         VideoFrame::Columns(i, src_frame.format(),
                             src_frame.visible_rect().size().width()),
         VideoFrame::Rows(i, src_frame.format(),
                          src_frame.visible_rect().size().height()),
-        dest_frame.GetWritableVisibleData(i), dest_frame.stride(i),
+        dest_frame.GetWritableVisibleData(i).data(), dest_frame.stride(i),
         VideoFrame::Columns(i, dest_frame.format(),
                             dest_frame.visible_rect().size().width()),
         VideoFrame::Rows(i, dest_frame.format(),
@@ -189,15 +189,15 @@ bool I420xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::I420ToNV12(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kU),
+          src_frame.visible_data(VideoFrame::Plane::kU).data(),
           src_frame.stride(VideoFrame::Plane::kU),
-          src_frame.visible_data(VideoFrame::Plane::kV),
+          src_frame.visible_data(VideoFrame::Plane::kV).data(),
           src_frame.stride(VideoFrame::Plane::kV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -207,9 +207,9 @@ bool I420xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   libyuv::CopyPlane(
-      src_frame.visible_data(VideoFrame::Plane::kA),
+      src_frame.visible_data(VideoFrame::Plane::kA).data(),
       src_frame.stride(VideoFrame::Plane::kA),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height());
   return true;
@@ -222,15 +222,15 @@ bool I444xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::I444ToNV12(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kU),
+          src_frame.visible_data(VideoFrame::Plane::kU).data(),
           src_frame.stride(VideoFrame::Plane::kU),
-          src_frame.visible_data(VideoFrame::Plane::kV),
+          src_frame.visible_data(VideoFrame::Plane::kV).data(),
           src_frame.stride(VideoFrame::Plane::kV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -240,9 +240,9 @@ bool I444xToNV12x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
     return true;
   }
   libyuv::CopyPlane(
-      src_frame.visible_data(VideoFrame::Plane::kA),
+      src_frame.visible_data(VideoFrame::Plane::kA).data(),
       src_frame.stride(VideoFrame::Plane::kA),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height());
   return true;
@@ -255,11 +255,11 @@ void MergeUV(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   libyuv::MergeUVPlane(
-      src_frame.visible_data(VideoFrame::Plane::kU),
+      src_frame.visible_data(VideoFrame::Plane::kU).data(),
       src_frame.stride(VideoFrame::Plane::kU),
-      src_frame.visible_data(VideoFrame::Plane::kV),
+      src_frame.visible_data(VideoFrame::Plane::kV).data(),
       src_frame.stride(VideoFrame::Plane::kV),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
       dest_frame.stride(VideoFrame::Plane::kUV),
       dest_frame.visible_rect().width() / 2,
       dest_frame.visible_rect().height() / 2);
@@ -271,11 +271,11 @@ void SplitUV(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   DCHECK(dest_frame.format() == PIXEL_FORMAT_I420 ||
          dest_frame.format() == PIXEL_FORMAT_I420A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
-  libyuv::SplitUVPlane(src_frame.visible_data(VideoFrame::Plane::kUV),
+  libyuv::SplitUVPlane(src_frame.visible_data(VideoFrame::Plane::kUV).data(),
                        src_frame.stride(VideoFrame::Plane::kUV),
-                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
                        dest_frame.stride(VideoFrame::Plane::kU),
-                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+                       dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
                        dest_frame.stride(VideoFrame::Plane::kV),
                        dest_frame.visible_rect().width() / 2,
                        dest_frame.visible_rect().height() / 2);
@@ -289,14 +289,14 @@ bool NV12xScale(const VideoFrame& src_frame,
   DCHECK(dest_frame.format() == PIXEL_FORMAT_NV12 ||
          dest_frame.format() == PIXEL_FORMAT_NV12A);
   if (libyuv::NV12Scale(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kUV),
+          src_frame.visible_data(VideoFrame::Plane::kUV).data(),
           src_frame.stride(VideoFrame::Plane::kUV),
           src_frame.visible_rect().width(), src_frame.visible_rect().height(),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
           dest_frame.stride(VideoFrame::Plane::kUV),
           dest_frame.visible_rect().width(), dest_frame.visible_rect().height(),
           filter) != 0) {
@@ -306,10 +306,10 @@ bool NV12xScale(const VideoFrame& src_frame,
     return true;
   }
   libyuv::ScalePlane(
-      src_frame.visible_data(VideoFrame::Plane::kATriPlanar),
+      src_frame.visible_data(VideoFrame::Plane::kATriPlanar).data(),
       src_frame.stride(VideoFrame::Plane::kATriPlanar),
       src_frame.visible_rect().width(), src_frame.visible_rect().height(),
-      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar),
+      dest_frame.GetWritableVisibleData(VideoFrame::Plane::kATriPlanar).data(),
       dest_frame.stride(VideoFrame::Plane::kATriPlanar),
       dest_frame.visible_rect().width(), dest_frame.visible_rect().height(),
       filter);
@@ -323,15 +323,15 @@ bool NV12xToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
          dest_frame.format() == PIXEL_FORMAT_I420A);
   DCHECK_EQ(src_frame.visible_rect().size(), dest_frame.visible_rect().size());
   if (libyuv::NV12ToI420(
-          src_frame.visible_data(VideoFrame::Plane::kY),
+          src_frame.visible_data(VideoFrame::Plane::kY).data(),
           src_frame.stride(VideoFrame::Plane::kY),
-          src_frame.visible_data(VideoFrame::Plane::kUV),
+          src_frame.visible_data(VideoFrame::Plane::kUV).data(),
           src_frame.stride(VideoFrame::Plane::kUV),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kY).data(),
           dest_frame.stride(VideoFrame::Plane::kY),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kU).data(),
           dest_frame.stride(VideoFrame::Plane::kU),
-          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV),
+          dest_frame.GetWritableVisibleData(VideoFrame::Plane::kV).data(),
           dest_frame.stride(VideoFrame::Plane::kV),
           dest_frame.visible_rect().width(),
           dest_frame.visible_rect().height()) != 0) {
@@ -340,9 +340,9 @@ bool NV12xToI420x(const VideoFrame& src_frame, VideoFrame& dest_frame) {
   if (dest_frame.format() == PIXEL_FORMAT_I420) {
     return true;
   }
-  libyuv::CopyPlane(src_frame.visible_data(VideoFrame::Plane::kATriPlanar),
+  libyuv::CopyPlane(src_frame.visible_data(VideoFrame::Plane::kATriPlanar).data(),
                     src_frame.stride(VideoFrame::Plane::kATriPlanar),
-                    dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA),
+                    dest_frame.GetWritableVisibleData(VideoFrame::Plane::kA).data(),
                     dest_frame.stride(VideoFrame::Plane::kA),
                     dest_frame.visible_rect().width(),
                     dest_frame.visible_rect().height());
diff --git a/media/base/video_frame_converter_unittest.cc b/media/base/video_frame_converter_unittest.cc
index ce97e02ac8679..ac5df3bdc40e4 100644
--- a/media/base/video_frame_converter_unittest.cc
+++ b/media/base/video_frame_converter_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -94,7 +96,7 @@ bool IsConversionSupported(VideoPixelFormat src, VideoPixelFormat dest) {
     auto plane_size =
         VideoFrame::PlaneSize(frame.format(), i, frame.visible_rect().size());
     for (int y = 0; y < plane_size.height(); ++y) {
-      fwrite(frame.visible_data(i) + y * frame.stride(i), 1, plane_size.width(),
+      fwrite(frame.visible_data(i) .subspan( y * frame.stride(i)).data(), 1, plane_size.width(),
              f);
     }
   }
@@ -160,12 +162,12 @@ TEST_P(VideoFrameConverterTest, ConvertAndScale) {
     auto plane_size = VideoFrame::PlaneSize(expected_dest_frame->format(), i,
                                             dest_visible_size);
     auto ssim = libyuv::CalcFrameSsim(
-        dest_frame->visible_data(i), dest_frame->stride(i),
-        expected_dest_frame->visible_data(i), expected_dest_frame->stride(i),
+        dest_frame->visible_data(i).data(), dest_frame->stride(i),
+        expected_dest_frame->visible_data(i).data(), expected_dest_frame->stride(i),
         plane_size.width(), plane_size.height());
     auto psnr = libyuv::CalcFramePsnr(
-        dest_frame->visible_data(i), dest_frame->stride(i),
-        expected_dest_frame->visible_data(i), expected_dest_frame->stride(i),
+        dest_frame->visible_data(i).data(), dest_frame->stride(i),
+        expected_dest_frame->visible_data(i).data(), expected_dest_frame->stride(i),
         plane_size.width(), plane_size.height());
     EXPECT_DOUBLE_EQ(ssim, 1.0);
     EXPECT_EQ(psnr, libyuv::kMaxPsnr);
diff --git a/media/base/video_frame_pool_unittest.cc b/media/base/video_frame_pool_unittest.cc
index bf580169d0960..7298cc6dd425d 100644
--- a/media/base/video_frame_pool_unittest.cc
+++ b/media/base/video_frame_pool_unittest.cc
@@ -75,7 +75,7 @@ TEST_P(VideoFramePoolTest, FrameInitializedAndZeroed) {
 TEST_P(VideoFramePoolTest, FrameReuse) {
   scoped_refptr<VideoFrame> frame =
       CreateFrame(std::get<0>(GetParam()), std::get<1>(GetParam()), 10);
-  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY);
+  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY).data();
 
   // Clear frame reference to return the frame to the pool.
   frame.reset();
@@ -83,7 +83,7 @@ TEST_P(VideoFramePoolTest, FrameReuse) {
   // Verify that the next frame from the pool uses the same memory.
   scoped_refptr<VideoFrame> new_frame =
       CreateFrame(std::get<0>(GetParam()), std::get<1>(GetParam()), 20);
-  EXPECT_EQ(old_y_data, new_frame->data(VideoFrame::Plane::kY));
+  EXPECT_EQ(old_y_data, new_frame->data(VideoFrame::Plane::kY).data());
 }
 
 INSTANTIATE_TEST_SUITE_P(All,
@@ -126,7 +126,7 @@ TEST_F(VideoFramePoolTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(frame->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(frame->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          frame->rows(VideoFrame::Plane::kY) *
              frame->stride(VideoFrame::Plane::kY));
 }
diff --git a/media/base/video_frame_unittest.cc b/media/base/video_frame_unittest.cc
index 8af9ae75baa43..868c1a392a677 100644
--- a/media/base/video_frame_unittest.cc
+++ b/media/base/video_frame_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -160,19 +162,19 @@ void InitializeYV12Frame(VideoFrame* frame, double white_to_black) {
   EXPECT_EQ(PIXEL_FORMAT_YV12, frame->format());
   const int first_black_row =
       static_cast<int>(frame->coded_size().height() * white_to_black);
-  uint8_t* y_plane = frame->writable_data(VideoFrame::Plane::kY);
+  base::span<uint8_t>y_plane = frame->writable_data(VideoFrame::Plane::kY);
   for (int row = 0; row < frame->coded_size().height(); ++row) {
     int color = (row < first_black_row) ? 0xFF : 0x00;
-    memset(y_plane, color, frame->stride(VideoFrame::Plane::kY));
-    y_plane += frame->stride(VideoFrame::Plane::kY);
+    memset(y_plane.data(), color, frame->stride(VideoFrame::Plane::kY));
+    y_plane=y_plane.subspan(frame->stride(VideoFrame::Plane::kY));
   }
-  uint8_t* u_plane = frame->writable_data(VideoFrame::Plane::kU);
-  uint8_t* v_plane = frame->writable_data(VideoFrame::Plane::kV);
+  base::span<uint8_t>u_plane = frame->writable_data(VideoFrame::Plane::kU);
+  base::span<uint8_t>v_plane = frame->writable_data(VideoFrame::Plane::kV);
   for (int row = 0; row < frame->coded_size().height(); row += 2) {
-    memset(u_plane, 0x80, frame->stride(VideoFrame::Plane::kU));
-    memset(v_plane, 0x80, frame->stride(VideoFrame::Plane::kV));
-    u_plane += frame->stride(VideoFrame::Plane::kU);
-    v_plane += frame->stride(VideoFrame::Plane::kV);
+    memset(u_plane.data(), 0x80, frame->stride(VideoFrame::Plane::kU));
+    memset(v_plane.data(), 0x80, frame->stride(VideoFrame::Plane::kV));
+    u_plane=u_plane.subspan(frame->stride(VideoFrame::Plane::kU));
+    v_plane=v_plane.subspan(frame->stride(VideoFrame::Plane::kV));
   }
 }
 
@@ -195,11 +197,11 @@ void ExpectFrameColor(VideoFrame* yv12_frame, uint32_t expect_rgb_color) {
                              VideoFrame::kFrameSizePadding,
                          VideoFrame::kFrameAddressAlignment));
 
-  libyuv::I420ToARGB(yv12_frame->data(VideoFrame::Plane::kY),
+  libyuv::I420ToARGB(yv12_frame->data(VideoFrame::Plane::kY).data(),
                      yv12_frame->stride(VideoFrame::Plane::kY),
-                     yv12_frame->data(VideoFrame::Plane::kU),
+                     yv12_frame->data(VideoFrame::Plane::kU).data(),
                      yv12_frame->stride(VideoFrame::Plane::kU),
-                     yv12_frame->data(VideoFrame::Plane::kV),
+                     yv12_frame->data(VideoFrame::Plane::kV).data(),
                      yv12_frame->stride(VideoFrame::Plane::kV), rgb_data,
                      bytes_per_row, yv12_frame->coded_size().width(),
                      yv12_frame->coded_size().height());
@@ -233,13 +235,13 @@ void ExpectFrameExtents(VideoPixelFormat format, const char* expected_hash) {
   int planes = VideoFrame::NumPlanes(format);
   for (int plane = 0; plane < planes; plane++) {
     SCOPED_TRACE(base::StringPrintf("Checking plane %d", plane));
-    EXPECT_TRUE(frame->data(plane));
+    EXPECT_TRUE(frame->data(plane).data());
     EXPECT_TRUE(frame->stride(plane));
     EXPECT_TRUE(frame->rows(plane));
     EXPECT_TRUE(frame->row_bytes(plane));
     EXPECT_TRUE(frame->columns(plane));
 
-    memset(frame->writable_data(plane), kFillByte,
+    memset(frame->writable_data(plane).data(), kFillByte,
            frame->stride(plane) * frame->rows(plane));
   }
 
@@ -347,19 +349,19 @@ TEST(VideoFrame, CreateBlackFrame) {
   EXPECT_EQ(kHeight, frame->coded_size().height());
 
   // Test frames themselves.
-  uint8_t* y_plane = frame->writable_data(VideoFrame::Plane::kY);
+  base::span<uint8_t>y_plane = frame->writable_data(VideoFrame::Plane::kY);
   for (int y = 0; y < frame->coded_size().height(); ++y) {
-    EXPECT_EQ(0, memcmp(kExpectedYRow, y_plane, std::size(kExpectedYRow)));
-    y_plane += frame->stride(VideoFrame::Plane::kY);
+    EXPECT_EQ(0, memcmp(kExpectedYRow, y_plane.data(), std::size(kExpectedYRow)));
+    y_plane=y_plane.subspan(frame->stride(VideoFrame::Plane::kY));
   }
 
-  uint8_t* u_plane = frame->writable_data(VideoFrame::Plane::kU);
-  uint8_t* v_plane = frame->writable_data(VideoFrame::Plane::kV);
+  base::span<uint8_t>u_plane = frame->writable_data(VideoFrame::Plane::kU);
+  base::span<uint8_t>v_plane = frame->writable_data(VideoFrame::Plane::kV);
   for (int y = 0; y < frame->coded_size().height() / 2; ++y) {
-    EXPECT_EQ(0, memcmp(kExpectedUVRow, u_plane, std::size(kExpectedUVRow)));
-    EXPECT_EQ(0, memcmp(kExpectedUVRow, v_plane, std::size(kExpectedUVRow)));
-    u_plane += frame->stride(VideoFrame::Plane::kU);
-    v_plane += frame->stride(VideoFrame::Plane::kV);
+    EXPECT_EQ(0, memcmp(kExpectedUVRow, u_plane.data(), std::size(kExpectedUVRow)));
+    EXPECT_EQ(0, memcmp(kExpectedUVRow, v_plane.data(), std::size(kExpectedUVRow)));
+    u_plane=u_plane.subspan(frame->stride(VideoFrame::Plane::kU));
+    v_plane=v_plane.subspan(frame->stride(VideoFrame::Plane::kV));
   }
 }
 
@@ -420,8 +422,8 @@ TEST(VideoFrame, WrapVideoFrame) {
         &FrameNoLongerNeededCallback, &base_frame_done_callback_was_run));
     ASSERT_TRUE(frame);
     EXPECT_EQ(base_frame->coded_size(), frame->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame->visible_rect());
     EXPECT_EQ(visible_rect, frame->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame->natural_size());
@@ -444,8 +446,8 @@ TEST(VideoFrame, WrapVideoFrame) {
                                         natural_size);
     ASSERT_TRUE(frame2);
     EXPECT_EQ(base_frame->coded_size(), frame2->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame2->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame2->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame2->visible_rect());
     EXPECT_EQ(visible_rect, frame2->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame2->natural_size());
@@ -464,8 +466,8 @@ TEST(VideoFrame, WrapVideoFrame) {
                                              larger_visible_rect.size());
     ASSERT_TRUE(frame3);
     EXPECT_EQ(base_frame->coded_size(), frame3->coded_size());
-    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY),
-              frame3->data(VideoFrame::Plane::kY));
+    EXPECT_EQ(base_frame->data(VideoFrame::Plane::kY).data(),
+              frame3->data(VideoFrame::Plane::kY).data());
     EXPECT_NE(base_frame->visible_rect(), frame3->visible_rect());
     EXPECT_EQ(larger_visible_rect, frame3->visible_rect());
     EXPECT_NE(base_frame->natural_size(), frame3->natural_size());
@@ -1028,12 +1030,12 @@ TEST(VideoFrame, WrappedPlaneDataAccess) {
       /* U plane */ base::span(u_pixels.data(), 0u),
       /* V plane */ v_pixels, timestamp);
 
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kY), y_pixels.data());
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kY).data(), y_pixels.data());
   EXPECT_EQ(frame->data_span(VideoFrame::Plane::kY).data(), y_pixels.data());
   EXPECT_EQ(frame->data_span(VideoFrame::Plane::kY).size(), y_pixels.size());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU), nullptr);
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(), nullptr);
   EXPECT_TRUE(frame->data_span(VideoFrame::Plane::kU).empty());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kV), nullptr);
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kV).data(), nullptr);
   EXPECT_TRUE(frame->data_span(VideoFrame::Plane::kV).empty());
 }
 }  // namespace media
diff --git a/media/base/video_util.cc b/media/base/video_util.cc
index 7c54d9bbcf719..b1331ac4d497b 100644
--- a/media/base/video_util.cc
+++ b/media/base/video_util.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -46,30 +48,30 @@ namespace {
 
 // Helper to apply padding to the region outside visible rect up to the coded
 // size with the repeated last column / row of the visible rect.
-void FillRegionOutsideVisibleRect(uint8_t* data,
+void FillRegionOutsideVisibleRect(base::span<uint8_t>data,
                                   size_t stride,
                                   const gfx::Size& coded_size,
                                   const gfx::Size& visible_size) {
   if (visible_size.IsEmpty()) {
     if (!coded_size.IsEmpty())
-      memset(data, 0, coded_size.height() * stride);
+      memset(data.data(), 0, coded_size.height() * stride);
     return;
   }
 
   const int coded_width = coded_size.width();
   if (visible_size.width() < coded_width) {
     const int pad_length = coded_width - visible_size.width();
-    uint8_t* dst = data + visible_size.width();
-    for (int i = 0; i < visible_size.height(); ++i, dst += stride)
-      memset(dst, *(dst - 1), pad_length);
+    base::span<uint8_t>dst = data .subspan( visible_size.width());
+    for (int i = 0; i < visible_size.height(); ++i, dst=dst.subspan(stride))
+      memset(dst.data(), *(dst - 1), pad_length);
   }
 
   if (visible_size.height() < coded_size.height()) {
-    uint8_t* dst = data + visible_size.height() * stride;
+    base::span<uint8_t>dst = data .subspan( visible_size.height() * stride);
     uint8_t* src = dst - stride;
     for (int i = visible_size.height(); i < coded_size.height();
-         ++i, dst += stride)
-      memcpy(dst, src, coded_width);
+         ++i, dst=dst.subspan(stride))
+      memcpy(dst.data(), src, coded_width);
   }
 }
 
@@ -104,45 +106,45 @@ VideoPixelFormat ReadbackFormat(const VideoFrame& frame) {
 }
 
 void LetterboxPlane(const gfx::Rect& view_area_in_bytes,
-                    uint8_t* ptr,
+                    base::span<uint8_t>ptr,
                     int rows,
                     int row_bytes,
                     int stride,
                     int bytes_per_element,
                     uint8_t fill_byte) {
   if (view_area_in_bytes.IsEmpty()) {
-    libyuv::SetPlane(ptr, stride, row_bytes, rows, fill_byte);
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, rows, fill_byte);
     return;
   }
 
   if (view_area_in_bytes.y() > 0) {
-    libyuv::SetPlane(ptr, stride, row_bytes, view_area_in_bytes.y(), fill_byte);
-    ptr += stride * view_area_in_bytes.y();
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, view_area_in_bytes.y(), fill_byte);
+    ptr=ptr.subspan(stride * view_area_in_bytes.y());
   }
 
   if (view_area_in_bytes.width() < row_bytes) {
     if (view_area_in_bytes.x() > 0) {
-      libyuv::SetPlane(ptr, stride, view_area_in_bytes.x(),
+      libyuv::SetPlane(ptr.data(), stride, view_area_in_bytes.x(),
                        view_area_in_bytes.height(), fill_byte);
     }
     if (view_area_in_bytes.right() < row_bytes) {
-      libyuv::SetPlane(ptr + view_area_in_bytes.right(), stride,
+      libyuv::SetPlane(ptr .subspan( view_area_in_bytes.right()).data(), stride,
                        row_bytes - view_area_in_bytes.right(),
                        view_area_in_bytes.height(), fill_byte);
     }
   }
 
-  ptr += stride * view_area_in_bytes.height();
+  ptr=ptr.subspan(stride * view_area_in_bytes.height());
 
   if (view_area_in_bytes.bottom() < rows) {
-    libyuv::SetPlane(ptr, stride, row_bytes, rows - view_area_in_bytes.bottom(),
+    libyuv::SetPlane(ptr.data(), stride, row_bytes, rows - view_area_in_bytes.bottom(),
                      fill_byte);
   }
 }
 
 void LetterboxPlane(VideoFrame* frame,
                     int plane,
-                    uint8_t* ptr,
+                    base::span<uint8_t>ptr,
                     const gfx::Rect& view_area_in_pixels,
                     uint8_t fill_byte) {
   const int rows = frame->rows(plane);
@@ -173,13 +175,13 @@ void LetterboxPlane(VideoFrame* frame,
                     int plane,
                     const gfx::Rect& view_area_in_pixels,
                     uint8_t fill_byte) {
-  uint8_t* ptr = nullptr;
+  base::span<uint8_t>ptr = {};
   if (frame->IsMappable()) {
     ptr = frame->writable_data(plane);
   } else if (scoped_mapping) {
     ptr = scoped_mapping->Memory(plane);
   }
-  CHECK(ptr);
+  CHECK(!ptr.empty());
 
   LetterboxPlane(frame, plane, ptr, view_area_in_pixels, fill_byte);
 }
@@ -230,11 +232,11 @@ void ProcessAsyncMappingResult(
 }  // namespace
 
 void FillYUV(VideoFrame* frame, uint8_t y, uint8_t u, uint8_t v) {
-  libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+  libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                    frame->stride(VideoFrame::Plane::kY),
-                   frame->writable_data(VideoFrame::Plane::kU),
+                   frame->writable_data(VideoFrame::Plane::kU).data(),
                    frame->stride(VideoFrame::Plane::kU),
-                   frame->writable_data(VideoFrame::Plane::kV),
+                   frame->writable_data(VideoFrame::Plane::kV).data(),
                    frame->stride(VideoFrame::Plane::kV), 0, 0,
                    frame->coded_size().width(), frame->coded_size().height(), y,
                    u, v);
@@ -245,7 +247,7 @@ void FillYUVA(VideoFrame* frame, uint8_t y, uint8_t u, uint8_t v, uint8_t a) {
   FillYUV(frame, y, u, v);
 
   // Fill the A plane.
-  libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA),
+  libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA).data(),
                    frame->stride(VideoFrame::Plane::kA),
                    frame->row_bytes(VideoFrame::Plane::kA),
                    frame->rows(VideoFrame::Plane::kA), a);
@@ -628,17 +630,17 @@ bool I420CopyWithPadding(const VideoFrame& src_frame, VideoFrame* dst_frame) {
             src_frame.visible_rect().height());
   DCHECK(dst_frame->visible_rect().origin().IsOrigin());
 
-  if (libyuv::I420Copy(src_frame.visible_data(VideoFrame::Plane::kY),
+  if (libyuv::I420Copy(src_frame.visible_data(VideoFrame::Plane::kY).data(),
                        src_frame.stride(VideoFrame::Plane::kY),
-                       src_frame.visible_data(VideoFrame::Plane::kU),
+                       src_frame.visible_data(VideoFrame::Plane::kU).data(),
                        src_frame.stride(VideoFrame::Plane::kU),
-                       src_frame.visible_data(VideoFrame::Plane::kV),
+                       src_frame.visible_data(VideoFrame::Plane::kV).data(),
                        src_frame.stride(VideoFrame::Plane::kV),
-                       dst_frame->writable_data(VideoFrame::Plane::kY),
+                       dst_frame->writable_data(VideoFrame::Plane::kY).data(),
                        dst_frame->stride(VideoFrame::Plane::kY),
-                       dst_frame->writable_data(VideoFrame::Plane::kU),
+                       dst_frame->writable_data(VideoFrame::Plane::kU).data(),
                        dst_frame->stride(VideoFrame::Plane::kU),
-                       dst_frame->writable_data(VideoFrame::Plane::kV),
+                       dst_frame->writable_data(VideoFrame::Plane::kV).data(),
                        dst_frame->stride(VideoFrame::Plane::kV),
                        src_frame.visible_rect().width(),
                        src_frame.visible_rect().height())) {
@@ -703,7 +705,7 @@ scoped_refptr<VideoFrame> ReadbackTextureBackedFrameToMemorySync(
   for (size_t plane = 0; plane < planes; plane++) {
     gfx::Rect src_rect(0, 0, txt_frame.columns(plane), txt_frame.rows(plane));
     if (!ReadbackTexturePlaneToMemorySync(txt_frame, plane, src_rect,
-                                          result->writable_data(plane),
+                                          result->writable_data(plane).data(),
                                           result->stride(plane), ri)) {
       return nullptr;
     }
diff --git a/media/base/video_util_unittest.cc b/media/base/video_util_unittest.cc
index 57824d9a06740..3854a220c851e 100644
--- a/media/base/video_util_unittest.cc
+++ b/media/base/video_util_unittest.cc
@@ -25,14 +25,14 @@
 namespace {
 
 // Initialize a plane's visible rect with value circularly from 0 to 255.
-void FillPlaneWithPattern(uint8_t* data,
+void FillPlaneWithPattern(base::span<uint8_t>data,
                           int stride,
                           const gfx::Size& visible_size) {
-  DCHECK(data && visible_size.width() <= stride);
+  DCHECK(!data.empty() && visible_size.width() <= stride);
 
   uint32_t val = 0;
-  uint8_t* src = data;
-  for (int i = 0; i < visible_size.height(); ++i, src += stride) {
+  base::span<uint8_t>src = data;
+  for (int i = 0; i < visible_size.height(); ++i, src=src.subspan(stride)) {
     for (int j = 0; j < visible_size.width(); ++j, ++val)
       src[j] = val & 0xff;
   }
@@ -70,15 +70,15 @@ scoped_refptr<media::VideoFrame> CreateFrameWithPatternFilled(
 
 // Helper function used to verify the data in the coded region after copying the
 // visible region and padding the remaining area.
-bool VerifyPlanCopyWithPadding(const uint8_t* src,
+bool VerifyPlanCopyWithPadding(base::span<const uint8_t>src,
                                size_t src_stride,
                                // Size of visible region.
                                const gfx::Size& src_size,
-                               const uint8_t* dst,
+                               base::span<const uint8_t>dst,
                                size_t dst_stride,
                                // Coded size of |dst|.
                                const gfx::Size& dst_size) {
-  if (!src || !dst)
+  if (src.empty() || dst.empty())
     return false;
 
   const size_t src_width = src_size.width();
@@ -89,10 +89,10 @@ bool VerifyPlanCopyWithPadding(const uint8_t* src,
       src_height > dst_height || src_size.IsEmpty() || dst_size.IsEmpty())
     return false;
 
-  const uint8_t *src_ptr = src, *dst_ptr = dst;
+  base::span<const uint8_t>dst_ptr = dst;
   for (size_t i = 0; i < src_height;
-       ++i, src_ptr += src_stride, dst_ptr += dst_stride) {
-    if (memcmp(src_ptr, dst_ptr, src_width))
+       ++i, src_ptr=src_ptr.subspan(src_stride), dst_ptr=dst_ptr.subspan(dst_stride)) {
+    if (memcmp(src_ptr.data(), dst_ptr.data(), src_width))
       return false;
     for (size_t j = src_width; j < dst_width; ++j) {
       if (src_ptr[src_width - 1] != dst_ptr[j])
@@ -100,8 +100,8 @@ bool VerifyPlanCopyWithPadding(const uint8_t* src,
     }
   }
   if (src_height < dst_height) {
-    src_ptr = dst + (src_height - 1) * dst_stride;
-    if (memcmp(src_ptr, dst_ptr, dst_width))
+    src_ptr = dst .subspan( (src_height - 1) * dst_stride);
+    if (memcmp(src_ptr.data(), dst_ptr.data(), dst_width))
       return false;
   }
   return true;
@@ -616,14 +616,14 @@ TEST_F(VideoUtilTest, WrapAsI420VideoFrame) {
   std::vector<size_t> planes = {VideoFrame::Plane::kY, VideoFrame::Plane::kU,
                                 VideoFrame::Plane::kV};
   for (auto plane : planes)
-    EXPECT_EQ(dst_frame->data(plane), src_frame->data(plane));
+    EXPECT_EQ(dst_frame->data(plane).data(), src_frame->data(plane).data());
 
   // Check that memory for planes is not released upon destruction of the
   // original frame pointer (new frame holds a reference). This check relies on
   // ASAN.
   src_frame.reset();
   for (auto plane : planes)
-    memset(dst_frame->writable_data(plane), 1, dst_frame->stride(plane));
+    memset(dst_frame->writable_data(plane).data(), 1, dst_frame->stride(plane));
 }
 
 }  // namespace media
diff --git a/media/capture/video/blob_utils.cc b/media/capture/video/blob_utils.cc
index c0aa5862877f7..f594432d6355e 100644
--- a/media/capture/video/blob_utils.cc
+++ b/media/capture/video/blob_utils.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -39,7 +41,7 @@ libyuv::RotationModeEnum TranslateIntegerRotationToLibyuvRotation(
   return libyuv::kRotate0;
 }
 
-mojom::BlobPtr ProduceJpegBlobFromMjpegFrame(const uint8_t* buffer,
+mojom::BlobPtr ProduceJpegBlobFromMjpegFrame(base::span<const uint8_t>buffer,
                                              const uint32_t bytesused,
                                              const gfx::Size size,
                                              const int rotation) {
@@ -57,7 +59,7 @@ mojom::BlobPtr ProduceJpegBlobFromMjpegFrame(const uint8_t* buffer,
     std::vector<uint8_t> bgra_buffer(output_width * output_height *
                                      bytes_per_pixel);
     libyuv::ConvertToARGB(
-        buffer, static_cast<size_t>(bytesused), bgra_buffer.data(),
+        buffer.data(), static_cast<size_t>(bytesused), bgra_buffer.data(),
         output_width * bytes_per_pixel, /*crop_x=*/0,
         /*crop_y=*/0, size.width(), size.height(), size.width(), size.height(),
         TranslateIntegerRotationToLibyuvRotation(rotation),
@@ -82,18 +84,18 @@ mojom::BlobPtr ProduceJpegBlobFromMjpegFrame(const uint8_t* buffer,
   }
 
   mojom::BlobPtr blob = mojom::Blob::New();
-  blob->data.assign(buffer, buffer + bytesused);
+  blob->data.assign(buffer.data(), buffer .subspan( bytesused).data());
   blob->mime_type = "image/jpeg";
   return blob;
 }
 
 }  // namespace
 
-mojom::BlobPtr RotateAndBlobify(const uint8_t* buffer,
+mojom::BlobPtr RotateAndBlobify(base::span<const uint8_t>buffer,
                                 const uint32_t bytesused,
                                 const VideoCaptureFormat& capture_format,
                                 const int rotation) {
-  DCHECK(buffer);
+  DCHECK(!buffer.empty());
   DCHECK(bytesused);
   DCHECK(capture_format.IsValid());
 
@@ -131,7 +133,7 @@ mojom::BlobPtr RotateAndBlobify(const uint8_t* buffer,
   // PNGCodec does not support YUV formats, convert to a temporary ARGB buffer.
   auto tmp_argb = std::make_unique<uint8_t[]>(
       VideoFrame::AllocationSize(PIXEL_FORMAT_ARGB, frame_size));
-  if (ConvertToARGB(buffer, bytesused, tmp_argb.get(), frame_size.width() * 4,
+  if (ConvertToARGB(buffer.data(), bytesused, tmp_argb.get(), frame_size.width() * 4,
                     0 /* crop_x_pos */, 0 /* crop_y_pos */, frame_size.width(),
                     frame_size.height(), frame_size.width(),
                     frame_size.height(), libyuv::RotationMode::kRotate0,
diff --git a/media/capture/video/blob_utils.h b/media/capture/video/blob_utils.h
index 930b62d41be99..d5ea22508c777 100644
--- a/media/capture/video/blob_utils.h
+++ b/media/capture/video/blob_utils.h
@@ -5,6 +5,7 @@
 #ifndef MEDIA_CAPTURE_VIDEO_BLOB_UTILS_H_
 #define MEDIA_CAPTURE_VIDEO_BLOB_UTILS_H_
 
+#include "base/containers/span.h"
 #include "media/capture/mojom/image_capture.mojom.h"
 
 namespace media {
@@ -16,7 +17,7 @@ struct VideoCaptureFormat;
 // rotation to be applied to the frame. The value can only be 0, 90, 180 or 270.
 // It's only effective if |capture_format| is PIXEL_FORMAT_MJPEG.
 // Returns a null BlobPtr in case of error.
-mojom::BlobPtr RotateAndBlobify(const uint8_t* buffer,
+mojom::BlobPtr RotateAndBlobify(base::span<const uint8_t>buffer,
                                 const uint32_t bytesused,
                                 const VideoCaptureFormat& capture_format,
                                 const int rotation);
diff --git a/media/capture/video/file_video_capture_device.cc b/media/capture/video/file_video_capture_device.cc
index 6142cb2c999f2..684ac45fbad94 100644
--- a/media/capture/video/file_video_capture_device.cc
+++ b/media/capture/video/file_video_capture_device.cc
@@ -724,7 +724,7 @@ void FileVideoCaptureDevice::OnCaptureTask() {
     take_photo_callbacks_.pop();
 
     mojom::BlobPtr blob =
-        RotateAndBlobify(ptz_frame.data(), ptz_frame.size(), ptz_format, 0);
+        RotateAndBlobify(ptz_frame, ptz_frame.size(), ptz_format, 0);
     if (!blob)
       continue;
 
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/media/capture/video/linux/v4l2_capture_delegate.cc
index 360b7ccb7be01..d03bb76fe92e2 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
 #pragma allow_unsafe_libc_calls
@@ -183,7 +185,7 @@ class V4L2CaptureDelegate::BufferTracker
   // Abstract method to mmap() given |fd| according to |buffer|.
   bool Init(int fd, const v4l2_buffer& buffer);
 
-  const uint8_t* start() const { return start_; }
+  const base::span<uint8_t> start() const { return start_; }
   size_t payload_size() const { return payload_size_; }
   void set_payload_size(size_t payload_size) {
     DCHECK_LE(payload_size, length_);
@@ -1161,7 +1163,7 @@ void V4L2CaptureDelegate::DoCapture() {
       } else
 #endif  //  BUILDFLAG(IS_LINUX)
         client_->OnIncomingCapturedData(
-            buffer_tracker->start(), buffer_tracker->payload_size(),
+            buffer_tracker->start().data(), buffer_tracker->payload_size(),
             capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
             now, timestamp, /*capture_begin_timestamp=*/std::nullopt,
             /*metadata=*/std::nullopt);
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
index 1cbc67b9a8a3e..b5da89fdd044b 100644
--- a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -98,7 +100,7 @@ V4L2CaptureDelegateGpuHelper::~V4L2CaptureDelegateGpuHelper() = default;
 
 int V4L2CaptureDelegateGpuHelper::OnIncomingCapturedData(
     VideoCaptureDevice::Client* client,
-    const uint8_t* sample,
+    base::span<const uint8_t>sample,
     size_t sample_size,
     const VideoCaptureFormat& capture_format,
     const gfx::ColorSpace& data_color_space,
@@ -188,7 +190,7 @@ int V4L2CaptureDelegateGpuHelper::OnIncomingCapturedData(
 }
 
 int V4L2CaptureDelegateGpuHelper::ConvertCaptureDataToNV12(
-    const uint8_t* sample,
+    base::span<const uint8_t>sample,
     size_t sample_size,
     const VideoCaptureFormat& capture_format,
     const gfx::Size& dimensions,
@@ -237,7 +239,7 @@ int V4L2CaptureDelegateGpuHelper::ConvertCaptureDataToNV12(
   const int crop_width = width & ~1;
   const int crop_height = height & ~1;
   int status = libyuv::ConvertToI420(
-      sample, sample_size, i420_y, i420_stride_y, i420_u, i420_stride_u, i420_v,
+      sample.data(), sample_size, i420_y, i420_stride_y, i420_u, i420_stride_u, i420_v,
       i420_stride_v, 0, 0, width, height, crop_width, crop_height,
       rotation_mode, fourcc);
   if (status != 0) {
@@ -252,7 +254,7 @@ int V4L2CaptureDelegateGpuHelper::ConvertCaptureDataToNV12(
 }
 
 int V4L2CaptureDelegateGpuHelper::FastConvertToNV12(
-    const uint8_t* sample,
+    base::span<const uint8_t>sample,
     size_t sample_size,
     const VideoCaptureFormat& capture_format,
     uint8_t* dst_y,
@@ -261,20 +263,20 @@ int V4L2CaptureDelegateGpuHelper::FastConvertToNV12(
     int dst_stride_uv) {
   const int src_width = capture_format.frame_size.width();
   const int src_height = capture_format.frame_size.height();
-  const uint8_t* src_uv = sample + (src_width * src_height);
+  const uint8_t* src_uv = sample .subspan( (src_width * src_height).data());
 
   const libyuv::FourCC fourcc =
       VideoCaptureFormatToLibyuvFourcc(capture_format);
   switch (libyuv::CanonicalFourCC(fourcc)) {
     case libyuv::FOURCC_YUY2:
-      return libyuv::YUY2ToNV12(sample, src_width * 2, dst_y, dst_stride_y,
+      return libyuv::YUY2ToNV12(sample.data(), src_width * 2, dst_y, dst_stride_y,
                                 dst_uv, dst_stride_uv, src_width, src_height);
     case libyuv::FOURCC_MJPG:
-      return libyuv::MJPGToNV12(sample, sample_size, dst_y, dst_stride_y,
+      return libyuv::MJPGToNV12(sample.data(), sample_size, dst_y, dst_stride_y,
                                 dst_uv, dst_stride_uv, src_width, src_height,
                                 src_width, src_height);
     case libyuv::FOURCC_NV12:
-      return libyuv::NV12Copy(sample, src_width, src_uv, src_width, dst_y,
+      return libyuv::NV12Copy(sample.data(), src_width, src_uv, src_width, dst_y,
                               dst_stride_y, dst_uv, dst_stride_uv, src_width,
                               src_height);
     default:
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
index 9f15efe57dd10..53a1cd6b195be 100644
--- a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
@@ -7,6 +7,7 @@
 
 #include <vector>
 
+#include "base/containers/span.h"
 #include "media/capture/video/video_capture_device.h"
 
 namespace media {
@@ -33,7 +34,7 @@ class CAPTURE_EXPORT V4L2CaptureDelegateGpuHelper {
   // `VideoCaptureDeviceClient::OnIncomingCapturedBufferExt()`.
   // The |rotation| value should be 0, 90, 180, or 270.
   int OnIncomingCapturedData(VideoCaptureDevice::Client* client,
-                             const uint8_t* sample,
+                             base::span<const uint8_t>sample,
                              size_t sample_size,
                              const VideoCaptureFormat& format,
                              const gfx::ColorSpace& data_color_space,
@@ -43,7 +44,7 @@ class CAPTURE_EXPORT V4L2CaptureDelegateGpuHelper {
                              int frame_feedback_id = 0);
 
  private:
-  int ConvertCaptureDataToNV12(const uint8_t* sample,
+  int ConvertCaptureDataToNV12(base::span<const uint8_t>sample,
                                size_t sample_size,
                                const VideoCaptureFormat& format,
                                const gfx::Size& dimensions,
@@ -56,7 +57,7 @@ class CAPTURE_EXPORT V4L2CaptureDelegateGpuHelper {
 
   // This method directly converts the sample data into `NV12` format when the
   // input `VideoCaptureFormat` supported.
-  int FastConvertToNV12(const uint8_t* sample,
+  int FastConvertToNV12(base::span<const uint8_t>sample,
                         size_t sample_size,
                         const VideoCaptureFormat& format,
                         uint8_t* dst_y,
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper_unittest.cc b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper_unittest.cc
index ab34124b7c5d0..e947129c1e3f3 100644
--- a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper_unittest.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper_unittest.cc
@@ -190,7 +190,7 @@ TEST_F(V4l2CaptureDelegateGpuHelperTest, FailureAsInvalidClient) {
   std::unique_ptr<std::vector<uint8_t>> sample = ReadSampleData(capture_format);
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      nullptr, sample->data(), sample->size(), capture_format,
+      nullptr, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
   EXPECT_NE(status, 0);
 }
@@ -231,7 +231,7 @@ TEST_F(V4l2CaptureDelegateGpuHelperTest,
       }));
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      &client, sample->data(), sample->size(), capture_format,
+      &client, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
   EXPECT_NE(status, 0);
 }
@@ -261,7 +261,7 @@ TEST_F(V4l2CaptureDelegateGpuHelperTest, FailureAsReserveOutputBufferErr) {
       }));
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      &client, sample->data(), sample->size(), capture_format,
+      &client, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
   EXPECT_NE(status, 0);
 }
@@ -296,7 +296,7 @@ TEST_F(V4l2CaptureDelegateGpuHelperTest, FailureAsInvalidSharedImageInterface) {
       }));
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      &client, sample->data(), sample->size(), capture_format,
+      &client, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
   EXPECT_NE(status, 0);
 }
@@ -326,7 +326,7 @@ TEST_F(V4l2CaptureDelegateGpuHelperTest, SuccessRotationIsNotZero) {
       .WillRepeatedly(InvokeWithoutArgs([]() {}));
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      &client, sample->data(), sample->size(), capture_format,
+      &client, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
 
   EXPECT_EQ(status, 0);
@@ -357,7 +357,7 @@ TEST_P(V4l2CaptureDelegateGpuHelperTest, SuccessConvertWithCaptureParam) {
       .WillRepeatedly(InvokeWithoutArgs([]() {}));
 
   int status = v4l2_gpu_helper_->OnIncomingCapturedData(
-      &client, sample->data(), sample->size(), capture_format,
+      &client, *sample, sample->size(), capture_format,
       gfx::ColorSpace(), kRotation, reference_time, timestamp);
   EXPECT_EQ(status, 0);
 }
diff --git a/media/capture/video/mock_device.cc b/media/capture/video/mock_device.cc
index 4f2d5032e5089..896f1bbd38b74 100644
--- a/media/capture/video/mock_device.cc
+++ b/media/capture/video/mock_device.cc
@@ -18,7 +18,7 @@ void MockDevice::SendStubFrame(const media::VideoCaptureFormat& format,
       gfx::Rect(format.frame_size.width(), format.frame_size.height()),
       format.frame_size, base::TimeDelta());
   client_->OnIncomingCapturedData(
-      stub_frame->data(0),
+      stub_frame->data(0).data(),
       static_cast<int>(media::VideoFrame::AllocationSize(
           stub_frame->format(), stub_frame->coded_size())),
       format, gfx::ColorSpace(), rotation, false /* flip_y */,
diff --git a/media/cast/encoding/av1_encoder.cc b/media/cast/encoding/av1_encoder.cc
index ebdfabce7ef0f..4738442d851df 100644
--- a/media/cast/encoding/av1_encoder.cc
+++ b/media/cast/encoding/av1_encoder.cc
@@ -220,7 +220,7 @@ void Av1Encoder::Encode(scoped_refptr<media::VideoFrame> video_frame,
   aom_image_t aom_image;
   aom_image_t* const result = aom_img_wrap(
       &aom_image, aom_format, frame_size.width(), frame_size.height(), 1,
-      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(result, &aom_image);
 
   aom_image.planes[AOM_PLANE_Y] =
diff --git a/media/cast/encoding/external_video_encoder.cc b/media/cast/encoding/external_video_encoder.cc
index 088e98fb06350..8ccc3dcdadc16 100644
--- a/media/cast/encoding/external_video_encoder.cc
+++ b/media/cast/encoding/external_video_encoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -284,7 +286,7 @@ class ExternalVideoEncoder::VEAClientImpl final
           video_frame->format(), frame_coded_size_,
           gfx::Rect(video_frame->visible_rect().size()),
           video_frame->visible_rect().size(),
-          static_cast<uint8_t*>(mapped_region.mapping.memory()),
+          static_cast<uint8_t*>(mapped_region.mapping.memory().data()),
           mapped_region.mapping.size(), video_frame->timestamp());
       if (!frame || !media::I420CopyWithPadding(*video_frame, frame.get())) {
         LOG(DFATAL) << "Error: ExternalVideoEncoder: copy failed.";
@@ -911,12 +913,12 @@ std::optional<double> QuantizerEstimator::EstimateForKeyFrame(
   const int row_skip = size.height() / rows_in_subset;
   int y = 0;
   for (int i = 0; i < rows_in_subset; ++i, y += row_skip) {
-    const uint8_t* const row_begin = frame.visible_data(VideoFrame::Plane::kY) +
-                                     y * frame.stride(VideoFrame::Plane::kY);
-    const uint8_t* const row_end = row_begin + size.width();
-    int left_hand_pixel_value = static_cast<int>(*row_begin);
-    for (const uint8_t* p = row_begin + 1; p < row_end; ++p) {
-      const int right_hand_pixel_value = static_cast<int>(*p);
+    const base::span<const uint8_t>row_begin = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                                     y * frame.stride(VideoFrame::Plane::kY));
+    const uint8_t* const row_end = row_begin .subspan( size.width()).data();
+    int left_hand_pixel_value = static_cast<int>( row_begin[0]);
+    for (base::span<const uint8_t>p = row_begin .subspan( 1); p < row_end; ++p) {
+      const int right_hand_pixel_value = static_cast<int>( p[0]);
       const int difference = right_hand_pixel_value - left_hand_pixel_value;
       const int histogram_index = difference + 255;
       ++histogram[histogram_index];
@@ -925,7 +927,7 @@ std::optional<double> QuantizerEstimator::EstimateForKeyFrame(
 
     // Copy the row of pixels into the buffer.  This will be used when
     // generating histograms for future delta frames.
-    memcpy(last_frame_pixel_buffer_.get() + i * size.width(), row_begin,
+    memcpy(last_frame_pixel_buffer_.get() + i * size.width(), row_begin.data(),
            size.width());
   }
 
@@ -958,21 +960,21 @@ std::optional<double> QuantizerEstimator::EstimateForDeltaFrame(
   const int row_skip = size.height() / rows_in_subset;
   int y = 0;
   for (int i = 0; i < rows_in_subset; ++i, y += row_skip) {
-    const uint8_t* const row_begin = frame.visible_data(VideoFrame::Plane::kY) +
-                                     y * frame.stride(VideoFrame::Plane::kY);
-    const uint8_t* const row_end = row_begin + size.width();
+    const base::span<const uint8_t>row_begin = frame.visible_data(VideoFrame::Plane::kY) .subspan(
+                                     y * frame.stride(VideoFrame::Plane::kY));
+    const uint8_t* const row_end = row_begin .subspan( size.width()).data();
     uint8_t* const last_frame_row_begin =
         last_frame_pixel_buffer_.get() + i * size.width();
-    for (const uint8_t *p = row_begin, *q = last_frame_row_begin; p < row_end;
+    for (base::span<const uint8_t>p = row_begin, *q = last_frame_row_begin; p < row_end;
          ++p, ++q) {
-      const int difference = static_cast<int>(*p) - static_cast<int>(*q);
+      const int difference = static_cast<int>( p[0]) - static_cast<int>(*q);
       const int histogram_index = difference + 255;
       ++histogram[histogram_index];
     }
 
     // Copy the row of pixels into the buffer.  This will be used when
     // generating histograms for future delta frames.
-    memcpy(last_frame_row_begin, row_begin, size.width());
+    memcpy(last_frame_row_begin, row_begin.data(), size.width());
   }
 
   // Estimate a quantizer value depending on the difference data in the
diff --git a/media/cast/encoding/external_video_encoder_unittest.cc b/media/cast/encoding/external_video_encoder_unittest.cc
index 7f077fcaca89a..051b79ad824c4 100644
--- a/media/cast/encoding/external_video_encoder_unittest.cc
+++ b/media/cast/encoding/external_video_encoder_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -24,8 +26,8 @@ scoped_refptr<VideoFrame> CreateFrame(const uint8_t* y_plane_data,
   scoped_refptr<VideoFrame> result = VideoFrame::CreateFrame(
       PIXEL_FORMAT_I420, size, gfx::Rect(size), size, base::TimeDelta());
   for (int y = 0, y_end = size.height(); y < y_end; ++y) {
-    memcpy(result->GetWritableVisibleData(VideoFrame::Plane::kY) +
-               y * result->stride(VideoFrame::Plane::kY),
+    memcpy(result->GetWritableVisibleData(VideoFrame::Plane::kY) .subspan(
+               y * result->stride(VideoFrame::Plane::kY)).data(),
            y_plane_data + y * size.width(), size.width());
   }
   return result;
diff --git a/media/cast/encoding/vpx_encoder.cc b/media/cast/encoding/vpx_encoder.cc
index 53b7e1601b789..8c40b1ecfdb2b 100644
--- a/media/cast/encoding/vpx_encoder.cc
+++ b/media/cast/encoding/vpx_encoder.cc
@@ -254,7 +254,7 @@ void VpxEncoder::Encode(scoped_refptr<media::VideoFrame> video_frame,
   vpx_image_t vpx_image;
   vpx_image_t* const result = vpx_img_wrap(
       &vpx_image, vpx_format, frame_size.width(), frame_size.height(), 1,
-      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(video_frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(result, &vpx_image);
   switch (vpx_format) {
     case VPX_IMG_FMT_I420:
diff --git a/media/cast/sender/performance_metrics_overlay.cc b/media/cast/sender/performance_metrics_overlay.cc
index f4b2b858c3dfb..2901be14ac5cb 100644
--- a/media/cast/sender/performance_metrics_overlay.cc
+++ b/media/cast/sender/performance_metrics_overlay.cc
@@ -113,17 +113,17 @@ scoped_refptr<VideoFrame> CopyVideoFrame(scoped_refptr<VideoFrame> source) {
   }
 
   // Copy the contents of the VideoFrame over.
-  libyuv::I420Copy(source->data(media::VideoFrame::Plane::kY),
+  libyuv::I420Copy(source->data(media::VideoFrame::Plane::kY).data(),
                    source->stride(media::VideoFrame::Plane::kY),
-                   source->data(media::VideoFrame::Plane::kU),
+                   source->data(media::VideoFrame::Plane::kU).data(),
                    source->stride(media::VideoFrame::Plane::kU),
-                   source->data(media::VideoFrame::Plane::kV),
+                   source->data(media::VideoFrame::Plane::kV).data(),
                    source->stride(media::VideoFrame::Plane::kV),
-                   frame->writable_data(media::VideoFrame::Plane::kY),
+                   frame->writable_data(media::VideoFrame::Plane::kY).data(),
                    frame->stride(media::VideoFrame::Plane::kY),
-                   frame->writable_data(media::VideoFrame::Plane::kU),
+                   frame->writable_data(media::VideoFrame::Plane::kU).data(),
                    frame->stride(media::VideoFrame::Plane::kU),
-                   frame->writable_data(media::VideoFrame::Plane::kV),
+                   frame->writable_data(media::VideoFrame::Plane::kV).data(),
                    frame->stride(media::VideoFrame::Plane::kV),
                    source->coded_size().width(), source->coded_size().height());
 
diff --git a/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc b/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
index 9a016d2e5f00a..4eac75e12d529 100644
--- a/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
+++ b/media/cdm/library_cdm/clear_key_cdm/cdm_video_decoder.cc
@@ -120,7 +120,7 @@ bool ToCdmVideoFrame(const VideoFrame& video_frame,
   uint8_t* dst = buffer->Data();
   uint32_t offset = 0;
   for (int plane = 0; plane < 3; ++plane) {
-    const uint8_t* src = video_frame.data(plane);
+    const uint8_t* src = video_frame.data(plane).data();
     int src_stride = video_frame.stride(plane);
     int row_bytes = video_frame.row_bytes(plane);
     int rows = video_frame.rows(plane);
diff --git a/media/filters/dav1d_video_decoder_unittest.cc b/media/filters/dav1d_video_decoder_unittest.cc
index af75237c246f8..2f801a64088f6 100644
--- a/media/filters/dav1d_video_decoder_unittest.cc
+++ b/media/filters/dav1d_video_decoder_unittest.cc
@@ -244,8 +244,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_8bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_I420, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("eeba03dcc9c22c4632bf74b481db36b2", GetVideoFrameHash(*frame));
 }
 
@@ -258,8 +258,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_10bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_YUV420P10, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("026c1fed9e161f09d816ac7278458a80", GetVideoFrameHash(*frame));
 }
 
@@ -272,8 +272,8 @@ TEST_F(Dav1dVideoDecoderTest, DecodeFrame_12bitMono) {
 
   const auto& frame = output_frames_.front();
   EXPECT_EQ(PIXEL_FORMAT_YUV420P12, frame->format());
-  EXPECT_EQ(frame->data(VideoFrame::Plane::kU),
-            frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(frame->data(VideoFrame::Plane::kU).data(),
+            frame->data(VideoFrame::Plane::kV).data());
   EXPECT_EQ("32115092dc00fbe86823b0b714a0f63e", GetVideoFrameHash(*frame));
 }
 
@@ -355,7 +355,7 @@ TEST_F(Dav1dVideoDecoderTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          output_frames_.front()->rows(VideoFrame::Plane::kY) *
              output_frames_.front()->stride(VideoFrame::Plane::kY));
 }
diff --git a/media/filters/ffmpeg_video_decoder.cc b/media/filters/ffmpeg_video_decoder.cc
index 331d1e778f9df..3ee0ab327a5a2 100644
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -203,15 +205,15 @@ int FFmpegVideoDecoder::GetVideoBuffer(struct AVCodecContext* codec_context,
     return AVERROR(ENOMEM);
   }
 
-  uint8_t* data = base::bits::AlignUp(span.data(), layout->buffer_addr_align());
+  base::span<uint8_t>data = base::bits::AlignUp(span.data(), layout->buffer_addr_align());
 
   for (size_t plane = 0; plane < num_planes; ++plane) {
-    frame->data[plane] = data + layout->planes()[plane].offset;
+    frame->data[plane] = data .subspan( layout->planes()[plane].offset);
     frame->linesize[plane] = layout->planes()[plane].stride;
   }
 
   // This will be freed by `ReleaseVideoBufferImpl`.
-  auto* opaque = new OpaqueData(fb_priv, frame_pool_, data, allocation_size,
+  auto* opaque = new OpaqueData(fb_priv, frame_pool_, data.data(), allocation_size,
                                 std::move(*layout));
 
   frame->buf[0] = av_buffer_create(
diff --git a/media/filters/file_data_source.cc b/media/filters/file_data_source.cc
index a853dbbf4dc47..caa37f3b069f2 100644
--- a/media/filters/file_data_source.cc
+++ b/media/filters/file_data_source.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -57,7 +59,7 @@ void FileDataSource::Read(int64_t position,
   int64_t clamped_size =
       std::min(static_cast<int64_t>(size), file_size - position);
 
-  memcpy(data, file_.data() + position, clamped_size);
+  memcpy(data, file_.data() .subspan( position).data(), clamped_size);
   bytes_read_ += clamped_size;
   std::move(read_cb).Run(clamped_size);
 }
diff --git a/media/filters/vpx_video_decoder.cc b/media/filters/vpx_video_decoder.cc
index 69481802f2b5c..91dd2d1fa2547 100644
--- a/media/filters/vpx_video_decoder.cc
+++ b/media/filters/vpx_video_decoder.cc
@@ -349,7 +349,7 @@ bool VpxVideoDecoder::VpxDecode(const DecoderBuffer* buffer,
     libyuv::CopyPlane(
         vpx_image_alpha->planes[VPX_PLANE_Y],
         vpx_image_alpha->stride[VPX_PLANE_Y],
-        (*video_frame)->GetWritableVisibleData(VideoFrame::Plane::kA),
+        (*video_frame)->GetWritableVisibleData(VideoFrame::Plane::kA).data(),
         (*video_frame)->stride(VideoFrame::Plane::kA),
         (*video_frame)->visible_rect().width(),
         (*video_frame)->visible_rect().height());
@@ -618,7 +618,7 @@ bool VpxVideoDecoder::CopyVpxImageToVideoFrame(
   auto strides = base::span(vpx_image->stride);
   for (int plane = 0; plane < 3; plane++) {
     libyuv::CopyPlane(planes[plane], strides[plane],
-                      (*video_frame)->GetWritableVisibleData(plane),
+                      (*video_frame)->GetWritableVisibleData(plane).data(),
                       (*video_frame)->stride(plane),
                       (*video_frame)->row_bytes(plane),
                       (*video_frame)->rows(plane));
diff --git a/media/filters/vpx_video_decoder_unittest.cc b/media/filters/vpx_video_decoder_unittest.cc
index 47781196c6425..659aa950994f0 100644
--- a/media/filters/vpx_video_decoder_unittest.cc
+++ b/media/filters/vpx_video_decoder_unittest.cc
@@ -271,7 +271,7 @@ TEST_F(VpxVideoDecoderTest, SimpleFrameReuse) {
 
   ASSERT_EQ(1u, output_frames_.size());
   scoped_refptr<VideoFrame> frame = std::move(output_frames_.front());
-  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY);
+  const uint8_t* old_y_data = frame->data(VideoFrame::Plane::kY).data();
   output_frames_.pop_back();
 
   // Clear frame reference to return the frame to the pool.
@@ -288,7 +288,7 @@ TEST_F(VpxVideoDecoderTest, SimpleFrameReuse) {
   Decode(i_frame_buffer_);
 
   ASSERT_EQ(2u, output_frames_.size());
-  EXPECT_EQ(old_y_data, output_frames_.back()->data(VideoFrame::Plane::kY));
+  EXPECT_EQ(old_y_data, output_frames_.back()->data(VideoFrame::Plane::kY).data());
 }
 
 TEST_F(VpxVideoDecoderTest, SimpleFormatChange) {
@@ -310,7 +310,7 @@ TEST_F(VpxVideoDecoderTest, FrameValidAfterPoolDestruction) {
 
   // Write to the Y plane. The memory tools should detect a
   // use-after-free if the storage was actually removed by pool destruction.
-  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY), 0xff,
+  memset(output_frames_.front()->writable_data(VideoFrame::Plane::kY).data(), 0xff,
          output_frames_.front()->rows(VideoFrame::Plane::kY) *
              output_frames_.front()->stride(VideoFrame::Plane::kY));
 }
@@ -345,12 +345,12 @@ TEST_F(VpxVideoDecoderTest, MemoryPoolAllowsMultipleDisplay) {
   scoped_refptr<VideoFrame> last_frame = output_frames_[25];
   scoped_refptr<VideoFrame> dupe_frame = output_frames_[23];
 
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kY),
-            dupe_frame->data(VideoFrame::Plane::kY));
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kU),
-            dupe_frame->data(VideoFrame::Plane::kU));
-  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kV),
-            dupe_frame->data(VideoFrame::Plane::kV));
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kY).data(),
+            dupe_frame->data(VideoFrame::Plane::kY).data());
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kU).data(),
+            dupe_frame->data(VideoFrame::Plane::kU).data());
+  EXPECT_EQ(last_frame->data(VideoFrame::Plane::kV).data(),
+            dupe_frame->data(VideoFrame::Plane::kV).data());
 
   // This will release all frames held by the memory pool, but should not
   // release |last_frame| since we still have a ref despite sharing the same
@@ -360,7 +360,7 @@ TEST_F(VpxVideoDecoderTest, MemoryPoolAllowsMultipleDisplay) {
   Destroy();
 
   // ASAN will be very unhappy with this line if the above is incorrect.
-  memset(last_frame->writable_data(VideoFrame::Plane::kY), 0,
+  memset(last_frame->writable_data(VideoFrame::Plane::kY).data(), 0,
          last_frame->row_bytes(VideoFrame::Plane::kY));
 }
 #endif  // !defined(LIBVPX_NO_HIGH_BIT_DEPTH) && !defined(ARCH_CPU_ARM_FAMILY)
diff --git a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
index af8ae8ce4d120..f15d5d034b310 100644
--- a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
+++ b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter.cc
@@ -56,7 +56,7 @@ MP4Status H265AnnexBToHevcBitstreamConverter::ConvertChunk(
   //     what configuration (profile and level) is active now.
   // A configure change will only happen on IDR frame. It is expected the
   // encoder output stream repeats VPS/SPS/PPS on IDR frames.
-  parser_.SetStream(input.data(), input.size());
+  parser_.SetStream(input, input.size());
   while ((result = parser_.AdvanceToNextNALU(&nalu)) != H265Parser::kEOStream) {
     if (result == H265Parser::kUnsupportedStream)
       return MP4Status::Codes::kUnsupportedStream;
diff --git a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
index 61d0e94d07251..0d635a45a8ccf 100644
--- a/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
+++ b/media/formats/mp4/h265_annex_b_to_hevc_bitstream_converter_unittest.cc
@@ -66,7 +66,7 @@ TEST(H265AnnexBToHevcBitstreamConverterTest, Success) {
       // parameter set are write to the output or not.
       EXPECT_TRUE(mp4::AVC::ConvertAVCToAnnexBInPlaceForLengthSize4(&output));
       H265Parser parser;
-      parser.SetStream(output.data(), output.size());
+      parser.SetStream(output, output.size());
       std::vector<H265NALU> parameter_sets;
       while (true) {
         H265NALU nalu;
@@ -226,7 +226,7 @@ TEST(H265AnnexBToHevcBitstreamConverterTest, PPS_SwitchWithoutReconfig) {
     // parameter set are write to the output.
     EXPECT_FALSE(mp4::AVC::ConvertAVCToAnnexBInPlaceForLengthSize4(&output));
     H265Parser parser;
-    parser.SetStream(output.data(), output.size());
+    parser.SetStream(output, output.size());
     std::vector<H265NALU> parameter_sets;
     while (true) {
       H265NALU nalu;
diff --git a/media/formats/mp4/hevc.cc b/media/formats/mp4/hevc.cc
index 519cb7e5d5916..e41f12b3e7abb 100644
--- a/media/formats/mp4/hevc.cc
+++ b/media/formats/mp4/hevc.cc
@@ -239,7 +239,7 @@ bool HEVCDecoderConfigurationRecord::ParseInternal(BufferReader* reader,
   }
   H265Parser parser;
   H265NALU nalu;
-  parser.SetStream(param_sets.data(), param_sets.size());
+  parser.SetStream(param_sets, param_sets.size());
   while (true) {
     H265Parser::Result result = parser.AdvanceToNextNALU(&nalu);
     if (result != H265Parser::kOk) {
@@ -362,11 +362,11 @@ bool HEVC::InsertParamSetsAnnexB(
     const HEVCDecoderConfigurationRecord& hevc_config,
     std::vector<uint8_t>* buffer,
     std::vector<SubsampleEntry>* subsamples) {
-  DCHECK(HEVC::AnalyzeAnnexB(buffer->data(), buffer->size(), *subsamples)
+  DCHECK(HEVC::AnalyzeAnnexB(*buffer, buffer->size(), *subsamples)
              .is_conformant.value_or(true));
 
   std::unique_ptr<H265NaluParser> parser(new H265NaluParser());
-  const uint8_t* start = buffer->data();
+  base::span<const uint8_t>start = *buffer;
   parser->SetEncryptedStream(start, buffer->size(), *subsamples);
 
   H265NALU nalu;
@@ -384,7 +384,7 @@ bool HEVC::InsertParamSetsAnnexB(
   // Clear |parser| and |start| since they aren't needed anymore and
   // will hold stale pointers once the insert happens.
   parser.reset();
-  start = nullptr;
+  start = {};
 
   std::vector<uint8_t> param_sets;
   HEVC::ConvertConfigToAnnexB(hevc_config, &param_sets);
@@ -402,7 +402,7 @@ bool HEVC::InsertParamSetsAnnexB(
   buffer->insert(config_insert_point,
                  param_sets.begin(), param_sets.end());
 
-  DCHECK(HEVC::AnalyzeAnnexB(buffer->data(), buffer->size(), *subsamples)
+  DCHECK(HEVC::AnalyzeAnnexB(*buffer, buffer->size(), *subsamples)
              .is_conformant.value_or(true));
   return true;
 }
@@ -429,7 +429,7 @@ void HEVC::ConvertConfigToAnnexB(
 
 // static
 BitstreamConverter::AnalysisResult HEVC::AnalyzeAnnexB(
-    const uint8_t* buffer,
+    base::span<const uint8_t>buffer,
     size_t size,
     const std::vector<SubsampleEntry>& subsamples) {
   DVLOG(3) << __func__;
@@ -675,7 +675,7 @@ bool HEVCBitstreamConverter::ConvertAndAnalyzeFrame(
 BitstreamConverter::AnalysisResult HEVCBitstreamConverter::Analyze(
     std::vector<uint8_t>* frame_buf,
     std::vector<SubsampleEntry>* subsamples) const {
-  return HEVC::AnalyzeAnnexB(frame_buf->data(), frame_buf->size(), *subsamples);
+  return HEVC::AnalyzeAnnexB(*frame_buf, frame_buf->size(), *subsamples);
 }
 
 }  // namespace mp4
diff --git a/media/formats/mp4/hevc.h b/media/formats/mp4/hevc.h
index b637219ab254a..5aea29550b89c 100644
--- a/media/formats/mp4/hevc.h
+++ b/media/formats/mp4/hevc.h
@@ -11,6 +11,7 @@
 #include <memory>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "media/base/media_export.h"
 #include "media/base/video_codecs.h"
 #include "media/base/video_decoder_config.h"
@@ -106,7 +107,7 @@ class MEDIA_EXPORT HEVC {
   // |subsamples| contains the information about what parts of the buffer are
   // encrypted and which parts are clear.
   static BitstreamConverter::AnalysisResult AnalyzeAnnexB(
-      const uint8_t* buffer,
+      base::span<const uint8_t>buffer,
       size_t size,
       const std::vector<SubsampleEntry>& subsamples);
 };
diff --git a/media/formats/mp4/hevc_unittest.cc b/media/formats/mp4/hevc_unittest.cc
index 3db99c0cb68e5..b1530da4f8770 100644
--- a/media/formats/mp4/hevc_unittest.cc
+++ b/media/formats/mp4/hevc_unittest.cc
@@ -7,6 +7,7 @@
 
 #include <array>
 
+#include "base/containers/span.h"
 #include "media/formats/mp4/nalu_test_helper.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -42,7 +43,7 @@ TEST(HEVCAnalyzeAnnexBTest, ValidAnnexBConstructs) {
     expected.is_conformant = true;
     expected.is_keyframe = test_cases[i].is_keyframe;
     EXPECT_PRED2(AnalysesMatch,
-                 HEVC::AnalyzeAnnexB(buf.data(), buf.size(), subsamples),
+                 HEVC::AnalyzeAnnexB(buf, buf.size(), subsamples),
                  expected)
         << "'" << test_cases[i].case_string << "' failed";
   }
@@ -50,7 +51,7 @@ TEST(HEVCAnalyzeAnnexBTest, ValidAnnexBConstructs) {
 
 TEST(HEVCAnalyzeAnnexBTest, EmptyBuffer) {
   std::vector<SubsampleEntry> subsamples;
-  auto result = HEVC::AnalyzeAnnexB(nullptr, 0, subsamples);
+  auto result = HEVC::AnalyzeAnnexB({}, 0, subsamples);
   EXPECT_TRUE(result.is_conformant);
   EXPECT_TRUE(subsamples.empty());
   EXPECT_FALSE(result.is_keyframe.has_value());
@@ -92,7 +93,7 @@ TEST(HEVCAnalyzeAnnexBTest, InvalidAnnexBConstructs) {
     HevcStringToAnnexB(test_cases[i].case_string, &buf, nullptr);
     expected.is_keyframe = test_cases[i].is_keyframe;
     EXPECT_PRED2(AnalysesMatch,
-                 HEVC::AnalyzeAnnexB(buf.data(), buf.size(), subsamples),
+                 HEVC::AnalyzeAnnexB(buf, buf.size(), subsamples),
                  expected)
         << "'" << test_cases[i].case_string << "' failed";
   }
diff --git a/media/gpu/av1_decoder_unittest.cc b/media/gpu/av1_decoder_unittest.cc
index 5d98592503dd1..abc7baa4c442a 100644
--- a/media/gpu/av1_decoder_unittest.cc
+++ b/media/gpu/av1_decoder_unittest.cc
@@ -249,7 +249,7 @@ std::vector<scoped_refptr<DecoderBuffer>> AV1DecoderTest::ReadIVF(
   IvfParser ivf_parser;
   IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
   EXPECT_EQ(ivf_header.fourcc, /*AV01=*/0x31305641u);
 
diff --git a/media/gpu/chromeos/frame_resource.h b/media/gpu/chromeos/frame_resource.h
index 961c9a9b6dfa9..a9180ffb2c7c3 100644
--- a/media/gpu/chromeos/frame_resource.h
+++ b/media/gpu/chromeos/frame_resource.h
@@ -5,6 +5,7 @@
 #ifndef MEDIA_GPU_CHROMEOS_FRAME_RESOURCE_H_
 #define MEDIA_GPU_CHROMEOS_FRAME_RESOURCE_H_
 
+#include "base/containers/span.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/time/time.h"
@@ -70,8 +71,8 @@ class FrameResource : public base::RefCountedThreadSafe<FrameResource> {
 
   // The visible variants return a pointer that is offsetted into the
   // plane buffer specified by visible_rect().origin().
-  virtual const uint8_t* visible_data(size_t plane) const = 0;
-  virtual uint8_t* GetWritableVisibleData(size_t plane) = 0;
+  virtual const base::span<uint8_t> visible_data(size_t plane) const = 0;
+  virtual base::span<uint8_t> GetWritableVisibleData(size_t plane) = 0;
 
   // The number of DmaBufs will be equal or less than the number of planes of
   // the frame. If there are less, this means that the last FD contains the
diff --git a/media/gpu/chromeos/libyuv_image_processor_backend.cc b/media/gpu/chromeos/libyuv_image_processor_backend.cc
index 1e4268aa4b3a0..08daa902da7d7 100644
--- a/media/gpu/chromeos/libyuv_image_processor_backend.cc
+++ b/media/gpu/chromeos/libyuv_image_processor_backend.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -324,22 +326,22 @@ void LibYUVImageProcessorBackend::ProcessFrame(
         for (size_t plane = 0;
              plane < VideoFrame::NumPlanes(crop_intermediate_frame_->format());
              plane++) {
-          const uint8_t* src_row_ptr =
+          base::span<const uint8_t>src_row_ptr =
               crop_intermediate_frame_->visible_data(plane);
-          uint8_t* dst_row_ptr = mapped_frame->GetWritableVisibleData(plane);
+          base::span<uint8_t>dst_row_ptr = mapped_frame->GetWritableVisibleData(plane);
           for (size_t row = 0;
                row < VideoFrame::Rows(
                          plane, crop_intermediate_frame_->format(),
                          crop_intermediate_frame_->visible_rect().height());
                row++) {
-            memcpy(dst_row_ptr, src_row_ptr,
+            memcpy(dst_row_ptr.data(), src_row_ptr.data(),
                    VideoFrame::Columns(
                        plane, crop_intermediate_frame_->format(),
                        crop_intermediate_frame_->visible_rect().width()) *
                        VideoFrame::BytesPerElement(
                            crop_intermediate_frame_->format(), plane));
-            src_row_ptr += crop_intermediate_frame_->row_bytes(plane);
-            dst_row_ptr += mapped_frame->row_bytes(plane);
+            src_row_ptr=src_row_ptr.subspan(crop_intermediate_frame_->row_bytes(plane));
+            dst_row_ptr=dst_row_ptr.subspan(mapped_frame->row_bytes(plane));
           }
         }
       }
@@ -362,40 +364,40 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
   DCHECK_CALLED_ON_VALID_SEQUENCE(backend_sequence_checker_);
 
 #define Y_U_V_DATA(fr)                                                        \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kU),                                \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kU).data(),                                \
       fr->stride(VideoFrame::Plane::kU),                                      \
-      fr->visible_data(VideoFrame::Plane::kV),                                \
+      fr->visible_data(VideoFrame::Plane::kV).data(),                                \
       fr->stride(VideoFrame::Plane::kV)
 
 #define Y_U_V_DATA_W(fr)                                 \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kY),     \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kY).data(),     \
       fr->stride(VideoFrame::Plane::kY),                 \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kU), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kU).data(), \
       fr->stride(VideoFrame::Plane::kU),                 \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kV), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kV).data(), \
       fr->stride(VideoFrame::Plane::kV)
 
 #define Y_V_U_DATA(fr)                                                        \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kV),                                \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kV).data(),                                \
       fr->stride(VideoFrame::Plane::kV),                                      \
-      fr->visible_data(VideoFrame::Plane::kU),                                \
+      fr->visible_data(VideoFrame::Plane::kU).data(),                                \
       fr->stride(VideoFrame::Plane::kU)
 
 #define Y_UV_DATA(fr)                                                         \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY), \
-      fr->visible_data(VideoFrame::Plane::kUV),                               \
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY), \
+      fr->visible_data(VideoFrame::Plane::kUV).data(),                               \
       fr->stride(VideoFrame::Plane::kUV)
 
 #define Y_UV_DATA_W(fr)                                   \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kY),      \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kY).data(),      \
       fr->stride(VideoFrame::Plane::kY),                  \
-      fr->GetWritableVisibleData(VideoFrame::Plane::kUV), \
+      fr->GetWritableVisibleData(VideoFrame::Plane::kUV).data(), \
       fr->stride(VideoFrame::Plane::kUV)
 
 #define YUY2_DATA(fr) \
-  fr->visible_data(VideoFrame::Plane::kY), fr->stride(VideoFrame::Plane::kY)
+  fr->visible_data(VideoFrame::Plane::kY).data(), fr->stride(VideoFrame::Plane::kY)
 
 #define Y_UV_DATA_10BIT(fr)                                                   \
   reinterpret_cast<const uint16_t*>(fr->visible_data(VideoFrame::Plane::kY)), \
@@ -414,7 +416,7 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
 
 #if BUILDFLAG(IS_LINUX)
 #define ARGB_DATA(fr)                                   \
-  fr->GetWritableVisibleData(VideoFrame::Plane::kARGB), \
+  fr->GetWritableVisibleData(VideoFrame::Plane::kARGB).data(), \
       fr->stride(VideoFrame::Plane::kARGB)
 #endif
 
@@ -556,13 +558,13 @@ int LibYUVImageProcessorBackend::DoConversion(const FrameResource* const input,
           (input->stride(VideoFrame::Plane::kY) * 5) >> 2;
 
       int libyuv_result = libyuv::MT2TToP010(
-          input->visible_data(VideoFrame::Plane::kY), src_stride_mt2t,
-          input->visible_data(VideoFrame::Plane::kUV), src_stride_mt2t,
+          input->visible_data(VideoFrame::Plane::kY).data(), src_stride_mt2t,
+          input->visible_data(VideoFrame::Plane::kUV).data(), src_stride_mt2t,
           reinterpret_cast<uint16_t*>(
-              output->GetWritableVisibleData(VideoFrame::Plane::kY)),
+              output->GetWritableVisibleData(VideoFrame::Plane::kY).data()),
           output->stride(VideoFrame::Plane::kY) >> 1,
           reinterpret_cast<uint16_t*>(
-              output->GetWritableVisibleData(VideoFrame::Plane::kUV)),
+              output->GetWritableVisibleData(VideoFrame::Plane::kUV).data()),
           output->stride(VideoFrame::Plane::kUV) >> 1,
           output->visible_rect().width(), output->visible_rect().height());
 
diff --git a/media/gpu/chromeos/native_pixmap_frame_resource.cc b/media/gpu/chromeos/native_pixmap_frame_resource.cc
index 6e1a1790f08cc..130137be2cc90 100644
--- a/media/gpu/chromeos/native_pixmap_frame_resource.cc
+++ b/media/gpu/chromeos/native_pixmap_frame_resource.cc
@@ -7,6 +7,7 @@
 #include <atomic>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/feature_list.h"
 #include "base/functional/callback_helpers.h"
 #include "base/logging.h"
@@ -281,12 +282,12 @@ uint8_t* NativePixmapFrameResource::writable_data(size_t plane) {
   return nullptr;
 }
 
-const uint8_t* NativePixmapFrameResource::visible_data(size_t plane) const {
-  return nullptr;
+const base::span<uint8_t> NativePixmapFrameResource::visible_data(size_t plane) const {
+  return {};
 }
 
-uint8_t* NativePixmapFrameResource::GetWritableVisibleData(size_t plane) {
-  return nullptr;
+base::span<uint8_t> NativePixmapFrameResource::GetWritableVisibleData(size_t plane) {
+  return {};
 }
 
 size_t NativePixmapFrameResource::NumDmabufFds() const {
diff --git a/media/gpu/chromeos/native_pixmap_frame_resource.h b/media/gpu/chromeos/native_pixmap_frame_resource.h
index 34277dd0e2609..29687af82870c 100644
--- a/media/gpu/chromeos/native_pixmap_frame_resource.h
+++ b/media/gpu/chromeos/native_pixmap_frame_resource.h
@@ -7,6 +7,7 @@
 
 #include <optional>
 
+#include "base/containers/span.h"
 #include "base/memory/ref_counted.h"
 #include "base/time/time.h"
 #include "base/types/pass_key.h"
@@ -85,8 +86,8 @@ class NativePixmapFrameResource : public FrameResource {
   bool IsMappable() const override;
   const uint8_t* data(size_t plane) const override;
   uint8_t* writable_data(size_t plane) override;
-  const uint8_t* visible_data(size_t plane) const override;
-  uint8_t* GetWritableVisibleData(size_t plane) override;
+  const base::span<uint8_t> visible_data(size_t plane) const override;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane) override;
   size_t NumDmabufFds() const override;
   int GetDmabufFd(size_t i) const override;
   scoped_refptr<const gfx::NativePixmapDmaBuf> GetNativePixmapDmaBuf()
diff --git a/media/gpu/chromeos/video_frame_resource.cc b/media/gpu/chromeos/video_frame_resource.cc
index 0fac2c3ccaa0a..f49683591e4fa 100644
--- a/media/gpu/chromeos/video_frame_resource.cc
+++ b/media/gpu/chromeos/video_frame_resource.cc
@@ -4,6 +4,7 @@
 
 #include "media/gpu/chromeos/video_frame_resource.h"
 
+#include "base/containers/span.h"
 #include "base/functional/callback_helpers.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/types/pass_key.h"
@@ -49,18 +50,18 @@ bool VideoFrameResource::IsMappable() const {
 }
 
 const uint8_t* VideoFrameResource::data(size_t plane) const {
-  return frame_->data(plane);
+  return frame_->data(plane).data();
 }
 
 uint8_t* VideoFrameResource::writable_data(size_t plane) {
-  return GetMutableVideoFrame()->writable_data(plane);
+  return GetMutableVideoFrame()->writable_data(plane).data();
 }
 
-const uint8_t* VideoFrameResource::visible_data(size_t plane) const {
+const base::span<uint8_t> VideoFrameResource::visible_data(size_t plane) const {
   return frame_->visible_data(plane);
 }
 
-uint8_t* VideoFrameResource::GetWritableVisibleData(size_t plane) {
+base::span<uint8_t> VideoFrameResource::GetWritableVisibleData(size_t plane) {
   return GetMutableVideoFrame()->GetWritableVisibleData(plane);
 }
 
diff --git a/media/gpu/chromeos/video_frame_resource.h b/media/gpu/chromeos/video_frame_resource.h
index fe6e585e41fb2..ff5985b45e21f 100644
--- a/media/gpu/chromeos/video_frame_resource.h
+++ b/media/gpu/chromeos/video_frame_resource.h
@@ -5,6 +5,7 @@
 #ifndef MEDIA_GPU_CHROMEOS_VIDEO_FRAME_RESOURCE_H_
 #define MEDIA_GPU_CHROMEOS_VIDEO_FRAME_RESOURCE_H_
 
+#include "base/containers/span.h"
 #include "base/time/time.h"
 #include "base/types/pass_key.h"
 #include "media/base/video_frame_layout.h"
@@ -34,8 +35,8 @@ class VideoFrameResource : public FrameResource {
   bool IsMappable() const override;
   const uint8_t* data(size_t plane) const override;
   uint8_t* writable_data(size_t plane) override;
-  const uint8_t* visible_data(size_t plane) const override;
-  uint8_t* GetWritableVisibleData(size_t plane) override;
+  const base::span<uint8_t> visible_data(size_t plane) const override;
+  base::span<uint8_t> GetWritableVisibleData(size_t plane) override;
   size_t NumDmabufFds() const override;
   int GetDmabufFd(size_t i) const override;
   scoped_refptr<const gfx::NativePixmapDmaBuf> GetNativePixmapDmaBuf()
diff --git a/media/gpu/h265_decoder.cc b/media/gpu/h265_decoder.cc
index fda0d67d7c6b5..b35c2158e2225 100644
--- a/media/gpu/h265_decoder.cc
+++ b/media/gpu/h265_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -153,16 +155,16 @@ H265Decoder::~H265Decoder() = default;
 
 void H265Decoder::SetStream(int32_t id, const DecoderBuffer& decoder_buffer) {
   auto decoder_buffer_span = base::span(decoder_buffer);
-  const uint8_t* ptr = decoder_buffer_span.data();
+  base::span<const uint8_t>ptr = decoder_buffer_span;
   const size_t size = decoder_buffer_span.size();
   const DecryptConfig* decrypt_config = decoder_buffer.decrypt_config();
 
-  DCHECK(ptr);
+  DCHECK(!ptr.empty());
   DCHECK(size);
-  DVLOG(4) << "New input stream id: " << id << " at: " << (void*)ptr
+  DVLOG(4) << "New input stream id: " << id << " at: " << (void*)ptr.data()
            << " size: " << size;
   stream_id_ = id;
-  current_stream_ = ptr;
+  current_stream_ = ptr.data();
   current_stream_size_ = size;
   current_stream_has_been_changed_ = true;
   if (decrypt_config) {
diff --git a/media/gpu/test/image.cc b/media/gpu/test/image.cc
index 3cb74d5f85659..555e8b08a8a5e 100644
--- a/media/gpu/test/image.cc
+++ b/media/gpu/test/image.cc
@@ -228,7 +228,7 @@ bool Image::IsMetadataLoaded() const {
 }
 
 uint8_t* Image::Data() const {
-  return mapped_file_.data();
+  return mapped_file_.data().data();
 }
 
 size_t Image::DataSize() const {
diff --git a/media/gpu/test/image_quality_metrics.cc b/media/gpu/test/image_quality_metrics.cc
index 6142e89035eff..434f0cebe986b 100644
--- a/media/gpu/test/image_quality_metrics.cc
+++ b/media/gpu/test/image_quality_metrics.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -227,7 +229,7 @@ bool ComputeLogJointDistribution(const VideoFrame& frame,
   // Downsample the RGB values of the plane into 4-bits per channel, and use the
   // downsampled color information to increment the corresponding element of the
   // distribution table.
-  const uint8_t* row_ptr = frame.visible_data(0);
+  base::span<const uint8_t>row_ptr = frame.visible_data(0);
   for (int y = 0; y < frame.visible_rect().height(); y++) {
     for (int x = 0; x < frame.visible_rect().width(); x++) {
       log_joint_distribution[row_ptr[4 * x + 1] >> kJointDistributionBitDepth]
@@ -235,7 +237,7 @@ bool ComputeLogJointDistribution(const VideoFrame& frame,
                             [row_ptr[4 * x + 3] >>
                              kJointDistributionBitDepth] += 1.0;
     }
-    row_ptr += frame.stride(0);
+    row_ptr=row_ptr.subspan(frame.stride(0));
   }
 
   // Normalize the joint distribution so that it sums to 1.0 and then take the
@@ -260,7 +262,7 @@ double ComputeLogProbability(const VideoFrame& frame,
 
   double ret = 0.0;
 
-  const uint8_t* row_ptr = frame.visible_data(0);
+  base::span<const uint8_t>row_ptr = frame.visible_data(0);
   for (int y = 0; y < frame.visible_rect().height(); y++) {
     for (int x = 0; x < frame.visible_rect().width(); x++) {
       ret += log_joint_distribution
@@ -268,7 +270,7 @@ double ComputeLogProbability(const VideoFrame& frame,
           [row_ptr[4 * x + 2] >> kJointDistributionBitDepth]
           [row_ptr[4 * x + 3] >> kJointDistributionBitDepth];
     }
-    row_ptr += frame.stride(0);
+    row_ptr=row_ptr.subspan(frame.stride(0));
   }
 
   return ret;
@@ -294,9 +296,9 @@ size_t CompareFramesWithErrorDiff(const VideoFrame& frame1,
   const size_t num_planes = VideoFrame::NumPlanes(format);
   const gfx::Size& visible_size = frame1.visible_rect().size();
   for (size_t i = 0; i < num_planes; ++i) {
-    const uint8_t* data1 = frame1.visible_data(i);
+    base::span<const uint8_t>data1 = frame1.visible_data(i);
     const int stride1 = frame1.stride(i);
-    const uint8_t* data2 = frame2.visible_data(i);
+    base::span<const uint8_t>data2 = frame2.visible_data(i);
     const int stride2 = frame2.stride(i);
     const size_t rows = VideoFrame::Rows(i, format, visible_size.height());
     const int row_bytes = VideoFrame::RowBytes(i, format, visible_size.width());
diff --git a/media/gpu/test/raw_video.cc b/media/gpu/test/raw_video.cc
index c0ae82d415662..494b73d828241 100644
--- a/media/gpu/test/raw_video.cc
+++ b/media/gpu/test/raw_video.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -248,8 +250,8 @@ class RawVideo::VP9Decoder {
     if (layout_.format() == PIXEL_FORMAT_NV12) {
       uint8_t* nv12_frame = buffer.data();
       int ret = libyuv::I420ToNV12(
-          i420_frame.data(0), i420_frame.stride(0), i420_frame.data(1),
-          i420_frame.stride(1), i420_frame.data(2), i420_frame.stride(2),
+          i420_frame.data(0).data(), i420_frame.stride(0), i420_frame.data(1).data(),
+          i420_frame.stride(1), i420_frame.data(2).data(), i420_frame.stride(2),
           nv12_frame + layout_.planes()[0].offset, layout_.planes()[0].stride,
           nv12_frame + layout_.planes()[1].offset, layout_.planes()[1].stride,
           layout_.coded_size().width(), layout_.coded_size().height());
@@ -267,7 +269,7 @@ class RawVideo::VP9Decoder {
         // VideoFrame::PlaneSize() cannot be used because it computes the
         // plane size with resolutions aligned by two while our test code
         // works with a succinct buffer size.
-        const uint8_t* src = i420_frame.data(plane);
+        const uint8_t* src = i420_frame.data(plane).data();
         libyuv::CopyPlane(src, stride, dst_plane, row_bytes, row_bytes, rows);
         dst_plane += (rows * row_bytes);
       }
@@ -304,7 +306,7 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
     LOG(ERROR) << "Failed to read file: " << vp9_webm_data_file_path;
     return nullptr;
   }
-  base::span<const uint8_t> vp9_webm_data(vp9_webm_data_mmap_file.data(),
+  base::span<const uint8_t> vp9_webm_data(vp9_webm_data_mmap_file.data().data(),
                                           vp9_webm_data_mmap_file.length());
 
   InitializeMediaLibrary();
@@ -333,7 +335,7 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
   }
 
   auto vp9_data_mmap_file = CreateMemoryMappedFile(vp9_webm_data.size());
-  uint8_t* const vp9_data = vp9_data_mmap_file->data();
+  const base::span<uint8_t>vp9_data = vp9_data_mmap_file->data();
   size_t vp9_data_size = 0;
   auto packet = ScopedAVPacket::Allocate();
   size_t num_packets = 0;
@@ -346,9 +348,9 @@ std::unique_ptr<RawVideo::VP9Decoder> RawVideo::VP9Decoder::Create(
         (*vp9_stream_index)) {
       LOG_ASSERT(vp9_data_size + packet->size <= vp9_data_mmap_file->length())
           << "The vp9 data size must be less than webm file size";
-      std::memcpy(vp9_data + vp9_data_size, packet->data, packet->size);
+      std::memcpy(vp9_data .subspan( vp9_data_size).data(), packet->data, packet->size);
       vp9_data_chunks[num_packets] = base::span<const uint8_t>(
-          vp9_data + vp9_data_size, base::checked_cast<size_t>(packet->size));
+          vp9_data .subspan( vp9_data_size).data(), base::checked_cast<size_t>(packet->size));
       vp9_data_size += packet->size;
 
       Vp9FrameHeader header;
@@ -564,7 +566,7 @@ std::unique_ptr<RawVideo> RawVideo::Create(
         CreateMemoryMappedFile(video_frame_size * metadata.num_frames);
     for (size_t i = 0; i < metadata.num_frames; ++i) {
       auto buffer = vp9_decoder->DecodeFrame(i);
-      memcpy(memory_mapped_file->data() + i * video_frame_size, buffer.data(),
+      memcpy(memory_mapped_file->data() .subspan( i * video_frame_size).data(), buffer.data(),
              buffer.size());
     }
   } else {
@@ -599,15 +601,15 @@ std::unique_ptr<RawVideo> RawVideo::CreateNV12Video() const {
   LOG_ASSERT(new_memory_mapped_file) << "Failed creating memory mapped file";
   for (size_t i = 0; i < NumFrames(); ++i) {
     const FrameData i420_frame = GetFrame(i);
-    uint8_t* const nv12_frame =
-        new_memory_mapped_file->data() + i * video_frame_size_;
+    const base::span<uint8_t>nv12_frame =
+        new_memory_mapped_file->data() .subspan( i * video_frame_size_);
     int ret =
         libyuv::I420ToNV12(i420_frame.plane_addrs[0], i420_frame.strides[0],
                            i420_frame.plane_addrs[1], i420_frame.strides[1],
                            i420_frame.plane_addrs[2], i420_frame.strides[2],
-                           nv12_frame + nv12_layout->planes()[0].offset,
+                           nv12_frame .subspan( nv12_layout->planes()[0].offset).data(),
                            nv12_layout->planes()[0].stride,
-                           nv12_frame + nv12_layout->planes()[1].offset,
+                           nv12_frame .subspan( nv12_layout->planes()[1].offset).data(),
                            nv12_layout->planes()[1].stride,
                            Resolution().width(), Resolution().height());
     LOG_ASSERT(ret == 0) << "Failed converting from I420 to NV12";
@@ -656,12 +658,12 @@ std::unique_ptr<RawVideo> RawVideo::CreateExpandedVideo(
       CreateMemoryMappedFile(new_video_frame_size * NumFrames());
   CHECK(new_memory_mapped_file);
   for (size_t i = 0; i < NumFrames(); i++) {
-    uint8_t* const dst_frame =
-        new_memory_mapped_file->data() + (i * new_video_frame_size);
+    const base::span<uint8_t>dst_frame =
+        new_memory_mapped_file->data() .subspan( (i * new_video_frame_size));
     uint8_t* const dst_y_plane_visible_data =
-        dst_frame + dst_planes[0].offset + dst_y_visible_offset;
+        dst_frame .subspan( dst_planes[0].offset + dst_y_visible_offset).data();
     uint8_t* const dst_uv_plane_visible_data =
-        dst_frame + dst_planes[1].offset + dst_uv_visible_offset;
+        dst_frame .subspan( dst_planes[1].offset + dst_uv_visible_offset).data();
     FrameData src_frame = GetFrame(i);
     libyuv::NV12Copy(src_frame.plane_addrs[0], src_frame.strides[0],
                      src_frame.plane_addrs[1], src_frame.strides[1],
@@ -680,12 +682,12 @@ std::unique_ptr<RawVideo> RawVideo::CreateExpandedVideo(
 RawVideo::FrameData RawVideo::GetFrame(size_t frame_index) const {
   CHECK_LT(frame_index, NumFrames());
   std::vector<uint8_t> buffer;
-  const uint8_t* frame_addr;
+  base::span<const uint8_t>frame_addr;
   if (vp9_decoder_) {
     buffer = vp9_decoder_->DecodeFrame(frame_index);
-    frame_addr = buffer.data();
+    frame_addr = buffer;
   } else {
-    frame_addr = memory_mapped_file_->data() + video_frame_size_ * frame_index;
+    frame_addr = memory_mapped_file_->data() .subspan( video_frame_size_ * frame_index);
   }
 
   const auto& plane_layouts = FrameLayout().planes();
@@ -693,7 +695,7 @@ RawVideo::FrameData RawVideo::GetFrame(size_t frame_index) const {
   std::vector<const uint8_t*> plane_addrs(num_planes);
   std::vector<size_t> strides(num_planes);
   for (size_t i = 0; i < num_planes; ++i) {
-    plane_addrs[i] = frame_addr + plane_layouts[i].offset;
+    plane_addrs[i] = frame_addr .subspan( plane_layouts[i].offset);
     strides[i] = plane_layouts[i].stride;
   }
   return RawVideo::FrameData(plane_addrs, strides, std::move(buffer));
diff --git a/media/gpu/test/video_bitstream.cc b/media/gpu/test/video_bitstream.cc
index 35d3c17416002..606c806df6ee4 100644
--- a/media/gpu/test/video_bitstream.cc
+++ b/media/gpu/test/video_bitstream.cc
@@ -204,7 +204,7 @@ std::unique_ptr<VideoBitstream> VideoBitstream::Create(
 
 base::span<const uint8_t> VideoBitstream::Data() const {
   CHECK(memory_mapped_file_ && memory_mapped_file_->IsValid());
-  return base::span<const uint8_t>(memory_mapped_file_->data(),
+  return base::span<const uint8_t>(memory_mapped_file_->data().data(),
                                    memory_mapped_file_->length());
 }
 // static
diff --git a/media/gpu/test/video_frame_file_writer.cc b/media/gpu/test/video_frame_file_writer.cc
index 94812d4b1bbe1..d709b4f9d8b7a 100644
--- a/media/gpu/test/video_frame_file_writer.cc
+++ b/media/gpu/test/video_frame_file_writer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -235,7 +237,7 @@ void VideoFrameFileWriter::WriteVideoFramePNG(
 
   // Convert the ARGB frame to PNG.
   std::optional<std::vector<uint8_t>> png_output = gfx::PNGCodec::Encode(
-      argb_out_frame->visible_data(VideoFrame::Plane::kARGB),
+      argb_out_frame->visible_data(VideoFrame::Plane::kARGB).data(),
       gfx::PNGCodec::FORMAT_BGRA, argb_out_frame->visible_rect().size(),
       argb_out_frame->stride(VideoFrame::Plane::kARGB),
       /*discard_transparency=*/true, std::vector<gfx::PNGCodec::Comment>());
@@ -288,7 +290,7 @@ void VideoFrameFileWriter::WriteVideoFrameYUV(
   const VideoPixelFormat pixel_format = out_frame->format();
   const size_t num_planes = VideoFrame::NumPlanes(pixel_format);
   for (size_t i = 0; i < num_planes; i++) {
-    const uint8_t* data = out_frame->visible_data(i);
+    base::span<const uint8_t>data = out_frame->visible_data(i);
     const int stride = out_frame->stride(i);
     const size_t rows =
         VideoFrame::Rows(i, pixel_format, visible_size.height());
@@ -297,7 +299,7 @@ void VideoFrameFileWriter::WriteVideoFrameYUV(
     ASSERT_TRUE(stride > 0);
     for (size_t row = 0; row < rows; ++row) {
       if (yuv_file.WriteAtCurrentPos(
-              reinterpret_cast<const char*>(data + (stride * row)),
+              reinterpret_cast<const char*>(data .subspan( (stride * row).data())),
               row_bytes) != row_bytes) {
         LOG(ERROR) << "Failed to write plane #" << i << " to file: "
                    << base::File::ErrorToString(base::File::GetLastFileError());
diff --git a/media/gpu/test/video_frame_helpers.cc b/media/gpu/test/video_frame_helpers.cc
index b66903a8a5f8b..76677d53f8101 100644
--- a/media/gpu/test/video_frame_helpers.cc
+++ b/media/gpu/test/video_frame_helpers.cc
@@ -56,39 +56,39 @@ bool ConvertVideoFrameToI420(const VideoFrame* src_frame,
   const int width = visible_rect.width();
   const int height = visible_rect.height();
   uint8_t* const dst_y =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data();
   uint8_t* const dst_u =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU).data();
   uint8_t* const dst_v =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV).data();
   const int dst_stride_y = dst_frame->stride(VideoFrame::Plane::kY);
   const int dst_stride_u = dst_frame->stride(VideoFrame::Plane::kU);
   const int dst_stride_v = dst_frame->stride(VideoFrame::Plane::kV);
 
   switch (src_frame->format()) {
     case PIXEL_FORMAT_I420:
-      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                               src_frame->stride(VideoFrame::Plane::kY),
-                              src_frame->visible_data(VideoFrame::Plane::kU),
+                              src_frame->visible_data(VideoFrame::Plane::kU).data(),
                               src_frame->stride(VideoFrame::Plane::kU),
-                              src_frame->visible_data(VideoFrame::Plane::kV),
+                              src_frame->visible_data(VideoFrame::Plane::kV).data(),
                               src_frame->stride(VideoFrame::Plane::kV), dst_y,
                               dst_stride_y, dst_u, dst_stride_u, dst_v,
                               dst_stride_v, width, height) == 0;
     case PIXEL_FORMAT_NV12:
-      return libyuv::NV12ToI420(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::NV12ToI420(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kUV),
+                                src_frame->visible_data(VideoFrame::Plane::kUV).data(),
                                 src_frame->stride(VideoFrame::Plane::kUV),
                                 dst_y, dst_stride_y, dst_u, dst_stride_u, dst_v,
                                 dst_stride_v, width, height) == 0;
     case PIXEL_FORMAT_YV12:
       // Swap U and V planes.
-      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::I420Copy(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                               src_frame->stride(VideoFrame::Plane::kY),
-                              src_frame->visible_data(VideoFrame::Plane::kV),
+                              src_frame->visible_data(VideoFrame::Plane::kV).data(),
                               src_frame->stride(VideoFrame::Plane::kV),
-                              src_frame->visible_data(VideoFrame::Plane::kU),
+                              src_frame->visible_data(VideoFrame::Plane::kU).data(),
                               src_frame->stride(VideoFrame::Plane::kU), dst_y,
                               dst_stride_y, dst_u, dst_stride_u, dst_v,
                               dst_stride_v, width, height) == 0;
@@ -122,19 +122,19 @@ bool ConvertVideoFrameToYUV420P10(const VideoFrame* src_frame,
   // stride needs to be converted from bytes to pixels by dividing by 2.
   const int conversion_result = libyuv::P010ToI010(
       reinterpret_cast<const uint16_t*>(
-          src_frame->visible_data(VideoFrame::Plane::kY)),
+          src_frame->visible_data(VideoFrame::Plane::kY).data()),
       src_frame->stride(VideoFrame::Plane::kY) >> 1,
       reinterpret_cast<const uint16_t*>(
-          src_frame->visible_data(VideoFrame::Plane::kUV)),
+          src_frame->visible_data(VideoFrame::Plane::kUV).data()),
       src_frame->stride(VideoFrame::Plane::kUV) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data()),
       dst_frame->stride(VideoFrame::Plane::kY) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kU).data()),
       dst_frame->stride(VideoFrame::Plane::kU) >> 1,
       reinterpret_cast<uint16_t*>(
-          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV)),
+          dst_frame->GetWritableVisibleData(VideoFrame::Plane::kV).data()),
       dst_frame->stride(VideoFrame::Plane::kV) >> 1,
       src_frame->visible_rect().width(), src_frame->visible_rect().height());
 
@@ -152,33 +152,33 @@ bool ConvertVideoFrameToARGB(const VideoFrame* src_frame,
   const int width = visible_rect.width();
   const int height = visible_rect.height();
   uint8_t* const dst_argb =
-      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kARGB);
+      dst_frame->GetWritableVisibleData(VideoFrame::Plane::kARGB).data();
   const int dst_stride = dst_frame->stride(VideoFrame::Plane::kARGB);
 
   switch (src_frame->format()) {
     case PIXEL_FORMAT_I420:
       // Note that we use J420ToARGB instead of I420ToARGB so that the
       // kYuvJPEGConstants YUV-to-RGB conversion matrix is used.
-      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kU),
+                                src_frame->visible_data(VideoFrame::Plane::kU).data(),
                                 src_frame->stride(VideoFrame::Plane::kU),
-                                src_frame->visible_data(VideoFrame::Plane::kV),
+                                src_frame->visible_data(VideoFrame::Plane::kV).data(),
                                 src_frame->stride(VideoFrame::Plane::kV),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_NV12:
-      return libyuv::NV12ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::NV12ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kUV),
+                                src_frame->visible_data(VideoFrame::Plane::kUV).data(),
                                 src_frame->stride(VideoFrame::Plane::kUV),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_YV12:
       // Same as I420, but U and V planes are swapped.
-      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY),
+      return libyuv::J420ToARGB(src_frame->visible_data(VideoFrame::Plane::kY).data(),
                                 src_frame->stride(VideoFrame::Plane::kY),
-                                src_frame->visible_data(VideoFrame::Plane::kV),
+                                src_frame->visible_data(VideoFrame::Plane::kV).data(),
                                 src_frame->stride(VideoFrame::Plane::kV),
-                                src_frame->visible_data(VideoFrame::Plane::kU),
+                                src_frame->visible_data(VideoFrame::Plane::kU).data(),
                                 src_frame->stride(VideoFrame::Plane::kU),
                                 dst_argb, dst_stride, width, height) == 0;
     case PIXEL_FORMAT_P010LE: {
@@ -196,13 +196,13 @@ bool ConvertVideoFrameToARGB(const VideoFrame* src_frame,
 
       return libyuv::I010ToARGB(
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kY)),
+                     i010_frame->visible_data(VideoFrame::Plane::kY).data()),
                  i010_frame->stride(VideoFrame::Plane::kY) >> 1,
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kU)),
+                     i010_frame->visible_data(VideoFrame::Plane::kU).data()),
                  i010_frame->stride(VideoFrame::Plane::kU) >> 1,
                  reinterpret_cast<const uint16_t*>(
-                     i010_frame->visible_data(VideoFrame::Plane::kV)),
+                     i010_frame->visible_data(VideoFrame::Plane::kV).data()),
                  i010_frame->stride(VideoFrame::Plane::kV) >> 1, dst_argb,
                  dst_stride, width, height) == 0;
     }
@@ -248,8 +248,8 @@ bool CopyVideoFrame(const VideoFrame* src_frame,
     gfx::Size plane_size =
         VideoFrame::PlaneSize(dst_frame->format(), i, dst_frame->coded_size());
     libyuv::CopyPlane(
-        src_frame->data(i), src_frame->layout().planes()[i].stride,
-        dst_frame->writable_data(i), dst_frame->layout().planes()[i].stride,
+        src_frame->data(i).data(), src_frame->layout().planes()[i].stride,
+        dst_frame->writable_data(i).data(), dst_frame->layout().planes()[i].stride,
         plane_size.width(), plane_size.height());
   }
   return true;
@@ -308,14 +308,14 @@ scoped_refptr<VideoFrame> ScaleVideoFrame(const VideoFrame* src_frame,
       PIXEL_FORMAT_NV12, dst_resolution, gfx::Rect(dst_resolution),
       dst_resolution, src_frame->timestamp());
   const int fail_scaling = libyuv::NV12Scale(
-      src_frame->visible_data(VideoFrame::Plane::kY),
+      src_frame->visible_data(VideoFrame::Plane::kY).data(),
       src_frame->stride(VideoFrame::Plane::kY),
-      src_frame->visible_data(VideoFrame::Plane::kUV),
+      src_frame->visible_data(VideoFrame::Plane::kUV).data(),
       src_frame->stride(VideoFrame::Plane::kUV),
       src_frame->visible_rect().width(), src_frame->visible_rect().height(),
-      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kY),
+      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kY).data(),
       scaled_frame->stride(VideoFrame::Plane::kY),
-      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kUV),
+      scaled_frame->GetWritableVisibleData(VideoFrame::Plane::kUV).data(),
       scaled_frame->stride(VideoFrame::Plane::kUV), dst_resolution.width(),
       dst_resolution.height(), libyuv::FilterMode::kFilterBilinear);
   if (fail_scaling) {
diff --git a/media/gpu/test/video_frame_validator.cc b/media/gpu/test/video_frame_validator.cc
index 03b80be7314f0..94ee4f414c330 100644
--- a/media/gpu/test/video_frame_validator.cc
+++ b/media/gpu/test/video_frame_validator.cc
@@ -354,7 +354,7 @@ std::string MD5VideoFrameValidator::ComputeMD5FromVideoFrame(
     const size_t stride = video_frame.stride(i);
     for (int row = 0; row < visible_rows; ++row) {
       base::MD5Update(&context, base::span<const uint8_t>(
-                                    video_frame.data(i) + (stride * row),
+                                    video_frame.data(i) .subspan( (stride * row).data()),
                                     visible_row_bytes));
     }
   }
diff --git a/media/gpu/test/video_test_helpers.cc b/media/gpu/test/video_test_helpers.cc
index fad7ae4bcd54c..820cc7cdf900b 100644
--- a/media/gpu/test/video_test_helpers.cc
+++ b/media/gpu/test/video_test_helpers.cc
@@ -286,7 +286,7 @@ EncodedDataHelperH265::EncodedDataHelperH265(base::span<const uint8_t> stream,
                                              VideoCodec codec)
     : EncodedDataHelper(std::move(stream), codec),
       h265_parser_(std::make_unique<H265Parser>()) {
-  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_.data()),
+  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_),
                           data_.size());
 }
 
@@ -439,7 +439,7 @@ bool EncodedDataHelperH265::ReachEndOfStream() const {
 
 void EncodedDataHelperH265::Rewind() {
   h265_parser_->Reset();
-  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_.data()),
+  h265_parser_->SetStream(reinterpret_cast<uint8_t*>(data_),
                           data_.size());
   previous_nalus_.clear();
   EncodedDataHelper::Rewind();
@@ -737,10 +737,10 @@ scoped_refptr<VideoFrame> AlignedDataHelper::CreateVideoFrameFromVideoFrameData(
       return nullptr;
     }
     base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();
-    uint8_t* buf = const_cast<uint8_t*>(mapping.GetMemoryAs<uint8_t>());
+    base::span<uint8_t>buf = const_cast<uint8_t*>(mapping.GetMemoryAs<uint8_t>());
     std::array<uint8_t*, 3> data = {};
     for (size_t i = 0; i < layout_->planes().size(); i++)
-      data[i] = buf + layout_->planes()[i].offset;
+      data[i] = buf .subspan( layout_->planes()[i].offset);
 
     auto frame = media::VideoFrame::WrapExternalYuvDataWithLayout(
         *layout_, visible_rect_, natural_size_, data[0], data[1], data[2],
@@ -775,7 +775,7 @@ AlignedDataHelper::VideoFrameData AlignedDataHelper::CreateVideoFrameData(
     for (size_t i = 0; i < src_layout.planes().size(); i++) {
       libyuv::CopyPlane(
           src_frame.plane_addrs[i], src_frame.strides[i],
-          memory_frame->writable_data(i), memory_frame->stride(i),
+          memory_frame->writable_data(i).data(), memory_frame->stride(i),
           VideoFrame::RowBytes(i, pixel_format, resolution.width()),
           VideoFrame::Rows(i, pixel_format, resolution.height()));
     }
@@ -801,7 +801,7 @@ AlignedDataHelper::VideoFrameData AlignedDataHelper::CreateVideoFrameData(
     LOG_ASSERT(mapped_region.IsValid()) << "Failed allocating a region";
     base::WritableSharedMemoryMapping& mapping = mapped_region.mapping;
     LOG_ASSERT(mapping.IsValid());
-    uint8_t* buffer = mapping.GetMemoryAs<uint8_t>();
+    base::span<uint8_t>buffer = mapping.GetMemoryAs<uint8_t>();
     for (size_t i = 0; i < src_layout.planes().size(); i++) {
       auto dst_plane_layout = dst_layout.planes()[i];
       uint8_t* dst_ptr = &buffer[dst_plane_layout.offset];
diff --git a/media/gpu/vaapi/test/decode.cc b/media/gpu/vaapi/test/decode.cc
index 3903447ce3f13..a0aa0595944ec 100644
--- a/media/gpu/vaapi/test/decode.cc
+++ b/media/gpu/vaapi/test/decode.cc
@@ -10,6 +10,7 @@
 #include <sstream>
 #include <string>
 
+#include "base/containers/span.h"
 #include "base/command_line.h"
 #include "base/files/memory_mapped_file.h"
 #include "base/logging.h"
@@ -138,14 +139,14 @@ std::unique_ptr<VideoDecoder> CreateDecoder(
     const std::string& codec,
     const VaapiDevice& va_device,
     SharedVASurface::FetchPolicy fetch_policy,
-    const uint8_t* stream_data,
+    base::span<const uint8_t>stream_data,
     size_t stream_len) {
   if (codec == "H264")
-    return std::make_unique<H264Decoder>(stream_data, stream_len, va_device,
+    return std::make_unique<H264Decoder>(stream_data.data(), stream_len, va_device,
                                          fetch_policy);
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
   if (codec == "H265")
-    return std::make_unique<H265Decoder>(stream_data, stream_len, va_device,
+    return std::make_unique<H265Decoder>(stream_data.data(), stream_len, va_device,
                                          fetch_policy);
 #endif
 
diff --git a/media/gpu/vaapi/test/h265_decoder.cc b/media/gpu/vaapi/test/h265_decoder.cc
index cba76a2dc1fcf..7569442e6d6a1 100644
--- a/media/gpu/vaapi/test/h265_decoder.cc
+++ b/media/gpu/vaapi/test/h265_decoder.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -85,7 +87,7 @@ bool IsValidBitDepth(uint8_t bit_depth, VideoCodecProfile profile) {
 
 namespace vaapi_test {
 
-H265Decoder::H265Decoder(const uint8_t* stream_data,
+H265Decoder::H265Decoder(base::span<const uint8_t>stream_data,
                          size_t stream_len,
                          const VaapiDevice& va_device,
                          SharedVASurface::FetchPolicy fetch_policy)
diff --git a/media/gpu/vaapi/test/h265_decoder.h b/media/gpu/vaapi/test/h265_decoder.h
index 1a155fbee3dc0..61383f2473312 100644
--- a/media/gpu/vaapi/test/h265_decoder.h
+++ b/media/gpu/vaapi/test/h265_decoder.h
@@ -37,7 +37,7 @@ namespace media::vaapi_test {
 // the test binary.
 class H265Decoder : public VideoDecoder {
  public:
-  H265Decoder(const uint8_t* stream_data,
+  H265Decoder(base::span<const uint8_t>stream_data,
               size_t stream_len,
               const VaapiDevice& va_device,
               SharedVASurface::FetchPolicy fetch_policy);
diff --git a/media/gpu/vaapi/vaapi_video_encode_accelerator.cc b/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
index 1ca4a3a515d84..76727445a7209 100644
--- a/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
+++ b/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
@@ -13,6 +13,7 @@
 #include <utility>
 #include <variant>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/containers/contains.h"
 #include "base/containers/fixed_flat_map.h"
@@ -527,7 +528,7 @@ void VaapiVideoEncodeAccelerator::ReturnBitstreamBuffer(
     const base::UnsafeSharedMemoryRegion& shm_region = buffer.region();
     DCHECK(shm_region.IsValid());
     base::WritableSharedMemoryMapping shm_mapping = shm_region.Map();
-    uint8_t* target_data = shm_mapping.GetMemoryAs<uint8_t>();
+    base::span<uint8_t>target_data = shm_mapping.GetMemoryAs<uint8_t>();
     size_t data_size = 0;
     // vaSyncSurface() is not necessary because GetEncodedChunkSize() has been
     // called in VaapiVideoEncoderDelegate::Encode().
diff --git a/media/gpu/vaapi/vaapi_wrapper.cc b/media/gpu/vaapi/vaapi_wrapper.cc
index cac6d20ed4ab2..837c6615aa104 100644
--- a/media/gpu/vaapi/vaapi_wrapper.cc
+++ b/media/gpu/vaapi/vaapi_wrapper.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -2856,11 +2858,11 @@ bool VaapiWrapper::UploadVideoFrameToSurface(const VideoFrame& frame,
     }
 
     if (frame.format() == PIXEL_FORMAT_I420) {
-      ret = libyuv::I420ToNV12(frame.data(VideoFrame::Plane::kY),
+      ret = libyuv::I420ToNV12(frame.data(VideoFrame::Plane::kY).data(),
                                frame.stride(VideoFrame::Plane::kY),
-                               frame.data(VideoFrame::Plane::kU),
+                               frame.data(VideoFrame::Plane::kU).data(),
                                frame.stride(VideoFrame::Plane::kU),
-                               frame.data(VideoFrame::Plane::kV),
+                               frame.data(VideoFrame::Plane::kV).data(),
                                frame.stride(VideoFrame::Plane::kV),
                                image_ptr + image.offsets[0], image.pitches[0],
                                image_ptr + image.offsets[1], image.pitches[1],
@@ -2940,11 +2942,11 @@ uint64_t VaapiWrapper::GetEncodedChunkSize(VABufferID buffer_id,
 bool VaapiWrapper::DownloadFromVABuffer(
     VABufferID buffer_id,
     std::optional<VASurfaceID> sync_surface_id,
-    uint8_t* target_ptr,
+    base::span<uint8_t>target_ptr,
     size_t target_size,
     size_t* coded_data_size) NO_THREAD_SAFETY_ANALYSIS {
   VAAPI_CHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DCHECK(target_ptr);
+  DCHECK(!target_ptr.empty());
   TRACE_EVENT0("media,gpu", "VaapiWrapper::DownloadFromVABuffer");
   std::optional<base::AutoLock> auto_lock =
       AutoLockOnlyIfNeeded(va_lock_.get());
@@ -2985,9 +2987,9 @@ bool VaapiWrapper::DownloadFromVABuffer(
                    << ", the buffer segment size: " << buffer_segment->size;
         break;
       }
-      memcpy(target_ptr, buffer_segment->buf, buffer_segment->size);
+      memcpy(target_ptr.data(), buffer_segment->buf, buffer_segment->size);
 
-      target_ptr += buffer_segment->size;
+      target_ptr=target_ptr.subspan(size);
       target_size -= buffer_segment->size;
       *coded_data_size += buffer_segment->size;
       buffer_segment =
diff --git a/media/gpu/vaapi/vaapi_wrapper.h b/media/gpu/vaapi/vaapi_wrapper.h
index ac4a104f72ac6..cb1b948f3ee26 100644
--- a/media/gpu/vaapi/vaapi_wrapper.h
+++ b/media/gpu/vaapi/vaapi_wrapper.h
@@ -20,6 +20,7 @@
 #include <set>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/atomic_ref_count.h"
 #include "base/files/file.h"
 #include "base/gtest_prod_util.h"
@@ -541,7 +542,7 @@ class MEDIA_GPU_EXPORT VaapiWrapper
   [[nodiscard]] virtual bool DownloadFromVABuffer(
       VABufferID buffer_id,
       std::optional<VASurfaceID> sync_surface_id,
-      uint8_t* target_ptr,
+      base::span<uint8_t>target_ptr,
       size_t target_size,
       size_t* coded_data_size);
 
diff --git a/media/mojo/clients/mojo_decryptor_unittest.cc b/media/mojo/clients/mojo_decryptor_unittest.cc
index fc193abfb79c5..263d1e2dce367 100644
--- a/media/mojo/clients/mojo_decryptor_unittest.cc
+++ b/media/mojo/clients/mojo_decryptor_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -81,11 +83,11 @@ class MojoDecryptorTest : public ::testing::Test {
     // VideoFrame.
     auto region = base::ReadOnlySharedMemoryRegion::Create(15000);
     CHECK(region.IsValid());
-    uint8_t* data = const_cast<uint8_t*>(region.mapping.GetMemoryAs<uint8_t>());
+    base::span<uint8_t>data = const_cast<uint8_t*>(region.mapping.GetMemoryAs<uint8_t>());
     scoped_refptr<VideoFrame> frame = VideoFrame::WrapExternalYuvData(
         PIXEL_FORMAT_I420, gfx::Size(100, 100), gfx::Rect(100, 100),
-        gfx::Size(100, 100), 100, 50, 50, data, data + 100 * 100,
-        data + (100 * 100 * 5 / 4), base::Seconds(100));
+        gfx::Size(100, 100), 100, 50, 50, data.data(), data .subspan( 100 * 100).data(),
+        data .subspan( (100 * 100 * 5 / 4).data()), base::Seconds(100));
     auto read_only_mapping = region.region.Map();
     CHECK(read_only_mapping.IsValid());
     frame->BackWithOwnedSharedMemory(std::move(region.region),
diff --git a/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc b/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
index beb226d2b27bd..89a8d8a512d94 100644
--- a/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
+++ b/media/mojo/clients/mojo_video_encode_accelerator_unittest.cc
@@ -286,7 +286,7 @@ TEST_F(MojoVideoEncodeAcceleratorTest, EncodeOneFrame) {
     ASSERT_TRUE(shmem.IsValid());
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInputVisibleSize, gfx::Rect(kInputVisibleSize),
-        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory()),
+        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory().data()),
         shmem.mapping.size(), base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
diff --git a/media/mojo/services/mojo_cdm_allocator.cc b/media/mojo/services/mojo_cdm_allocator.cc
index 35d1ad4be0830..81c034bae1df5 100644
--- a/media/mojo/services/mojo_cdm_allocator.cc
+++ b/media/mojo/services/mojo_cdm_allocator.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -66,7 +68,7 @@ class MojoCdmBuffer final : public cdm::Buffer {
   uint32_t Capacity() const final { return mapped_region_->mapping.size(); }
 
   uint8_t* Data() final {
-    return mapped_region_->mapping.GetMemoryAs<uint8_t>();
+    return mapped_region_->mapping.GetMemoryAs<uint8_t>().data();
   }
 
   void SetSize(uint32_t size) final {
@@ -124,7 +126,7 @@ class MojoCdmVideoFrame final : public VideoFrameImpl {
     // Destroy the MojoCdmBuffer as it is no longer needed.
     buffer->Destroy();
 
-    uint8_t* data =
+    base::span<uint8_t>data =
         const_cast<uint8_t*>(mapped_region->mapping.GetMemoryAs<uint8_t>());
     if (PlaneOffset(cdm::kYPlane) != 0u) {
       LOG(ERROR) << "The first buffer offset is not 0";
@@ -135,8 +137,8 @@ class MojoCdmVideoFrame final : public VideoFrameImpl {
         natural_size, static_cast<int32_t>(Stride(cdm::kYPlane)),
         static_cast<int32_t>(Stride(cdm::kUPlane)),
         static_cast<int32_t>(Stride(cdm::kVPlane)),
-        data + PlaneOffset(cdm::kYPlane), data + PlaneOffset(cdm::kUPlane),
-        data + PlaneOffset(cdm::kVPlane), base::Microseconds(Timestamp()));
+        data .subspan( PlaneOffset(cdm::kYPlane)).data(), data .subspan( PlaneOffset(cdm::kUPlane)).data(),
+        data .subspan( PlaneOffset(cdm::kVPlane)).data(), base::Microseconds(Timestamp()));
 
     // |frame| could fail to be created if the memory can't be mapped into
     // this address space.
diff --git a/media/mojo/services/mojo_cdm_allocator_unittest.cc b/media/mojo/services/mojo_cdm_allocator_unittest.cc
index a25a84e756ee8..8006374cbdafd 100644
--- a/media/mojo/services/mojo_cdm_allocator_unittest.cc
+++ b/media/mojo/services/mojo_cdm_allocator_unittest.cc
@@ -72,7 +72,7 @@ TEST_F(MojoCdmAllocatorTest, ReuseCdmBuffer) {
     // Create a mapping and write some test data.
     auto& mapping = GetRegion(buffer).mapping;
     // Note: deliberately using sizeof() to include the null terminator.
-    memcpy(mapping.memory(), kTestData, sizeof(kTestData));
+    memcpy(mapping.memory().data(), kTestData, sizeof(kTestData));
   }
   buffer->Destroy();
 
@@ -83,7 +83,7 @@ TEST_F(MojoCdmAllocatorTest, ReuseCdmBuffer) {
     auto& mapping = GetRegion(new_buffer).mapping;
     // Check that the test data that was written there is still there as a proxy
     // signal for checking that the shmem region is reused.
-    EXPECT_STREQ(kTestData, mapping.GetMemoryAs<char>());
+    EXPECT_STREQ(kTestData, mapping.GetMemoryAs<char>().data());
   }
   new_buffer->Destroy();
 }
diff --git a/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc b/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
index 2e89fd9b244be..2297e1751e47c 100644
--- a/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
+++ b/media/mojo/test/mojo_video_encode_accelerator_integration_test.cc
@@ -290,7 +290,7 @@ TEST_F(MojoVideoEncodeAcceleratorIntegrationTest, EncodeOneFrame) {
     ASSERT_TRUE(shmem.IsValid());
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInputVisibleSize, gfx::Rect(kInputVisibleSize),
-        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory()),
+        kInputVisibleSize, static_cast<uint8_t*>(shmem.mapping.memory().data()),
         shmem.mapping.size(), base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
@@ -335,7 +335,7 @@ TEST_F(MojoVideoEncodeAcceleratorIntegrationTest,
     const scoped_refptr<VideoFrame> video_frame = VideoFrame::WrapExternalData(
         PIXEL_FORMAT_I420, kInvalidInputVisibleSize,
         gfx::Rect(kInvalidInputVisibleSize), kInvalidInputVisibleSize,
-        static_cast<uint8_t*>(shmem.mapping.memory()), shmem.mapping.size(),
+        static_cast<uint8_t*>(shmem.mapping.memory().data()), shmem.mapping.size(),
         base::TimeDelta());
     video_frame->BackWithSharedMemory(&shmem.region);
     const bool is_keyframe = true;
diff --git a/media/parsers/h264_parser_unittest.cc b/media/parsers/h264_parser_unittest.cc
index 9bd0d5e4d001b..f799fc38fbb37 100644
--- a/media/parsers/h264_parser_unittest.cc
+++ b/media/parsers/h264_parser_unittest.cc
@@ -113,7 +113,7 @@ TEST(H264ParserTest, StreamFileParsing) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   H264Parser parser;
-  parser.SetStream(stream.data(), stream.length());
+  parser.SetStream(stream.data().data(), stream.length());
 
   // Parse until the end of stream/unsupported stream/error in stream is found.
   size_t num_parsed_nalus = 0;
@@ -167,7 +167,7 @@ TEST(H264ParserTest, ParseNALUsFromStreamFile) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   std::vector<H264NALU> nalus;
-  ASSERT_TRUE(H264Parser::ParseNALUs(stream.data(), stream.length(), &nalus));
+  ASSERT_TRUE(H264Parser::ParseNALUs(stream.data().data(), stream.length(), &nalus));
   ASSERT_EQ(kTestFileNALUnits, nalus.size());
 }
 
diff --git a/media/parsers/h265_nalu_parser.cc b/media/parsers/h265_nalu_parser.cc
index 6abd7cbd62298..33a4ee55d1ed1 100644
--- a/media/parsers/h265_nalu_parser.cc
+++ b/media/parsers/h265_nalu_parser.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -48,22 +50,22 @@ H265NaluParser::H265NaluParser() {
 H265NaluParser::~H265NaluParser() {}
 
 void H265NaluParser::Reset() {
-  stream_ = nullptr;
+  stream_ = {};
   bytes_left_ = 0;
   encrypted_ranges_.clear();
   previous_nalu_range_.clear();
 }
 
-void H265NaluParser::SetStream(const uint8_t* stream, off_t stream_size) {
+void H265NaluParser::SetStream(base::span<const uint8_t>stream, off_t stream_size) {
   std::vector<SubsampleEntry> subsamples;
   SetEncryptedStream(stream, stream_size, subsamples);
 }
 
 void H265NaluParser::SetEncryptedStream(
-    const uint8_t* stream,
+    base::span<const uint8_t>stream,
     off_t stream_size,
     const std::vector<SubsampleEntry>& subsamples) {
-  CHECK(stream);
+  CHECK(!stream.empty());
   DCHECK_GT(stream_size, 0);
 
   stream_ = stream;
@@ -71,8 +73,8 @@ void H265NaluParser::SetEncryptedStream(
   previous_nalu_range_.clear();
 
   encrypted_ranges_.clear();
-  const uint8_t* start = stream;
-  const uint8_t* stream_end = stream_ + base::checked_cast<size_t>(bytes_left_);
+  const uint8_t* start = stream.data();
+  const uint8_t* stream_end = stream_ .subspan( base::checked_cast<size_t>(bytes_left_)).data();
   for (size_t i = 0; i < subsamples.size() && start < stream_end; ++i) {
     start += subsamples[i].clear_bytes;
 
@@ -89,18 +91,18 @@ bool H265NaluParser::LocateNALU(off_t* nalu_size, off_t* start_code_size) {
   off_t annexb_start_code_size = 0;
 
   if (!H264Parser::FindStartCodeInClearRanges(
-          stream_, bytes_left_, encrypted_ranges_, &nalu_start_off,
+          stream_.data(), bytes_left_, encrypted_ranges_, &nalu_start_off,
           &annexb_start_code_size)) {
     DVLOG(4) << "Could not find start code, end of stream?";
     return false;
   }
 
   // Move the stream to the beginning of the NALU (pointing at the start code).
-  stream_ += base::checked_cast<size_t>(nalu_start_off);
+  stream_=stream_.subspan(base::checked_cast<size_t>(nalu_start_off));
   bytes_left_ -= nalu_start_off;
 
   const uint8_t* nalu_data =
-      stream_ + base::checked_cast<size_t>(annexb_start_code_size);
+      stream_ .subspan( base::checked_cast<size_t>(annexb_start_code_size)).data();
   off_t max_nalu_data_size = bytes_left_ - annexb_start_code_size;
   if (max_nalu_data_size <= 0) {
     DVLOG(3) << "End of stream";
@@ -135,7 +137,7 @@ H265NaluParser::Result H265NaluParser::AdvanceToNextNALU(H265NALU* nalu) {
   }
 
   DCHECK(nalu);
-  nalu->data = (stream_ + base::checked_cast<size_t>(start_code_size)).get();
+  nalu->data = (stream_ .subspan( base::checked_cast<size_t>(start_code_size))).get();
   nalu->size = nalu_size_with_start_code - start_code_size;
   DVLOG(4) << "NALU found: size=" << nalu_size_with_start_code;
 
@@ -147,7 +149,7 @@ H265NaluParser::Result H265NaluParser::AdvanceToNextNALU(H265NALU* nalu) {
   // is called, we will effectively be skipping it;
   // other parsing functions will use the position saved
   // in bit reader for parsing, so we don't have to remember it here.
-  stream_ += base::checked_cast<size_t>(nalu_size_with_start_code);
+  stream_=stream_.subspan(base::checked_cast<size_t>(nalu_size_with_start_code));
   bytes_left_ -= nalu_size_with_start_code;
 
   // Read NALU header, skip the forbidden_zero_bit, but check for it.
diff --git a/media/parsers/h265_nalu_parser.h b/media/parsers/h265_nalu_parser.h
index f3f65367e9443..332e23a3a1a87 100644
--- a/media/parsers/h265_nalu_parser.h
+++ b/media/parsers/h265_nalu_parser.h
@@ -13,6 +13,8 @@
 
 #include <vector>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 #include "media/base/media_export.h"
 #include "media/base/ranges.h"
@@ -130,8 +132,8 @@ class MEDIA_EXPORT H265NaluParser {
   // |stream| owned by caller.
   // |subsamples| contains information about what parts of |stream| are
   // encrypted.
-  void SetStream(const uint8_t* stream, off_t stream_size);
-  void SetEncryptedStream(const uint8_t* stream,
+  void SetStream(base::span<const uint8_t>stream, off_t stream_size);
+  void SetEncryptedStream(base::span<const uint8_t>stream,
                           off_t stream_size,
                           const std::vector<SubsampleEntry>& subsamples);
 
@@ -163,7 +165,7 @@ class MEDIA_EXPORT H265NaluParser {
   bool LocateNALU(off_t* nalu_size, off_t* start_code_size);
 
   // Pointer to the current NALU in the stream.
-  raw_ptr<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> stream_;
+  base::raw_span<const uint8_t, AllowPtrArithmetic | DanglingUntriaged> stream_;
 
   // Bytes left in the stream after the current NALU.
   off_t bytes_left_;
diff --git a/media/parsers/ivf_parser.cc b/media/parsers/ivf_parser.cc
index 22cc1b9f4ee45..5d5fb212af206 100644
--- a/media/parsers/ivf_parser.cc
+++ b/media/parsers/ivf_parser.cc
@@ -19,15 +19,15 @@
 
 namespace media {
 
-IvfParser::IvfParser() : ptr_(nullptr), end_(nullptr) {}
+IvfParser::IvfParser() : ptr_({}), end_(nullptr) {}
 
-bool IvfParser::Initialize(const uint8_t* stream,
+bool IvfParser::Initialize(base::span<const uint8_t>stream,
                            size_t size,
                            IvfFileHeader* file_header) {
-  DCHECK(stream);
+  DCHECK(!stream.empty());
   DCHECK(file_header);
   ptr_ = stream;
-  end_ = stream + size;
+  end_ = stream .subspan( size).data();
   CHECK_GE(end_, ptr_);
 
   if (size < sizeof(IvfFileHeader)) {
@@ -38,7 +38,7 @@ bool IvfParser::Initialize(const uint8_t* stream,
   auto input =
       // TODO(crbug.com/40284755): Initialize() should receive a span, not a
       // pointer. IvfParser should hold a span, not a pointer.
-      UNSAFE_TODO(base::span(ptr_.get(), end_.get()));
+      UNSAFE_TODO(base::span(ptr_.data(), end_.get()));
   auto [in_header, in_rem] = input.split_at<sizeof(IvfFileHeader)>();
 
   // The stream is little-endian encoded, so we can just copy it into place.
@@ -57,14 +57,14 @@ bool IvfParser::Initialize(const uint8_t* stream,
   }
 
   // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-  ptr_ = in_rem.data();
+  ptr_ = in_rem;
 
   return true;
 }
 
 bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
                                const uint8_t** payload) {
-  DCHECK(ptr_);
+  DCHECK(!ptr_.empty());
   DCHECK(payload);
   CHECK_GE(end_, ptr_);
 
@@ -75,14 +75,14 @@ bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
 
   auto input =
       // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-      UNSAFE_TODO(base::span(ptr_.get(), end_.get()));
+      UNSAFE_TODO(base::span(ptr_.data(), end_.get()));
   auto [in_header, in_rem] = input.split_at<sizeof(IvfFrameHeader)>();
 
   // The stream is little-endian encoded, so we can just copy it into place.
   base::byte_span_from_ref(*frame_header).copy_from(in_header);
 
   // TODO(crbug.com/40284755): IvfParser should hold a span, not a pointer.
-  ptr_ = in_rem.data();
+  ptr_ = in_rem;
 
   if (base::checked_cast<uint32_t>(end_ - ptr_) < frame_header->frame_size) {
     DLOG(ERROR) << "Not enough frame data";
@@ -90,7 +90,7 @@ bool IvfParser::ParseNextFrame(IvfFrameHeader* frame_header,
   }
 
   *payload = ptr_;
-  ptr_ += frame_header->frame_size;
+  ptr_=ptr_.subspan(frame_size);
 
   return true;
 }
diff --git a/media/parsers/ivf_parser.h b/media/parsers/ivf_parser.h
index bb46e6c718de4..c7b8fc82314c5 100644
--- a/media/parsers/ivf_parser.h
+++ b/media/parsers/ivf_parser.h
@@ -8,6 +8,8 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/memory/raw_ptr.h"
 
 namespace media {
@@ -55,7 +57,7 @@ class IvfParser {
 
   // Initializes the parser for IVF |stream| with size |size| and parses the
   // file header. Returns true on success.
-  bool Initialize(const uint8_t* stream,
+  bool Initialize(base::span<const uint8_t>stream,
                   size_t size,
                   IvfFileHeader* file_header);
 
@@ -69,7 +71,7 @@ class IvfParser {
   bool ParseFileHeader(IvfFileHeader* file_header);
 
   // Current reading position of input stream.
-  raw_ptr<const uint8_t, AllowPtrArithmetic> ptr_;
+  base::raw_span<const uint8_t, AllowPtrArithmetic> ptr_;
 
   // The end position of input stream.
   raw_ptr<const uint8_t, AllowPtrArithmetic> end_;
diff --git a/media/parsers/temporal_scalability_id_extractor.cc b/media/parsers/temporal_scalability_id_extractor.cc
index e445367630d6b..428caf369d734 100644
--- a/media/parsers/temporal_scalability_id_extractor.cc
+++ b/media/parsers/temporal_scalability_id_extractor.cc
@@ -113,7 +113,7 @@ bool TemporalScalabilityIdExtractor::ParseH264(base::span<const uint8_t> chunk,
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
 bool TemporalScalabilityIdExtractor::ParseHEVC(base::span<const uint8_t> chunk,
                                                BitstreamMetadata& md) {
-  h265_->SetStream(chunk.data(), chunk.size());
+  h265_->SetStream(chunk, chunk.size());
   H265NALU nalu;
   H265NaluParser::Result result;
   while ((result = h265_->AdvanceToNextNALU(&nalu)) !=
diff --git a/media/parsers/temporal_scalability_id_extractor_unittest.cc b/media/parsers/temporal_scalability_id_extractor_unittest.cc
index 8ffe04bd804db..ddf7d22412629 100644
--- a/media/parsers/temporal_scalability_id_extractor_unittest.cc
+++ b/media/parsers/temporal_scalability_id_extractor_unittest.cc
@@ -83,7 +83,7 @@ std::vector<scoped_refptr<media::DecoderBuffer>> ReadIVF(
   media::IvfParser ivf_parser;
   media::IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
 
   std::vector<scoped_refptr<media::DecoderBuffer>> buffers;
diff --git a/media/parsers/webp_parser_unittest.cc b/media/parsers/webp_parser_unittest.cc
index a82d13b19770e..4b75cd43d350c 100644
--- a/media/parsers/webp_parser_unittest.cc
+++ b/media/parsers/webp_parser_unittest.cc
@@ -204,7 +204,7 @@ TEST(WebPParserTest, ParseLossyWebP) {
       << "Couldn't open stream file: " << file_path.MaybeAsASCII();
 
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_TRUE(result);
 
   ASSERT_TRUE(result->IsKeyframe());
@@ -231,7 +231,7 @@ TEST(WebPParserTest, ParseLosslessWebP) {
 
   // Should fail because WebP parser does not parse lossless webp images.
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_FALSE(result);
 }
 
@@ -250,7 +250,7 @@ TEST(WebPParserTest, ParseExtendedWebP) {
 
   // Should fail because WebP parser does not parse extended webp images.
   std::unique_ptr<Vp8FrameHeader> result =
-      ParseWebPImage(base::span<const uint8_t>(stream.data(), stream.length()));
+      ParseWebPImage(base::span<const uint8_t>(stream.data().data(), stream.length()));
   ASSERT_FALSE(result);
 }
 
diff --git a/media/renderers/paint_canvas_video_renderer.cc b/media/renderers/paint_canvas_video_renderer.cc
index 66d5fedddea80..52ff3eead5780 100644
--- a/media/renderers/paint_canvas_video_renderer.cc
+++ b/media/renderers/paint_canvas_video_renderer.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -310,7 +313,7 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
 
   struct PlaneMetaData {
     size_t stride;
-    raw_ptr<const uint8_t> data;
+    base::raw_span<const uint8_t> data;
   };
   std::array<PlaneMetaData, VideoFrame::kMaxPlanes> plane_meta;
 
@@ -322,11 +325,11 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
           // pixel on row N and column M will wrap to column M on row N + 1.
           .stride = video_frame->stride(plane),
 
-          .data = video_frame->visible_data(plane) +
+          .data = video_frame->visible_data(plane) .subspan(
                   video_frame->stride(plane) * (chunk_start * rows_per_chunk) /
-                      VideoFrame::SampleSize(format, plane).height()};
+                      VideoFrame)::SampleSize(format, plane).height()};
     } else {
-      plane_meta[plane] = {.stride = 0, .data = nullptr};
+      plane_meta[plane] = {.stride = 0, .data = {}};
     }
   }
 
@@ -336,7 +339,7 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   if (format == PIXEL_FORMAT_ARGB || format == PIXEL_FORMAT_XRGB ||
       format == PIXEL_FORMAT_ABGR || format == PIXEL_FORMAT_XBGR) {
     DCHECK_LE(width, static_cast<int>(row_bytes));
-    const uint8_t* data = plane_meta[VideoFrame::Plane::kARGB].data;
+    base::span<const uint8_t>data = plane_meta[VideoFrame::Plane::kARGB].data;
 
     // Handle order swapping depending on the source and destination formats.
     if ((OUTPUT_ARGB &&
@@ -345,12 +348,12 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
          (format == PIXEL_FORMAT_ABGR || format == PIXEL_FORMAT_XBGR))) {
       uint8_t* dest = pixels;
       for (size_t i = 0; i < rows; i++) {
-        memcpy(dest, data, width * 4);
+        memcpy(dest, data.data(), width * 4);
         dest += row_bytes;
-        data += plane_meta[VideoFrame::Plane::kARGB].stride;
+        data=data.subspan(stride);
       }
     } else {
-      LIBYUV_ABGR_TO_ARGB(plane_meta[VideoFrame::Plane::kARGB].data,
+      LIBYUV_ABGR_TO_ARGB(plane_meta[VideoFrame::Plane::kARGB].data.data(),
                           plane_meta[VideoFrame::Plane::kARGB].stride, pixels,
                           row_bytes, width, rows);
     }
@@ -373,11 +376,11 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   const libyuv::YuvConstants* matrix =
       GetYuvContantsForColorSpace(yuv_cs, OUTPUT_ARGB);
 
-  if (!video_frame->data(VideoFrame::Plane::kU) &&
-      !video_frame->data(VideoFrame::Plane::kV)) {
+  if ().empty() &&
+      ).empty()) {
     DCHECK_EQ(format, PIXEL_FORMAT_I420);
     // For monochrome content ARGB and ABGR are interchangeable.
-    libyuv::I400ToARGBMatrix(plane_meta[VideoFrame::Plane::kY].data,
+    libyuv::I400ToARGBMatrix(plane_meta[VideoFrame::Plane::kY].data.data(),
                              plane_meta[VideoFrame::Plane::kY].stride, pixels,
                              row_bytes, matrix, width, rows);
     done->Run();
@@ -432,13 +435,13 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
 
   auto convert_yuv16 = [&](const libyuv::YuvConstants* matrix, auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          pixels, row_bytes, matrix, width, rows);
   };
@@ -446,29 +449,29 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   auto convert_yuv16_with_filter = [&](const libyuv::YuvConstants* matrix,
                                        auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          pixels, row_bytes, matrix, width, rows, filter);
   };
 
   auto convert_yuva16 = [&](const libyuv::YuvConstants* matrix, auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          reinterpret_cast<const uint16_t*>(
-             plane_meta[VideoFrame::Plane::kA].data.get()),
+             plane_meta[VideoFrame::Plane::kA].data),
          plane_meta[VideoFrame::Plane::kA].stride / 2, pixels, row_bytes,
          matrix, width, rows, premultiply_alpha);
   };
@@ -476,16 +479,16 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
   auto convert_yuva16_with_filter = [&](const libyuv::YuvConstants* matrix,
                                         auto&& func) {
     func(YUV_ORDER(reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kY].data.get()),
+                       plane_meta[VideoFrame::Plane::kY].data),
                    plane_meta[VideoFrame::Plane::kY].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kU].data.get()),
+                       plane_meta[VideoFrame::Plane::kU].data),
                    plane_meta[VideoFrame::Plane::kU].stride / 2,
                    reinterpret_cast<const uint16_t*>(
-                       plane_meta[VideoFrame::Plane::kV].data.get()),
+                       plane_meta[VideoFrame::Plane::kV].data),
                    plane_meta[VideoFrame::Plane::kV].stride / 2),
          reinterpret_cast<const uint16_t*>(
-             plane_meta[VideoFrame::Plane::kA].data.get()),
+             plane_meta[VideoFrame::Plane::kA].data),
          plane_meta[VideoFrame::Plane::kA].stride / 2, pixels, row_bytes,
          matrix, width, rows, premultiply_alpha, filter);
   };
@@ -503,13 +506,13 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
       if (video_frame->ColorSpace().GetMatrixID() ==
           gfx::ColorSpace::MatrixID::GBR) {
         libyuv::MergeARGBPlane(
-            GBR_TO_RGB_ORDER(plane_meta[VideoFrame::Plane::kY].data,
+            GBR_TO_RGB_ORDER(plane_meta[VideoFrame::Plane::kY].data.data(),
                              plane_meta[VideoFrame::Plane::kY].stride,
-                             plane_meta[VideoFrame::Plane::kU].data,
+                             plane_meta[VideoFrame::Plane::kU].data.data(),
                              plane_meta[VideoFrame::Plane::kU].stride,
-                             plane_meta[VideoFrame::Plane::kV].data,
+                             plane_meta[VideoFrame::Plane::kV].data.data(),
                              plane_meta[VideoFrame::Plane::kV].stride),
-            plane_meta[VideoFrame::Plane::kA].data,
+            plane_meta[VideoFrame::Plane::kA].data.data(),
             plane_meta[VideoFrame::Plane::kA].stride, pixels, row_bytes, width,
             rows);
       } else {
@@ -548,19 +551,19 @@ void ConvertVideoFrameToRGBPixelsTask(const VideoFrame* video_frame,
       break;
 
     case PIXEL_FORMAT_NV12:
-      LIBYUV_NV12_TO_ARGB_MATRIX(plane_meta[VideoFrame::Plane::kY].data,
+      LIBYUV_NV12_TO_ARGB_MATRIX(plane_meta[VideoFrame::Plane::kY].data.data(),
                                  plane_meta[VideoFrame::Plane::kY].stride,
-                                 plane_meta[VideoFrame::Plane::kUV].data,
+                                 plane_meta[VideoFrame::Plane::kUV].data.data(),
                                  plane_meta[VideoFrame::Plane::kUV].stride,
                                  pixels, row_bytes, matrix, width, rows);
       break;
     case PIXEL_FORMAT_P010LE:
       libyuv::P010ToARGBMatrix(
           reinterpret_cast<const uint16_t*>(
-              plane_meta[VideoFrame::Plane::kY].data.get()),
+              plane_meta[VideoFrame::Plane::kY].data.data()),
           plane_meta[VideoFrame::Plane::kY].stride,
           reinterpret_cast<const uint16_t*>(
-              plane_meta[VideoFrame::Plane::kUV].data.get()),
+              plane_meta[VideoFrame::Plane::kUV].data.data()),
           plane_meta[VideoFrame::Plane::kUV].stride, pixels, row_bytes, matrix,
           width, rows);
       if (!OUTPUT_ARGB)
@@ -797,7 +800,7 @@ class VideoImageGenerator : public cc::PaintImageGenerator {
 
       // Copy the frame to the supplied memory. It'd be nice to avoid this copy,
       // but the memory is externally owned so we can't w/o an API change.
-      libyuv::CopyPlane(frame_->visible_data(plane), frame_->stride(plane),
+      libyuv::CopyPlane(frame_->visible_data(plane).data(), frame_->stride(plane),
                         reinterpret_cast<uint8_t*>(out_plane.writable_addr()),
                         out_plane.rowBytes(), plane_size.width(),
                         plane_size.height());
@@ -1163,8 +1166,8 @@ scoped_refptr<VideoFrame> DownShiftHighbitVideoFrame(
     int height = VideoFrame::Rows(plane, video_frame->format(),
                                   video_frame->visible_rect().height());
     const uint16_t* src =
-        reinterpret_cast<const uint16_t*>(video_frame->visible_data(plane));
-    uint8_t* dst = ret->GetWritableVisibleData(plane);
+        reinterpret_cast<const uint16_t*>(video_frame->visible_data(plane).data());
+    uint8_t* dst = ret->GetWritableVisibleData(plane).data();
     if (!src) {
       // An AV1 monochrome (grayscale) frame has no U and V planes. Set all U
       // and V samples to the neutral value (128).
@@ -1186,19 +1189,19 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
                        unsigned type,
                        bool flip_y,
                        size_t output_row_bytes) {
-  const uint8_t* row_head = video_frame->visible_data(0);
+  base::span<const uint8_t>row_head = video_frame->visible_data(0);
   const size_t stride = video_frame->stride(0);
   const int height = video_frame->visible_rect().height();
-  for (int i = 0; i < height; ++i, row_head += stride) {
+  for (int i = 0; i < height; ++i, row_head=row_head.subspan(stride)) {
     uint8_t* out_row_head = flip_y ? out + output_row_bytes * (height - i - 1)
                                    : out + output_row_bytes * i;
-    const uint16_t* row = reinterpret_cast<const uint16_t*>(row_head);
-    const uint16_t* row_end = row + video_frame->visible_rect().width();
+    base::span<const uint16_t>row = reinterpret_cast<const uint16_t*>(row_head);
+    const uint16_t* row_end = row .subspan( video_frame->visible_rect().width()).data();
     if (type == GL_FLOAT) {
       float* out_row = reinterpret_cast<float*>(out_row_head);
       if (format == GL_RGBA) {
         while (row < row_end) {
-          float gray_value = *row++ / 65535.f;
+          float gray_value = (row++)[0] / 65535.f;
           *out_row++ = gray_value;
           *out_row++ = gray_value;
           *out_row++ = gray_value;
@@ -1207,7 +1210,7 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
         continue;
       } else if (format == GL_RED) {
         while (row < row_end)
-          *out_row++ = *row++ / 65535.f;
+          *out_row++ = (row++)[0] / 65535.f;
         continue;
       }
       // For other formats, hit NOTREACHED below.
@@ -1219,7 +1222,7 @@ void FlipAndConvertY16(const VideoFrame* video_frame,
       DCHECK_EQ(static_cast<unsigned>(GL_RGBA), format);
       uint32_t* rgba = reinterpret_cast<uint32_t*>(out_row_head);
       while (row < row_end) {
-        uint32_t gray_value = *row++ >> 8;
+        uint32_t gray_value = (row++)[0] >> 8;
         *rgba++ = SkColorSetRGB(gray_value, gray_value, gray_value);
       }
       continue;
@@ -1349,8 +1352,8 @@ void PaintCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
       // frame with no U and V planes. Since there are no 10-bit and 12-bit
       // versions of libyuv::I400ToARGBMatrix(), convert the frame to an 8-bit
       // YUV 4:2:0 frame with U and V planes.
-      if (!video_frame->data(VideoFrame::Plane::kU) &&
-          !video_frame->data(VideoFrame::Plane::kV)) {
+      if ().empty() &&
+          ).empty()) {
         temporary_frame = DownShiftHighbitVideoFrame(video_frame);
         video_frame = temporary_frame.get();
       }
diff --git a/media/renderers/paint_canvas_video_renderer_unittest.cc b/media/renderers/paint_canvas_video_renderer_unittest.cc
index 2ca5b03e3f7f2..4c18eab37d5a3 100644
--- a/media/renderers/paint_canvas_video_renderer_unittest.cc
+++ b/media/renderers/paint_canvas_video_renderer_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -252,11 +254,11 @@ static scoped_refptr<VideoFrame> CreateCroppedFrame() {
   };
 
   libyuv::I420Copy(cropped_y_plane, 16, cropped_u_plane, 8, cropped_v_plane, 8,
-                   cropped_frame->writable_data(VideoFrame::Plane::kY),
+                   cropped_frame->writable_data(VideoFrame::Plane::kY).data(),
                    cropped_frame->stride(VideoFrame::Plane::kY),
-                   cropped_frame->writable_data(VideoFrame::Plane::kU),
+                   cropped_frame->writable_data(VideoFrame::Plane::kU).data(),
                    cropped_frame->stride(VideoFrame::Plane::kU),
-                   cropped_frame->writable_data(VideoFrame::Plane::kV),
+                   cropped_frame->writable_data(VideoFrame::Plane::kV).data(),
                    cropped_frame->stride(VideoFrame::Plane::kV), 16, 16);
 
   return cropped_frame;
@@ -462,14 +464,14 @@ TEST_F(PaintCanvasVideoRendererTest, CroppedFrameToRGBParallel) {
       gfx::Size(1920, 810), base::TimeDelta());
 
   // Fill in the frame with the same data as the cropped frame.
-  libyuv::I420Scale(cropped_frame()->data(0), cropped_frame()->stride(0),
-                    cropped_frame()->data(1), cropped_frame()->stride(1),
-                    cropped_frame()->data(2), cropped_frame()->stride(2),
+  libyuv::I420Scale(cropped_frame()->data(0).data(), cropped_frame()->stride(0),
+                    cropped_frame()->data(1).data(), cropped_frame()->stride(1),
+                    cropped_frame()->data(2).data(), cropped_frame()->stride(2),
                     cropped_frame()->coded_size().width(),
                     cropped_frame()->coded_size().height(),
-                    test_frame->writable_data(0), test_frame->stride(0),
-                    test_frame->writable_data(1), test_frame->stride(1),
-                    test_frame->writable_data(2), test_frame->stride(2),
+                    test_frame->writable_data(0).data(), test_frame->stride(0),
+                    test_frame->writable_data(1).data(), test_frame->stride(1),
+                    test_frame->writable_data(2).data(), test_frame->stride(2),
                     test_frame->coded_size().width(),
                     test_frame->coded_size().height(), libyuv::kFilterNone);
 
@@ -661,14 +663,14 @@ TEST_F(PaintCanvasVideoRendererTest, HighBitDepth) {
     for (int plane = VideoFrame::Plane::kY; plane <= VideoFrame::Plane::kV;
          ++plane) {
       int width = cropped_frame()->row_bytes(plane);
-      uint16_t* dst = reinterpret_cast<uint16_t*>(frame->writable_data(plane));
-      const uint8_t* src = cropped_frame()->data(plane);
+      base::span<uint16_t>dst = reinterpret_cast<uint16_t*>(frame->writable_data(plane));
+      base::span<const uint8_t>src = cropped_frame()->data(plane);
       for (int row = 0; row < cropped_frame()->rows(plane); row++) {
         for (int col = 0; col < width; col++) {
           dst[col] = src[col] << (param.bit_depth - 8);
         }
-        src += cropped_frame()->stride(plane);
-        dst += frame->stride(plane) / 2;
+        src=src.subspan(cropped_frame()->stride(plane));
+        dst=dst.subspan(frame->stride(plane) / 2);
       }
     }
 
diff --git a/media/renderers/video_frame_yuv_converter.cc b/media/renderers/video_frame_yuv_converter.cc
index 9616bb82de719..c0d487c464a91 100644
--- a/media/renderers/video_frame_yuv_converter.cc
+++ b/media/renderers/video_frame_yuv_converter.cc
@@ -149,7 +149,7 @@ gpu::SyncToken ConvertYuvVideoFrameToRgbSharedImage(
     SkImageInfo info = SkImageInfo::Make(gfx::SizeToSkISize(plane_size),
                                          color_type, kPlaneAlphaType);
     pixmaps[plane] =
-        SkPixmap(info, video_frame->data(plane), video_frame->stride(plane));
+        SkPixmap(info, video_frame->data(plane).data(), video_frame->stride(plane));
   }
 
   // Prepare the SkYUVAInfo
diff --git a/media/renderers/video_resource_updater.cc b/media/renderers/video_resource_updater.cc
index 8007d0b12ac80..67eb73d982b4d 100644
--- a/media/renderers/video_resource_updater.cc
+++ b/media/renderers/video_resource_updater.cc
@@ -997,7 +997,7 @@ bool VideoResourceUpdater::WriteRGBPixelsToTexture(
     // We can passthrough when the texture format matches. Since we
     // always copy the entire coded area we don't have to worry about
     // origin.
-    source_pixels = video_frame->data(VideoFrame::Plane::kARGB);
+    source_pixels = video_frame->data(VideoFrame::Plane::kARGB).data();
   } else {
     size_t needed_size = bytes_per_row * video_frame->coded_size().height();
     if (upload_pixels_size_[0] < needed_size) {
@@ -1102,7 +1102,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
     const uint8_t* pixels;
     int pixels_stride_in_bytes;
     if (!needs_conversion) {
-      pixels = video_frame->data(frame_planes[plane_index]);
+      pixels = video_frame->data(frame_planes[plane_index]).data();
       pixels_stride_in_bytes = video_stride_bytes;
     } else {
       // Avoid malloc for each frame/plane if possible.
@@ -1126,7 +1126,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         float libyuv_multiplier = 1.f / max_value;
         libyuv::HalfFloatPlane(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes,
             reinterpret_cast<uint16_t*>(upload_pixels_[plane_index].get()),
             upload_image_stride, libyuv_multiplier,
@@ -1137,7 +1137,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         const int scale = 0x10000 >> (bits_per_channel - 8);
         libyuv::Convert16To8Plane(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes / 2, upload_pixels_[plane_index].get(),
             upload_image_stride, scale, bytes_per_row,
             resource_size_pixels.height());
@@ -1145,7 +1145,7 @@ bool VideoResourceUpdater::WriteYUVPixelsForAllPlanesToTexture(
         CHECK_EQ(resource_bit_depth, 16u);
         libyuv::ConvertToMSBPlane_16(
             reinterpret_cast<const uint16_t*>(
-                video_frame->data(frame_planes[plane_index])),
+                video_frame->data(frame_planes[plane_index]).data()),
             video_stride_bytes / 2,
             reinterpret_cast<uint16_t*>(upload_pixels_[plane_index].get()),
             upload_image_stride / 2, resource_size_pixels.width(),
diff --git a/media/renderers/video_resource_updater_unittest.cc b/media/renderers/video_resource_updater_unittest.cc
index 64f0c8c6cd301..249fb229abd0c 100644
--- a/media/renderers/video_resource_updater_unittest.cc
+++ b/media/renderers/video_resource_updater_unittest.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <array>
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -123,7 +126,7 @@ class VideoResourceUpdaterTest : public testing::Test {
     const int kYWidth = kDimension + 5;
     const int kUWidth = (kYWidth + 1) / 2 + 200;
     const int kVWidth = (kYWidth + 1) / 2 + 1;
-    static uint8_t y_data[kYWidth * kDimension] = {};
+    static std::array<uint8_t, kYWidth * kDimension> y_data = {};
     static uint8_t u_data[kUWidth * kDimension] = {};
     static uint8_t v_data[kVWidth * kDimension] = {};
 
@@ -135,7 +138,7 @@ class VideoResourceUpdaterTest : public testing::Test {
         -kYWidth,                                 // y_stride (negative)
         kUWidth,                                  // u_stride
         kVWidth,                                  // v_stride
-        y_data + kYWidth * (kDimension - 1),      // y_data
+        base::span<uint8_t>(y_data ).subspan( kYWidth * ().data()kDimension - 1),      // y_data
         u_data,                                   // u_data
         v_data,                                   // v_data
         base::TimeDelta());                       // timestamp
@@ -398,7 +401,7 @@ TEST_F(VideoResourceUpdaterTest, SoftwareFrameRGBNonOrigin) {
         VideoFrame::BytesPerElement(fmt, VideoFrame::Plane::kARGB);
     auto* dest_pixels = gl_->last_upload() + rect.y() * bytes_per_row +
                         rect.x() * bytes_per_element;
-    auto* src_pixels = video_frame->visible_data(VideoFrame::Plane::kARGB);
+    base::span<const uint8_t>src_pixels = video_frame->visible_data(VideoFrame::Plane::kARGB);
 
     // Pixels are 0xFFFFFFFF, so channel reordering doesn't matter.
     for (int y = 0; y < rect.height(); ++y) {
diff --git a/media/video/alpha_video_encoder_wrapper_unittest.cc b/media/video/alpha_video_encoder_wrapper_unittest.cc
index 7cbced931cdf9..f123e5c5ffe24 100644
--- a/media/video/alpha_video_encoder_wrapper_unittest.cc
+++ b/media/video/alpha_video_encoder_wrapper_unittest.cc
@@ -96,11 +96,11 @@ class AlphaVideoEncoderWrapperTest
     uint32_t y = color & 0xFF;
     uint32_t u = (color >> 8) & 0xFF;
     uint32_t v = (color >> 16) & 0xFF;
-    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                      frame->stride(VideoFrame::Plane::kY),
-                     frame->writable_data(VideoFrame::Plane::kU),
+                     frame->writable_data(VideoFrame::Plane::kU).data(),
                      frame->stride(VideoFrame::Plane::kU),
-                     frame->writable_data(VideoFrame::Plane::kV),
+                     frame->writable_data(VideoFrame::Plane::kV).data(),
                      frame->stride(VideoFrame::Plane::kV),
                      frame->visible_rect().x(),       // x
                      frame->visible_rect().y(),       // y
@@ -109,7 +109,7 @@ class AlphaVideoEncoderWrapperTest
                      y,                               // Y color
                      u,                               // U color
                      v);                              // V color
-    libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA),
+    libyuv::SetPlane(frame->writable_data(VideoFrame::Plane::kA).data(),
                      frame->stride(VideoFrame::Plane::kA),
                      frame->visible_rect().width(),   // width
                      frame->visible_rect().height(),  // height
diff --git a/media/video/av1_video_encoder.cc b/media/video/av1_video_encoder.cc
index b23e8166c2003..1f7163b9a40ea 100644
--- a/media/video/av1_video_encoder.cc
+++ b/media/video/av1_video_encoder.cc
@@ -494,7 +494,7 @@ void Av1VideoEncoder::Encode(scoped_refptr<VideoFrame> frame,
   aom_image_t* image = aom_img_wrap(
       &image_, GetAomImgFormat(frame->format()), options_.frame_size.width(),
       options_.frame_size.height(), 1,
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::Plane::kY)));
+      const_cast<uint8_t*>(frame->visible_data(VideoFrame::Plane::kY).data()));
   DCHECK_EQ(image, &image_);
 
   // Resizing should have been taken care of above.
diff --git a/media/video/fake_gpu_memory_buffer.cc b/media/video/fake_gpu_memory_buffer.cc
index 0066457007202..dd5ef14d762f9 100644
--- a/media/video/fake_gpu_memory_buffer.cc
+++ b/media/video/fake_gpu_memory_buffer.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -56,7 +58,7 @@ class FakeGpuMemoryBufferImpl : public gpu::GpuMemoryBufferImpl {
   bool AsyncMappingIsNonBlocking() const override {
     return fake_gmb_->AsyncMappingIsNonBlocking();
   }
-  void* memory(size_t plane) override { return fake_gmb_->memory(plane); }
+  base::span<void> memory(size_t plane) override { return fake_gmb_->memory(plane); }
   void Unmap() override { fake_gmb_->Unmap(); }
   int stride(size_t plane) const override { return fake_gmb_->stride(plane); }
   gfx::GpuMemoryBufferType GetType() const override {
@@ -147,12 +149,11 @@ bool FakeGpuMemoryBuffer::AsyncMappingIsNonBlocking() const {
   return true;
 }
 
-void* FakeGpuMemoryBuffer::memory(size_t plane) {
+base::span<void> FakeGpuMemoryBuffer::memory(size_t plane) {
   DCHECK_LT(plane, VideoFrame::NumPlanes(video_pixel_format_));
-  auto* data_ptr = data_.data();
+  base::span<value_type>data_ptr = data_;
   for (size_t i = 1; i <= plane; i++) {
-    data_ptr +=
-        VideoFrame::PlaneSize(video_pixel_format_, i - 1, size_).GetArea();
+    data_ptr=data_ptr.subspan(VideoFrame::PlaneSize(video_pixel_format_, i - 1, size_).GetArea());
   }
   return data_ptr;
 }
diff --git a/media/video/fake_gpu_memory_buffer.h b/media/video/fake_gpu_memory_buffer.h
index c6f4c1af5fd11..7199db63d0215 100644
--- a/media/video/fake_gpu_memory_buffer.h
+++ b/media/video/fake_gpu_memory_buffer.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "media/base/video_types.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 
@@ -57,7 +58,7 @@ class FakeGpuMemoryBuffer : public gfx::GpuMemoryBuffer {
   bool Map() override;
   void MapAsync(base::OnceCallback<void(bool)> result_cb) override;
   bool AsyncMappingIsNonBlocking() const override;
-  void* memory(size_t plane) override;
+  base::span<void> memory(size_t plane) override;
   void Unmap() override;
   gfx::Size GetSize() const override;
   gfx::BufferFormat GetFormat() const override;
diff --git a/media/video/gpu_memory_buffer_video_frame_pool.cc b/media/video/gpu_memory_buffer_video_frame_pool.cc
index 3d7c7c1c8e5c7..766cb0ec2b77f 100644
--- a/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -346,7 +348,7 @@ void CopyRowsToI420Buffer(int first_row,
                           int rows,
                           int bytes_per_row,
                           size_t bit_depth,
-                          const uint8_t* source,
+                          base::span<const uint8_t>source,
                           int source_stride,
                           uint8_t* output,
                           int dest_stride) {
@@ -362,13 +364,13 @@ void CopyRowsToI420Buffer(int first_row,
   DCHECK_GE(bit_depth, 8u);
 
   if (bit_depth == 8) {
-    libyuv::CopyPlane(source + source_stride * first_row, source_stride,
+    libyuv::CopyPlane(source .subspan( source_stride * first_row).data(), source_stride,
                       output + dest_stride * first_row, dest_stride,
                       bytes_per_row, rows);
   } else {
     const int scale = 0x10000 >> (bit_depth - 8);
     libyuv::Convert16To8Plane(
-        reinterpret_cast<const uint16_t*>(source + source_stride * first_row),
+        reinterpret_cast<const uint16_t*>(source .subspan( source_stride * first_row).data()),
         source_stride / 2, output + dest_stride * first_row, dest_stride, scale,
         bytes_per_row, rows);
   }
@@ -395,16 +397,16 @@ void CopyRowsToP010Buffer(int first_row,
             source_frame->stride(VideoFrame::Plane::kY));
 
   const uint16_t* y_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kY) +
-      first_row * source_frame->stride(VideoFrame::Plane::kY));
+      source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+      first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
   const size_t y_plane_stride = source_frame->stride(VideoFrame::Plane::kY) / 2;
   const uint16_t* u_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kU) +
-      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU));
+      source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU)).data());
   const size_t u_plane_stride = source_frame->stride(VideoFrame::Plane::kU) / 2;
   const uint16_t* v_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kV) +
-      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV));
+      source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+      (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV)).data());
   const size_t v_plane_stride = source_frame->stride(VideoFrame::Plane::kV) / 2;
 
   libyuv::I010ToP010(
@@ -451,14 +453,14 @@ void CopyRowsToNV12Buffer(int first_row,
 
     if (source_frame->format() == PIXEL_FORMAT_NV12) {
       libyuv::CopyPlane(
-          source_frame->visible_data(VideoFrame::Plane::kY) +
-              first_row * source_frame->stride(VideoFrame::Plane::kY),
+          source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+              first_row * source_frame->stride(VideoFrame::Plane::kY)).data(),
           source_frame->stride(VideoFrame::Plane::kY),
           dest_y + first_row * dest_stride_y, dest_stride_y, bytes_per_row_y,
           rows_y);
       libyuv::CopyPlane(
-          source_frame->visible_data(VideoFrame::Plane::kUV) +
-              first_row / 2 * source_frame->stride(VideoFrame::Plane::kUV),
+          source_frame->visible_data(VideoFrame::Plane::kUV) .subspan(
+              first_row / 2 * source_frame->stride(VideoFrame::Plane::kUV)).data(),
           source_frame->stride(VideoFrame::Plane::kUV),
           dest_uv + first_row / 2 * dest_stride_uv, dest_stride_uv,
           bytes_per_row_uv, rows_uv);
@@ -467,14 +469,14 @@ void CopyRowsToNV12Buffer(int first_row,
     }
 
     libyuv::I420ToNV12(
-        source_frame->visible_data(VideoFrame::Plane::kY) +
-            first_row * source_frame->stride(VideoFrame::Plane::kY),
+        source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+            first_row * source_frame->stride(VideoFrame::Plane::kY)).data(),
         source_frame->stride(VideoFrame::Plane::kY),
-        source_frame->visible_data(VideoFrame::Plane::kU) +
-            first_row / 2 * source_frame->stride(VideoFrame::Plane::kU),
+        source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+            first_row / 2 * source_frame->stride(VideoFrame::Plane::kU)).data(),
         source_frame->stride(VideoFrame::Plane::kU),
-        source_frame->visible_data(VideoFrame::Plane::kV) +
-            first_row / 2 * source_frame->stride(VideoFrame::Plane::kV),
+        source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+            first_row / 2 * source_frame->stride(VideoFrame::Plane::kV)).data(),
         source_frame->stride(VideoFrame::Plane::kV),
         dest_y + first_row * dest_stride_y, dest_stride_y,
         dest_uv + first_row / 2 * dest_stride_uv, dest_stride_uv,
@@ -484,18 +486,18 @@ void CopyRowsToNV12Buffer(int first_row,
               source_frame->stride(VideoFrame::Plane::kY));
 
     const uint16_t* y_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kY) +
-        first_row * source_frame->stride(VideoFrame::Plane::kY));
+        source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+        first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
     const size_t y_plane_stride =
         source_frame->stride(VideoFrame::Plane::kY) / 2;
     const uint16_t* u_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kU) +
-        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU));
+        source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kU)).data());
     const size_t u_plane_stride =
         source_frame->stride(VideoFrame::Plane::kU) / 2;
     const uint16_t* v_plane = reinterpret_cast<const uint16_t*>(
-        source_frame->visible_data(VideoFrame::Plane::kV) +
-        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV));
+        source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+        (first_row / 2) * source_frame->stride(VideoFrame::Plane::kV)).data());
     const size_t v_plane_stride =
         source_frame->stride(VideoFrame::Plane::kV) / 2;
 
@@ -525,14 +527,14 @@ void CopyRowsToRGB10Buffer(bool is_rgba,
   DCHECK_EQ(source_frame->format(), PIXEL_FORMAT_YUV420P10);
 
   const auto* y_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kY) +
-      first_row * source_frame->stride(VideoFrame::Plane::kY));
+      source_frame->visible_data(VideoFrame::Plane::kY) .subspan(
+      first_row * source_frame->stride(VideoFrame::Plane::kY)).data());
   const auto* u_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kU) +
-      first_row / 2 * source_frame->stride(VideoFrame::Plane::kU));
+      source_frame->visible_data(VideoFrame::Plane::kU) .subspan(
+      first_row / 2 * source_frame->stride(VideoFrame::Plane::kU)).data());
   const auto* v_plane = reinterpret_cast<const uint16_t*>(
-      source_frame->visible_data(VideoFrame::Plane::kV) +
-      first_row / 2 * source_frame->stride(VideoFrame::Plane::kV));
+      source_frame->visible_data(VideoFrame::Plane::kV) .subspan(
+      first_row / 2 * source_frame->stride(VideoFrame::Plane::kV)).data());
 
   size_t y_plane_stride = source_frame->stride(VideoFrame::Plane::kY) / 2;
   size_t u_plane_stride = source_frame->stride(VideoFrame::Plane::kU) / 2;
diff --git a/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc b/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
index dc69aa5b41340..eb95cf123f5a8 100644
--- a/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
+++ b/media/video/gpu_memory_buffer_video_frame_pool_unittest.cc
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -72,11 +75,11 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
     RunUntilIdle();
     mock_gpu_factories_.reset();
 
-    if (y_data_)
+    if (!y_data_.empty())
       delete[] y_data_;
-    if (u_data_)
+    if (!u_data_.empty())
       delete[] u_data_;
-    if (v_data_)
+    if (!v_data_.empty())
       delete[] v_data_;
     if (uv_data_)
       delete[] uv_data_;
@@ -155,9 +158,9 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
         size.width() * multiplier,                         // y_stride
         dimension_aligned * multiplier / 2,                // u_stride
         dimension_aligned * multiplier / 2,                // v_stride
-        y_data_,                                           // y_data
-        u_data_,                                           // u_data
-        v_data_,                                           // v_data
+        y_data_.data(),                                           // y_data
+        u_data_.data(),                                           // u_data
+        v_data_.data(),                                           // v_data
         base::TimeDelta());                                // timestamp
     EXPECT_TRUE(video_frame);
     return video_frame;
@@ -240,7 +243,7 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
                                         size,                // natural_size
                                         size.width(),        // y_stride
                                         dimension_aligned,   // uv_stride
-                                        y_data_,             // y_data
+                                        y_data_.data(),             // y_data
                                         uv_data_,            // uv_data
                                         base::TimeDelta());  // timestamp
     EXPECT_TRUE(video_frame);
@@ -261,9 +264,9 @@ class GpuMemoryBufferVideoFramePoolTest : public ::testing::Test {
   static constexpr uint8_t kUValue = 50;
   static constexpr uint8_t kVValue = 150;
 
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> y_data_ = nullptr;
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> u_data_ = nullptr;
-  raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> v_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> y_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> u_data_ = nullptr;
+  base::raw_span<uint8_t, DanglingUntriaged | AllowPtrArithmetic> v_data_ = nullptr;
   raw_ptr<uint8_t, DanglingUntriaged | AllowPtrArithmetic> uv_data_ = nullptr;
 
   base::SimpleTestTickClock test_clock_;
@@ -340,11 +343,11 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest, CreateOneHardwareFrameWithOddSize) {
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* u_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>u_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
-    const auto* v_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>v_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(2));
 
     // Y plane = 9x9, U and V plan = 5x5.
@@ -434,18 +437,18 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
     // Copy 10 bpp to I420.
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* u_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>u_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
-    const auto* v_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>v_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(2));
 
-    const uint16_t* y_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>y_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kY));
-    const uint16_t* u_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>u_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kU));
-    const uint16_t* v_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>v_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kV));
 
     // Y plane = 17x17 = 289, U and V plan = 9x9.
@@ -573,9 +576,9 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* uv_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>uv_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
     // Y plane = 5x5, U and V plan = 3x3.
@@ -642,9 +645,9 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-    const auto* y_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>y_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const auto* uv_memory = reinterpret_cast<uint8_t*>(
+    base::span<const uint8_t>uv_memory = reinterpret_cast<uint8_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
     // Y plane = 135x135 = 18225, UV plan = 136x68 = 9248.
@@ -722,11 +725,11 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest, CreateOneHardwareP010Frame) {
   EXPECT_EQ(1u, mock_gpu_factories_->created_memory_buffers().size());
   mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
-  const uint16_t* y_memory = reinterpret_cast<uint16_t*>(
+  base::span<const uint16_t>y_memory = reinterpret_cast<uint16_t*>(
       mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
   EXPECT_EQ(software_frame->visible_data(VideoFrame::Plane::kY)[0] << 6,
             y_memory[0]);
-  const uint16_t* uv_memory = reinterpret_cast<uint16_t*>(
+  base::span<const uint16_t>uv_memory = reinterpret_cast<uint16_t*>(
       mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
   EXPECT_EQ(software_frame->visible_data(VideoFrame::Plane::kU)[0] << 6,
             uv_memory[0]);
@@ -761,16 +764,16 @@ TEST_F(GpuMemoryBufferVideoFramePoolTest,
     mock_gpu_factories_->created_memory_buffers()[0]->Map();
 
     // Copy I010 To P010.
-    const uint16_t* y_memory = reinterpret_cast<uint16_t*>(
+    base::span<const uint16_t>y_memory = reinterpret_cast<uint16_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(0));
-    const uint16_t* uv_memory = reinterpret_cast<uint16_t*>(
+    base::span<const uint16_t>uv_memory = reinterpret_cast<uint16_t*>(
         mock_gpu_factories_->created_memory_buffers()[0]->memory(1));
 
-    const uint16_t* y_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>y_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kY));
-    const uint16_t* u_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>u_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kU));
-    const uint16_t* v_plane_data = reinterpret_cast<const uint16_t*>(
+    base::span<const uint16_t>v_plane_data = reinterpret_cast<const uint16_t*>(
         software_frame->visible_data(VideoFrame::Plane::kV));
 
     // Y plane = 7x7 = 49, U and V plan = 4x4 = 16.
diff --git a/media/video/video_encode_accelerator_adapter.cc b/media/video/video_encode_accelerator_adapter.cc
index 5c4fc961fae97..a86a80acc80de 100644
--- a/media/video/video_encode_accelerator_adapter.cc
+++ b/media/video/video_encode_accelerator_adapter.cc
@@ -1054,7 +1054,7 @@ VideoEncodeAcceleratorAdapter::PrepareCpuFrame(
                               : src_frame;
   auto shared_frame = VideoFrame::WrapExternalData(
       PIXEL_FORMAT_I420, dest_coded_size, dest_visible_rect,
-      dest_visible_rect.size(), static_cast<const uint8_t*>(mapping->memory()),
+      dest_visible_rect.size(), static_cast<const uint8_t*>(mapping->memory().data()),
       mapping->size(), src_frame->timestamp());
 
   if (!shared_frame || !mapped_src_frame)
diff --git a/media/video/video_encode_accelerator_adapter_test.cc b/media/video/video_encode_accelerator_adapter_test.cc
index af5410c8455cc..16708c34a0f57 100644
--- a/media/video/video_encode_accelerator_adapter_test.cc
+++ b/media/video/video_encode_accelerator_adapter_test.cc
@@ -125,11 +125,11 @@ class VideoEncodeAcceleratorAdapterTest
                                          gfx::Rect(size), size, timestamp);
 
     // Green I420 frame (Y:0x96, U:0x40, V:0x40)
-    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY),
+    libyuv::I420Rect(frame->writable_data(VideoFrame::Plane::kY).data(),
                      frame->stride(VideoFrame::Plane::kY),
-                     frame->writable_data(VideoFrame::Plane::kU),
+                     frame->writable_data(VideoFrame::Plane::kU).data(),
                      frame->stride(VideoFrame::Plane::kU),
-                     frame->writable_data(VideoFrame::Plane::kV),
+                     frame->writable_data(VideoFrame::Plane::kV).data(),
                      frame->stride(VideoFrame::Plane::kV),
                      0,                               // left
                      0,                               // top
@@ -149,7 +149,7 @@ class VideoEncodeAcceleratorAdapterTest
                                          gfx::Rect(size), size, timestamp);
 
     // Green XRGB frame (R:0x3B, G:0xD9, B:0x24)
-    libyuv::ARGBRect(frame->writable_data(VideoFrame::Plane::kARGB),
+    libyuv::ARGBRect(frame->writable_data(VideoFrame::Plane::kARGB).data(),
                      frame->stride(VideoFrame::Plane::kARGB),
                      0,                               // left
                      0,                               // top
diff --git a/media/video/vpx_video_encoder.cc b/media/video/vpx_video_encoder.cc
index 2380b6c3692be..aa789223624ee 100644
--- a/media/video/vpx_video_encoder.cc
+++ b/media/video/vpx_video_encoder.cc
@@ -314,7 +314,7 @@ void I444ToI410(const VideoFrame& frame, vpx_image_t* vpx_image) {
   auto stride = base::span(vpx_image->stride);
   for (size_t i = 0; i < VideoFrame::NumPlanes(frame.format()); ++i) {
     libyuv::Convert8To16Plane(
-        frame.visible_data(i), frame.stride(i),
+        frame.visible_data(i).data(), frame.stride(i),
         reinterpret_cast<uint16_t*>(planes[i]), stride[i] / 2, 1024,
         VideoFrame::Columns(i, frame.format(),
                             frame.visible_rect().size().width()),
@@ -659,11 +659,11 @@ void VpxVideoEncoder::Encode(scoped_refptr<VideoFrame> frame,
         break;
       }
       RecreateVpxImageIfNeeded(VPX_IMG_FMT_I42016, /*needs_memory=*/true);
-      libyuv::I420ToI010(frame->visible_data(VideoFrame::Plane::kY),
+      libyuv::I420ToI010(frame->visible_data(VideoFrame::Plane::kY).data(),
                          frame->stride(VideoFrame::Plane::kY),
-                         frame->visible_data(VideoFrame::Plane::kU),
+                         frame->visible_data(VideoFrame::Plane::kU).data(),
                          frame->stride(VideoFrame::Plane::kU),
-                         frame->visible_data(VideoFrame::Plane::kV),
+                         frame->visible_data(VideoFrame::Plane::kV).data(),
                          frame->stride(VideoFrame::Plane::kV),
                          reinterpret_cast<uint16_t*>(planes[VPX_PLANE_Y]),
                          stride[VPX_PLANE_Y] / 2,
diff --git a/mojo/core/embedder_unittest.cc b/mojo/core/embedder_unittest.cc
index 56adf67612e23..c974e00b80e3b 100644
--- a/mojo/core/embedder_unittest.cc
+++ b/mojo/core/embedder_unittest.cc
@@ -331,7 +331,7 @@ TEST_F(EmbedderTest, MultiprocessBaseSharedMemory) {
     // expected value.
     auto mapping = shared_memory.Map();
     ASSERT_TRUE(mapping.IsValid());
-    EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory())));
+    EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory().data())));
 
     ASSERT_EQ(MOJO_RESULT_OK, MojoClose(sb1));
 
@@ -368,7 +368,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(MultiprocessSharedMemoryClient,
   auto mapping = shared_memory.Map();
   ASSERT_TRUE(mapping.IsValid());
   EXPECT_NE(buffer, mapping.memory());
-  EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory())));
+  EXPECT_EQ(kByeWorld, std::string(static_cast<char*>(mapping.memory().data())));
 
   EXPECT_EQ("bye", ReadMessage(client_mp));
 
diff --git a/mojo/core/invitation_unittest.cc b/mojo/core/invitation_unittest.cc
index 00ec10d88e7d8..d4a447550d101 100644
--- a/mojo/core/invitation_unittest.cc
+++ b/mojo/core/invitation_unittest.cc
@@ -1038,7 +1038,7 @@ TEST_F(MAYBE_InvitationTest, MultiBrokerNetwork) {
 MojoHandle CreateMemory(std::string_view contents) {
   auto region = base::WritableSharedMemoryRegion::Create(contents.size());
   auto mapping = region.Map();
-  memcpy(mapping.memory(), contents.data(), contents.size());
+  memcpy(mapping.memory().data(), contents.data(), contents.size());
   auto buffer = WrapReadOnlySharedMemoryRegion(
       base::WritableSharedMemoryRegion::ConvertToReadOnly(std::move(region)));
   return buffer.release().value();
@@ -1048,7 +1048,7 @@ std::string ReadMemory(MojoHandle handle) {
   auto region = UnwrapReadOnlySharedMemoryRegion(
       ScopedSharedBufferHandle{SharedBufferHandle{handle}});
   auto mapping = region.Map();
-  std::string_view contents{reinterpret_cast<const char*>(mapping.memory()),
+  std::string_view contents{reinterpret_cast<const char*>(mapping.memory().data()),
                             region.GetSize()};
   return std::string{contents};
 }
diff --git a/mojo/core/ipcz_driver/transport_test.cc b/mojo/core/ipcz_driver/transport_test.cc
index b9a1e9940dd5a..6625a78e41b13 100644
--- a/mojo/core/ipcz_driver/transport_test.cc
+++ b/mojo/core/ipcz_driver/transport_test.cc
@@ -475,7 +475,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(TransmitMemoryClient,
       DeserializeObjectFrom<SharedBuffer>(*transport, message)->region()));
   EXPECT_EQ(kMemoryMessage.size(), region.GetSize());
   auto mapping = region.Map();
-  auto contents = std::string_view(static_cast<const char*>(mapping.memory()),
+  auto contents = std::string_view(static_cast<const char*>(mapping.memory().data()),
                                    kMemoryMessage.size());
   EXPECT_EQ(kMemoryMessage, contents);
   EXPECT_EQ(MOJO_RESULT_OK, MojoClose(h));
@@ -488,7 +488,7 @@ TEST_F(MojoIpczTransportTest, TransmitMemory) {
 
     auto region = base::UnsafeSharedMemoryRegion::Create(kMemoryMessage.size());
     auto mapping = region.Map();
-    memcpy(mapping.memory(), kMemoryMessage.data(), kMemoryMessage.size());
+    memcpy(mapping.memory().data(), kMemoryMessage.data(), kMemoryMessage.size());
     auto buffer = SharedBuffer::MakeForRegion(std::move(region));
 
     TransportListener listener(*transport);
diff --git a/mojo/public/cpp/base/big_buffer.h b/mojo/public/cpp/base/big_buffer.h
index 3b125fd3b387a..91ed027289f01 100644
--- a/mojo/public/cpp/base/big_buffer.h
+++ b/mojo/public/cpp/base/big_buffer.h
@@ -143,34 +143,34 @@ class COMPONENT_EXPORT(MOJO_BASE) BigBuffer {
   }
 
   iterator begin() {
-    uint8_t* const ptr = data();
+    const base::span<uint8_t>ptr = *data();
     // SAFETY: If this is an invalid buffer, `ptr` is null and `size()` is zero,
     // which results in a well-defined (null) result. Otherwise, the underlying
     // storage (`bytes_` or `shared_memory_`) guarantees that `ptr` points to at
     // least `size()` bytes.
-    return UNSAFE_BUFFERS(iterator(ptr, ptr + size()));
+    return UNSAFE_BUFFERS(iterator(ptr.data(), ptr + size()));
   }
 
   const_iterator begin() const {
-    const uint8_t* const ptr = data();
+    const base::span<const uint8_t>ptr = *data();
     // SAFETY: As in the non-const version above.
-    return UNSAFE_BUFFERS(const_iterator(ptr, ptr + size()));
+    return UNSAFE_BUFFERS(const_iterator(ptr.data(), ptr + size()));
   }
 
   const_iterator cbegin() const { return begin(); }
 
   iterator end() {
-    uint8_t* const ptr = data();
+    const base::span<uint8_t>ptr = *data();
     const size_t len = size();
     // SAFETY: As in `begin()` above.
-    return UNSAFE_BUFFERS(iterator(ptr, ptr + len, ptr + len));
+    return UNSAFE_BUFFERS(iterator(ptr.data(), ptr + len, ptr + len));
   }
 
   const_iterator end() const {
-    const uint8_t* const ptr = data();
+    const base::span<const uint8_t>ptr = *data();
     const size_t len = size();
     // SAFETY: As in the non-const version above.
-    return UNSAFE_BUFFERS(const_iterator(ptr, ptr + len, ptr + len));
+    return UNSAFE_BUFFERS(const_iterator(ptr.data(), ptr + len, ptr + len));
   }
 
   const_iterator cend() const { return end(); }
diff --git a/remoting/host/video_memory_utils.cc b/remoting/host/video_memory_utils.cc
index 988bf031d85f5..57efbd26a202a 100644
--- a/remoting/host/video_memory_utils.cc
+++ b/remoting/host/video_memory_utils.cc
@@ -74,7 +74,7 @@ SharedVideoMemory::SharedVideoMemory(base::ReadOnlySharedMemoryRegion region,
                                      webrtc::SharedMemory::Handle handle,
                                      int id,
                                      base::OnceClosure on_deleted_callback)
-    : SharedMemory(mapping.memory(), mapping.size(), handle, id),
+    : SharedMemory(mapping.memory().data(), mapping.size(), handle, id),
       on_deleted_callback_(std::move(on_deleted_callback))
 #if BUILDFLAG(IS_WIN)
       ,
diff --git a/remoting/host/video_memory_utils.h b/remoting/host/video_memory_utils.h
index 3587e453fca77..1869be85d8dc8 100644
--- a/remoting/host/video_memory_utils.h
+++ b/remoting/host/video_memory_utils.h
@@ -93,7 +93,7 @@ class IpcSharedBufferCore
 
   int id() const { return id_; }
   size_t size() const { return mapping_.size(); }
-  const void* memory() const { return mapping_.memory(); }
+  const void* memory() const { return mapping_.memory().data(); }
 
  private:
   ~IpcSharedBufferCore();
diff --git a/services/audio/input_sync_writer.cc b/services/audio/input_sync_writer.cc
index 0d514271a128f..23535c4c23085 100644
--- a/services/audio/input_sync_writer.cc
+++ b/services/audio/input_sync_writer.cc
@@ -95,15 +95,15 @@ InputSyncWriter::InputSyncWriter(
   audio_buses_.resize(shared_memory_segment_count);
 
   // Create vector of audio buses by wrapping existing blocks of memory.
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
-  CHECK(ptr);
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  CHECK(!ptr.empty());
   for (auto& bus : audio_buses_) {
     CHECK_EQ(0U, reinterpret_cast<uintptr_t>(ptr) &
                      (media::AudioBus::kChannelAlignment - 1));
     media::AudioInputBuffer* buffer =
-        reinterpret_cast<media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
     bus = media::AudioBus::WrapMemory(params, buffer->audio);
-    ptr += shared_memory_segment_size_;
+    ptr=ptr.subspan(shared_memory_segment_size_);
   }
 }
 
@@ -419,10 +419,10 @@ bool InputSyncWriter::SignalDataWrittenAndUpdateCounters() {
 
 media::AudioInputBuffer* InputSyncWriter::GetSharedInputBuffer(
     uint32_t segment_id) {
-  uint8_t* ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
+  base::span<uint8_t>ptr = static_cast<uint8_t*>(shared_memory_mapping_.memory());
   CHECK_LT(segment_id, audio_buses_.size());
-  ptr += segment_id * shared_memory_segment_size_;
-  return reinterpret_cast<media::AudioInputBuffer*>(ptr);
+  ptr=ptr.subspan(segment_id * shared_memory_segment_size_);
+  return reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
 }
 
 }  // namespace audio
diff --git a/services/audio/input_sync_writer_unittest.cc b/services/audio/input_sync_writer_unittest.cc
index 92d75c7535ff6..99da4ac1c99b2 100644
--- a/services/audio/input_sync_writer_unittest.cc
+++ b/services/audio/input_sync_writer_unittest.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -221,11 +223,11 @@ class InputSyncWriterTest
     socket_->Read(1);
 
     size_t segment_id = current_renderer_side_buffer_ % kSegments;
-    uint8_t* ptr =
+    base::span<uint8_t>ptr =
         static_cast<uint8_t*>(renderer_shared_memory_mapping_.memory());
-    ptr += segment_id * segment_length_;
+    ptr=ptr.subspan(segment_id * segment_length_);
     media::AudioInputBuffer* buffer =
-        reinterpret_cast<media::AudioInputBuffer*>(ptr);
+        reinterpret_cast<media::AudioInputBuffer*>(ptr.data());
     EXPECT_EQ(base::subtle::NoBarrier_Load(&(buffer->params.has_unread_data)),
               1);
     base::subtle::Release_Store(&(buffer->params.has_unread_data), 0);
diff --git a/services/audio/sync_reader.cc b/services/audio/sync_reader.cc
index b4888f7556f69..a7629fbb1aaed 100644
--- a/services/audio/sync_reader.cc
+++ b/services/audio/sync_reader.cc
@@ -69,7 +69,7 @@ SyncReader::SyncReader(
   if (shared_memory_region_.IsValid() && shared_memory_mapping_.IsValid() &&
       base::CancelableSyncSocket::CreatePair(&socket_, foreign_socket)) {
     auto* const buffer =
-        shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>();
+        shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>().data();
     output_bus_ = media::AudioBus::WrapMemory(params, buffer->audio);
     output_bus_->Zero();
     output_bus_->set_is_bitstream_format(params.IsBitstreamFormat());
@@ -114,7 +114,7 @@ void SyncReader::RequestMoreData(base::TimeDelta delay,
   // bytes might lead to being descheduled. The reading side will zero
   // them when consumed.
   auto* const buffer =
-      shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>();
+      shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>().data();
   // Increase the number of skipped frames stored in shared memory.
   buffer->params.delay_us = delay.InMicroseconds();
   buffer->params.delay_timestamp_us =
@@ -189,7 +189,7 @@ bool SyncReader::Read(media::AudioBus* dest, bool is_mixing) {
   if (output_bus_->is_bitstream_format()) {
     // For bitstream formats, we need the real data size and PCM frame count.
     auto* const buffer =
-        shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>();
+        shared_memory_mapping_.GetMemoryAs<media::AudioOutputBuffer>().data();
     uint32_t data_size = buffer->params.bitstream_data_size;
     uint32_t bitstream_frames = buffer->params.bitstream_frames;
     if (data_size > output_bus_buffer_size_) {
diff --git a/services/audio/sync_reader_unittest.cc b/services/audio/sync_reader_unittest.cc
index 53aaf4c4f86de..82d146b920792 100644
--- a/services/audio/sync_reader_unittest.cc
+++ b/services/audio/sync_reader_unittest.cc
@@ -79,7 +79,7 @@ TEST_P(SyncReaderBitstreamTest, BitstreamBufferOverflow_DoesNotWriteOOB) {
   base::WritableSharedMemoryMapping shmem =
       reader.TakeSharedMemoryRegion().Map();
   ASSERT_TRUE(shmem.IsValid());
-  auto* const buffer = shmem.GetMemoryAs<media::AudioOutputBuffer>();
+  auto* const buffer = shmem.GetMemoryAs<media::AudioOutputBuffer>().data();
   ASSERT_TRUE(buffer);
   reader.RequestMoreData(base::TimeDelta(), base::TimeTicks(), {});
 
@@ -158,7 +158,7 @@ class SyncReaderTest : public ::testing::Test {
     reader_->set_max_wait_timeout_for_test(base::Milliseconds(999));
     shmem_ = reader_->TakeSharedMemoryRegion().Map();
     CHECK(shmem_.IsValid());
-    buffer_ = shmem_.GetMemoryAs<media::AudioOutputBuffer>();
+    buffer_ = shmem_.GetMemoryAs<media::AudioOutputBuffer>().data();
     CHECK(buffer_);
   }
 
diff --git a/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc b/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
index d4e0dddac3f1b..1ed2b2f6c03be 100644
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest.cc
@@ -150,7 +150,7 @@ TEST_F(PlatformSensorAndProviderTest, SharedBufferDefaultValue) {
       GetSensorReadingSharedBufferOffset(mojom::SensorType::AMBIENT_LIGHT),
       sizeof(SensorReadingSharedBuffer));
 
-  const auto* buffer = mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+  const auto* buffer = mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 0);
 }
 
diff --git a/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc b/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
index 92308b4ced345..24735bfb7142b 100644
--- a/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
+++ b/services/device/generic_sensor/platform_sensor_and_provider_unittest_linux.cc
@@ -551,7 +551,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckAmbientLightReadings) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 50);
 
   EXPECT_TRUE(sensor->StopListening(client.get(), configuration));
@@ -593,7 +593,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest,
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kAccelerometerScalingValue;
   EXPECT_THAT(buffer->reading.accel.x,
               RoundAccelerometerValue(
@@ -647,7 +647,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckLinearAcceleration) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.accel.x, 0.0);
   EXPECT_THAT(buffer->reading.accel.y, 0.0);
   EXPECT_THAT(static_cast<int>(buffer->reading.accel.z),
@@ -690,7 +690,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckGyroscopeReadingConversion) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kGyroscopeScalingValue;
   EXPECT_THAT(buffer->reading.gyro.x,
               RoundGyroscopeValue(scaling *
@@ -740,7 +740,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest, CheckMagnetometerReadingConversion) {
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   double scaling = kMagnetometerScalingValue * kMicroteslaInGauss;
   EXPECT_THAT(buffer->reading.magn.x,
               RoundMagnetometerValue(
@@ -789,7 +789,7 @@ TEST_F(PlatformSensorAndProviderLinuxTest,
   WaitOnSensorReadingChangedEvent(client.get(), sensor->GetType());
 
   const SensorReadingSharedBuffer* buffer =
-      mapping.GetMemoryAs<SensorReadingSharedBuffer>();
+      mapping.GetMemoryAs<SensorReadingSharedBuffer>().data();
   EXPECT_THAT(buffer->reading.als.value, 50);
 
   EXPECT_TRUE(sensor->StopListening(client.get(), configuration));
diff --git a/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc b/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
index 2442ac71de2f7..1dc6bf28223bd 100644
--- a/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
+++ b/services/device/public/cpp/generic_sensor/sensor_reading_shared_buffer_reader.cc
@@ -44,7 +44,7 @@ SensorReadingSharedBufferReader::Create(base::ReadOnlySharedMemoryRegion region,
 
 bool SensorReadingSharedBufferReader::GetReading(SensorReading* result) {
   DCHECK(mapping_.IsValid());
-  return GetReading(mapping_.GetMemoryAs<device::SensorReadingSharedBuffer>(),
+  return GetReading(mapping_.GetMemoryAs<device::SensorReadingSharedBuffer>().data(),
                     result);
 }
 
diff --git a/services/passage_embeddings/passage_embedder.cc b/services/passage_embeddings/passage_embedder.cc
index 0adc947fb30de..930e07785107b 100644
--- a/services/passage_embeddings/passage_embedder.cc
+++ b/services/passage_embeddings/passage_embedder.cc
@@ -113,7 +113,7 @@ bool PassageEmbedder::LoadSentencePieceModelFile(base::File sp_file) {
   }
 
   auto model_proto = std::make_unique<sentencepiece::ModelProto>();
-  model_proto->ParseFromArray(sp_model.data(), sp_model.length());
+  model_proto->ParseFromArray(sp_model.data().data(), sp_model.length());
   sp_processor_ = std::make_unique<sentencepiece::SentencePieceProcessor>();
   if (!(sp_processor_->Load(std::move(model_proto)).ok())) {
     sp_processor_.reset();
diff --git a/services/tracing/public/cpp/perfetto/shared_memory.cc b/services/tracing/public/cpp/perfetto/shared_memory.cc
index b85064adfa387..947b96297f883 100644
--- a/services/tracing/public/cpp/perfetto/shared_memory.cc
+++ b/services/tracing/public/cpp/perfetto/shared_memory.cc
@@ -40,7 +40,7 @@ base::UnsafeSharedMemoryRegion ChromeBaseSharedMemory::CloneRegion() {
 }
 
 const void* ChromeBaseSharedMemory::start() const {
-  return mapping_.memory();
+  return mapping_.memory().data();
 }
 
 size_t ChromeBaseSharedMemory::size() const {
diff --git a/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc b/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
index adbe5b881dc1f..7e9d03d36ffb7 100644
--- a/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
+++ b/services/viz/public/cpp/compositing/bitmap_in_shared_memory_mojom_traits.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -70,17 +72,17 @@ StructTraits<viz::mojom::BitmapInSharedMemoryDataView,
 
     auto* src_pixels = static_cast<const uint8_t*>(sk_bitmap.getPixels());
     size_t src_stride = sk_bitmap.rowBytes();
-    auto* dst_pixels = static_cast<uint8_t*>(mapping.memory());
+    base::span<uint8_t>dst_pixels = static_cast<uint8_t*>(mapping.memory());
 
     // If source and destination stride are the same use a single copy
     // operation, otherwise do a row-by-row copy.
     if (src_stride == min_row_bytes) {
-      memcpy(dst_pixels, src_pixels, byte_size);
+      memcpy(dst_pixels.data(), src_pixels, byte_size);
     } else {
       for (int y = 0; y < sk_bitmap.height(); ++y) {
-        memcpy(dst_pixels, src_pixels, min_row_bytes);
+        memcpy(dst_pixels.data(), src_pixels, min_row_bytes);
         src_pixels += src_stride;
-        dst_pixels += min_row_bytes;
+        dst_pixels=dst_pixels.subspan(min_row_bytes);
       }
     }
   }
@@ -114,7 +116,7 @@ bool StructTraits<viz::mojom::BitmapInSharedMemoryDataView, SkBitmap>::Read(
     return false;
   }
 
-  if (!sk_bitmap->installPixels(image_info, mapping_ptr->memory(),
+  if (!sk_bitmap->installPixels(image_info, mapping_ptr->memory().data(),
                                 data.row_bytes(), &DeleteSharedMemoryMapping,
                                 mapping_ptr.get())) {
     return false;
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
index ca77fdb152c56..6fee43409f8fa 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_argument_context_test.cc
@@ -37,7 +37,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
 
     EXPECT_EQ(expected_leftmost_relation, context.LeftmostRelation())
@@ -74,7 +74,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext argument_context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     for (CheckPseudoHasArgumentTraversalIterator iterator(*has_anchor_element,
                                                           argument_context);
@@ -102,7 +102,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     EXPECT_EQ(selector_list->First()->GetPseudoType(), CSSSelector::kPseudoHas);
 
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     return context.TraversalType();
   }
@@ -127,7 +127,7 @@ class CheckPseudoHasArgumentContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         css_test_helpers::ParseSelectorList(selector_text);
     CheckPseudoHasArgumentContext argument_context(
-        selector_list->First()->SelectorList()->First(), /*scope=*/nullptr,
+        selector_list->First()->SelectorList()->First().data(), /*scope=*/nullptr,
         match_in_shadow_tree);
     for (CheckPseudoHasArgumentTraversalIterator iterator(*has_anchor_element,
                                                           argument_context);
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
index d52d767b77ed4..c69275ff0a720 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_cache_scope_context_test.cc
@@ -101,7 +101,7 @@ class CheckPseudoHasCacheScopeContextTest : public PageTestBase {
     CSSSelectorList* selector_list =
         CSSSelectorList::AdoptSelectorVector(selector_vector);
     const CSSSelector* selector = nullptr;
-    for (selector = selector_list->First();
+    for (selector = selector_list->First().data();
          selector && selector->GetPseudoType() != CSSSelector::kPseudoHas;
          selector = selector->NextSimpleSelector()) {
     }
@@ -110,7 +110,7 @@ class CheckPseudoHasCacheScopeContextTest : public PageTestBase {
                     << selector_text << ")";
       return;
     }
-    const CSSSelector* argument_selector = selector->SelectorList()->First();
+    const CSSSelector* argument_selector = selector->SelectorList()->First().data();
 
     CheckPseudoHasArgumentContext argument_context(argument_selector,
                                                    /*scope=*/nullptr,
diff --git a/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc b/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
index 07d20e24777bb..c415365ed8814 100644
--- a/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
+++ b/third_party/blink/renderer/core/css/check_pseudo_has_fast_reject_filter_test.cc
@@ -48,7 +48,7 @@ class CheckPseudoHasFastRejectFilterTest : public PageTestBase {
     EXPECT_EQ(selector_list->First()->GetPseudoType(), CSSSelector::kPseudoHas);
 
     CheckPseudoHasArgumentContext context(
-        selector_list->First()->SelectorList()->First(),
+        selector_list->First()->SelectorList()->First().data(),
         /*scope=*/nullptr,
         /* match_in_shadow_tree */ false);
 
diff --git a/third_party/blink/renderer/core/css/css_selector.cc b/third_party/blink/renderer/core/css/css_selector.cc
index 179b00ca4dada..961ad49d6fce0 100644
--- a/third_party/blink/renderer/core/css/css_selector.cc
+++ b/third_party/blink/renderer/core/css/css_selector.cc
@@ -1111,7 +1111,7 @@ template <bool expand_pseudo_references>
 void CSSSelector::SerializeSelectorList(const CSSSelectorList* selector_list,
                                         StringBuilder& builder,
                                         uintptr_t scope_id) {
-  const CSSSelector* first_sub_selector = selector_list->First();
+  const CSSSelector* first_sub_selector = selector_list->First().data();
   for (const CSSSelector* sub_selector = first_sub_selector; sub_selector;
        sub_selector = CSSSelectorList::Next(*sub_selector)) {
     if (sub_selector != first_sub_selector) {
@@ -1572,7 +1572,7 @@ bool CSSSelector::HasLinkOrVisited() const {
       return true;
     }
     if (const CSSSelectorList* list = current->SelectorList()) {
-      for (const CSSSelector* sub_selector = list->First(); sub_selector;
+      for (const CSSSelector* sub_selector = list->First().data(); sub_selector;
            sub_selector = CSSSelectorList::Next(*sub_selector)) {
         if (sub_selector->HasLinkOrVisited()) {
           return true;
@@ -1883,7 +1883,7 @@ static bool ForAnyInComplexSelector(const Functor& functor,
       return true;
     }
     if (const CSSSelectorList* selector_list = current->SelectorList()) {
-      for (const CSSSelector* sub_selector = selector_list->First();
+      for (const CSSSelector* sub_selector = selector_list->First().data();
            sub_selector; sub_selector = CSSSelectorList::Next(*sub_selector)) {
         if (ForAnyInComplexSelector(functor, *sub_selector)) {
           return true;
@@ -2019,7 +2019,7 @@ const CSSSelector* CSSSelector::SelectorListOrParent() const {
       return nullptr;
     }
   } else if (HasRareData() && data_.rare_data_->selector_list_) {
-    return data_.rare_data_->selector_list_->First();
+    return data_.rare_data_->selector_list_->First().data();
   } else {
     return nullptr;
   }
diff --git a/third_party/blink/renderer/core/css/css_selector_list.cc b/third_party/blink/renderer/core/css/css_selector_list.cc
index 46d9cdbe3d3c5..e068861278e88 100644
--- a/third_party/blink/renderer/core/css/css_selector_list.cc
+++ b/third_party/blink/renderer/core/css/css_selector_list.cc
@@ -28,6 +28,7 @@
 
 #include <memory>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/core/css/css_selector.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
@@ -62,22 +63,22 @@ CSSSelectorList* CSSSelectorList::Copy() const {
 }
 
 HeapVector<CSSSelector> CSSSelectorList::Copy(
-    const CSSSelector* selector_list) {
+    base::span<const CSSSelector>selector_list) {
   HeapVector<CSSSelector> selectors;
-  for (const CSSSelector* selector = selector_list; selector;
+  for (base::span<const CSSSelector>selector = selector_list; !selector.empty();
        selector = selector->IsLastInSelectorList()
-                      ? nullptr
+                      ? {}
                       : UNSAFE_TODO(selector + 1)) {
-    selectors.push_back(*selector);
+    selectors.push_back( selector[0]);
   }
   return selectors;
 }
 
 void CSSSelectorList::AdoptSelectorVector(
     base::span<CSSSelector> selector_vector,
-    CSSSelector* selector_array) {
+    base::span<CSSSelector>selector_array) {
   std::uninitialized_move(selector_vector.begin(), selector_vector.end(),
-                          selector_array);
+                          selector_array.data());
   UNSAFE_TODO(selector_array[selector_vector.size() - 1])
       .SetLastInSelectorList(true);
 }
@@ -99,33 +100,33 @@ unsigned CSSSelectorList::ComputeLength() const {
   if (!IsValid()) {
     return 0;
   }
-  const CSSSelector* current = First();
+  base::span<const CSSSelector>current = First();
   while (!current->IsLastInSelectorList()) {
     UNSAFE_TODO(++current);
   }
-  return SelectorIndex(*current) + 1;
+  return SelectorIndex( current[0]) + 1;
 }
 
 unsigned CSSSelectorList::MaximumSpecificity() const {
   unsigned specificity = 0;
 
-  for (const CSSSelector* s = First(); s; s = Next(*s)) {
+  for (const CSSSelector* s = First().data(); s; s = Next(*s)) {
     specificity = std::max(specificity, s->Specificity());
   }
 
   return specificity;
 }
 
-bool CSSSelectorList::Renest(const CSSSelector* selector_list,
+bool CSSSelectorList::Renest(base::span<const CSSSelector>selector_list,
                              StyleRule* new_parent,
                              HeapVector<CSSSelector>& result) {
   bool renested_any = false;
-  for (const CSSSelector* current = selector_list; current;
-       current = current->IsLastInSelectorList() ? nullptr
+  for (base::span<const CSSSelector>current = selector_list; !current.empty();
+       current = current->IsLastInSelectorList() ? {}
                                                  : UNSAFE_TODO(++current)) {
     std::optional<CSSSelector> renested = current->Renest(new_parent);
     renested_any |= renested.has_value();
-    result.push_back(renested.value_or(*current));
+    result.push_back(renested.value_or( current[0]));
   }
   return renested_any;
 }
diff --git a/third_party/blink/renderer/core/css/css_selector_list.h b/third_party/blink/renderer/core/css/css_selector_list.h
index bfcf7d2ea2e5d..1672d755f6132 100644
--- a/third_party/blink/renderer/core/css/css_selector_list.h
+++ b/third_party/blink/renderer/core/css/css_selector_list.h
@@ -26,6 +26,8 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_CSS_CSS_SELECTOR_LIST_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_CSS_CSS_SELECTOR_LIST_H_
 
+#include <array>
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/types/pass_key.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -78,24 +80,24 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
 
   CSSSelectorList(CSSSelectorList&& o) {
     UNSAFE_TODO(
-        memcpy(this, o.first_selector_, ComputeLength() * sizeof(CSSSelector)));
+        memcpy(this, o.first_selector_.data(), ComputeLength() * sizeof(CSSSelector)));
   }
   ~CSSSelectorList() = default;
 
   static CSSSelectorList* AdoptSelectorVector(
       base::span<CSSSelector> selector_vector);
   static void AdoptSelectorVector(base::span<CSSSelector> selector_vector,
-                                  CSSSelector* selector_array);
+                                  base::span<CSSSelector>selector_array);
 
   CSSSelectorList* Copy() const;
-  static HeapVector<CSSSelector> Copy(const CSSSelector* selector_list);
+  static HeapVector<CSSSelector> Copy(base::span<const CSSSelector>selector_list);
 
   static bool IsValid(const CSSSelector& first) {
     return first.Match() != CSSSelector::kInvalidList;
   }
-  bool IsValid() const { return IsValid(*first_selector_); }
-  const CSSSelector* First() const {
-    return IsValid() ? first_selector_ : nullptr;
+  bool IsValid() const { return IsValid( first_selector_[0]); }
+  const base::span<CSSSelector> First() const {
+    return IsValid() ? first_selector_ : {};
   }
   static const CSSSelector* Next(const CSSSelector&);
   static CSSSelector* Next(CSSSelector&);
@@ -106,7 +108,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
     return IsValid(first) && !Next(first);
   }
   bool IsSingleComplexSelector() const {
-    return IsSingleComplexSelector(*first_selector_);
+    return IsSingleComplexSelector( first_selector_[0]);
   }
   const CSSSelector& SelectorAt(wtf_size_t index) const {
     DCHECK(IsValid());
@@ -127,7 +129,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
     return SelectorIndex(*next);
   }
 
-  String SelectorsText() const { return SelectorsText(First()); }
+  String SelectorsText() const { return SelectorsText(First().data()); }
   static String SelectorsText(const CSSSelector* first);
 
   // Selector lists don't know their length, computing it is O(n) and should be
@@ -143,7 +145,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
   // needed re-nesting.
   //
   // See also CSSSelector::Renest.
-  static bool Renest(const CSSSelector* selector_list,
+  static bool Renest(base::span<const CSSSelector>selector_list,
                      StyleRule* new_parent,
                      HeapVector<CSSSelector>& result);
 
@@ -166,7 +168,7 @@ class CORE_EXPORT CSSSelectorList : public GarbageCollected<CSSSelectorList> {
   // is not stored explicitly anywhere: End of a multipart selector is
   // indicated by is_last_in_complexlector_ bit in the last item. End of the
   // array is indicated by is_last_in_selector_list_ bit in the last item.
-  CSSSelector first_selector_[1];
+  std::array<CSSSelector, 1> first_selector_;
 };
 
 inline const CSSSelector* CSSSelectorList::Next(const CSSSelector& current) {
diff --git a/third_party/blink/renderer/core/css/css_selector_test.cc b/third_party/blink/renderer/core/css/css_selector_test.cc
index af9cb9590eaaa..d128d855ec33d 100644
--- a/third_party/blink/renderer/core/css/css_selector_test.cc
+++ b/third_party/blink/renderer/core/css/css_selector_test.cc
@@ -226,7 +226,7 @@ TEST(CSSSelector, CueDefaultNamespace) {
 
   const CSSSelectorList* cue_arguments = cue_selector.SelectorList();
   ASSERT_TRUE(cue_arguments);
-  const CSSSelector* vtt_type_selector = cue_arguments->First();
+  const CSSSelector* vtt_type_selector = cue_arguments->First().data();
   ASSERT_TRUE(vtt_type_selector);
   EXPECT_EQ(vtt_type_selector->TagQName().LocalName(), "b");
   // Default namespace should not affect VTT node type selector.
@@ -251,7 +251,7 @@ TEST(CSSSelector, FirstInInvalidList) {
   test::TaskEnvironment task_environment;
   CSSSelectorList* list = CSSSelectorList::Empty();
   EXPECT_FALSE(list->IsValid());
-  EXPECT_FALSE(list->First());
+  EXPECT_FALSE(list->First().empty());
 }
 
 TEST(CSSSelector, ImplicitPseudoDescendant) {
diff --git a/third_party/blink/renderer/core/css/css_selector_watch.cc b/third_party/blink/renderer/core/css/css_selector_watch.cc
index 61d515ea1f8d3..f986bb82962d2 100644
--- a/third_party/blink/renderer/core/css/css_selector_watch.cc
+++ b/third_party/blink/renderer/core/css/css_selector_watch.cc
@@ -142,7 +142,7 @@ void CSSSelectorWatch::UpdateSelectorMatches(
 }
 
 static bool AllCompound(const StyleRule* style_rule) {
-  for (const CSSSelector* selector = style_rule->FirstSelector(); selector;
+  for (const CSSSelector* selector = style_rule->FirstSelector().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     if (!selector->IsCompound()) {
       return false;
diff --git a/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc b/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
index 95698854cb23b..e677d1bfe546f 100644
--- a/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
+++ b/third_party/blink/renderer/core/css/invalidation/rule_invalidation_data_visitor.cc
@@ -1193,7 +1193,7 @@ void RuleInvalidationDataVisitor<VisitorType>::CollectValuesInHasArgument(
   const CSSSelectorList* selector_list = has_pseudo_class.SelectorList();
   DCHECK(selector_list);
 
-  for (const CSSSelector* relative_selector = selector_list->First();
+  for (const CSSSelector* relative_selector = selector_list->First().data();
        relative_selector;
        relative_selector = CSSSelectorList::Next(*relative_selector)) {
     DCHECK(relative_selector);
@@ -1256,7 +1256,7 @@ void RuleInvalidationDataVisitor<VisitorType>::
 
   DCHECK(pseudo_has.SelectorList());
 
-  for (const CSSSelector* relative = pseudo_has.SelectorList()->First();
+  for (const CSSSelector* relative = pseudo_has.SelectorList()->First().data();
        relative; relative = CSSSelectorList::Next(*relative)) {
     for (const CSSSelector* simple = relative;
          simple->GetPseudoType() != CSSSelector::kPseudoRelativeAnchor;
@@ -1609,7 +1609,7 @@ void RuleInvalidationDataVisitor<VisitorType>::
           simple_selector->GetPseudoType() == CSSSelector::kPseudoNthChild ||
           simple_selector->GetPseudoType() == CSSSelector::kPseudoNthLastChild;
       MarkInvalidationSetsWithinNthChild(
-          *simple_selector->SelectorList()->First(), sub_in_nth_child);
+           simple_selector->SelectorList()->First()[0], sub_in_nth_child);
     }
   }
 }
diff --git a/third_party/blink/renderer/core/css/parser/css_parser_impl.cc b/third_party/blink/renderer/core/css/parser/css_parser_impl.cc
index 1d2acbd361c59..8f7736674c5cb 100644
--- a/third_party/blink/renderer/core/css/parser/css_parser_impl.cc
+++ b/third_party/blink/renderer/core/css/parser/css_parser_impl.cc
@@ -9,6 +9,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/auto_reset.h"
 #include "base/compiler_specific.h"
 #include "base/cpu.h"
@@ -1234,10 +1235,10 @@ StyleRuleNestedDeclarations* CreateNestedDeclarationsRule(
 
 StyleRuleBase* CSSParserImpl::CreateDeclarationsRule(
     CSSNestingType nesting_type,
-    const CSSSelector* selector_list,
+    base::span<const CSSSelector>selector_list,
     wtf_size_t start_index,
     wtf_size_t end_index) {
-  DCHECK(selector_list || (nesting_type != CSSNestingType::kNesting));
+  DCHECK(!selector_list.empty() || (nesting_type != CSSNestingType::kNesting));
   DCHECK_LE(start_index, end_index);
 
   // Create a nested declarations rule containing all declarations
diff --git a/third_party/blink/renderer/core/css/parser/css_parser_impl.h b/third_party/blink/renderer/core/css/parser/css_parser_impl.h
index 30196a5b0ccf1..1348dbdd5210d 100644
--- a/third_party/blink/renderer/core/css/parser/css_parser_impl.h
+++ b/third_party/blink/renderer/core/css/parser/css_parser_impl.h
@@ -8,6 +8,7 @@
 #include <memory>
 #include <optional>
 
+#include "base/containers/span.h"
 #include "base/gtest_prod_util.h"
 #include "css_at_rule_id.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -447,7 +448,7 @@ class CORE_EXPORT CSSParserImpl {
   // https://drafts.csswg.org/css-nesting-1/#nested-declarations-rule
   // https://drafts.csswg.org/css-mixins-1/#cssfunctiondeclarations
   StyleRuleBase* CreateDeclarationsRule(CSSNestingType nesting_type,
-                                        const CSSSelector* selector_list,
+                                        base::span<const CSSSelector>selector_list,
                                         wtf_size_t start_index,
                                         wtf_size_t end_index);
 
diff --git a/third_party/blink/renderer/core/css/parser/css_selector_parser.cc b/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
index eb029176369e7..112eec2da931a 100644
--- a/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
+++ b/third_party/blink/renderer/core/css/parser/css_selector_parser.cc
@@ -669,7 +669,7 @@ base::span<CSSSelector> CSSSelectorParser::ConsumeRelativeSelector(
 // A return value of CSSNestingType::kScope means that the list
 // contains the :scope selector.
 static CSSNestingType GetNestingTypeForSelectorList(
-    const CSSSelector* selector) {
+    base::span<const CSSSelector>selector) {
   if (selector == nullptr) {
     return CSSNestingType::kNone;
   }
@@ -2614,7 +2614,7 @@ static void RecordUsageAndDeprecationsOneSelector(
     context->Count(WebFeature::kCSSSelectorIndirectAdjacent);
   }
   if (selector->SelectorList()) {
-    for (const CSSSelector* current = selector->SelectorList()->First();
+    for (const CSSSelector* current = selector->SelectorList()->First().data();
          current; current = current->NextSimpleSelector()) {
       RecordUsageAndDeprecationsOneSelector(current, context,
                                             has_visited_pseudo);
diff --git a/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc b/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
index a42fd61d72769..092736eb24312 100644
--- a/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
+++ b/third_party/blink/renderer/core/css/parser/css_selector_parser_test.cc
@@ -283,7 +283,7 @@ TEST(CSSSelectorParserTest, TransitionPseudoStyles) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    auto* selector = list->First();
+    auto* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -504,7 +504,7 @@ TEST(CSSSelectorParserTest, ScrollControlPseudos) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -550,7 +550,7 @@ TEST(CSSSelectorParserTest, ColumnPseudo) {
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     ASSERT_TRUE(list->IsSingleComplexSelector());
 
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     while (selector->NextSimpleSelector()) {
       selector = selector->NextSimpleSelector();
     }
@@ -749,7 +749,7 @@ TEST(CSSSelectorParserTest, ASCIILowerHTMLStrict) {
     EXPECT_GT(vector.size(), 0u);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     ASSERT_TRUE(selector);
     EXPECT_EQ(AtomicString(test_case.expected), test_case.getter(selector));
   }
@@ -778,7 +778,7 @@ TEST(CSSSelectorParserTest, ASCIILowerHTMLQuirks) {
     EXPECT_GT(vector.size(), 0u);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     ASSERT_TRUE(selector);
     EXPECT_EQ(AtomicString(test_case.expected), test_case.getter(selector));
   }
@@ -1058,7 +1058,7 @@ TEST(CSSSelectorParserTest, ImplicitShadowCrossingCombinators) {
         /*semicolon_aborts_nested_selector=*/false, sheet, arena);
     CSSSelectorList* list = CSSSelectorList::AdoptSelectorVector(vector);
     EXPECT_TRUE(list->IsValid());
-    const CSSSelector* selector = list->First();
+    const CSSSelector* selector = list->First().data();
     for (auto sub_expectation : test_case.expectation) {
       ASSERT_TRUE(selector);
       AtomicString selector_value =
@@ -1173,7 +1173,7 @@ static CSSSelectorList* ParseNested(String inner_rule,
                 css_test_helpers::ParseRule(document, "div {}"));
   CSSSelectorList* list = css_test_helpers::ParseSelectorList(
       inner_rule, nesting_type, parent_rule_for_nesting);
-  if (!list || !list->First()) {
+  if (!list || ).empty()) {
     return nullptr;
   }
   return list;
@@ -1188,7 +1188,7 @@ static std::optional<CSSSelector> GetImplicitlyAddedSelector(
   }
 
   Vector<const CSSSelector*> selectors;
-  for (const CSSSelector* selector = list->First(); selector;
+  for (const CSSSelector* selector = list->First().data(); selector;
        selector = selector->NextSimpleSelector()) {
     selectors.push_back(selector);
   }
@@ -1305,7 +1305,7 @@ static HeapVector<CSSSelector> FlattenSelector(const CSSSelector* selector) {
   while (selector) {
     result.push_back(*selector);
     if (const CSSSelectorList* list = selector->SelectorList()) {
-      for (const CSSSelector* s = list->First(); s;
+      for (const CSSSelector* s = list->First().data(); s;
            s = CSSSelectorList::Next(*s)) {
         result.AppendVector(FlattenSelector(s));
       }
@@ -1463,11 +1463,11 @@ TEST_P(IsScopeContainingTest, RefTest) {
       ParseNested(param.selector_text, CSSNestingType::kNone);
   CSSSelectorList* ref_list = ParseNested(ref, CSSNestingType::kNone);
   ASSERT_TRUE(actual_list);
-  ASSERT_TRUE(actual_list->First());
+  ASSERT_TRUE(actual_list->First().data());
   ASSERT_TRUE(ref_list);
-  ASSERT_TRUE(ref_list->First());
-  EXPECT_TRUE(IsScopeContainingComparison(FlattenSelector(actual_list->First()),
-                                          FlattenSelector(ref_list->First())));
+  ASSERT_TRUE(ref_list->First().data());
+  EXPECT_TRUE(IsScopeContainingComparison(FlattenSelector(actual_list->First().data()),
+                                          FlattenSelector(ref_list->First().data())));
 }
 
 TEST(CSSSelectorParserTest, ImplicitSelectorIsScopeContaining) {
diff --git a/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc b/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
index 109593ea32f85..f06d6984961e8 100644
--- a/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
+++ b/third_party/blink/renderer/core/css/resolver/selector_filter_parent_scope_test.cc
@@ -64,7 +64,7 @@ TEST_F(SelectorFilterParentScopeTest, ParentScope) {
       CSSSelectorList* selectors =
           CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-      for (const CSSSelector* selector = selectors->First(); selector;
+      for (const CSSSelector* selector = selectors->First().data(); selector;
            selector = CSSSelectorList::Next(*selector)) {
         Vector<uint16_t> selector_hashes;
         filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
@@ -98,7 +98,7 @@ TEST_F(SelectorFilterParentScopeTest, RootScope) {
   CSSSelectorList* selectors =
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-  for (const CSSSelector* selector = selectors->First(); selector;
+  for (const CSSSelector* selector = selectors->First().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     Vector<uint16_t> selector_hashes;
     filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
@@ -172,7 +172,7 @@ TEST_F(SelectorFilterParentScopeTest, AttributeFilter) {
   CSSSelectorList* selectors =
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
-  for (const CSSSelector* selector = selectors->First(); selector;
+  for (const CSSSelector* selector = selectors->First().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     Vector<uint16_t> selector_hashes;
     filter.CollectIdentifierHashes(*selector, /* style_scope */ nullptr,
diff --git a/third_party/blink/renderer/core/css/rule_feature_set_test.cc b/third_party/blink/renderer/core/css/rule_feature_set_test.cc
index 80dcb264cc1e8..9b8837c3d5d3f 100644
--- a/third_party/blink/renderer/core/css/rule_feature_set_test.cc
+++ b/third_party/blink/renderer/core/css/rule_feature_set_test.cc
@@ -76,7 +76,7 @@ class RuleFeatureSetTest : public testing::Test {
                                             const StyleScope* style_scope,
                                             RuleFeatureSet& set) {
     SelectorPreMatch result = SelectorPreMatch::kNeverMatches;
-    for (const CSSSelector* s = style_rule->FirstSelector(); s;
+    for (const CSSSelector* s = style_rule->FirstSelector().data(); s;
          s = CSSSelectorList::Next(*s)) {
       if (set.CollectFeaturesFromSelector(*s, style_scope) ==
           SelectorPreMatch::kMayMatch) {
diff --git a/third_party/blink/renderer/core/css/rule_set.cc b/third_party/blink/renderer/core/css/rule_set.cc
index acb67fb1de6f4..326221b9869f1 100644
--- a/third_party/blink/renderer/core/css/rule_set.cc
+++ b/third_party/blink/renderer/core/css/rule_set.cc
@@ -34,6 +34,7 @@
 #include <type_traits>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
 #include "base/substring_set_matcher/substring_set_matcher.h"
@@ -1052,13 +1053,13 @@ void RuleSet::AddRulesFromSheet(const StyleSheetContents* sheet,
 // If there's a reference to the parent selector (implicit or explicit)
 // somewhere in the selector, use that to find the parent StyleRule.
 // If not, it's not relevant what the parent is anyway.
-const StyleRule* FindParentIfUsed(const CSSSelector* selector) {
+const StyleRule* FindParentIfUsed(base::span<const CSSSelector>selector) {
   do {
     if (selector->Match() == CSSSelector::kPseudoClass &&
         selector->GetPseudoType() == CSSSelector::kPseudoParent) {
       return selector->ParentRule();
     }
-    if (selector->SelectorList() && selector->SelectorList()->First()) {
+    if (selector->SelectorList() && !selector->SelectorList()->First().empty()) {
       const StyleRule* parent =
           FindParentIfUsed(selector->SelectorList()->First());
       if (parent != nullptr) {
@@ -1178,7 +1179,7 @@ void RuleSet::AddStyleRule(StyleRule* style_rule,
   if (within_mixin) {
     style_rule = To<StyleRule>(style_rule->Renest(parent_rule));
   }
-  for (const CSSSelector* selector = style_rule->FirstSelector(); selector;
+  for (const CSSSelector* selector = style_rule->FirstSelector().data(); selector;
        selector = CSSSelectorList::Next(*selector)) {
     wtf_size_t selector_index = style_rule->SelectorIndex(*selector);
     AddRule(style_rule, selector_index, add_rule_flags, container_query,
diff --git a/third_party/blink/renderer/core/css/selector_checker.cc b/third_party/blink/renderer/core/css/selector_checker.cc
index 2093816946883..aa19a69157253 100644
--- a/third_party/blink/renderer/core/css/selector_checker.cc
+++ b/third_party/blink/renderer/core/css/selector_checker.cc
@@ -988,7 +988,7 @@ ALWAYS_INLINE bool SelectorChecker::CheckOne(
 
 bool SelectorChecker::CheckPseudoNot(const SelectorCheckingContext& context,
                                      MatchResult& result) const {
-  return !MatchesAnyInList(context, context.selector->SelectorList()->First(),
+  return !MatchesAnyInList(context, context.selector->SelectorList()->First().data(),
                            result);
 }
 
@@ -1467,7 +1467,7 @@ bool SelectorChecker::CheckPseudoHas(const SelectorCheckingContext& context,
   }
 
   DCHECK(context.selector->SelectorList());
-  for (const CSSSelector* selector = context.selector->SelectorList()->First();
+  for (const CSSSelector* selector = context.selector->SelectorList()->First().data();
        selector; selector = CSSSelectorList::Next(*selector)) {
     CheckPseudoHasArgumentContext argument_context(selector, context.scope,
                                                    match_in_shadow_tree);
@@ -1730,7 +1730,7 @@ bool SelectorChecker::CheckPseudoClass(const SelectorCheckingContext& context,
         // Check if the element itself matches the “of” selector.
         // Note that this will also propagate the correct MatchResult flags,
         // so NthIndexCache does not have to do that.
-        if (!MatchesAnyInList(context, selector.SelectorList()->First(),
+        if (!MatchesAnyInList(context, selector.SelectorList()->First().data(),
                               result)) {
           return false;
         }
@@ -1756,7 +1756,7 @@ bool SelectorChecker::CheckPseudoClass(const SelectorCheckingContext& context,
       }
       if (selector.SelectorList()) {
         // Check if the element itself matches the “of” selector.
-        if (!MatchesAnyInList(context, selector.SelectorList()->First(),
+        if (!MatchesAnyInList(context, selector.SelectorList()->First().data(),
                               result)) {
           return false;
         }
@@ -2520,7 +2520,7 @@ bool SelectorChecker::CheckPseudoElement(const SelectorCheckingContext& context,
       sub_context.scope = nullptr;
       sub_context.tree_scope = nullptr;
 
-      for (sub_context.selector = selector.SelectorList()->First();
+      for (sub_context.selector = selector.SelectorList()->First().data();
            sub_context.selector; sub_context.selector = CSSSelectorList::Next(
                                      *sub_context.selector)) {
         SubResult sub_result(result);
@@ -2568,9 +2568,9 @@ bool SelectorChecker::CheckPseudoElement(const SelectorCheckingContext& context,
       sub_context.tree_scope = nullptr;
 
       // ::slotted() only allows one compound selector.
-      DCHECK(selector.SelectorList()->First());
+      DCHECK(!selector.SelectorList()->First().empty());
       DCHECK(!CSSSelectorList::Next(*selector.SelectorList()->First()));
-      sub_context.selector = selector.SelectorList()->First();
+      sub_context.selector = selector.SelectorList()->First().data();
       SubResult sub_result(result);
       if (MatchSelector(sub_context, sub_result) != kSelectorMatches) {
         return false;
@@ -2745,7 +2745,7 @@ bool SelectorChecker::CheckPseudoHost(const SelectorCheckingContext& context,
 
   SelectorCheckingContext sub_context(context);
   sub_context.is_sub_selector = true;
-  sub_context.selector = selector.SelectorList()->First();
+  sub_context.selector = selector.SelectorList()->First().data();
 
   // "When evaluated in the context of a shadow tree, it matches the shadow
   //  tree’s shadow host if the shadow host, **in its normal context**,
diff --git a/third_party/blink/renderer/core/css/selector_checker_test.cc b/third_party/blink/renderer/core/css/selector_checker_test.cc
index b9d3f086e3df3..3c1509ef4c7fb 100644
--- a/third_party/blink/renderer/core/css/selector_checker_test.cc
+++ b/third_party/blink/renderer/core/css/selector_checker_test.cc
@@ -230,7 +230,7 @@ TEST_P(ScopeProximityTest, All) {
   StyleScopeFrame style_scope_frame(*target, /* parent */ nullptr);
   SelectorChecker::SelectorCheckingContext context{
       ElementResolveContext(*target)};
-  context.selector = style_rule->FirstSelector();
+  context.selector = style_rule->FirstSelector().data();
   context.style_scope = scope;
   context.style_scope_frame = &style_scope_frame;
 
@@ -323,7 +323,7 @@ TEST_P(MatchFlagsTest, All) {
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{
       ElementResolveContext(*element)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
 
   SelectorChecker::MatchResult result;
   checker.Match(context, result);
@@ -374,7 +374,7 @@ class ImpactTest : public PageTestBase {
     SelectorChecker checker(SelectorChecker::kResolvingStyle);
     SelectorChecker::SelectorCheckingContext context{
         ElementResolveContext(element)};
-    context.selector = selector_list->First();
+    context.selector = selector_list->First().data();
     context.impact = impact;
 
     SelectorChecker::MatchResult result;
@@ -692,7 +692,7 @@ TEST_P(MatchFlagsShadowTest, Host) {
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{
       ElementResolveContext(*host)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
   context.scope = host->GetShadowRoot();
   context.tree_scope = host->GetShadowRoot();
 
@@ -823,8 +823,8 @@ bool EasySelectorCheckerTest::Matches(const String& selector_text,
                                       const char* id) {
   StyleRule* rule = To<StyleRule>(
       css_test_helpers::ParseRule(GetDocument(), selector_text + " {}"));
-  CHECK(EasySelectorChecker::IsEasy(rule->FirstSelector()));
-  return EasySelectorChecker::Match(rule->FirstSelector(), GetElementById(id));
+  CHECK(EasySelectorChecker::IsEasy(rule->FirstSelector().data()));
+  return EasySelectorChecker::Match(rule->FirstSelector().data(), GetElementById(id));
 }
 
 #if DCHECK_IS_ON()  // Requires all_rules_, to find back the rules we add.
@@ -916,14 +916,14 @@ TEST_F(SelectorCheckerTest, PseudoScopeWithoutScope) {
   CSSSelectorList* selector_list =
       css_test_helpers::ParseSelectorList(":scope #foo");
   ASSERT_TRUE(selector_list);
-  ASSERT_TRUE(selector_list->First());
+  ASSERT_TRUE(selector_list->First().data());
 
   Element* foo = GetDocument().getElementById(AtomicString("foo"));
   ASSERT_TRUE(foo);
 
   SelectorChecker checker(SelectorChecker::kResolvingStyle);
   SelectorChecker::SelectorCheckingContext context{ElementResolveContext(*foo)};
-  context.selector = selector_list->First();
+  context.selector = selector_list->First().data();
   // We have a selector with :scope, but no context.scope:
   context.scope = nullptr;
 
diff --git a/third_party/blink/renderer/core/css/selector_filter_test.cc b/third_party/blink/renderer/core/css/selector_filter_test.cc
index bd3ad3381d21f..5242faa974f3b 100644
--- a/third_party/blink/renderer/core/css/selector_filter_test.cc
+++ b/third_party/blink/renderer/core/css/selector_filter_test.cc
@@ -28,13 +28,13 @@ Vector<uint16_t> CollectIdentifierHashesFromInnerRule(Document& document,
   const auto* inner_style_rule =
       DynamicTo<StyleRule>(outer_rule->ChildRules()[0].Get());
   CHECK(inner_style_rule);
-  CHECK(inner_style_rule->FirstSelector());
+  CHECK(!inner_style_rule->FirstSelector().empty());
 
   const auto* scope_rule = DynamicTo<StyleRuleScope>(outer_rule);
   const StyleScope* style_scope =
       scope_rule ? &scope_rule->GetStyleScope() : nullptr;
 
-  SelectorFilter::CollectIdentifierHashes(*inner_style_rule->FirstSelector(),
+  SelectorFilter::CollectIdentifierHashes( inner_style_rule->FirstSelector()[0],
                                           style_scope, result);
   return result;
 }
diff --git a/third_party/blink/renderer/core/css/selector_query.cc b/third_party/blink/renderer/core/css/selector_query.cc
index 741ec2c2bae70..6972bc75338a3 100644
--- a/third_party/blink/renderer/core/css/selector_query.cc
+++ b/third_party/blink/renderer/core/css/selector_query.cc
@@ -576,7 +576,7 @@ SelectorQuery::SelectorQuery(CSSSelectorList* selector_list)
       selector_id_is_rightmost_(true),
       selector_id_affected_by_sibling_combinator_(false),
       use_slow_scan_(true) {
-  const CSSSelector* base = selector_list_->First();
+  const CSSSelector* base = selector_list_->First().data();
   for (const CSSSelector* selector = base; selector;
        selector = CSSSelectorList::Next(*selector)) {
     if (selector->MatchesPseudoElement()) {
diff --git a/third_party/blink/renderer/core/css/style_engine.cc b/third_party/blink/renderer/core/css/style_engine.cc
index e7958162be680..70d0948b49a93 100644
--- a/third_party/blink/renderer/core/css/style_engine.cc
+++ b/third_party/blink/renderer/core/css/style_engine.cc
@@ -4717,7 +4717,7 @@ void RevisitStyleRulesForInspector(const RuleFeatureSet& features,
                                    const VectorType& rules) {
   for (StyleRuleBase* rule : rules) {
     if (StyleRule* style_rule = DynamicTo<StyleRule>(rule)) {
-      for (const CSSSelector* selector = style_rule->FirstSelector(); selector;
+      for (const CSSSelector* selector = style_rule->FirstSelector().data(); selector;
            selector = CSSSelectorList::Next(*selector)) {
         InvalidationSetToSelectorMap::SelectorScope selector_scope(
             style_rule, style_rule->SelectorIndex(*selector));
diff --git a/third_party/blink/renderer/core/css/style_rule.cc b/third_party/blink/renderer/core/css/style_rule.cc
index ccc27676128d3..46c268406c019 100644
--- a/third_party/blink/renderer/core/css/style_rule.cc
+++ b/third_party/blink/renderer/core/css/style_rule.cc
@@ -21,6 +21,7 @@
 
 #include "third_party/blink/renderer/core/css/style_rule.h"
 
+#include "base/containers/span.h"
 #include "base/compiler_specific.h"
 #include "third_party/blink/renderer/core/css/cascade_layer.h"
 #include "third_party/blink/renderer/core/css/css_container_rule.h"
@@ -515,7 +516,7 @@ StyleRule::StyleRule(const StyleRule& other, size_t flattened_size)
 
 StyleRule::~StyleRule() {
   // Clean up any RareData that the selectors may be owning.
-  CSSSelector* selector = SelectorArray();
+  base::span<CSSSelector>selector = SelectorArray();
   for (;;) {
     bool is_last = selector->IsLastInSelectorList();
     selector->~CSSSelector();
@@ -567,9 +568,9 @@ void StyleRule::TraceAfterDispatch(blink::Visitor* visitor) const {
   visitor->Trace(lazy_property_parser_);
   visitor->Trace(child_rules_);
 
-  const CSSSelector* current = SelectorArray();
+  base::span<const CSSSelector>current = SelectorArray();
   do {
-    visitor->Trace(*current);
+    visitor->Trace( current[0]);
   } while (!(UNSAFE_TODO(current++))->IsLastInSelectorList());
 
   StyleRuleBase::TraceAfterDispatch(visitor);
diff --git a/third_party/blink/renderer/core/css/style_rule.h b/third_party/blink/renderer/core/css/style_rule.h
index 9fa547c27e3cb..7dea4d90400e5 100644
--- a/third_party/blink/renderer/core/css/style_rule.h
+++ b/third_party/blink/renderer/core/css/style_rule.h
@@ -24,6 +24,7 @@
 
 #include <limits>
 
+#include "base/containers/span.h"
 #include "base/bits.h"
 #include "base/compiler_specific.h"
 #include "base/memory/scoped_refptr.h"
@@ -243,7 +244,7 @@ class CORE_EXPORT StyleRule : public StyleRuleBase {
   }
 
   // Partial subset of the CSSSelector API.
-  const CSSSelector* FirstSelector() const { return SelectorArray(); }
+  const base::span<CSSSelector> FirstSelector() const { return SelectorArray().data(); }
   const CSSSelector& SelectorAt(wtf_size_t index) const {
     return UNSAFE_TODO(SelectorArray()[index]);
   }
@@ -262,14 +263,14 @@ class CORE_EXPORT StyleRule : public StyleRuleBase {
     return SelectorIndex(*next);
   }
   String SelectorsText() const {
-    return CSSSelectorList::SelectorsText(FirstSelector());
+    return CSSSelectorList::SelectorsText(FirstSelector().data());
   }
 
   const CSSPropertyValueSet& Properties() const;
   MutableCSSPropertyValueSet& MutableProperties();
 
   StyleRule* Copy() const {
-    const CSSSelector* selector_array = SelectorArray();
+    base::span<const CSSSelector>selector_array = SelectorArray();
     size_t flattened_size = 1;
     while (!UNSAFE_TODO(selector_array[flattened_size - 1])
                 .IsLastInSelectorList()) {
@@ -314,12 +315,12 @@ class CORE_EXPORT StyleRule : public StyleRuleBase {
   friend class CSSLazyParsingTest;
   bool HasParsedProperties() const;
 
-  CSSSelector* SelectorArray() {
+  base::span<CSSSelector> SelectorArray() {
     return reinterpret_cast<CSSSelector*>(
         base::bits::AlignUp(UNSAFE_TODO(reinterpret_cast<uint8_t*>(this + 1)),
                             alignof(CSSSelector)));
   }
-  const CSSSelector* SelectorArray() const {
+  const base::span<CSSSelector> SelectorArray() const {
     return const_cast<StyleRule*>(this)->SelectorArray();
   }
 
@@ -464,7 +465,7 @@ class StyleRulePage : public StyleRuleGroup {
                 HeapVector<Member<StyleRuleBase>> child_rules);
   StyleRulePage(const StyleRulePage&);
 
-  const CSSSelector* Selector() const { return selector_list_->First(); }
+  const CSSSelector* Selector() const { return selector_list_->First().data(); }
   const CSSPropertyValueSet& Properties() const { return *properties_; }
   MutableCSSPropertyValueSet& MutableProperties();
 
diff --git a/third_party/blink/renderer/core/css/style_rule_test.cc b/third_party/blink/renderer/core/css/style_rule_test.cc
index 12993799666df..0432e61ed82de 100644
--- a/third_party/blink/renderer/core/css/style_rule_test.cc
+++ b/third_party/blink/renderer/core/css/style_rule_test.cc
@@ -30,7 +30,7 @@ const CSSSelector* FindPseudoSelector(const CSSSelector* selector,
       return s;
     }
     if (s->SelectorList()) {
-      for (const CSSSelector* complex = s->SelectorList()->First(); complex;
+      for (const CSSSelector* complex = s->SelectorList()->First().data(); complex;
            complex = CSSSelectorList::Next(*complex)) {
         if (const CSSSelector* parent =
                 FindPseudoSelector(complex, pseudo_type)) {
@@ -116,7 +116,7 @@ TEST_F(StyleRuleTest, SetPreludeTextReparentsStyleRules) {
   EXPECT_EQ(rule_before, FindParentSelector(scope_before.To())->ParentRule());
   EXPECT_EQ(
       rule_before,
-      FindParentSelector(child_rule_before.FirstSelector())->ParentRule());
+      FindParentSelector(child_rule_before.FirstSelector().data())->ParentRule());
 
   scope_rule->SetPreludeText(GetDocument().GetExecutionContext(),
                              "(.x) to (.b &)");
@@ -134,7 +134,7 @@ TEST_F(StyleRuleTest, SetPreludeTextReparentsStyleRules) {
   EXPECT_EQ(rule_after, FindParentSelector(scope_after.To())->ParentRule());
   // Verify that '&' (in '.c &') now points to `rule_after`.
   EXPECT_EQ(rule_after,
-            FindParentSelector(child_rule_afer.FirstSelector())->ParentRule());
+            FindParentSelector(child_rule_afer.FirstSelector().data())->ParentRule());
 }
 
 TEST_F(StyleRuleTest, SetPreludeTextWithEscape) {
diff --git a/third_party/blink/renderer/core/css/style_scope.cc b/third_party/blink/renderer/core/css/style_scope.cc
index 2c5b61ce595ae..fbca954a39bef 100644
--- a/third_party/blink/renderer/core/css/style_scope.cc
+++ b/third_party/blink/renderer/core/css/style_scope.cc
@@ -49,14 +49,14 @@ const StyleScope* StyleScope::Renest(StyleRule* new_parent) const {
 
 const CSSSelector* StyleScope::From() const {
   if (from_) {
-    return from_->FirstSelector();
+    return from_->FirstSelector().data();
   }
   return nullptr;
 }
 
 const CSSSelector* StyleScope::To() const {
   if (to_) {
-    return to_->First();
+    return to_->First().data();
   }
   return nullptr;
 }
diff --git a/third_party/blink/renderer/core/dom/nth_index_cache.cc b/third_party/blink/renderer/core/dom/nth_index_cache.cc
index 226b3fa349f9d..970262b7cd24d 100644
--- a/third_party/blink/renderer/core/dom/nth_index_cache.cc
+++ b/third_party/blink/renderer/core/dom/nth_index_cache.cc
@@ -99,7 +99,7 @@ bool NthIndexCache::MatchesFilter(
   sub_context.is_sub_selector = true;
   sub_context.in_nested_complex_selector = true;
   sub_context.pseudo_id = kPseudoIdNone;
-  for (sub_context.selector = filter->First(); sub_context.selector;
+  for (sub_context.selector = filter->First().data(); sub_context.selector;
        sub_context.selector = CSSSelectorList::Next(*sub_context.selector)) {
     // NOTE: We don't want to propagate match_result up to the parent;
     // the correct flags were already set when the caller tested that
diff --git a/third_party/blink/renderer/core/exported/web_selector.cc b/third_party/blink/renderer/core/exported/web_selector.cc
index 9d84376556386..fec3a20279a5d 100644
--- a/third_party/blink/renderer/core/exported/web_selector.cc
+++ b/third_party/blink/renderer/core/exported/web_selector.cc
@@ -60,7 +60,7 @@ WebString CanonicalizeSelector(WebString web_selector,
       CSSSelectorList::AdoptSelectorVector(selector_vector);
 
   if (restriction == kWebSelectorTypeCompound) {
-    for (const CSSSelector* selector = selector_list->First(); selector;
+    for (const CSSSelector* selector = selector_list->First().data(); selector;
          selector = selector_list->Next(*selector)) {
       if (!selector->IsCompound())
         return {};
diff --git a/third_party/blink/renderer/core/inspector/inspector_css_agent.cc b/third_party/blink/renderer/core/inspector/inspector_css_agent.cc
index b0c2f806e0eeb..d65e2e0d505a1 100644
--- a/third_party/blink/renderer/core/inspector/inspector_css_agent.cc
+++ b/third_party/blink/renderer/core/inspector/inspector_css_agent.cc
@@ -1283,7 +1283,7 @@ protocol::Response InspectorCSSAgent::getLocationForSelector(
 
     // Iterate over selector list. (eg. `.box, .alert` => ['.box', '.alert'])
     for (const CSSSelector* selector =
-             css_style_rule->GetStyleRule()->FirstSelector();
+             css_style_rule->GetStyleRule()->FirstSelector().data();
          selector; selector = CSSSelectorList::Next(*selector)) {
       if (selector->SelectorText() == selector_text) {
         const CSSRuleSourceData* source_data =
diff --git a/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc b/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
index a2499cc3f7273..940e2c7273f0d 100644
--- a/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
+++ b/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
@@ -156,7 +156,7 @@ String FindMagicComment(const String& content, const String& name) {
 }
 
 void GetClassNamesFromRule(CSSStyleRule* rule, HashSet<String>& unique_names) {
-  for (const CSSSelector* sub_selector = rule->GetStyleRule()->FirstSelector();
+  for (const CSSSelector* sub_selector = rule->GetStyleRule()->FirstSelector().data();
        sub_selector; sub_selector = CSSSelectorList::Next(*sub_selector)) {
     const CSSSelector* simple_selector = sub_selector;
     while (simple_selector) {
@@ -1879,7 +1879,7 @@ InspectorStyleSheet::SelectorsFromSource(CSSRuleSourceData* source_data,
   }
   auto result = std::make_unique<protocol::Array<protocol::CSS::Value>>();
   const Vector<SourceRange>& ranges = source_data->selector_ranges;
-  const CSSSelector* obj_selector = rule->GetStyleRule()->FirstSelector();
+  const CSSSelector* obj_selector = rule->GetStyleRule()->FirstSelector().data();
 
   for (wtf_size_t i = 0, size = ranges.size(); i < size && obj_selector;
        ++i, obj_selector = CSSSelectorList::Next(*obj_selector)) {
@@ -1927,7 +1927,7 @@ InspectorStyleSheet::BuildObjectForSelectorList(CSSStyleRule* rule) {
     selectors = SelectorsFromSource(source_data, text_, rule);
   } else {
     selectors = std::make_unique<protocol::Array<protocol::CSS::Value>>();
-    for (const CSSSelector* selector = rule->GetStyleRule()->FirstSelector();
+    for (const CSSSelector* selector = rule->GetStyleRule()->FirstSelector().data();
          selector; selector = CSSSelectorList::Next(*selector)) {
       std::array<uint8_t, 3> specificity_tuple = selector->SpecificityTuple();
 
diff --git a/third_party/blink/renderer/core/layout/physical_box_fragment.h b/third_party/blink/renderer/core/layout/physical_box_fragment.h
index 6e14adbc8cac2..1effd516226ce 100644
--- a/third_party/blink/renderer/core/layout/physical_box_fragment.h
+++ b/third_party/blink/renderer/core/layout/physical_box_fragment.h
@@ -666,7 +666,7 @@ class CORE_EXPORT PhysicalBoxFragment final : public PhysicalFragment {
     // is valid. See Create() and AdditionalByteSize().
     return reinterpret_cast<const FragmentItems*>(base::bits::AlignUp(
         reinterpret_cast<const uint8_t*>(UNSAFE_BUFFERS(this + 1)),
-        alignof(FragmentItems)));
+        alignof(FragmentItems)).data());
   }
 
   void SetInkOverflow(const PhysicalRect& self, const PhysicalRect& contents);
diff --git a/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc b/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
index 4e537c5403432..22b6f04896b13 100644
--- a/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
+++ b/third_party/blink/renderer/modules/gamepad/gamepad_shared_memory_reader.cc
@@ -63,7 +63,7 @@ void GamepadSharedMemoryReader::Start(blink::GamepadListener* listener) {
   renderer_shared_buffer_mapping_ = renderer_shared_buffer_region_.Map();
   CHECK(renderer_shared_buffer_mapping_.IsValid());
   gamepad_hardware_buffer_ = renderer_shared_buffer_mapping_
-                                 .GetMemoryAs<device::GamepadHardwareBuffer>();
+                                 .GetMemoryAs<device::GamepadHardwareBuffer>().data();
   CHECK(gamepad_hardware_buffer_);
 }
 
diff --git a/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc b/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
index 353758cfdadc6..d8e478dee1d35 100644
--- a/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
+++ b/third_party/blink/renderer/modules/imagecapture/image_capture_frame_grabber.cc
@@ -209,11 +209,11 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
 
       libyuv::NV12ToI420(
           y_plane, y_stride, uv_plane, uv_stride,
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           i420_frame->stride(media::VideoFrame::Plane::kY),
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           i420_frame->stride(media::VideoFrame::Plane::kU),
-          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          i420_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           i420_frame->stride(media::VideoFrame::Plane::kV),
           original_size.width(), original_size.height());
     } else {
@@ -259,28 +259,28 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
       }();
 
       libyuv::I420Rotate(
-          i420_frame->visible_data(media::VideoFrame::Plane::kY),
+          i420_frame->visible_data(media::VideoFrame::Plane::kY).data(),
           i420_frame->stride(media::VideoFrame::Plane::kY),
-          i420_frame->visible_data(media::VideoFrame::Plane::kU),
+          i420_frame->visible_data(media::VideoFrame::Plane::kU).data(),
           i420_frame->stride(media::VideoFrame::Plane::kU),
-          i420_frame->visible_data(media::VideoFrame::Plane::kV),
+          i420_frame->visible_data(media::VideoFrame::Plane::kV).data(),
           i420_frame->stride(media::VideoFrame::Plane::kV),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kY),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kU),
-          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          rotated_frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           rotated_frame->stride(media::VideoFrame::Plane::kV),
           original_size.width(), original_size.height(), libyuv_rotate);
       i420_frame = std::move(rotated_frame);
     }
 
     libyuv::ConvertFromI420(
-        i420_frame->visible_data(media::VideoFrame::Plane::kY),
+        i420_frame->visible_data(media::VideoFrame::Plane::kY).data(),
         i420_frame->stride(media::VideoFrame::Plane::kY),
-        i420_frame->visible_data(media::VideoFrame::Plane::kU),
+        i420_frame->visible_data(media::VideoFrame::Plane::kU).data(),
         i420_frame->stride(media::VideoFrame::Plane::kU),
-        i420_frame->visible_data(media::VideoFrame::Plane::kV),
+        i420_frame->visible_data(media::VideoFrame::Plane::kV).data(),
         i420_frame->stride(media::VideoFrame::Plane::kV), destination_plane,
         destination_stride, destination_width, destination_height,
         destination_pixel_format);
@@ -289,7 +289,7 @@ void ImageCaptureFrameGrabber::SingleShotFrameHandler::ConvertAndDeliverFrame(
       DCHECK(!info.isOpaque());
       // This function copies any plane into the alpha channel of an ARGB image.
       libyuv::ARGBCopyYToAlpha(
-          i420_frame->visible_data(media::VideoFrame::Plane::kA),
+          i420_frame->visible_data(media::VideoFrame::Plane::kA).data(),
           i420_frame->stride(media::VideoFrame::Plane::kA), destination_plane,
           destination_stride, destination_width, destination_height);
     }
diff --git a/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc b/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
index 79fff34a838b6..c328b90f22f3d 100644
--- a/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
+++ b/third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler_unittest.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/mediacapturefromelement/canvas_capture_handler.h"
 
+#include "base/containers/span.h"
 #include "base/functional/bind.h"
 #include "base/run_loop.h"
 #include "base/test/gmock_callback_support.h"
@@ -137,17 +138,17 @@ class CanvasCaptureHandlerTest
     const gfx::Size& size = video_frame->visible_rect().size();
     EXPECT_EQ(expected_width, size.width());
     EXPECT_EQ(expected_height, size.height());
-    const uint8_t* y_plane =
+    base::span<const uint8_t>y_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kY);
     EXPECT_NEAR(74, y_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
-    const uint8_t* u_plane =
+    base::span<const uint8_t>u_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kU);
     EXPECT_NEAR(193, u_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
-    const uint8_t* v_plane =
+    base::span<const uint8_t>v_plane =
         video_frame->visible_data(media::VideoFrame::Plane::kV);
     EXPECT_NEAR(105, v_plane[0], kTestCanvasCaptureFrameColorErrorTolerance);
     if (!opaque) {
-      const uint8_t* a_plane =
+      base::span<const uint8_t>a_plane =
           video_frame->visible_data(media::VideoFrame::Plane::kA);
       EXPECT_EQ(kTestAlphaValue, a_plane[0]);
     }
diff --git a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
index 28fdbe7a6a61f..4e389f70409b1 100644
--- a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder.cc
@@ -701,11 +701,11 @@ VideoTrackRecorderImpl::Encoder::MaybeProvideEncodableFrame(
     if (libyuv::ConvertToI420(
             static_cast<uint8_t*>(pixmap.writable_addr()),
             pixmap.computeByteSize(),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
             frame->stride(media::VideoFrame::Plane::kY),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
             frame->stride(media::VideoFrame::Plane::kU),
-            frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+            frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
             frame->stride(media::VideoFrame::Plane::kV), 0 /* crop_x */,
             0 /* crop_y */, pixmap.width(), pixmap.height(),
             old_visible_size.width(), old_visible_size.height(),
@@ -718,7 +718,7 @@ VideoTrackRecorderImpl::Encoder::MaybeProvideEncodableFrame(
       libyuv::ARGBExtractAlpha(
           static_cast<uint8_t*>(pixmap.writable_addr()),
           static_cast<int>(pixmap.rowBytes()) /* stride */,
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kA),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kA).data(),
           frame->stride(media::VideoFrame::Plane::kA), pixmap.width(),
           pixmap.height());
     }
@@ -750,12 +750,12 @@ VideoTrackRecorderImpl::Encoder::ConvertToI420ForSoftwareEncoder(
       media::VideoPixelFormat::PIXEL_FORMAT_I420, frame->coded_size(),
       frame->visible_rect(), frame->natural_size(), frame->timestamp());
   auto ret = libyuv::NV12ToI420(
-      frame->data(0), frame->stride(0), frame->data(1), frame->stride(1),
-      i420_frame->writable_data(media::VideoFrame::Plane::kY),
+      frame->data(0).data(), frame->stride(0), frame->data(1).data(), frame->stride(1),
+      i420_frame->writable_data(media::VideoFrame::Plane::kY).data(),
       i420_frame->stride(media::VideoFrame::Plane::kY),
-      i420_frame->writable_data(media::VideoFrame::Plane::kU),
+      i420_frame->writable_data(media::VideoFrame::Plane::kU).data(),
       i420_frame->stride(media::VideoFrame::Plane::kU),
-      i420_frame->writable_data(media::VideoFrame::Plane::kV),
+      i420_frame->writable_data(media::VideoFrame::Plane::kV).data(),
       i420_frame->stride(media::VideoFrame::Plane::kV),
       frame->coded_size().width(), frame->coded_size().height());
   if (ret) {
diff --git a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
index e57775d9cecbb..6669ca84156d3 100644
--- a/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/video_track_recorder_unittest.cc
@@ -440,9 +440,9 @@ class VideoTrackRecorderTest : public VideoTrackRecorderTestBase {
     // Fade to black.
     const uint8_t kBlackY = 0x00;
     const uint8_t kBlackUV = 0x80;
-    memset(video_frame2->writable_data(0), kBlackY,
+    memset(video_frame2->writable_data(0).data(), kBlackY,
            video_frame2->stride(0) * frame_size.height());
-    memset(video_frame2->writable_data(1), kBlackUV,
+    memset(video_frame2->writable_data(1).data(), kBlackUV,
            video_frame2->stride(1) * (frame_size.height() / 2));
     if (frame_type == TestFrameType::kNv12GpuMemoryBuffer) {
       return video_frame;
diff --git a/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc b/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
index 9e280bf28581b..393c04270e4e7 100644
--- a/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
+++ b/third_party/blink/renderer/modules/mediastream/web_media_player_ms_compositor.cc
@@ -122,41 +122,41 @@ scoped_refptr<media::VideoFrame> CopyFrame(
     }
 
     if (frame->format() == media::PIXEL_FORMAT_NV12) {
-      libyuv::NV12Copy(frame->data(media::VideoFrame::Plane::kY),
+      libyuv::NV12Copy(frame->data(media::VideoFrame::Plane::kY).data(),
                        frame->stride(media::VideoFrame::Plane::kY),
-                       frame->data(media::VideoFrame::Plane::kUV),
+                       frame->data(media::VideoFrame::Plane::kUV).data(),
                        frame->stride(media::VideoFrame::Plane::kUV),
-                       new_frame->writable_data(media::VideoFrame::Plane::kY),
+                       new_frame->writable_data(media::VideoFrame::Plane::kY).data(),
                        new_frame->stride(media::VideoFrame::Plane::kY),
-                       new_frame->writable_data(media::VideoFrame::Plane::kUV),
+                       new_frame->writable_data(media::VideoFrame::Plane::kUV).data(),
                        new_frame->stride(media::VideoFrame::Plane::kUV),
                        coded_size.width(), coded_size.height());
     } else if (frame->format() == media::PIXEL_FORMAT_ARGB) {
       libyuv::ARGBCopy(
-          frame->data(media::VideoFrame::Plane::kARGB),
+          frame->data(media::VideoFrame::Plane::kARGB).data(),
           frame->stride(media::VideoFrame::Plane::kARGB),
-          new_frame->writable_data(media::VideoFrame::Plane::kARGB),
+          new_frame->writable_data(media::VideoFrame::Plane::kARGB).data(),
           new_frame->stride(media::VideoFrame::Plane::kARGB),
           coded_size.width(), coded_size.height());
     } else {
-      libyuv::I420Copy(frame->data(media::VideoFrame::Plane::kY),
+      libyuv::I420Copy(frame->data(media::VideoFrame::Plane::kY).data(),
                        frame->stride(media::VideoFrame::Plane::kY),
-                       frame->data(media::VideoFrame::Plane::kU),
+                       frame->data(media::VideoFrame::Plane::kU).data(),
                        frame->stride(media::VideoFrame::Plane::kU),
-                       frame->data(media::VideoFrame::Plane::kV),
+                       frame->data(media::VideoFrame::Plane::kV).data(),
                        frame->stride(media::VideoFrame::Plane::kV),
-                       new_frame->writable_data(media::VideoFrame::Plane::kY),
+                       new_frame->writable_data(media::VideoFrame::Plane::kY).data(),
                        new_frame->stride(media::VideoFrame::Plane::kY),
-                       new_frame->writable_data(media::VideoFrame::Plane::kU),
+                       new_frame->writable_data(media::VideoFrame::Plane::kU).data(),
                        new_frame->stride(media::VideoFrame::Plane::kU),
-                       new_frame->writable_data(media::VideoFrame::Plane::kV),
+                       new_frame->writable_data(media::VideoFrame::Plane::kV).data(),
                        new_frame->stride(media::VideoFrame::Plane::kV),
                        coded_size.width(), coded_size.height());
     }
     if (frame->format() == media::PIXEL_FORMAT_I420A) {
-      libyuv::CopyPlane(frame->data(media::VideoFrame::Plane::kA),
+      libyuv::CopyPlane(frame->data(media::VideoFrame::Plane::kA).data(),
                         frame->stride(media::VideoFrame::Plane::kA),
-                        new_frame->writable_data(media::VideoFrame::Plane::kA),
+                        new_frame->writable_data(media::VideoFrame::Plane::kA).data(),
                         new_frame->stride(media::VideoFrame::Plane::kA),
                         coded_size.width(), coded_size.height());
     }
diff --git a/third_party/blink/renderer/modules/webcodecs/background_readback.cc b/third_party/blink/renderer/modules/webcodecs/background_readback.cc
index 63e88befd23af..7fabe58b33017 100644
--- a/third_party/blink/renderer/modules/webcodecs/background_readback.cc
+++ b/third_party/blink/renderer/modules/webcodecs/background_readback.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/modules/webcodecs/background_readback.h"
 
+#include "base/containers/span.h"
 #include "base/feature_list.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/task/bind_post_task.h"
@@ -200,7 +201,7 @@ void BackgroundReadback::ReadbackRGBTextureBackedFrameToMemory(
       "media", "ReadbackRGBTextureBackedFrameToMemory", txt_frame.get(),
       "timestamp", txt_frame->timestamp());
 
-  uint8_t* dst_pixels =
+  base::span<uint8_t>dst_pixels =
       result->GetWritableVisibleData(media::VideoFrame::Plane::kARGB);
   int rgba_stide = result->stride(media::VideoFrame::Plane::kARGB);
   DCHECK_GT(rgba_stide, 0);
@@ -266,7 +267,7 @@ void BackgroundReadback::ReadbackRGBTextureBackedFrameToBuffer(
   uint32_t offset = dest_layout.Offset(0);
   uint32_t stride = dest_layout.Stride(0);
 
-  uint8_t* dst_pixels = dest_buffer.subspan(offset).data();
+  base::span<uint8_t>dst_pixels = dest_buffer.subspan(offset);
   size_t max_bytes_written = stride * src_rect.height();
   if (stride <= 0 || max_bytes_written > dest_buffer.size()) {
     DLOG(ERROR) << "Buffer is not sufficiently large for readback";
diff --git a/third_party/blink/renderer/modules/webcodecs/video_decoder.cc b/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
index 9412ea404a8bd..8b05efb6ebdfd 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_decoder.cc
@@ -210,7 +210,7 @@ void ParseH265KeyFrame(const media::DecoderBuffer& buffer, bool* is_key_frame) {
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
   auto buffer_span = base::span(buffer);
   auto result =
-      media::mp4::HEVC::AnalyzeAnnexB(buffer_span.data(), buffer_span.size(),
+      media::mp4::HEVC::AnalyzeAnnexB(buffer_span, buffer_span.size(),
                                       std::vector<media::SubsampleEntry>());
   *is_key_frame = result.is_keyframe.value_or(false);
 #endif  // BUILDFLAG(ENABLE_PLATFORM_HEVC)
diff --git a/third_party/blink/renderer/modules/webcodecs/video_frame.cc b/third_party/blink/renderer/modules/webcodecs/video_frame.cc
index 4554f4f3e9ac5..7bf561a4220c0 100644
--- a/third_party/blink/renderer/modules/webcodecs/video_frame.cc
+++ b/third_party/blink/renderer/modules/webcodecs/video_frame.cc
@@ -1047,8 +1047,8 @@ VideoFrame* VideoFrame::Create(ScriptState* script_state,
     }
 
     for (wtf_size_t i = 0; i < media::VideoFrame::NumPlanes(media_fmt); i++) {
-      libyuv::CopyPlane(src_frame->visible_data(i), src_frame->stride(i),
-                        frame->GetWritableVisibleData(i), frame->stride(i),
+      libyuv::CopyPlane(src_frame->visible_data(i).data(), src_frame->stride(i),
+                        frame->GetWritableVisibleData(i).data(), frame->stride(i),
                         frame->row_bytes(i), frame->rows(i));
     }
   }
diff --git a/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc b/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
index 8b0aea63f6a66..500e2d22856ad 100644
--- a/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
+++ b/third_party/blink/renderer/platform/peerconnection/resolution_monitor_unittest.cc
@@ -112,7 +112,7 @@ std::vector<scoped_refptr<media::DecoderBuffer>> ReadIVF(const std::string& fnam
   media::IvfParser ivf_parser;
   media::IvfFileHeader ivf_header{};
   EXPECT_TRUE(
-      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data.data()),
+      ivf_parser.Initialize(reinterpret_cast<const uint8_t*>(ivf_data),
                             ivf_data.size(), &ivf_header));
 
   std::vector<scoped_refptr<media::DecoderBuffer>> buffers;
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
index 787db4ed0bdce..e2b0d21e63fc4 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_encoder.cc
@@ -192,10 +192,10 @@ class RefCountedWritableSharedMemoryMapping
       const RefCountedWritableSharedMemoryMapping&) = delete;
 
   const unsigned char* front() const {
-    return static_cast<const unsigned char*>(mapping_.memory());
+    return static_cast<const unsigned char*>(mapping_.memory().data());
   }
   unsigned char* front() {
-    return static_cast<unsigned char*>(mapping_.memory());
+    return static_cast<unsigned char*>(mapping_.memory().data());
   }
   size_t size() const { return mapping_.size(); }
 
@@ -2112,7 +2112,7 @@ RTCVideoEncoder::Impl::CreateI420SharedMemoryFrameByLibyuv(
   auto frame = media::VideoFrame::WrapExternalData(
       media::PIXEL_FORMAT_I420, input_frame_coded_size_,
       gfx::Rect(input_visible_size_), input_visible_size_,
-      static_cast<uint8_t*>(mapping.memory()), mapping.size(),
+      static_cast<uint8_t*>(mapping.memory().data()), mapping.size(),
       base::TimeDelta());
   if (!frame) {
     NotifyErrorStatus({media::EncoderStatus::Codes::kEncoderFailedEncode,
@@ -2131,11 +2131,11 @@ RTCVideoEncoder::Impl::CreateI420SharedMemoryFrameByLibyuv(
           i420_buffer->DataY(), i420_buffer->StrideY(), i420_buffer->DataU(),
           i420_buffer->StrideU(), i420_buffer->DataV(), i420_buffer->StrideV(),
           i420_buffer->width(), i420_buffer->height(),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kY),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kY).data(),
           frame->stride(media::VideoFrame::Plane::kY),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kU),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kU).data(),
           frame->stride(media::VideoFrame::Plane::kU),
-          frame->GetWritableVisibleData(media::VideoFrame::Plane::kV),
+          frame->GetWritableVisibleData(media::VideoFrame::Plane::kV).data(),
           frame->stride(media::VideoFrame::Plane::kV),
           frame->visible_rect().width(), frame->visible_rect().height(),
           libyuv::kFilterBox)) {
diff --git a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
index 86057e66f8559..7c2b8089215e4 100644
--- a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
+++ b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer.cc
@@ -55,15 +55,15 @@ class I420FrameAdapter : public webrtc::I420BufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataU() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kU);
+    return frame_->visible_data(media::VideoFrame::Plane::kU).data();
   }
 
   const uint8_t* DataV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kV);
+    return frame_->visible_data(media::VideoFrame::Plane::kV).data();
   }
 
   int StrideY() const override {
@@ -94,19 +94,19 @@ class I420AFrameAdapter : public webrtc::I420ABufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataU() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kU);
+    return frame_->visible_data(media::VideoFrame::Plane::kU).data();
   }
 
   const uint8_t* DataV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kV);
+    return frame_->visible_data(media::VideoFrame::Plane::kV).data();
   }
 
   const uint8_t* DataA() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kA);
+    return frame_->visible_data(media::VideoFrame::Plane::kA).data();
   }
 
   int StrideY() const override {
@@ -141,11 +141,11 @@ class NV12FrameAdapter : public webrtc::NV12BufferInterface {
   int height() const override { return frame_->visible_rect().height(); }
 
   const uint8_t* DataY() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kY);
+    return frame_->visible_data(media::VideoFrame::Plane::kY).data();
   }
 
   const uint8_t* DataUV() const override {
-    return frame_->visible_data(media::VideoFrame::Plane::kUV);
+    return frame_->visible_data(media::VideoFrame::Plane::kUV).data();
   }
 
   int StrideY() const override {
diff --git a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
index 0e1eaa3e51e0d..0391bd054b693 100644
--- a/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
+++ b/third_party/blink/renderer/platform/webrtc/convert_to_webrtc_video_frame_buffer_test.cc
@@ -299,7 +299,7 @@ TEST_F(ConvertToWebRtcVideoFrameBufferTest,
                       media::VideoPixelFormat::PIXEL_FORMAT_ARGB,
                       base::TimeDelta(), test_sii_.get());
   // fill mock image with whilte color.
-  memset(memory_frame->writable_data(media::VideoFrame::Plane::kARGB), 0xFF,
+  memset(memory_frame->writable_data(media::VideoFrame::Plane::kARGB).data(), 0xFF,
          kCodedSize.GetArea() * 4);
 
   // Should call texture conversion.
diff --git a/third_party/lzma_sdk/google/seven_zip_reader.cc b/third_party/lzma_sdk/google/seven_zip_reader.cc
index 8b217dff20856..6e9bd452c6919 100644
--- a/third_party/lzma_sdk/google/seven_zip_reader.cc
+++ b/third_party/lzma_sdk/google/seven_zip_reader.cc
@@ -11,6 +11,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/containers/span.h"
 #include "base/check.h"
 #include "base/containers/buffer_iterator.h"
 #include "base/containers/heap_array.h"
@@ -93,7 +94,7 @@ class SevenZipReaderImpl {
   base::span<uint8_t> mapped_span() {
     if (!temp_file_mapped_)
       return base::span<uint8_t>();
-    return base::span<uint8_t>(temp_file_mapped_->data(),
+    return base::span<uint8_t>(temp_file_mapped_->data().data(),
                                temp_file_mapped_->length());
   }
   EntryInfo GetEntryInfo(size_t entry_index) const;
@@ -320,7 +321,7 @@ Result SevenZipReaderImpl::ExtractFile(size_t entry_index,
 
     // Copy the range of extracted folder corresponding to `entry_index` into
     // `output`.
-    memcpy(output.data(), temp_file_mapped_->data() + file_offset_in_folder,
+    memcpy(output.data(), temp_file_mapped_->data() .subspan( file_offset_in_folder).data(),
            output.size());
   } else {
     // Extract directly into `output`.
@@ -516,7 +517,7 @@ Result SevenZipReaderImpl::ExtractIntoTempFile(size_t folder_index) {
   }
 
   SRes sz_res = SzAr_DecodeFolder(&db_.db, folder_index, &look_stream_.vt,
-                                  db_.dataPos, temp_file_mapped_->data(),
+                                  db_.dataPos, temp_file_mapped_->data().data(),
                                   folder_unpack_size, &alloc_temp_);
 
   if (sz_res != SZ_OK) {
diff --git a/ui/base/resource/data_pack.cc b/ui/base/resource/data_pack.cc
index d72d8a25eb568..344dc88802751 100644
--- a/ui/base/resource/data_pack.cc
+++ b/ui/base/resource/data_pack.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -122,7 +124,7 @@ class DataPack::MemoryMappedDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return mmap_->length(); }
-  const uint8_t* GetData() const override { return mmap_->data(); }
+  const base::span<uint8_t> GetData() const override { return mmap_->data(); }
 
  private:
   std::unique_ptr<base::MemoryMappedFile> mmap_;
@@ -140,7 +142,7 @@ class DataPack::StringDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return data_.size(); }
-  const uint8_t* GetData() const override {
+  const base::span<uint8_t> GetData() const override {
     return reinterpret_cast<const uint8_t*>(data_.c_str());
   }
 
@@ -160,7 +162,7 @@ class DataPack::BufferDataSource : public DataPack::DataSource {
 
   // DataPack::DataSource:
   size_t GetLength() const override { return buffer_.size(); }
-  const uint8_t* GetData() const override { return buffer_.data(); }
+  const base::span<uint8_t> GetData() const override { return buffer_; }
 
  private:
   base::raw_span<const uint8_t> buffer_;
@@ -201,7 +203,7 @@ std::unique_ptr<DataPack::DataSource> DataPack::LoadFromPathInternal(
     return nullptr;
   }
   if (net::GZipHeader::HasGZipHeader(mmap->bytes())) {
-    std::string_view compressed(reinterpret_cast<char*>(mmap->data()),
+    std::string_view compressed(reinterpret_cast<char*>(mmap->data().data()),
                                 mmap->length());
     std::string data;
     if (!compression::GzipUncompress(compressed, &data)) {
@@ -244,7 +246,7 @@ bool DataPack::LoadFromBuffer(base::span<const uint8_t> buffer) {
 }
 
 bool DataPack::SanityCheckFileAndRegisterResources(size_t margin_to_skip,
-                                                   const uint8_t* data,
+                                                   base::span<const uint8_t>data,
                                                    size_t data_length) {
   // 1) Check we have enough entries. There's an extra entry after the last item
   // which gives the length of the last item.
@@ -297,12 +299,12 @@ bool DataPack::SanityCheckFileAndRegisterResources(size_t margin_to_skip,
 }
 
 bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
-  const uint8_t* data = data_source->GetData();
+  base::span<const uint8_t>data = data_source->GetData();
   size_t data_length = data_source->GetLength();
   // Parse the version and check for truncated header.
   uint32_t version = 0;
   if (data_length > sizeof(version)) {
-    memcpy(&version, data, sizeof(uint32_t));
+    memcpy(&version, data.data(), sizeof(uint32_t));
   }
   size_t header_length =
       version == kFileFormatV4 ? kHeaderLengthV4 : kHeaderLengthV5;
@@ -313,14 +315,14 @@ bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
 
   // Parse the header of the file.
   if (version == kFileFormatV4) {
-    memcpy(&resource_count_, data + 4, sizeof(uint32_t));
+    memcpy(&resource_count_, data .subspan( 4).data(), sizeof(uint32_t));
     alias_count_ = 0;
     text_encoding_type_ = static_cast<TextEncodingType>(data[8]);
   } else if (version == kFileFormatV5) {
     // Version 5 added the alias table and changed the header format.
     text_encoding_type_ = static_cast<TextEncodingType>(data[4]);
-    memcpy(&resource_count_, data + 8, sizeof(uint16_t));
-    memcpy(&alias_count_, data + 10, sizeof(uint16_t));
+    memcpy(&resource_count_, data .subspan( 8).data(), sizeof(uint16_t));
+    memcpy(&alias_count_, data .subspan( 10).data(), sizeof(uint16_t));
   } else {
     LOG(ERROR) << "Bad data pack version: got " << version << ", expected "
                << kFileFormatV4 << " or " << kFileFormatV5;
@@ -366,9 +368,9 @@ bool DataPack::HasResource(uint16_t resource_id) const {
 // static
 std::string_view DataPack::GetStringViewFromOffset(uint32_t target_offset,
                                                    uint32_t next_offset,
-                                                   const uint8_t* data_source) {
+                                                   base::span<const uint8_t>data_source) {
   size_t length = next_offset - target_offset;
-  return {reinterpret_cast<const char*>(data_source + target_offset), length};
+  return {reinterpret_cast<const char*>(data_source .subspan( target_offset).data()), length};
 }
 
 std::optional<std::string_view> DataPack::GetStringView(
diff --git a/ui/base/resource/data_pack.h b/ui/base/resource/data_pack.h
index 369c4e3291d70..d0a09894e4a13 100644
--- a/ui/base/resource/data_pack.h
+++ b/ui/base/resource/data_pack.h
@@ -17,6 +17,8 @@
 #include <string_view>
 #include <vector>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/component_export.h"
 #include "base/files/file.h"
 #include "base/files/memory_mapped_file.h"
@@ -102,14 +104,14 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
 
    private:
     friend class DataPack;
-    explicit Iterator(const uint8_t* data_source, const Entry* entry)
+    explicit Iterator(base::span<const uint8_t>data_source, const Entry* entry)
         : data_source_(data_source), entry_(entry) {
       UpdateResourceData();
     }
 
     void UpdateResourceData();
 
-    raw_ptr<const uint8_t> data_source_;
+    base::raw_span<const uint8_t> data_source_;
     raw_ptr<ResourceData> resource_data_;
     raw_ptr<const Entry, AllowPtrArithmetic> entry_;
   };
@@ -123,7 +125,7 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
     virtual ~DataSource() = default;
 
     virtual size_t GetLength() const = 0;
-    virtual const uint8_t* GetData() const = 0;
+    virtual const base::span<uint8_t> GetData() const = 0;
   };
 
   // Load a pack file from |path|, returning false on error. If the final
@@ -205,13 +207,13 @@ class COMPONENT_EXPORT(UI_DATA_PACK) DataPack : public ResourceHandle {
   // If there is no extra data in data pack, `margin_to_skip` is equal to the
   // length of file header.
   bool SanityCheckFileAndRegisterResources(size_t margin_to_skip,
-                                           const uint8_t* data,
+                                           base::span<const uint8_t>data,
                                            size_t data_length);
 
   // Returns the string between `target_offset` and `next_offset` in data pack.
   static std::string_view GetStringViewFromOffset(uint32_t target_offset,
                                                   uint32_t next_offset,
-                                                  const uint8_t* data_source);
+                                                  base::span<const uint8_t>data_source);
 
   std::unique_ptr<DataSource> data_source_;
 
diff --git a/ui/gfx/client_native_pixmap.h b/ui/gfx/client_native_pixmap.h
index 01193111f6ce1..3349677ad74ae 100644
--- a/ui/gfx/client_native_pixmap.h
+++ b/ui/gfx/client_native_pixmap.h
@@ -5,6 +5,7 @@
 #ifndef UI_GFX_CLIENT_NATIVE_PIXMAP_H_
 #define UI_GFX_CLIENT_NATIVE_PIXMAP_H_
 
+#include "base/containers/span.h"
 #include "base/component_export.h"
 
 namespace gfx {
@@ -24,7 +25,7 @@ class COMPONENT_EXPORT(GFX) ClientNativePixmap {
   virtual void Unmap() = 0;
 
   virtual size_t GetNumberOfPlanes() const = 0;
-  virtual void* GetMemoryAddress(size_t plane) const = 0;
+  virtual base::span<void> GetMemoryAddress(size_t plane) const = 0;
   virtual int GetStride(size_t plane) const = 0;
   virtual NativePixmapHandle CloneHandleForIPC() const = 0;
 };
diff --git a/ui/gfx/gpu_memory_buffer.h b/ui/gfx/gpu_memory_buffer.h
index 07e99e88d8f6b..2fb6c2697d78c 100644
--- a/ui/gfx/gpu_memory_buffer.h
+++ b/ui/gfx/gpu_memory_buffer.h
@@ -10,6 +10,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/component_export.h"
 #include "base/memory/unsafe_shared_memory_region.h"
 #include "build/build_config.h"
@@ -280,7 +281,7 @@ class COMPONENT_EXPORT(GFX) GpuMemoryBuffer {
 
   // Returns a pointer to the memory address of a plane. Buffer must have been
   // successfully mapped using a call to Map() before calling this function.
-  virtual void* memory(size_t plane) = 0;
+  virtual base::span<void> memory(size_t plane) = 0;
 
   // Unmaps the buffer. It's illegal to use any pointer returned by memory()
   // after this has been called.
diff --git a/ui/gfx/linux/client_native_pixmap_dmabuf.cc b/ui/gfx/linux/client_native_pixmap_dmabuf.cc
index 0862e12cb7806..9bb543ff9bc39 100644
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.cc
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.cc
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
+
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
@@ -92,12 +94,12 @@ ClientNativePixmapDmaBuf::PlaneInfo::PlaneInfo() = default;
 ClientNativePixmapDmaBuf::PlaneInfo::PlaneInfo(PlaneInfo&& info)
     : data(info.data), offset(info.offset), size(info.size) {
   // Set nullptr to info.data in order not to call munmap in |info| dtor.
-  info.data = nullptr;
+  info.data = {};
 }
 
 ClientNativePixmapDmaBuf::PlaneInfo::~PlaneInfo() {
-  if (data) {
-    int ret = munmap(data, offset + size);
+  if (!data.empty()) {
+    int ret = munmap(data.data(), offset + size);
     DCHECK(!ret);
   }
 }
@@ -249,11 +251,11 @@ size_t ClientNativePixmapDmaBuf::GetNumberOfPlanes() const {
   return pixmap_handle_.planes.size();
 }
 
-void* ClientNativePixmapDmaBuf::GetMemoryAddress(size_t plane) const {
+base::span<void> ClientNativePixmapDmaBuf::GetMemoryAddress(size_t plane) const {
   DCHECK_LT(plane, pixmap_handle_.planes.size());
   CHECK(mapped_);
-  return static_cast<uint8_t*>(plane_info_[plane].data) +
-         plane_info_[plane].offset;
+  return static_cast<uint8_t*>(plane_info_[plane].data) .subspan(
+         plane_info_[plane].offset);
 }
 
 int ClientNativePixmapDmaBuf::GetStride(size_t plane) const {
diff --git a/ui/gfx/linux/client_native_pixmap_dmabuf.h b/ui/gfx/linux/client_native_pixmap_dmabuf.h
index 90ed56f2ab363..ab805075e1680 100644
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.h
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.h
@@ -10,6 +10,8 @@
 #include <array>
 #include <memory>
 
+#include "base/containers/span.h"
+#include "base/memory/raw_span.h"
 #include "base/component_export.h"
 #include "base/files/scoped_file.h"
 #include "base/memory/raw_ptr.h"
@@ -45,7 +47,7 @@ class ClientNativePixmapDmaBuf : public gfx::ClientNativePixmap {
   void Unmap() override;
 
   size_t GetNumberOfPlanes() const override;
-  void* GetMemoryAddress(size_t plane) const override;
+  base::span<void> GetMemoryAddress(size_t plane) const override;
   int GetStride(size_t plane) const override;
   NativePixmapHandle CloneHandleForIPC() const override;
 
@@ -57,7 +59,7 @@ class ClientNativePixmapDmaBuf : public gfx::ClientNativePixmap {
     PlaneInfo(PlaneInfo&& plane_info);
     ~PlaneInfo();
 
-    raw_ptr<void> data = nullptr;
+    base::raw_span<void> data = nullptr;
     size_t offset = 0;
     size_t size = 0;
   };
diff --git a/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc b/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
index c65ab9bd87c6c..4781a0d5be85a 100644
--- a/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
+++ b/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/trace_event/trace_event.h"
@@ -32,7 +33,7 @@ class ClientNativePixmapOpaque : public ClientNativePixmap {
   size_t GetNumberOfPlanes() const override {
     return pixmap_handle_.planes.size();
   }
-  void* GetMemoryAddress(size_t plane) const override { NOTREACHED(); }
+  base::span<void> GetMemoryAddress(size_t plane) const override { NOTREACHED(); }
   int GetStride(size_t plane) const override {
     CHECK_LT(plane, pixmap_handle_.planes.size());
     // Even though a ClientNativePixmapOpaque should not be mapped, we may still
diff --git a/ui/gl/test/gl_test_support.cc b/ui/gl/test/gl_test_support.cc
index f2b911a47d5eb..7926dc1bdc8b2 100644
--- a/ui/gl/test/gl_test_support.cc
+++ b/ui/gl/test/gl_test_support.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/containers/span.h"
 #include "ui/gl/test/gl_test_support.h"
 
 #include <array>
@@ -36,27 +37,27 @@ void rgb_to_yuv(uint8_t r, uint8_t g, uint8_t b, T* y, T* u, T* v) {
   *v = (0.439 * r) - (0.368 * g) - (0.071 * b) + 128;
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint8_t> ToSpan_uint8(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint8_t> ToSpan_uint8(base::span<uint8_t>data,
                                                      size_t start,
                                                      size_t size) {
   return UNSAFE_BUFFERS(base::span<uint8_t>(data + start, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint16_t> ToSpan_uint16(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint16_t> ToSpan_uint16(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint16_t* pointer = reinterpret_cast<uint16_t*>(UNSAFE_BUFFERS(data + start));
   return UNSAFE_BUFFERS(base::span<uint16_t>(pointer, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint32_t> ToSpan_uint32(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint32_t> ToSpan_uint32(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint32_t* pointer = reinterpret_cast<uint32_t*>(UNSAFE_BUFFERS(data + start));
   return UNSAFE_BUFFERS(base::span<uint32_t>(pointer, size));
 }
 
-UNSAFE_BUFFER_USAGE base::span<uint64_t> ToSpan_uint64(uint8_t* data,
+UNSAFE_BUFFER_USAGE base::span<uint64_t> ToSpan_uint64(base::span<uint8_t>data,
                                                        size_t start,
                                                        size_t size) {
   uint64_t* pointer = reinterpret_cast<uint64_t*>(UNSAFE_BUFFERS(data + start));
@@ -109,19 +110,19 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                          int plane,
                                          gfx::BufferFormat format,
                                          base::span<const uint8_t, 4> color,
-                                         uint8_t* data) {
+                                         base::span<uint8_t>data) {
   switch (format) {
     case gfx::BufferFormat::R_8:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint8(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), y * stride, width));
         std::ranges::fill(row, color[0]);  // R
       }
       return;
     case gfx::BufferFormat::RG_88:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, (color[1] << 8) |  // G
                                    color[0]);     // R
       }
@@ -129,14 +130,14 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::R_16:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, color[0] << 8);  // R
       }
       return;
     case gfx::BufferFormat::RG_1616:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[1] << 24) |     // G
                                    (color[0] << 8));  // R
       }
@@ -144,7 +145,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBA_4444:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, ((color[3] & 0xf) << 4) |      // A
                                    (color[2] & 0xf) |         // B
                                    (color[1] << 12) |         // G
@@ -154,7 +155,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGR_565:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
         std::ranges::fill(row, ((color[0] >> 3) << 11) |     // R
                                    ((color[1] >> 2) << 5) |  // G
                                    (color[2] >> 3));         // B
@@ -163,7 +164,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBX_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (0xaa << 24) |          // unused
                                    (color[2] << 16) |  // B
                                    (color[1] << 8) |   // G
@@ -173,7 +174,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::RGBA_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[3] << 24) |      // A
                                    (color[2] << 16) |  // B
                                    (color[1] << 8) |   // G
@@ -183,7 +184,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGRX_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (0xaa << 24) |          // unused
                                    (color[0] << 16) |  // R
                                    (color[1] << 8) |   // G
@@ -196,7 +197,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                       "precision for the supplied value";
       const uint8_t scaled_alpha = color[3] >> 6;
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(
             row,
             (scaled_alpha << 30) |                             // A
@@ -212,7 +213,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
                                       "precision for the supplied value";
       const uint8_t scaled_alpha = color[3] >> 6;
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(
             row, (scaled_alpha << 30) |                             // A
                      (((color[2] << 2) | (color[2] >> 6)) << 20) |  // B
@@ -224,7 +225,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
     case gfx::BufferFormat::BGRA_8888:
       DCHECK_EQ(0, plane);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width));
         std::ranges::fill(row, (color[3] << 24) |      // A
                                    (color[0] << 16) |  // R
                                    (color[1] << 8) |   // G
@@ -242,7 +243,7 @@ void GLTestSupport::SetBufferDataToColor(int width,
       uint16_t half_float_color[4];
       gfx::FloatToHalfFloat(float_color, half_float_color, 4);
       for (int y = 0; y < height; ++y) {
-        auto row = UNSAFE_TODO(ToSpan_uint64(data, y * stride, width));
+        auto row = UNSAFE_TODO(ToSpan_uint64(data.data(), y * stride, width));
         std::ranges::fill(row, base::bit_cast<uint64_t>(half_float_color));
       }
       return;
@@ -256,12 +257,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yvu[0]);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width / 2));
           std::ranges::fill(row, yvu[plane]);
         }
       }
@@ -276,12 +277,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[0]);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), stride * y, width / 2));
           std::ranges::fill(row, (yuv[2] << 8) | yuv[1]);
         }
       }
@@ -297,17 +298,17 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[0]);
         }
       } else if (plane == 1) {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, stride * y, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), stride * y, width / 2));
           std::ranges::fill(row, (yuv[2] << 8) | yuv[1]);
         }
       } else {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint8(data, stride * y, width));
+          auto row = UNSAFE_TODO(ToSpan_uint8(data.data(), stride * y, width));
           std::ranges::fill(row, yuv[3]);
         }
       }
@@ -322,12 +323,12 @@ void GLTestSupport::SetBufferDataToColor(int width,
 
       if (plane == 0) {
         for (int y = 0; y < height; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint16(data, y * stride, width));
+          auto row = UNSAFE_TODO(ToSpan_uint16(data.data(), y * stride, width));
           std::ranges::fill(row, yuv[0] << 2);
         }
       } else {
         for (int y = 0; y < height / 2; ++y) {
-          auto row = UNSAFE_TODO(ToSpan_uint32(data, y * stride, width / 2));
+          auto row = UNSAFE_TODO(ToSpan_uint32(data.data(), y * stride, width / 2));
           std::ranges::fill(row, (yuv[2] << 18) | (yuv[1] << 2));
         }
       }
diff --git a/ui/gl/test/gl_test_support.h b/ui/gl/test/gl_test_support.h
index 06fe53efd1419..57352129e41b4 100644
--- a/ui/gl/test/gl_test_support.h
+++ b/ui/gl/test/gl_test_support.h
@@ -34,7 +34,7 @@ class GLTestSupport {
                                    int plane,
                                    gfx::BufferFormat format,
                                    base::span<const uint8_t, 4> color,
-                                   uint8_t* data);
+                                   base::span<uint8_t>data);
 };
 
 }  // namespace gl
diff --git a/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc b/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
index 72dd5d8cb2e49..fa51a3f535d8e 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_canvas_surface.cc
@@ -91,7 +91,7 @@ class WaylandCanvasSurface::SharedMemoryBuffer {
     SkSurfaceProps props = skia::LegacyDisplayGlobals::GetSkSurfaceProps();
     sk_surface_ = SkSurfaces::WrapPixels(
         SkImageInfo::MakeN32Premul(size.width(), size.height()),
-        shm_mapping_.memory(), CalculateStride(size.width()), &props);
+        shm_mapping_.memory().data(), CalculateStride(size.width()), &props);
     DCHECK(sk_surface_);
 
     dirty_region_.setRect(gfx::RectToSkIRect(gfx::Rect(size)));
diff --git a/ui/ozone/platform/wayland/host/wayland_shm_buffer.cc b/ui/ozone/platform/wayland/host/wayland_shm_buffer.cc
index d1d36e7657b7b..3bf4673fe596a 100644
--- a/ui/ozone/platform/wayland/host/wayland_shm_buffer.cc
+++ b/ui/ozone/platform/wayland/host/wayland_shm_buffer.cc
@@ -60,7 +60,7 @@ void WaylandShmBuffer::Initialize(WaylandBufferFactory* buffer_factory) {
 uint8_t* WaylandShmBuffer::GetMemory() {
   if (!IsValid() || !shared_memory_mapping_.IsValid())
     return nullptr;
-  return shared_memory_mapping_.GetMemoryAs<uint8_t>();
+  return shared_memory_mapping_.GetMemoryAs<uint8_t>().data();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 73a465b6ea537..5a9cd5a6dd442 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -266,7 +266,7 @@ void WaylandTestBase::MaybeSetUpXkb() {
             std::move(shared_keymap_region));
     ASSERT_TRUE(shared_keymap.IsValid());
 
-    memcpy(shared_keymap.memory(), keymap_string.get(), keymap_size);
+    memcpy(shared_keymap.memory().data(), keymap_string.get(), keymap_size);
 
     auto* const keyboard = server->seat()->keyboard()->resource();
     ASSERT_TRUE(keyboard);
diff --git a/ui/surface/transport_dib.cc b/ui/surface/transport_dib.cc
index bd4d3c4295d22..8d3de86b14b5e 100644
--- a/ui/surface/transport_dib.cc
+++ b/ui/surface/transport_dib.cc
@@ -94,7 +94,7 @@ bool TransportDIB::Map() {
 }
 
 const void* TransportDIB::memory() const {
-  return shm_mapping_.IsValid() ? shm_mapping_.memory() : nullptr;
+  return shm_mapping_.IsValid() ? shm_mapping_.memory().data() : nullptr;
 }
 
 base::UnsafeSharedMemoryRegion* TransportDIB::shared_memory_region() {
```

## Build Failure Log

```
Overlapping replacements: ./media/base/video_util_unittest.cc at offset 3492, length 15: "base::span<const uint8_t>" and offset 3492, length 31: "base::span<const uint8_t>"
Overlapping replacements: ./mojo/public/cpp/base/big_buffer.h at offset 6111, length 8: "" and offset 6113, length 0: "*"
Overlapping replacements: ./mojo/public/cpp/base/big_buffer.h at offset 5903, length 8: "" and offset 5905, length 0: "*"
Overlapping replacements: ./mojo/public/cpp/base/big_buffer.h at offset 5681, length 8: "" and offset 5683, length 0: "*"
Overlapping replacements: ./mojo/public/cpp/base/big_buffer.h at offset 5277, length 8: "" and offset 5279, length 0: "*"
Applied 21 edits (0 errors) to 1 files [0.34%]
Applied 35 edits (0 errors) to 2 files [0.68%]
Applied 43 edits (0 errors) to 3 files [1.02%]
Applied 80 edits (0 errors) to 4 files [1.36%]
Applied 85 edits (0 errors) to 5 files [1.70%]
Applied 89 edits (0 errors) to 6 files [2.04%]
Applied 115 edits (0 errors) to 7 files [2.38%]
Applied 149 edits (0 errors) to 8 files [2.72%]
Applied 150 edits (0 errors) to 9 files [3.06%]
Applied 154 edits (0 errors) to 10 files [3.40%]
Applied 175 edits (0 errors) to 11 files [3.74%]
Applied 183 edits (0 errors) to 12 files [4.08%]
Applied 193 edits (0 errors) to 13 files [4.42%]
Applied 203 edits (0 errors) to 14 files [4.76%]
Applied 213 edits (0 errors) to 15 files [5.10%]
Applied 214 edits (0 errors) to 16 files [5.44%]
Applied 215 edits (0 errors) to 17 files [5.78%]
Applied 236 edits (0 errors) to 18 files [6.12%]
Applied 245 edits (0 errors) to 19 files [6.46%]
Applied 250 edits (0 errors) to 20 files [6.80%]
Applied 259 edits (0 errors) to 21 files [7.14%]
Applied 308 edits (0 errors) to 22 files [7.48%]
Applied 326 edits (0 errors) to 23 files [7.82%]
Applied 331 edits (0 errors) to 24 files [8.16%]
Applied 339 edits (0 errors) to 25 files [8.50%]
Applied 367 edits (0 errors) to 26 files [8.84%]
Applied 384 edits (0 errors) to 27 files [9.18%]
Applied 391 edits (0 errors) to 28 files [9.52%]
Applied 405 edits (0 errors) to 29 files [9.86%]
Applied 441 edits (0 errors) to 30 files [10.20%]
Applied 446 edits (0 errors) to 31 files [10.54%]
Applied 468 edits (0 errors) to 32 files [10.88%]
Applied 475 edits (0 errors) to 33 files [11.22%]
Applied 479 edits (0 errors) to 34 files [11.56%]
Applied 512 edits (0 errors) to 35 files [11.90%]
Applied 535 edits (0 errors) to 36 files [12.24%]
Applied 537 edits (0 errors) to 37 files [12.59%]
Applied 540 edits (0 errors) to 38 files [12.93%]
Applied 549 edits (0 errors) to 39 files [13.27%]
Applied 555 edits (0 errors) to 40 files [13.61%]
Applied 566 edits (0 errors) to 41 files [13.95%]
Applied 598 edits (0 errors) to 42 files [14.29%]
Applied 605 edits (0 errors) to 43 files [14.63%]
Applied 618 edits (0 errors) to 44 files [14.97%]
Applied 625 edits (0 errors) to 45 files [15.31%]
Applied 633 edits (0 errors) to 46 files [15.65%]
Applied 635 edits (0 errors) to 47 files [15.99%]
Applied 641 edits (0 errors) to 48 files [16.33%]
Applied 654 edits (0 errors) to 49 files [16.67%]
Applied 655 edits (0 errors) to 50 files [17.01%]
Applied 669 edits (0 errors) to 51 files [17.35%]
Applied 670 edits (0 errors) to 52 files [17.69%]
Applied 680 edits (0 errors) to 53 files [18.03%]
Applied 687 edits (0 errors) to 54 files [18.37%]
Applied 688 edits (0 errors) to 55 files [18.71%]
Applied 744 edits (0 errors) to 56 files [19.05%]
Applied 753 edits (0 errors) to 57 files [19.39%]
Applied 755 edits (0 errors) to 58 files [19.73%]
Applied 756 edits (0 errors) to 59 files [20.07%]
Applied 761 edits (0 errors) to 60 files [20.41%]
Applied 768 edits (0 errors) to 61 files [20.75%]
Applied 773 edits (0 errors) to 62 files [21.09%]
Applied 808 edits (0 errors) to 63 files [21.43%]
Applied 812 edits (0 errors) to 64 files [21.77%]
Applied 816 edits (0 errors) to 65 files [22.11%]
Applied 840 edits (0 errors) to 66 files [22.45%]
Applied 863 edits (1 errors) to 67 files [22.79%]
Applied 879 edits (1 errors) to 68 files [23.13%]
Applied 883 edits (1 errors) to 69 files [23.47%]
Applied 885 edits (1 errors) to 70 files [23.81%]
Applied 887 edits (1 errors) to 71 files [24.15%]
Applied 892 edits (1 errors) to 72 files [24.49%]
Applied 906 edits (1 errors) to 73 files [24.83%]
Applied 912 edits (1 errors) to 74 files [25.17%]
Applied 946 edits (1 errors) to 75 files [25.51%]
Applied 950 edits (1 errors) to 76 files [25.85%]
Applied 960 edits (1 errors) to 77 files [26.19%]
Applied 989 edits (1 errors) to 78 files [26.53%]
Applied 994 edits (1 errors) to 79 files [26.87%]
Applied 1010 edits (1 errors) to 80 files [27.21%]
Applied 1021 edits (1 errors) to 81 files [27.55%]
Applied 1023 edits (1 errors) to 82 files [27.89%]
Applied 1025 edits (1 errors) to 83 files [28.23%]
Applied 1036 edits (1 errors) to 84 files [28.57%]
Applied 1040 edits (1 errors) to 85 files [28.91%]
Applied 1048 edits (1 errors) to 86 files [29.25%]
Applied 1061 edits (5 errors) to 87 files [29.59%]
Applied 1065 edits (5 errors) to 88 files [29.93%]
Applied 1069 edits (5 errors) to 89 files [30.27%]
Applied 1071 edits (5 errors) to 90 files [30.61%]
Applied 1074 edits (5 errors) to 91 files [30.95%]
Applied 1075 edits (5 errors) to 92 files [31.29%]
Applied 1077 edits (5 errors) to 93 files [31.63%]
Applied 1078 edits (5 errors) to 94 files [31.97%]
Applied 1082 edits (5 errors) to 95 files [32.31%]
Applied 1092 edits (5 errors) to 96 files [32.65%]
Applied 1096 edits (5 errors) to 97 files [32.99%]
Applied 1101 edits (5 errors) to 98 files [33.33%]
Applied 1110 edits (5 errors) to 99 files [33.67%]
Applied 1116 edits (5 errors) to 100 files [34.01%]
Applied 1118 edits (5 errors) to 101 files [34.35%]
Applied 1127 edits (5 errors) to 102 files [34.69%]
Applied 1130 edits (5 errors) to 103 files [35.03%]
Applied 1142 edits (5 errors) to 104 files [35.37%]
Applied 1151 edits (5 errors) to 105 files [35.71%]
Applied 1160 edits (5 errors) to 106 files [36.05%]
Applied 1175 edits (5 errors) to 107 files [36.39%]
Applied 1177 edits (5 errors) to 108 files [36.73%]
Applied 1191 edits (5 errors) to 109 files [37.07%]
Applied 1215 edits (5 errors) to 110 files [37.41%]
Applied 1221 edits (5 errors) to 111 files [37.76%]
Applied 1223 edits (5 errors) to 112 files [38.10%]
Applied 1224 edits (5 errors) to 113 files [38.44%]
Applied 1227 edits (5 errors) to 114 files [38.78%]
Applied 1234 edits (5 errors) to 115 files [39.12%]
Applied 1237 edits (5 errors) to 116 files [39.46%]
Applied 1244 edits (5 errors) to 117 files [39.80%]
Applied 1249 edits (5 errors) to 118 files [40.14%]
Applied 1252 edits (5 errors) to 119 files [40.48%]
Applied 1255 edits (5 errors) to 120 files [40.82%]
Applied 1257 edits (5 errors) to 121 files [41.16%]
Applied 1264 edits (5 errors) to 122 files [41.50%]
Applied 1266 edits (5 errors) to 123 files [41.84%]
Applied 1274 edits (5 errors) to 124 files [42.18%]
Applied 1278 edits (5 errors) to 125 files [42.52%]
Applied 1288 edits (5 errors) to 126 files [42.86%]
Applied 1295 edits (5 errors) to 127 files [43.20%]
Applied 1297 edits (5 errors) to 128 files [43.54%]
Applied 1301 edits (5 errors) to 129 files [43.88%]
Applied 1314 edits (5 errors) to 130 files [44.22%]
Applied 1320 edits (5 errors) to 131 files [44.56%]
Applied 1324 edits (5 errors) to 132 files [44.90%]
Applied 1325 edits (5 errors) to 133 files [45.24%]
Applied 1333 edits (5 errors) to 134 files [45.58%]
Applied 1337 edits (5 errors) to 135 files [45.92%]
Applied 1338 edits (5 errors) to 136 files [46.26%]
Applied 1360 edits (5 errors) to 137 files [46.60%]
Applied 1361 edits (5 errors) to 138 files [46.94%]
Applied 1366 edits (5 errors) to 139 files [47.28%]
Applied 1369 edits (5 errors) to 140 files [47.62%]
Applied 1375 edits (5 errors) to 141 files [47.96%]
Applied 1378 edits (5 errors) to 142 files [48.30%]
Applied 1379 edits (5 errors) to 143 files [48.64%]
Applied 1382 edits (5 errors) to 144 files [48.98%]
Applied 1383 edits (5 errors) to 145 files [49.32%]
Applied 1385 edits (5 errors) to 146 files [49.66%]
Applied 1387 edits (5 errors) to 147 files [50.00%]
Applied 1392 edits (5 errors) to 148 files [50.34%]
Applied 1397 edits (5 errors) to 149 files [50.68%]
Applied 1402 edits (5 errors) to 150 files [51.02%]
Applied 1404 edits (5 errors) to 151 files [51.36%]
Applied 1409 edits (5 errors) to 152 files [51.70%]
Applied 1410 edits (5 errors) to 153 files [52.04%]
Applied 1415 edits (5 errors) to 154 files [52.38%]
Applied 1420 edits (5 errors) to 155 files [52.72%]
Applied 1421 edits (5 errors) to 156 files [53.06%]
Applied 1422 edits (5 errors) to 157 files [53.40%]
Applied 1423 edits (5 errors) to 158 files [53.74%]
Applied 1426 edits (5 errors) to 159 files [54.08%]
Applied 1433 edits (5 errors) to 160 files [54.42%]
Applied 1435 edits (5 errors) to 161 files [54.76%]
Applied 1439 edits (5 errors) to 162 files [55.10%]
Applied 1441 edits (5 errors) to 163 files [55.44%]
Applied 1443 edits (5 errors) to 164 files [55.78%]
Applied 1453 edits (5 errors) to 165 files [56.12%]
Applied 1454 edits (5 errors) to 166 files [56.46%]
Applied 1472 edits (5 errors) to 167 files [56.80%]
Applied 1474 edits (5 errors) to 168 files [57.14%]
Applied 1479 edits (5 errors) to 169 files [57.48%]
Applied 1480 edits (5 errors) to 170 files [57.82%]
Applied 1489 edits (5 errors) to 171 files [58.16%]
Applied 1492 edits (5 errors) to 172 files [58.50%]
Applied 1504 edits (5 errors) to 173 files [58.84%]
Applied 1506 edits (5 errors) to 174 files [59.18%]
Applied 1508 edits (5 errors) to 175 files [59.52%]
Applied 1509 edits (5 errors) to 176 files [59.86%]
Applied 1510 edits (5 errors) to 177 files [60.20%]
Applied 1515 edits (5 errors) to 178 files [60.54%]
Applied 1517 edits (5 errors) to 179 files [60.88%]
Applied 1520 edits (5 errors) to 180 files [61.22%]
Applied 1521 edits (5 errors) to 181 files [61.56%]
Applied 1523 edits (5 errors) to 182 files [61.90%]
Applied 1524 edits (5 errors) to 183 files [62.24%]
Applied 1527 edits (5 errors) to 184 files [62.59%]
Applied 1530 edits (5 errors) to 185 files [62.93%]
Applied 1536 edits (5 errors) to 186 files [63.27%]
Applied 1538 edits (5 errors) to 187 files [63.61%]
Applied 1542 edits (5 errors) to 188 files [63.95%]
Applied 1544 edits (5 errors) to 189 files [64.29%]
Applied 1546 edits (5 errors) to 190 files [64.63%]
Applied 1549 edits (5 errors) to 191 files [64.97%]
Applied 1551 edits (5 errors) to 192 files [65.31%]
Applied 1554 edits (5 errors) to 193 files [65.65%]
Applied 1563 edits (5 errors) to 194 files [65.99%]
Applied 1565 edits (5 errors) to 195 files [66.33%]
Applied 1566 edits (5 errors) to 196 files [66.67%]
Applied 1567 edits (5 errors) to 197 files [67.01%]
Applied 1568 edits (5 errors) to 198 files [67.35%]
Applied 1572 edits (5 errors) to 199 files [67.69%]
Applied 1578 edits (5 errors) to 200 files [68.03%]
Applied 1579 edits (5 errors) to 201 files [68.37%]
Applied 1584 edits (5 errors) to 202 files [68.71%]
Applied 1587 edits (5 errors) to 203 files [69.05%]
Applied 1588 edits (5 errors) to 204 files [69.39%]
Applied 1590 edits (5 errors) to 205 files [69.73%]
Applied 1591 edits (5 errors) to 206 files [70.07%]
Applied 1598 edits (5 errors) to 207 files [70.41%]
Applied 1599 edits (5 errors) to 208 files [70.75%]
Applied 1600 edits (5 errors) to 209 files [71.09%]
Applied 1601 edits (5 errors) to 210 files [71.43%]
Applied 1602 edits (5 errors) to 211 files [71.77%]
Applied 1606 edits (5 errors) to 212 files [72.11%]
Applied 1610 edits (5 errors) to 213 files [72.45%]
Applied 1611 edits (5 errors) to 214 files [72.79%]
Applied 1612 edits (5 errors) to 215 files [73.13%]
Applied 1613 edits (5 errors) to 216 files [73.47%]
Applied 1616 edits (5 errors) to 217 files [73.81%]
Applied 1620 edits (5 errors) to 218 files [74.15%]
Applied 1622 edits (5 errors) to 219 files [74.49%]
Applied 1623 edits (5 errors) to 220 files [74.83%]
Applied 1624 edits (5 errors) to 221 files [75.17%]
Applied 1626 edits (5 errors) to 222 files [75.51%]
Applied 1629 edits (5 errors) to 223 files [75.85%]
Applied 1633 edits (5 errors) to 224 files [76.19%]
Applied 1637 edits (5 errors) to 225 files [76.53%]
Applied 1641 edits (5 errors) to 226 files [76.87%]
Applied 1642 edits (5 errors) to 227 files [77.21%]
Applied 1644 edits (5 errors) to 228 files [77.55%]
Applied 1645 edits (5 errors) to 229 files [77.89%]
Applied 1646 edits (5 errors) to 230 files [78.23%]
Applied 1648 edits (5 errors) to 231 files [78.57%]
Applied 1649 edits (5 errors) to 232 files [78.91%]
Applied 1651 edits (5 errors) to 233 files [79.25%]
Applied 1654 edits (5 errors) to 234 files [79.59%]
Applied 1656 edits (5 errors) to 235 files [79.93%]
Applied 1658 edits (5 errors) to 236 files [80.27%]
Applied 1660 edits (5 errors) to 237 files [80.61%]
Applied 1661 edits (5 errors) to 238 files [80.95%]
Applied 1662 edits (5 errors) to 239 files [81.29%]
Applied 1664 edits (5 errors) to 240 files [81.63%]
Applied 1665 edits (5 errors) to 241 files [81.97%]
Applied 1666 edits (5 errors) to 242 files [82.31%]
Applied 1668 edits (5 errors) to 243 files [82.65%]
Applied 1669 edits (5 errors) to 244 files [82.99%]
Applied 1670 edits (5 errors) to 245 files [83.33%]
Applied 1672 edits (5 errors) to 246 files [83.67%]
Applied 1674 edits (5 errors) to 247 files [84.01%]
Applied 1676 edits (5 errors) to 248 files [84.35%]
Applied 1678 edits (5 errors) to 249 files [84.69%]
Applied 1680 edits (5 errors) to 250 files [85.03%]
Applied 1682 edits (5 errors) to 251 files [85.37%]
Applied 1683 edits (5 errors) to 252 files [85.71%]
Applied 1684 edits (5 errors) to 253 files [86.05%]
Applied 1685 edits (5 errors) to 254 files [86.39%]
Applied 1687 edits (5 errors) to 255 files [86.73%]
Applied 1688 edits (5 errors) to 256 files [87.07%]
Applied 1690 edits (5 errors) to 257 files [87.41%]
Applied 1691 edits (5 errors) to 258 files [87.76%]
Applied 1692 edits (5 errors) to 259 files [88.10%]
Applied 1693 edits (5 errors) to 260 files [88.44%]
Applied 1694 edits (5 errors) to 261 files [88.78%]
Applied 1695 edits (5 errors) to 262 files [89.12%]
Applied 1697 edits (5 errors) to 263 files [89.46%]
Applied 1699 edits (5 errors) to 264 files [89.80%]
Applied 1701 edits (5 errors) to 265 files [90.14%]
Applied 1704 edits (5 errors) to 266 files [90.48%]
Applied 1705 edits (5 errors) to 267 files [90.82%]
Applied 1706 edits (5 errors) to 268 files [91.16%]
Applied 1707 edits (5 errors) to 269 files [91.50%]
Applied 1708 edits (5 errors) to 270 files [91.84%]
Applied 1709 edits (5 errors) to 271 files [92.18%]
Applied 1710 edits (5 errors) to 272 files [92.52%]
Applied 1711 edits (5 errors) to 273 files [92.86%]
Applied 1713 edits (5 errors) to 274 files [93.20%]
Applied 1714 edits (5 errors) to 275 files [93.54%]
Applied 1716 edits (5 errors) to 276 files [93.88%]
Applied 1717 edits (5 errors) to 277 files [94.22%]
Applied 1718 edits (5 errors) to 278 files [94.56%]
Applied 1719 edits (5 errors) to 279 files [94.90%]
Applied 1721 edits (5 errors) to 280 files [95.24%]
Applied 1722 edits (5 errors) to 281 files [95.58%]
Applied 1723 edits (5 errors) to 282 files [95.92%]
Applied 1724 edits (5 errors) to 283 files [96.26%]
Applied 1726 edits (5 errors) to 284 files [96.60%]
Applied 1729 edits (5 errors) to 285 files [96.94%]
Applied 1730 edits (5 errors) to 286 files [97.28%]
Applied 1731 edits (5 errors) to 287 files [97.62%]
Applied 1732 edits (5 errors) to 288 files [97.96%]
Applied 1733 edits (5 errors) to 289 files [98.30%]
Applied 1734 edits (5 errors) to 290 files [98.64%]
Applied 1735 edits (5 errors) to 291 files [98.98%]
Applied 1736 edits (5 errors) to 292 files [99.32%]
Applied 1738 edits (5 errors) to 293 files [99.66%]
Applied 1739 edits (5 errors) to 294 files [100.00%]
```
